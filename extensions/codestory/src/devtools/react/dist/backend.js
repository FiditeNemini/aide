/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReactDevToolsBackend"] = factory();
	else
		root["ReactDevToolsBackend"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js":
/*!*******************************************************************************************!*\
  !*** ../../build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @license React\n * react-debug-tools.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n true && function () {\n  function getPrimitiveStackCache() {\n    if (null === primitiveStackCache) {\n      var cache = new Map();\n\n      try {\n        Dispatcher.useContext({\n          _currentValue: null\n        });\n        Dispatcher.useState(null);\n        Dispatcher.useReducer(function (s) {\n          return s;\n        }, null);\n        Dispatcher.useRef(null);\n        \"function\" === typeof Dispatcher.useCacheRefresh && Dispatcher.useCacheRefresh();\n        Dispatcher.useLayoutEffect(function () {});\n        Dispatcher.useInsertionEffect(function () {});\n        Dispatcher.useEffect(function () {});\n        Dispatcher.useImperativeHandle(void 0, function () {\n          return null;\n        });\n        Dispatcher.useDebugValue(null);\n        Dispatcher.useCallback(function () {});\n        Dispatcher.useTransition();\n        Dispatcher.useSyncExternalStore(function () {\n          return function () {};\n        }, function () {\n          return null;\n        }, function () {\n          return null;\n        });\n        Dispatcher.useDeferredValue(null);\n        Dispatcher.useMemo(function () {\n          return null;\n        });\n        Dispatcher.useOptimistic(null, function (s) {\n          return s;\n        });\n        Dispatcher.useFormState(function (s) {\n          return s;\n        }, null);\n        Dispatcher.useActionState(function (s) {\n          return s;\n        }, null);\n        Dispatcher.useHostTransitionStatus();\n        \"function\" === typeof Dispatcher.useMemoCache && Dispatcher.useMemoCache(0);\n\n        if (\"function\" === typeof Dispatcher.use) {\n          Dispatcher.use({\n            $$typeof: REACT_CONTEXT_TYPE,\n            _currentValue: null\n          });\n          Dispatcher.use({\n            then: function then() {},\n            status: \"fulfilled\",\n            value: null\n          });\n\n          try {\n            Dispatcher.use({\n              then: function then() {}\n            });\n          } catch (x) {}\n        }\n\n        Dispatcher.useId();\n      } finally {\n        var readHookLog = hookLog;\n        hookLog = [];\n      }\n\n      for (var i = 0; i < readHookLog.length; i++) {\n        var hook = readHookLog[i];\n        cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));\n      }\n\n      primitiveStackCache = cache;\n    }\n\n    return primitiveStackCache;\n  }\n\n  function nextHook() {\n    var hook = currentHook;\n    null !== hook && (currentHook = hook.next);\n    return hook;\n  }\n\n  function readContext(context) {\n    if (null === currentFiber) return context._currentValue;\n    if (null === currentContextDependency) throw Error(\"Context reads do not line up with context dependencies. This is a bug in React Debug Tools.\");\n    hasOwnProperty.call(currentContextDependency, \"memoizedValue\") ? (context = currentContextDependency.memoizedValue, currentContextDependency = currentContextDependency.next) : context = context._currentValue;\n    return context;\n  }\n\n  function findSharedIndex(hookStack, rootStack, rootIndex) {\n    var source = rootStack[rootIndex].source,\n        i = 0;\n\n    a: for (; i < hookStack.length; i++) {\n      if (hookStack[i].source === source) {\n        for (var a = rootIndex + 1, b = i + 1; a < rootStack.length && b < hookStack.length; a++, b++) {\n          if (hookStack[b].source !== rootStack[a].source) continue a;\n        }\n\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function isReactWrapper(functionName, wrapperName) {\n    functionName = parseHookName(functionName);\n    return \"HostTransitionStatus\" === wrapperName ? functionName === wrapperName || \"FormStatus\" === functionName : functionName === wrapperName;\n  }\n\n  function parseHookName(functionName) {\n    if (!functionName) return \"\";\n    var startIndex = functionName.lastIndexOf(\"[as \");\n    if (-1 !== startIndex) return parseHookName(functionName.slice(startIndex + 4, -1));\n    startIndex = functionName.lastIndexOf(\".\");\n    startIndex = -1 === startIndex ? 0 : startIndex + 1;\n    functionName.slice(startIndex).startsWith(\"unstable_\") && (startIndex += 9);\n\n    if (\"use\" === functionName.slice(startIndex, startIndex + 3)) {\n      if (3 === functionName.length - startIndex) return \"Use\";\n      startIndex += 3;\n    }\n\n    return functionName.slice(startIndex);\n  }\n\n  function buildTree(rootStack$jscomp$0, readHookLog) {\n    for (var rootChildren = [], prevStack = null, levelChildren = rootChildren, nativeHookID = 0, stackOfChildren = [], i = 0; i < readHookLog.length; i++) {\n      var hook = readHookLog[i];\n      var rootStack = rootStack$jscomp$0,\n          hook$jscomp$0 = hook;\n      var parseResult = ErrorStackParser.parse(hook$jscomp$0.stackError);\n\n      b: {\n        var hookStack = parseResult,\n            rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex);\n        if (-1 !== rootIndex) rootStack = rootIndex;else {\n          for (var i$jscomp$0 = 0; i$jscomp$0 < rootStack.length && 5 > i$jscomp$0; i$jscomp$0++) {\n            if (rootIndex = findSharedIndex(hookStack, rootStack, i$jscomp$0), -1 !== rootIndex) {\n              mostLikelyAncestorIndex = i$jscomp$0;\n              rootStack = rootIndex;\n              break b;\n            }\n          }\n\n          rootStack = -1;\n        }\n      }\n\n      b: {\n        hookStack = parseResult;\n        rootIndex = getPrimitiveStackCache().get(hook$jscomp$0.primitive);\n        if (void 0 !== rootIndex) for (i$jscomp$0 = 0; i$jscomp$0 < rootIndex.length && i$jscomp$0 < hookStack.length; i$jscomp$0++) {\n          if (rootIndex[i$jscomp$0].source !== hookStack[i$jscomp$0].source) {\n            i$jscomp$0 < hookStack.length - 1 && isReactWrapper(hookStack[i$jscomp$0].functionName, hook$jscomp$0.dispatcherHookName) && i$jscomp$0++;\n            i$jscomp$0 < hookStack.length - 1 && isReactWrapper(hookStack[i$jscomp$0].functionName, hook$jscomp$0.dispatcherHookName) && i$jscomp$0++;\n            hook$jscomp$0 = i$jscomp$0;\n            break b;\n          }\n        }\n        hook$jscomp$0 = -1;\n      }\n\n      parseResult = -1 === rootStack || -1 === hook$jscomp$0 || 2 > rootStack - hook$jscomp$0 ? -1 === hook$jscomp$0 ? [null, null] : [parseResult[hook$jscomp$0 - 1], null] : [parseResult[hook$jscomp$0 - 1], parseResult.slice(hook$jscomp$0, rootStack - 1)];\n      rootStack = parseResult[0];\n      parseResult = parseResult[1];\n      hook$jscomp$0 = hook.displayName;\n      null === hook$jscomp$0 && null !== rootStack && (hook$jscomp$0 = parseHookName(rootStack.functionName) || parseHookName(hook.dispatcherHookName));\n\n      if (null !== parseResult) {\n        rootStack = 0;\n\n        if (null !== prevStack) {\n          for (; rootStack < parseResult.length && rootStack < prevStack.length && parseResult[parseResult.length - rootStack - 1].source === prevStack[prevStack.length - rootStack - 1].source;) {\n            rootStack++;\n          }\n\n          for (prevStack = prevStack.length - 1; prevStack > rootStack; prevStack--) {\n            levelChildren = stackOfChildren.pop();\n          }\n        }\n\n        for (prevStack = parseResult.length - rootStack - 1; 1 <= prevStack; prevStack--) {\n          rootStack = [], hookStack = parseResult[prevStack], hookStack = {\n            id: null,\n            isStateEditable: !1,\n            name: parseHookName(parseResult[prevStack - 1].functionName),\n            value: void 0,\n            subHooks: rootStack,\n            debugInfo: null,\n            hookSource: {\n              lineNumber: hookStack.lineNumber,\n              columnNumber: hookStack.columnNumber,\n              functionName: hookStack.functionName,\n              fileName: hookStack.fileName\n            }\n          }, levelChildren.push(hookStack), stackOfChildren.push(levelChildren), levelChildren = rootStack;\n        }\n\n        prevStack = parseResult;\n      }\n\n      rootStack = hook.primitive;\n      hookStack = hook.debugInfo;\n      hook = {\n        id: \"Context\" === rootStack || \"Context (use)\" === rootStack || \"DebugValue\" === rootStack || \"Promise\" === rootStack || \"Unresolved\" === rootStack || \"HostTransitionStatus\" === rootStack ? null : nativeHookID++,\n        isStateEditable: \"Reducer\" === rootStack || \"State\" === rootStack,\n        name: hook$jscomp$0 || rootStack,\n        value: hook.value,\n        subHooks: [],\n        debugInfo: hookStack,\n        hookSource: null\n      };\n      hook$jscomp$0 = {\n        lineNumber: null,\n        functionName: null,\n        fileName: null,\n        columnNumber: null\n      };\n      parseResult && 1 <= parseResult.length && (parseResult = parseResult[0], hook$jscomp$0.lineNumber = parseResult.lineNumber, hook$jscomp$0.functionName = parseResult.functionName, hook$jscomp$0.fileName = parseResult.fileName, hook$jscomp$0.columnNumber = parseResult.columnNumber);\n      hook.hookSource = hook$jscomp$0;\n      levelChildren.push(hook);\n    }\n\n    processDebugValues(rootChildren, null);\n    return rootChildren;\n  }\n\n  function processDebugValues(hooksTree, parentHooksNode) {\n    for (var debugValueHooksNodes = [], i = 0; i < hooksTree.length; i++) {\n      var hooksNode = hooksTree[i];\n      \"DebugValue\" === hooksNode.name && 0 === hooksNode.subHooks.length ? (hooksTree.splice(i, 1), i--, debugValueHooksNodes.push(hooksNode)) : processDebugValues(hooksNode.subHooks, hooksNode);\n    }\n\n    null !== parentHooksNode && (1 === debugValueHooksNodes.length ? parentHooksNode.value = debugValueHooksNodes[0].value : 1 < debugValueHooksNodes.length && (parentHooksNode.value = debugValueHooksNodes.map(function (_ref) {\n      return _ref.value;\n    })));\n  }\n\n  function handleRenderFunctionError(error) {\n    if (error !== SuspenseException) {\n      if (error instanceof Error && \"ReactDebugToolsUnsupportedHookError\" === error.name) throw error;\n      var wrapperError = Error(\"Error rendering inspected component\", {\n        cause: error\n      });\n      wrapperError.name = \"ReactDebugToolsRenderError\";\n      wrapperError.cause = error;\n      throw wrapperError;\n    }\n  }\n\n  function inspectHooks(renderFunction, props, currentDispatcher) {\n    null == currentDispatcher && (currentDispatcher = ReactSharedInternals);\n    var previousDispatcher = currentDispatcher.H;\n    currentDispatcher.H = DispatcherProxy;\n\n    try {\n      var ancestorStackError = Error();\n      renderFunction(props);\n    } catch (error) {\n      handleRenderFunctionError(error);\n    } finally {\n      renderFunction = hookLog, hookLog = [], currentDispatcher.H = previousDispatcher;\n    }\n\n    currentDispatcher = ErrorStackParser.parse(ancestorStackError);\n    return buildTree(currentDispatcher, renderFunction);\n  }\n\n  function restoreContexts(contextMap) {\n    contextMap.forEach(function (value, context) {\n      return context._currentValue = value;\n    });\n  }\n\n  var ErrorStackParser = __webpack_require__(/*! error-stack-parser */ \"../../node_modules/error-stack-parser/error-stack-parser.js\"),\n      React = __webpack_require__(/*! react */ \"../../build/oss-experimental/react/index.js\"),\n      assign = Object.assign,\n      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"),\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      hookLog = [],\n      primitiveStackCache = null,\n      currentFiber = null,\n      currentHook = null,\n      currentContextDependency = null,\n      SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"),\n      Dispatcher = {\n    use: function use(usable) {\n      if (null !== usable && \"object\" === _typeof(usable)) {\n        if (\"function\" === typeof usable.then) {\n          switch (usable.status) {\n            case \"fulfilled\":\n              var fulfilledValue = usable.value;\n              hookLog.push({\n                displayName: null,\n                primitive: \"Promise\",\n                stackError: Error(),\n                value: fulfilledValue,\n                debugInfo: void 0 === usable._debugInfo ? null : usable._debugInfo,\n                dispatcherHookName: \"Use\"\n              });\n              return fulfilledValue;\n\n            case \"rejected\":\n              throw usable.reason;\n          }\n\n          hookLog.push({\n            displayName: null,\n            primitive: \"Unresolved\",\n            stackError: Error(),\n            value: usable,\n            debugInfo: void 0 === usable._debugInfo ? null : usable._debugInfo,\n            dispatcherHookName: \"Use\"\n          });\n          throw SuspenseException;\n        }\n\n        if (usable.$$typeof === REACT_CONTEXT_TYPE) return fulfilledValue = readContext(usable), hookLog.push({\n          displayName: usable.displayName || \"Context\",\n          primitive: \"Context (use)\",\n          stackError: Error(),\n          value: fulfilledValue,\n          debugInfo: null,\n          dispatcherHookName: \"Use\"\n        }), fulfilledValue;\n      }\n\n      throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    },\n    readContext: readContext,\n    useCacheRefresh: function useCacheRefresh() {\n      var hook = nextHook();\n      hookLog.push({\n        displayName: null,\n        primitive: \"CacheRefresh\",\n        stackError: Error(),\n        value: null !== hook ? hook.memoizedState : function () {},\n        debugInfo: null,\n        dispatcherHookName: \"CacheRefresh\"\n      });\n      return function () {};\n    },\n    useCallback: function useCallback(callback) {\n      var hook = nextHook();\n      hookLog.push({\n        displayName: null,\n        primitive: \"Callback\",\n        stackError: Error(),\n        value: null !== hook ? hook.memoizedState[0] : callback,\n        debugInfo: null,\n        dispatcherHookName: \"Callback\"\n      });\n      return callback;\n    },\n    useContext: function useContext(context) {\n      var value = readContext(context);\n      hookLog.push({\n        displayName: context.displayName || null,\n        primitive: \"Context\",\n        stackError: Error(),\n        value: value,\n        debugInfo: null,\n        dispatcherHookName: \"Context\"\n      });\n      return value;\n    },\n    useEffect: function useEffect(create) {\n      nextHook();\n      hookLog.push({\n        displayName: null,\n        primitive: \"Effect\",\n        stackError: Error(),\n        value: create,\n        debugInfo: null,\n        dispatcherHookName: \"Effect\"\n      });\n    },\n    useImperativeHandle: function useImperativeHandle(ref) {\n      nextHook();\n      var instance = void 0;\n      null !== ref && \"object\" === _typeof(ref) && (instance = ref.current);\n      hookLog.push({\n        displayName: null,\n        primitive: \"ImperativeHandle\",\n        stackError: Error(),\n        value: instance,\n        debugInfo: null,\n        dispatcherHookName: \"ImperativeHandle\"\n      });\n    },\n    useDebugValue: function useDebugValue(value, formatterFn) {\n      hookLog.push({\n        displayName: null,\n        primitive: \"DebugValue\",\n        stackError: Error(),\n        value: \"function\" === typeof formatterFn ? formatterFn(value) : value,\n        debugInfo: null,\n        dispatcherHookName: \"DebugValue\"\n      });\n    },\n    useLayoutEffect: function useLayoutEffect(create) {\n      nextHook();\n      hookLog.push({\n        displayName: null,\n        primitive: \"LayoutEffect\",\n        stackError: Error(),\n        value: create,\n        debugInfo: null,\n        dispatcherHookName: \"LayoutEffect\"\n      });\n    },\n    useInsertionEffect: function useInsertionEffect(create) {\n      nextHook();\n      hookLog.push({\n        displayName: null,\n        primitive: \"InsertionEffect\",\n        stackError: Error(),\n        value: create,\n        debugInfo: null,\n        dispatcherHookName: \"InsertionEffect\"\n      });\n    },\n    useMemo: function useMemo(nextCreate) {\n      var hook = nextHook();\n      nextCreate = null !== hook ? hook.memoizedState[0] : nextCreate();\n      hookLog.push({\n        displayName: null,\n        primitive: \"Memo\",\n        stackError: Error(),\n        value: nextCreate,\n        debugInfo: null,\n        dispatcherHookName: \"Memo\"\n      });\n      return nextCreate;\n    },\n    useMemoCache: function useMemoCache(size) {\n      var fiber = currentFiber;\n      if (null == fiber) return [];\n      fiber = null != fiber.updateQueue ? fiber.updateQueue.memoCache : null;\n      if (null == fiber) return [];\n      var data = fiber.data[fiber.index];\n\n      if (void 0 === data) {\n        data = fiber.data[fiber.index] = Array(size);\n\n        for (var i = 0; i < size; i++) {\n          data[i] = REACT_MEMO_CACHE_SENTINEL;\n        }\n      }\n\n      fiber.index++;\n      return data;\n    },\n    useOptimistic: function useOptimistic(passthrough) {\n      var hook = nextHook();\n      passthrough = null !== hook ? hook.memoizedState : passthrough;\n      hookLog.push({\n        displayName: null,\n        primitive: \"Optimistic\",\n        stackError: Error(),\n        value: passthrough,\n        debugInfo: null,\n        dispatcherHookName: \"Optimistic\"\n      });\n      return [passthrough, function () {}];\n    },\n    useReducer: function useReducer(reducer, initialArg, init) {\n      reducer = nextHook();\n      initialArg = null !== reducer ? reducer.memoizedState : void 0 !== init ? init(initialArg) : initialArg;\n      hookLog.push({\n        displayName: null,\n        primitive: \"Reducer\",\n        stackError: Error(),\n        value: initialArg,\n        debugInfo: null,\n        dispatcherHookName: \"Reducer\"\n      });\n      return [initialArg, function () {}];\n    },\n    useRef: function useRef(initialValue) {\n      var hook = nextHook();\n      initialValue = null !== hook ? hook.memoizedState : {\n        current: initialValue\n      };\n      hookLog.push({\n        displayName: null,\n        primitive: \"Ref\",\n        stackError: Error(),\n        value: initialValue.current,\n        debugInfo: null,\n        dispatcherHookName: \"Ref\"\n      });\n      return initialValue;\n    },\n    useState: function useState(initialState) {\n      var hook = nextHook();\n      initialState = null !== hook ? hook.memoizedState : \"function\" === typeof initialState ? initialState() : initialState;\n      hookLog.push({\n        displayName: null,\n        primitive: \"State\",\n        stackError: Error(),\n        value: initialState,\n        debugInfo: null,\n        dispatcherHookName: \"State\"\n      });\n      return [initialState, function () {}];\n    },\n    useTransition: function useTransition() {\n      var stateHook = nextHook();\n      nextHook();\n      stateHook = null !== stateHook ? stateHook.memoizedState : !1;\n      hookLog.push({\n        displayName: null,\n        primitive: \"Transition\",\n        stackError: Error(),\n        value: stateHook,\n        debugInfo: null,\n        dispatcherHookName: \"Transition\"\n      });\n      return [stateHook, function () {}];\n    },\n    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot) {\n      nextHook();\n      nextHook();\n      subscribe = getSnapshot();\n      hookLog.push({\n        displayName: null,\n        primitive: \"SyncExternalStore\",\n        stackError: Error(),\n        value: subscribe,\n        debugInfo: null,\n        dispatcherHookName: \"SyncExternalStore\"\n      });\n      return subscribe;\n    },\n    useDeferredValue: function useDeferredValue(value) {\n      var hook = nextHook();\n      value = null !== hook ? hook.memoizedState : value;\n      hookLog.push({\n        displayName: null,\n        primitive: \"DeferredValue\",\n        stackError: Error(),\n        value: value,\n        debugInfo: null,\n        dispatcherHookName: \"DeferredValue\"\n      });\n      return value;\n    },\n    useId: function useId() {\n      var hook = nextHook();\n      hook = null !== hook ? hook.memoizedState : \"\";\n      hookLog.push({\n        displayName: null,\n        primitive: \"Id\",\n        stackError: Error(),\n        value: hook,\n        debugInfo: null,\n        dispatcherHookName: \"Id\"\n      });\n      return hook;\n    },\n    useFormState: function useFormState(action, initialState) {\n      var hook = nextHook();\n      nextHook();\n      nextHook();\n      action = Error();\n      var debugInfo = null,\n          error = null;\n      if (null !== hook) {\n        if (initialState = hook.memoizedState, \"object\" === _typeof(initialState) && null !== initialState && \"function\" === typeof initialState.then) switch (initialState.status) {\n          case \"fulfilled\":\n            var value = initialState.value;\n            debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo;\n            break;\n\n          case \"rejected\":\n            error = initialState.reason;\n            break;\n\n          default:\n            error = SuspenseException, debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo, value = initialState;\n        } else value = initialState;\n      } else value = initialState;\n      hookLog.push({\n        displayName: null,\n        primitive: \"FormState\",\n        stackError: action,\n        value: value,\n        debugInfo: debugInfo,\n        dispatcherHookName: \"FormState\"\n      });\n      if (null !== error) throw error;\n      return [value, function () {}, !1];\n    },\n    useActionState: function useActionState(action, initialState) {\n      var hook = nextHook();\n      nextHook();\n      nextHook();\n      action = Error();\n      var debugInfo = null,\n          error = null;\n      if (null !== hook) {\n        if (initialState = hook.memoizedState, \"object\" === _typeof(initialState) && null !== initialState && \"function\" === typeof initialState.then) switch (initialState.status) {\n          case \"fulfilled\":\n            var value = initialState.value;\n            debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo;\n            break;\n\n          case \"rejected\":\n            error = initialState.reason;\n            break;\n\n          default:\n            error = SuspenseException, debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo, value = initialState;\n        } else value = initialState;\n      } else value = initialState;\n      hookLog.push({\n        displayName: null,\n        primitive: \"ActionState\",\n        stackError: action,\n        value: value,\n        debugInfo: debugInfo,\n        dispatcherHookName: \"ActionState\"\n      });\n      if (null !== error) throw error;\n      return [value, function () {}, !1];\n    },\n    useHostTransitionStatus: function useHostTransitionStatus() {\n      var status = readContext({\n        _currentValue: null\n      });\n      hookLog.push({\n        displayName: null,\n        primitive: \"HostTransitionStatus\",\n        stackError: Error(),\n        value: status,\n        debugInfo: null,\n        dispatcherHookName: \"HostTransitionStatus\"\n      });\n      return status;\n    }\n  };\n\n  React = {\n    get: function get(target, prop) {\n      if (target.hasOwnProperty(prop)) return target[prop];\n      target = Error(\"Missing method in Dispatcher: \" + prop);\n      target.name = \"ReactDebugToolsUnsupportedHookError\";\n      throw target;\n    }\n  };\n  var DispatcherProxy = \"undefined\" === typeof Proxy ? Dispatcher : new Proxy(Dispatcher, React),\n      mostLikelyAncestorIndex = 0;\n  exports.inspectHooks = inspectHooks;\n\n  exports.inspectHooksOfFiber = function (fiber, currentDispatcher) {\n    null == currentDispatcher && (currentDispatcher = ReactSharedInternals);\n    if (0 !== fiber.tag && 15 !== fiber.tag && 11 !== fiber.tag) throw Error(\"Unknown Fiber. Needs to be a function component to inspect hooks.\");\n    getPrimitiveStackCache();\n    currentHook = fiber.memoizedState;\n    currentFiber = fiber;\n\n    if (hasOwnProperty.call(currentFiber, \"dependencies\")) {\n      var dependencies = currentFiber.dependencies;\n      currentContextDependency = null !== dependencies ? dependencies.firstContext : null;\n    } else if (hasOwnProperty.call(currentFiber, \"dependencies_old\")) dependencies = currentFiber.dependencies_old, currentContextDependency = null !== dependencies ? dependencies.firstContext : null;else if (hasOwnProperty.call(currentFiber, \"dependencies_new\")) dependencies = currentFiber.dependencies_new, currentContextDependency = null !== dependencies ? dependencies.firstContext : null;else if (hasOwnProperty.call(currentFiber, \"contextDependencies\")) dependencies = currentFiber.contextDependencies, currentContextDependency = null !== dependencies ? dependencies.first : null;else throw Error(\"Unsupported React version. This is a bug in React Debug Tools.\");\n\n    dependencies = fiber.type;\n    var props = fiber.memoizedProps;\n\n    if (dependencies !== fiber.elementType && dependencies && dependencies.defaultProps) {\n      props = assign({}, props);\n      var defaultProps = dependencies.defaultProps;\n\n      for (propName in defaultProps) {\n        void 0 === props[propName] && (props[propName] = defaultProps[propName]);\n      }\n    }\n\n    var propName = new Map();\n\n    try {\n      if (null !== currentContextDependency && !hasOwnProperty.call(currentContextDependency, \"memoizedValue\")) for (defaultProps = fiber; defaultProps;) {\n        if (10 === defaultProps.tag) {\n          var context = defaultProps.type;\n          void 0 !== context._context && (context = context._context);\n          propName.has(context) || (propName.set(context, context._currentValue), context._currentValue = defaultProps.memoizedProps.value);\n        }\n\n        defaultProps = defaultProps.return;\n      }\n\n      if (11 === fiber.tag) {\n        var renderFunction = dependencies.render;\n        context = props;\n        var ref = fiber.ref;\n        fiber = currentDispatcher;\n        var previousDispatcher = fiber.H;\n        fiber.H = DispatcherProxy;\n\n        try {\n          var ancestorStackError = Error();\n          renderFunction(context, ref);\n        } catch (error) {\n          handleRenderFunctionError(error);\n        } finally {\n          var readHookLog = hookLog;\n          hookLog = [];\n          fiber.H = previousDispatcher;\n        }\n\n        var rootStack = ErrorStackParser.parse(ancestorStackError);\n        return buildTree(rootStack, readHookLog);\n      }\n\n      return inspectHooks(dependencies, props, currentDispatcher);\n    } finally {\n      currentContextDependency = currentHook = currentFiber = null, restoreContexts(propName);\n    }\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1kZWJ1Zy10b29scy9janMvcmVhY3QtZGVidWctdG9vbHMuZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVVBOzs7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBTEE7O0FBTUE7QUFDQTtBQVRBOztBQVVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUFBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFFQTtBQUtBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7O0FBaUJBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBR0E7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQXRCQTtBQXVCQTtBQUNBOztBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBUUE7QUFSQTs7QUFTQTtBQUtBO0FBTEE7QUFNQTs7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBUEE7QUFQQTs7QUF3QkE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBT0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUEE7QUFTQTs7QUFDQTtBQUNBO0FBZEE7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUEE7QUFTQTtBQUNBOztBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFVQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVpBO0FBUEE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBWkE7QUFQQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQXRZQTs7QUF3WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQUE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBZ0JBO0FBQ0E7O0FBQ0E7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUNBOztBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uLy4uL2J1aWxkL29zcy1leHBlcmltZW50YWwvcmVhY3QtZGVidWctdG9vbHMvY2pzL3JlYWN0LWRlYnVnLXRvb2xzLmRldmVsb3BtZW50LmpzPzMzMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZGVidWctdG9vbHMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0UHJpbWl0aXZlU3RhY2tDYWNoZSgpIHtcbiAgICAgIGlmIChudWxsID09PSBwcmltaXRpdmVTdGFja0NhY2hlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZUNvbnRleHQoeyBfY3VycmVudFZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgIERpc3BhdGNoZXIudXNlU3RhdGUobnVsbCk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VSZWR1Y2VyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZVJlZihudWxsKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBEaXNwYXRjaGVyLnVzZUNhY2hlUmVmcmVzaCAmJlxuICAgICAgICAgICAgRGlzcGF0Y2hlci51c2VDYWNoZVJlZnJlc2goKTtcbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIERpc3BhdGNoZXIudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUodm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUobnVsbCk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIERpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZShudWxsKTtcbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VPcHRpbWlzdGljKG51bGwsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZUZvcm1TdGF0ZShmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VBY3Rpb25TdGF0ZShmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgICAgRGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIERpc3BhdGNoZXIudXNlTWVtb0NhY2hlICYmXG4gICAgICAgICAgICBEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZSgwKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRGlzcGF0Y2hlci51c2UpIHtcbiAgICAgICAgICAgIERpc3BhdGNoZXIudXNlKHtcbiAgICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgICAgICAgICAgX2N1cnJlbnRWYWx1ZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBEaXNwYXRjaGVyLnVzZSh7XG4gICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgICBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIERpc3BhdGNoZXIudXNlKHsgdGhlbjogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgICBEaXNwYXRjaGVyLnVzZUlkKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdmFyIHJlYWRIb29rTG9nID0gaG9va0xvZztcbiAgICAgICAgICBob29rTG9nID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkSG9va0xvZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBob29rID0gcmVhZEhvb2tMb2dbaV07XG4gICAgICAgICAgY2FjaGUuc2V0KGhvb2sucHJpbWl0aXZlLCBFcnJvclN0YWNrUGFyc2VyLnBhcnNlKGhvb2suc3RhY2tFcnJvcikpO1xuICAgICAgICB9XG4gICAgICAgIHByaW1pdGl2ZVN0YWNrQ2FjaGUgPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmltaXRpdmVTdGFja0NhY2hlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXh0SG9vaygpIHtcbiAgICAgIHZhciBob29rID0gY3VycmVudEhvb2s7XG4gICAgICBudWxsICE9PSBob29rICYmIChjdXJyZW50SG9vayA9IGhvb2submV4dCk7XG4gICAgICByZXR1cm4gaG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRGaWJlcikgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50Q29udGV4dERlcGVuZGVuY3kpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCByZWFkcyBkbyBub3QgbGluZSB1cCB3aXRoIGNvbnRleHQgZGVwZW5kZW5jaWVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IERlYnVnIFRvb2xzLlwiXG4gICAgICAgICk7XG4gICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnRDb250ZXh0RGVwZW5kZW5jeSwgXCJtZW1vaXplZFZhbHVlXCIpXG4gICAgICAgID8gKChjb250ZXh0ID0gY3VycmVudENvbnRleHREZXBlbmRlbmN5Lm1lbW9pemVkVmFsdWUpLFxuICAgICAgICAgIChjdXJyZW50Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50Q29udGV4dERlcGVuZGVuY3kubmV4dCkpXG4gICAgICAgIDogKGNvbnRleHQgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUpO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRTaGFyZWRJbmRleChob29rU3RhY2ssIHJvb3RTdGFjaywgcm9vdEluZGV4KSB7XG4gICAgICB2YXIgc291cmNlID0gcm9vdFN0YWNrW3Jvb3RJbmRleF0uc291cmNlLFxuICAgICAgICBpID0gMDtcbiAgICAgIGE6IGZvciAoOyBpIDwgaG9va1N0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoaG9va1N0YWNrW2ldLnNvdXJjZSA9PT0gc291cmNlKSB7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBhID0gcm9vdEluZGV4ICsgMSwgYiA9IGkgKyAxO1xuICAgICAgICAgICAgYSA8IHJvb3RTdGFjay5sZW5ndGggJiYgYiA8IGhvb2tTdGFjay5sZW5ndGg7XG4gICAgICAgICAgICBhKyssIGIrK1xuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChob29rU3RhY2tbYl0uc291cmNlICE9PSByb290U3RhY2tbYV0uc291cmNlKSBjb250aW51ZSBhO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVhY3RXcmFwcGVyKGZ1bmN0aW9uTmFtZSwgd3JhcHBlck5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSA9IHBhcnNlSG9va05hbWUoZnVuY3Rpb25OYW1lKTtcbiAgICAgIHJldHVybiBcIkhvc3RUcmFuc2l0aW9uU3RhdHVzXCIgPT09IHdyYXBwZXJOYW1lXG4gICAgICAgID8gZnVuY3Rpb25OYW1lID09PSB3cmFwcGVyTmFtZSB8fCBcIkZvcm1TdGF0dXNcIiA9PT0gZnVuY3Rpb25OYW1lXG4gICAgICAgIDogZnVuY3Rpb25OYW1lID09PSB3cmFwcGVyTmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VIb29rTmFtZShmdW5jdGlvbk5hbWUpIHtcbiAgICAgIGlmICghZnVuY3Rpb25OYW1lKSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gZnVuY3Rpb25OYW1lLmxhc3RJbmRleE9mKFwiW2FzIFwiKTtcbiAgICAgIGlmICgtMSAhPT0gc3RhcnRJbmRleClcbiAgICAgICAgcmV0dXJuIHBhcnNlSG9va05hbWUoZnVuY3Rpb25OYW1lLnNsaWNlKHN0YXJ0SW5kZXggKyA0LCAtMSkpO1xuICAgICAgc3RhcnRJbmRleCA9IGZ1bmN0aW9uTmFtZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICBzdGFydEluZGV4ID0gLTEgPT09IHN0YXJ0SW5kZXggPyAwIDogc3RhcnRJbmRleCArIDE7XG4gICAgICBmdW5jdGlvbk5hbWUuc2xpY2Uoc3RhcnRJbmRleCkuc3RhcnRzV2l0aChcInVuc3RhYmxlX1wiKSAmJlxuICAgICAgICAoc3RhcnRJbmRleCArPSA5KTtcbiAgICAgIGlmIChcInVzZVwiID09PSBmdW5jdGlvbk5hbWUuc2xpY2Uoc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIDMpKSB7XG4gICAgICAgIGlmICgzID09PSBmdW5jdGlvbk5hbWUubGVuZ3RoIC0gc3RhcnRJbmRleCkgcmV0dXJuIFwiVXNlXCI7XG4gICAgICAgIHN0YXJ0SW5kZXggKz0gMztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUuc2xpY2Uoc3RhcnRJbmRleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkVHJlZShyb290U3RhY2skanNjb21wJDAsIHJlYWRIb29rTG9nKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgcm9vdENoaWxkcmVuID0gW10sXG4gICAgICAgICAgcHJldlN0YWNrID0gbnVsbCxcbiAgICAgICAgICBsZXZlbENoaWxkcmVuID0gcm9vdENoaWxkcmVuLFxuICAgICAgICAgIG5hdGl2ZUhvb2tJRCA9IDAsXG4gICAgICAgICAgc3RhY2tPZkNoaWxkcmVuID0gW10sXG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIGkgPCByZWFkSG9va0xvZy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKSB7XG4gICAgICAgIHZhciBob29rID0gcmVhZEhvb2tMb2dbaV07XG4gICAgICAgIHZhciByb290U3RhY2sgPSByb290U3RhY2skanNjb21wJDAsXG4gICAgICAgICAgaG9vayRqc2NvbXAkMCA9IGhvb2s7XG4gICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IEVycm9yU3RhY2tQYXJzZXIucGFyc2UoaG9vayRqc2NvbXAkMC5zdGFja0Vycm9yKTtcbiAgICAgICAgYjoge1xuICAgICAgICAgIHZhciBob29rU3RhY2sgPSBwYXJzZVJlc3VsdCxcbiAgICAgICAgICAgIHJvb3RJbmRleCA9IGZpbmRTaGFyZWRJbmRleChcbiAgICAgICAgICAgICAgaG9va1N0YWNrLFxuICAgICAgICAgICAgICByb290U3RhY2ssXG4gICAgICAgICAgICAgIG1vc3RMaWtlbHlBbmNlc3RvckluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgtMSAhPT0gcm9vdEluZGV4KSByb290U3RhY2sgPSByb290SW5kZXg7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgaSRqc2NvbXAkMCA9IDA7XG4gICAgICAgICAgICAgIGkkanNjb21wJDAgPCByb290U3RhY2subGVuZ3RoICYmIDUgPiBpJGpzY29tcCQwO1xuICAgICAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgocm9vdEluZGV4ID0gZmluZFNoYXJlZEluZGV4KFxuICAgICAgICAgICAgICAgICAgaG9va1N0YWNrLFxuICAgICAgICAgICAgICAgICAgcm9vdFN0YWNrLFxuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIC0xICE9PSByb290SW5kZXgpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1vc3RMaWtlbHlBbmNlc3RvckluZGV4ID0gaSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgICByb290U3RhY2sgPSByb290SW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdFN0YWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGI6IHtcbiAgICAgICAgICBob29rU3RhY2sgPSBwYXJzZVJlc3VsdDtcbiAgICAgICAgICByb290SW5kZXggPSBnZXRQcmltaXRpdmVTdGFja0NhY2hlKCkuZ2V0KGhvb2skanNjb21wJDAucHJpbWl0aXZlKTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSByb290SW5kZXgpXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpJGpzY29tcCQwID0gMDtcbiAgICAgICAgICAgICAgaSRqc2NvbXAkMCA8IHJvb3RJbmRleC5sZW5ndGggJiYgaSRqc2NvbXAkMCA8IGhvb2tTdGFjay5sZW5ndGg7XG4gICAgICAgICAgICAgIGkkanNjb21wJDArK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcm9vdEluZGV4W2kkanNjb21wJDBdLnNvdXJjZSAhPT0gaG9va1N0YWNrW2kkanNjb21wJDBdLnNvdXJjZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpJGpzY29tcCQwIDwgaG9va1N0YWNrLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgICAgIGlzUmVhY3RXcmFwcGVyKFxuICAgICAgICAgICAgICAgICAgICBob29rU3RhY2tbaSRqc2NvbXAkMF0uZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBob29rJGpzY29tcCQwLmRpc3BhdGNoZXJIb29rTmFtZVxuICAgICAgICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgICAgICAgaSRqc2NvbXAkMCsrO1xuICAgICAgICAgICAgICAgIGkkanNjb21wJDAgPCBob29rU3RhY2subGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgICAgaXNSZWFjdFdyYXBwZXIoXG4gICAgICAgICAgICAgICAgICAgIGhvb2tTdGFja1tpJGpzY29tcCQwXS5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGhvb2skanNjb21wJDAuZGlzcGF0Y2hlckhvb2tOYW1lXG4gICAgICAgICAgICAgICAgICApICYmXG4gICAgICAgICAgICAgICAgICBpJGpzY29tcCQwKys7XG4gICAgICAgICAgICAgICAgaG9vayRqc2NvbXAkMCA9IGkkanNjb21wJDA7XG4gICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGhvb2skanNjb21wJDAgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVJlc3VsdCA9XG4gICAgICAgICAgLTEgPT09IHJvb3RTdGFjayB8fFxuICAgICAgICAgIC0xID09PSBob29rJGpzY29tcCQwIHx8XG4gICAgICAgICAgMiA+IHJvb3RTdGFjayAtIGhvb2skanNjb21wJDBcbiAgICAgICAgICAgID8gLTEgPT09IGhvb2skanNjb21wJDBcbiAgICAgICAgICAgICAgPyBbbnVsbCwgbnVsbF1cbiAgICAgICAgICAgICAgOiBbcGFyc2VSZXN1bHRbaG9vayRqc2NvbXAkMCAtIDFdLCBudWxsXVxuICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHRbaG9vayRqc2NvbXAkMCAtIDFdLFxuICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LnNsaWNlKGhvb2skanNjb21wJDAsIHJvb3RTdGFjayAtIDEpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgIHJvb3RTdGFjayA9IHBhcnNlUmVzdWx0WzBdO1xuICAgICAgICBwYXJzZVJlc3VsdCA9IHBhcnNlUmVzdWx0WzFdO1xuICAgICAgICBob29rJGpzY29tcCQwID0gaG9vay5kaXNwbGF5TmFtZTtcbiAgICAgICAgbnVsbCA9PT0gaG9vayRqc2NvbXAkMCAmJlxuICAgICAgICAgIG51bGwgIT09IHJvb3RTdGFjayAmJlxuICAgICAgICAgIChob29rJGpzY29tcCQwID1cbiAgICAgICAgICAgIHBhcnNlSG9va05hbWUocm9vdFN0YWNrLmZ1bmN0aW9uTmFtZSkgfHxcbiAgICAgICAgICAgIHBhcnNlSG9va05hbWUoaG9vay5kaXNwYXRjaGVySG9va05hbWUpKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHBhcnNlUmVzdWx0KSB7XG4gICAgICAgICAgcm9vdFN0YWNrID0gMDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gcHJldlN0YWNrKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgIHJvb3RTdGFjayA8IHBhcnNlUmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICByb290U3RhY2sgPCBwcmV2U3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgICAgIHBhcnNlUmVzdWx0W3BhcnNlUmVzdWx0Lmxlbmd0aCAtIHJvb3RTdGFjayAtIDFdLnNvdXJjZSA9PT1cbiAgICAgICAgICAgICAgICBwcmV2U3RhY2tbcHJldlN0YWNrLmxlbmd0aCAtIHJvb3RTdGFjayAtIDFdLnNvdXJjZTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByb290U3RhY2srKztcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIHByZXZTdGFjayA9IHByZXZTdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBwcmV2U3RhY2sgPiByb290U3RhY2s7XG4gICAgICAgICAgICAgIHByZXZTdGFjay0tXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGxldmVsQ2hpbGRyZW4gPSBzdGFja09mQ2hpbGRyZW4ucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBwcmV2U3RhY2sgPSBwYXJzZVJlc3VsdC5sZW5ndGggLSByb290U3RhY2sgLSAxO1xuICAgICAgICAgICAgMSA8PSBwcmV2U3RhY2s7XG4gICAgICAgICAgICBwcmV2U3RhY2stLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIChyb290U3RhY2sgPSBbXSksXG4gICAgICAgICAgICAgIChob29rU3RhY2sgPSBwYXJzZVJlc3VsdFtwcmV2U3RhY2tdKSxcbiAgICAgICAgICAgICAgKGhvb2tTdGFjayA9IHtcbiAgICAgICAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICAgICAgICBpc1N0YXRlRWRpdGFibGU6ICExLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBhcnNlSG9va05hbWUocGFyc2VSZXN1bHRbcHJldlN0YWNrIC0gMV0uZnVuY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHN1Ykhvb2tzOiByb290U3RhY2ssXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvOiBudWxsLFxuICAgICAgICAgICAgICAgIGhvb2tTb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGhvb2tTdGFjay5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBob29rU3RhY2suY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBob29rU3RhY2suZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGhvb2tTdGFjay5maWxlTmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGxldmVsQ2hpbGRyZW4ucHVzaChob29rU3RhY2spLFxuICAgICAgICAgICAgICBzdGFja09mQ2hpbGRyZW4ucHVzaChsZXZlbENoaWxkcmVuKSxcbiAgICAgICAgICAgICAgKGxldmVsQ2hpbGRyZW4gPSByb290U3RhY2spO1xuICAgICAgICAgIHByZXZTdGFjayA9IHBhcnNlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJvb3RTdGFjayA9IGhvb2sucHJpbWl0aXZlO1xuICAgICAgICBob29rU3RhY2sgPSBob29rLmRlYnVnSW5mbztcbiAgICAgICAgaG9vayA9IHtcbiAgICAgICAgICBpZDpcbiAgICAgICAgICAgIFwiQ29udGV4dFwiID09PSByb290U3RhY2sgfHxcbiAgICAgICAgICAgIFwiQ29udGV4dCAodXNlKVwiID09PSByb290U3RhY2sgfHxcbiAgICAgICAgICAgIFwiRGVidWdWYWx1ZVwiID09PSByb290U3RhY2sgfHxcbiAgICAgICAgICAgIFwiUHJvbWlzZVwiID09PSByb290U3RhY2sgfHxcbiAgICAgICAgICAgIFwiVW5yZXNvbHZlZFwiID09PSByb290U3RhY2sgfHxcbiAgICAgICAgICAgIFwiSG9zdFRyYW5zaXRpb25TdGF0dXNcIiA9PT0gcm9vdFN0YWNrXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IG5hdGl2ZUhvb2tJRCsrLFxuICAgICAgICAgIGlzU3RhdGVFZGl0YWJsZTogXCJSZWR1Y2VyXCIgPT09IHJvb3RTdGFjayB8fCBcIlN0YXRlXCIgPT09IHJvb3RTdGFjayxcbiAgICAgICAgICBuYW1lOiBob29rJGpzY29tcCQwIHx8IHJvb3RTdGFjayxcbiAgICAgICAgICB2YWx1ZTogaG9vay52YWx1ZSxcbiAgICAgICAgICBzdWJIb29rczogW10sXG4gICAgICAgICAgZGVidWdJbmZvOiBob29rU3RhY2ssXG4gICAgICAgICAgaG9va1NvdXJjZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBob29rJGpzY29tcCQwID0ge1xuICAgICAgICAgIGxpbmVOdW1iZXI6IG51bGwsXG4gICAgICAgICAgZnVuY3Rpb25OYW1lOiBudWxsLFxuICAgICAgICAgIGZpbGVOYW1lOiBudWxsLFxuICAgICAgICAgIGNvbHVtbk51bWJlcjogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBwYXJzZVJlc3VsdCAmJlxuICAgICAgICAgIDEgPD0gcGFyc2VSZXN1bHQubGVuZ3RoICYmXG4gICAgICAgICAgKChwYXJzZVJlc3VsdCA9IHBhcnNlUmVzdWx0WzBdKSxcbiAgICAgICAgICAoaG9vayRqc2NvbXAkMC5saW5lTnVtYmVyID0gcGFyc2VSZXN1bHQubGluZU51bWJlciksXG4gICAgICAgICAgKGhvb2skanNjb21wJDAuZnVuY3Rpb25OYW1lID0gcGFyc2VSZXN1bHQuZnVuY3Rpb25OYW1lKSxcbiAgICAgICAgICAoaG9vayRqc2NvbXAkMC5maWxlTmFtZSA9IHBhcnNlUmVzdWx0LmZpbGVOYW1lKSxcbiAgICAgICAgICAoaG9vayRqc2NvbXAkMC5jb2x1bW5OdW1iZXIgPSBwYXJzZVJlc3VsdC5jb2x1bW5OdW1iZXIpKTtcbiAgICAgICAgaG9vay5ob29rU291cmNlID0gaG9vayRqc2NvbXAkMDtcbiAgICAgICAgbGV2ZWxDaGlsZHJlbi5wdXNoKGhvb2spO1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0RlYnVnVmFsdWVzKHJvb3RDaGlsZHJlbiwgbnVsbCk7XG4gICAgICByZXR1cm4gcm9vdENoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzRGVidWdWYWx1ZXMoaG9va3NUcmVlLCBwYXJlbnRIb29rc05vZGUpIHtcbiAgICAgIGZvciAodmFyIGRlYnVnVmFsdWVIb29rc05vZGVzID0gW10sIGkgPSAwOyBpIDwgaG9va3NUcmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBob29rc05vZGUgPSBob29rc1RyZWVbaV07XG4gICAgICAgIFwiRGVidWdWYWx1ZVwiID09PSBob29rc05vZGUubmFtZSAmJiAwID09PSBob29rc05vZGUuc3ViSG9va3MubGVuZ3RoXG4gICAgICAgICAgPyAoaG9va3NUcmVlLnNwbGljZShpLCAxKSwgaS0tLCBkZWJ1Z1ZhbHVlSG9va3NOb2Rlcy5wdXNoKGhvb2tzTm9kZSkpXG4gICAgICAgICAgOiBwcm9jZXNzRGVidWdWYWx1ZXMoaG9va3NOb2RlLnN1Ykhvb2tzLCBob29rc05vZGUpO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gcGFyZW50SG9va3NOb2RlICYmXG4gICAgICAgICgxID09PSBkZWJ1Z1ZhbHVlSG9va3NOb2Rlcy5sZW5ndGhcbiAgICAgICAgICA/IChwYXJlbnRIb29rc05vZGUudmFsdWUgPSBkZWJ1Z1ZhbHVlSG9va3NOb2Rlc1swXS52YWx1ZSlcbiAgICAgICAgICA6IDEgPCBkZWJ1Z1ZhbHVlSG9va3NOb2Rlcy5sZW5ndGggJiZcbiAgICAgICAgICAgIChwYXJlbnRIb29rc05vZGUudmFsdWUgPSBkZWJ1Z1ZhbHVlSG9va3NOb2Rlcy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9yZWYudmFsdWU7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZW5kZXJGdW5jdGlvbkVycm9yKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgIT09IFN1c3BlbnNlRXhjZXB0aW9uKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgXCJSZWFjdERlYnVnVG9vbHNVbnN1cHBvcnRlZEhvb2tFcnJvclwiID09PSBlcnJvci5uYW1lXG4gICAgICAgIClcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgdmFyIHdyYXBwZXJFcnJvciA9IEVycm9yKFwiRXJyb3IgcmVuZGVyaW5nIGluc3BlY3RlZCBjb21wb25lbnRcIiwge1xuICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgICAgd3JhcHBlckVycm9yLm5hbWUgPSBcIlJlYWN0RGVidWdUb29sc1JlbmRlckVycm9yXCI7XG4gICAgICAgIHdyYXBwZXJFcnJvci5jYXVzZSA9IGVycm9yO1xuICAgICAgICB0aHJvdyB3cmFwcGVyRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc3BlY3RIb29rcyhyZW5kZXJGdW5jdGlvbiwgcHJvcHMsIGN1cnJlbnREaXNwYXRjaGVyKSB7XG4gICAgICBudWxsID09IGN1cnJlbnREaXNwYXRjaGVyICYmIChjdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzKTtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBjdXJyZW50RGlzcGF0Y2hlci5IO1xuICAgICAgY3VycmVudERpc3BhdGNoZXIuSCA9IERpc3BhdGNoZXJQcm94eTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhbmNlc3RvclN0YWNrRXJyb3IgPSBFcnJvcigpO1xuICAgICAgICByZW5kZXJGdW5jdGlvbihwcm9wcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVSZW5kZXJGdW5jdGlvbkVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZW5kZXJGdW5jdGlvbiA9IGhvb2tMb2cpLFxuICAgICAgICAgIChob29rTG9nID0gW10pLFxuICAgICAgICAgIChjdXJyZW50RGlzcGF0Y2hlci5IID0gcHJldmlvdXNEaXNwYXRjaGVyKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnREaXNwYXRjaGVyID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShhbmNlc3RvclN0YWNrRXJyb3IpO1xuICAgICAgcmV0dXJuIGJ1aWxkVHJlZShjdXJyZW50RGlzcGF0Y2hlciwgcmVuZGVyRnVuY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXN0b3JlQ29udGV4dHMoY29udGV4dE1hcCkge1xuICAgICAgY29udGV4dE1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgRXJyb3JTdGFja1BhcnNlciA9IHJlcXVpcmUoXCJlcnJvci1zdGFjay1wYXJzZXJcIiksXG4gICAgICBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgaG9va0xvZyA9IFtdLFxuICAgICAgcHJpbWl0aXZlU3RhY2tDYWNoZSA9IG51bGwsXG4gICAgICBjdXJyZW50RmliZXIgPSBudWxsLFxuICAgICAgY3VycmVudEhvb2sgPSBudWxsLFxuICAgICAgY3VycmVudENvbnRleHREZXBlbmRlbmN5ID0gbnVsbCxcbiAgICAgIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYC5cIlxuICAgICAgKSxcbiAgICAgIERpc3BhdGNoZXIgPSB7XG4gICAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICAgIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodXNhYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRWYWx1ZSA9IHVzYWJsZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmU6IFwiUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVsZmlsbGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbzpcbiAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHVzYWJsZS5fZGVidWdJbmZvID8gbnVsbCA6IHVzYWJsZS5fZGVidWdJbmZvLFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVySG9va05hbWU6IFwiVXNlXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgdGhyb3cgdXNhYmxlLnJlYXNvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZTogXCJVbnJlc29sdmVkXCIsXG4gICAgICAgICAgICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdXNhYmxlLFxuICAgICAgICAgICAgICAgIGRlYnVnSW5mbzpcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdXNhYmxlLl9kZWJ1Z0luZm8gPyBudWxsIDogdXNhYmxlLl9kZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlckhvb2tOYW1lOiBcIlVzZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoZnVsZmlsbGVkVmFsdWUgPSByZWFkQ29udGV4dCh1c2FibGUpKSxcbiAgICAgICAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IHVzYWJsZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIixcbiAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZTogXCJDb250ZXh0ICh1c2UpXCIsXG4gICAgICAgICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bGZpbGxlZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgZGVidWdJbmZvOiBudWxsLFxuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlckhvb2tOYW1lOiBcIlVzZVwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZnVsZmlsbGVkVmFsdWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogXCIgKyBTdHJpbmcodXNhYmxlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJDYWNoZVJlZnJlc2hcIixcbiAgICAgICAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCAhPT0gaG9vayA/IGhvb2subWVtb2l6ZWRTdGF0ZSA6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgZGVidWdJbmZvOiBudWxsLFxuICAgICAgICAgICAgZGlzcGF0Y2hlckhvb2tOYW1lOiBcIkNhY2hlUmVmcmVzaFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9LFxuICAgICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJDYWxsYmFja1wiLFxuICAgICAgICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsICE9PSBob29rID8gaG9vay5tZW1vaXplZFN0YXRlWzBdIDogY2FsbGJhY2ssXG4gICAgICAgICAgICBkZWJ1Z0luZm86IG51bGwsXG4gICAgICAgICAgICBkaXNwYXRjaGVySG9va05hbWU6IFwiQ2FsbGJhY2tcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IGNvbnRleHQuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJDb250ZXh0XCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZGVidWdJbmZvOiBudWxsLFxuICAgICAgICAgICAgZGlzcGF0Y2hlckhvb2tOYW1lOiBcIkNvbnRleHRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlKSB7XG4gICAgICAgICAgbmV4dEhvb2soKTtcbiAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG51bGwsXG4gICAgICAgICAgICBwcmltaXRpdmU6IFwiRWZmZWN0XCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgdmFsdWU6IGNyZWF0ZSxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJFZmZlY3RcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgbmV4dEhvb2soKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgICAgICAgbnVsbCAhPT0gcmVmICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZWYgJiYgKGluc3RhbmNlID0gcmVmLmN1cnJlbnQpO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJJbXBlcmF0aXZlSGFuZGxlXCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgdmFsdWU6IGluc3RhbmNlLFxuICAgICAgICAgICAgZGVidWdJbmZvOiBudWxsLFxuICAgICAgICAgICAgZGlzcGF0Y2hlckhvb2tOYW1lOiBcIkltcGVyYXRpdmVIYW5kbGVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICAgICAgaG9va0xvZy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgICAgICAgcHJpbWl0aXZlOiBcIkRlYnVnVmFsdWVcIixcbiAgICAgICAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm9ybWF0dGVyRm4gPyBmb3JtYXR0ZXJGbih2YWx1ZSkgOiB2YWx1ZSxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJEZWJ1Z1ZhbHVlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlKSB7XG4gICAgICAgICAgbmV4dEhvb2soKTtcbiAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG51bGwsXG4gICAgICAgICAgICBwcmltaXRpdmU6IFwiTGF5b3V0RWZmZWN0XCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgdmFsdWU6IGNyZWF0ZSxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJMYXlvdXRFZmZlY3RcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUpIHtcbiAgICAgICAgICBuZXh0SG9vaygpO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJJbnNlcnRpb25FZmZlY3RcIixcbiAgICAgICAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICAgICAgICB2YWx1ZTogY3JlYXRlLFxuICAgICAgICAgICAgZGVidWdJbmZvOiBudWxsLFxuICAgICAgICAgICAgZGlzcGF0Y2hlckhvb2tOYW1lOiBcIkluc2VydGlvbkVmZmVjdFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChuZXh0Q3JlYXRlKSB7XG4gICAgICAgICAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICAgICAgICAgIG5leHRDcmVhdGUgPSBudWxsICE9PSBob29rID8gaG9vay5tZW1vaXplZFN0YXRlWzBdIDogbmV4dENyZWF0ZSgpO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJNZW1vXCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgdmFsdWU6IG5leHRDcmVhdGUsXG4gICAgICAgICAgICBkZWJ1Z0luZm86IG51bGwsXG4gICAgICAgICAgICBkaXNwYXRjaGVySG9va05hbWU6IFwiTWVtb1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5leHRDcmVhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gICAgICAgICAgaWYgKG51bGwgPT0gZmliZXIpIHJldHVybiBbXTtcbiAgICAgICAgICBmaWJlciA9XG4gICAgICAgICAgICBudWxsICE9IGZpYmVyLnVwZGF0ZVF1ZXVlID8gZmliZXIudXBkYXRlUXVldWUubWVtb0NhY2hlIDogbnVsbDtcbiAgICAgICAgICBpZiAobnVsbCA9PSBmaWJlcikgcmV0dXJuIFtdO1xuICAgICAgICAgIHZhciBkYXRhID0gZmliZXIuZGF0YVtmaWJlci5pbmRleF07XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IGZpYmVyLmRhdGFbZmliZXIuaW5kZXhdID0gQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgZGF0YVtpXSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpYmVyLmluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU9wdGltaXN0aWM6IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCkge1xuICAgICAgICAgIHZhciBob29rID0gbmV4dEhvb2soKTtcbiAgICAgICAgICBwYXNzdGhyb3VnaCA9IG51bGwgIT09IGhvb2sgPyBob29rLm1lbW9pemVkU3RhdGUgOiBwYXNzdGhyb3VnaDtcbiAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG51bGwsXG4gICAgICAgICAgICBwcmltaXRpdmU6IFwiT3B0aW1pc3RpY1wiLFxuICAgICAgICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgICAgICAgIHZhbHVlOiBwYXNzdGhyb3VnaCxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJPcHRpbWlzdGljXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBmdW5jdGlvbiAoKSB7fV07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgICAgcmVkdWNlciA9IG5leHRIb29rKCk7XG4gICAgICAgICAgaW5pdGlhbEFyZyA9XG4gICAgICAgICAgICBudWxsICE9PSByZWR1Y2VyXG4gICAgICAgICAgICAgID8gcmVkdWNlci5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgIDogdm9pZCAwICE9PSBpbml0XG4gICAgICAgICAgICAgICAgPyBpbml0KGluaXRpYWxBcmcpXG4gICAgICAgICAgICAgICAgOiBpbml0aWFsQXJnO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJSZWR1Y2VyXCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgdmFsdWU6IGluaXRpYWxBcmcsXG4gICAgICAgICAgICBkZWJ1Z0luZm86IG51bGwsXG4gICAgICAgICAgICBkaXNwYXRjaGVySG9va05hbWU6IFwiUmVkdWNlclwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFtpbml0aWFsQXJnLCBmdW5jdGlvbiAoKSB7fV07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgIHZhciBob29rID0gbmV4dEhvb2soKTtcbiAgICAgICAgICBpbml0aWFsVmFsdWUgPVxuICAgICAgICAgICAgbnVsbCAhPT0gaG9vayA/IGhvb2subWVtb2l6ZWRTdGF0ZSA6IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH07XG4gICAgICAgICAgaG9va0xvZy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgICAgICAgcHJpbWl0aXZlOiBcIlJlZlwiLFxuICAgICAgICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgICAgICAgIHZhbHVlOiBpbml0aWFsVmFsdWUuY3VycmVudCxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJSZWZcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9XG4gICAgICAgICAgICBudWxsICE9PSBob29rXG4gICAgICAgICAgICAgID8gaG9vay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbFN0YXRlXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsU3RhdGUoKVxuICAgICAgICAgICAgICAgIDogaW5pdGlhbFN0YXRlO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJTdGF0ZVwiLFxuICAgICAgICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgICAgICAgIHZhbHVlOiBpbml0aWFsU3RhdGUsXG4gICAgICAgICAgICBkZWJ1Z0luZm86IG51bGwsXG4gICAgICAgICAgICBkaXNwYXRjaGVySG9va05hbWU6IFwiU3RhdGVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLCBmdW5jdGlvbiAoKSB7fV07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhdGVIb29rID0gbmV4dEhvb2soKTtcbiAgICAgICAgICBuZXh0SG9vaygpO1xuICAgICAgICAgIHN0YXRlSG9vayA9IG51bGwgIT09IHN0YXRlSG9vayA/IHN0YXRlSG9vay5tZW1vaXplZFN0YXRlIDogITE7XG4gICAgICAgICAgaG9va0xvZy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgICAgICAgcHJpbWl0aXZlOiBcIlRyYW5zaXRpb25cIixcbiAgICAgICAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICAgICAgICB2YWx1ZTogc3RhdGVIb29rLFxuICAgICAgICAgICAgZGVidWdJbmZvOiBudWxsLFxuICAgICAgICAgICAgZGlzcGF0Y2hlckhvb2tOYW1lOiBcIlRyYW5zaXRpb25cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBbc3RhdGVIb29rLCBmdW5jdGlvbiAoKSB7fV07XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCkge1xuICAgICAgICAgIG5leHRIb29rKCk7XG4gICAgICAgICAgbmV4dEhvb2soKTtcbiAgICAgICAgICBzdWJzY3JpYmUgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICAgIGhvb2tMb2cucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogXCJTeW5jRXh0ZXJuYWxTdG9yZVwiLFxuICAgICAgICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgICAgICAgIHZhbHVlOiBzdWJzY3JpYmUsXG4gICAgICAgICAgICBkZWJ1Z0luZm86IG51bGwsXG4gICAgICAgICAgICBkaXNwYXRjaGVySG9va05hbWU6IFwiU3luY0V4dGVybmFsU3RvcmVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBob29rID0gbmV4dEhvb2soKTtcbiAgICAgICAgICB2YWx1ZSA9IG51bGwgIT09IGhvb2sgPyBob29rLm1lbW9pemVkU3RhdGUgOiB2YWx1ZTtcbiAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG51bGwsXG4gICAgICAgICAgICBwcmltaXRpdmU6IFwiRGVmZXJyZWRWYWx1ZVwiLFxuICAgICAgICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJEZWZlcnJlZFZhbHVlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICAgICAgICAgIGhvb2sgPSBudWxsICE9PSBob29rID8gaG9vay5tZW1vaXplZFN0YXRlIDogXCJcIjtcbiAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG51bGwsXG4gICAgICAgICAgICBwcmltaXRpdmU6IFwiSWRcIixcbiAgICAgICAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICAgICAgICB2YWx1ZTogaG9vayxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJJZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGhvb2s7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUZvcm1TdGF0ZTogZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgdmFyIGhvb2sgPSBuZXh0SG9vaygpO1xuICAgICAgICAgIG5leHRIb29rKCk7XG4gICAgICAgICAgbmV4dEhvb2soKTtcbiAgICAgICAgICBhY3Rpb24gPSBFcnJvcigpO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSBudWxsLFxuICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgIGlmIChudWxsICE9PSBob29rKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGluaXRpYWxTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBpbml0aWFsU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBpbml0aWFsU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsU3RhdGUudGhlbilcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgc3dpdGNoIChpbml0aWFsU3RhdGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5pdGlhbFN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgZGVidWdJbmZvID1cbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBpbml0aWFsU3RhdGUuX2RlYnVnSW5mb1xuICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgIDogaW5pdGlhbFN0YXRlLl9kZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICAgIGVycm9yID0gaW5pdGlhbFN0YXRlLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAoZXJyb3IgPSBTdXNwZW5zZUV4Y2VwdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIChkZWJ1Z0luZm8gPVxuICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gaW5pdGlhbFN0YXRlLl9kZWJ1Z0luZm9cbiAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbml0aWFsU3RhdGUuX2RlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9IGluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgdmFsdWUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgZWxzZSB2YWx1ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgICBob29rTG9nLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG51bGwsXG4gICAgICAgICAgICBwcmltaXRpdmU6IFwiRm9ybVN0YXRlXCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBhY3Rpb24sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBkZWJ1Z0luZm86IGRlYnVnSW5mbyxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJGb3JtU3RhdGVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChudWxsICE9PSBlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIFt2YWx1ZSwgZnVuY3Rpb24gKCkge30sICExXTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlQWN0aW9uU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgIHZhciBob29rID0gbmV4dEhvb2soKTtcbiAgICAgICAgICBuZXh0SG9vaygpO1xuICAgICAgICAgIG5leHRIb29rKCk7XG4gICAgICAgICAgYWN0aW9uID0gRXJyb3IoKTtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gbnVsbCxcbiAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gaG9vaylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChpbml0aWFsU3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgaW5pdGlhbFN0YXRlICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5pdGlhbFN0YXRlICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5pdGlhbFN0YXRlLnRoZW4pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHN3aXRjaCAoaW5pdGlhbFN0YXRlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWxTdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGRlYnVnSW5mbyA9XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gaW5pdGlhbFN0YXRlLl9kZWJ1Z0luZm9cbiAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICA6IGluaXRpYWxTdGF0ZS5fZGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICBlcnJvciA9IGluaXRpYWxTdGF0ZS5yZWFzb247XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgKGVycm9yID0gU3VzcGVuc2VFeGNlcHRpb24pLFxuICAgICAgICAgICAgICAgICAgICAoZGVidWdJbmZvID1cbiAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGluaXRpYWxTdGF0ZS5fZGVidWdJbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5pdGlhbFN0YXRlLl9kZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPSBpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHZhbHVlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICAgIGVsc2UgdmFsdWUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgaG9va0xvZy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgICAgICAgcHJpbWl0aXZlOiBcIkFjdGlvblN0YXRlXCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBhY3Rpb24sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBkZWJ1Z0luZm86IGRlYnVnSW5mbyxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJBY3Rpb25TdGF0ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgICByZXR1cm4gW3ZhbHVlLCBmdW5jdGlvbiAoKSB7fSwgITFdO1xuICAgICAgICB9LFxuICAgICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGF0dXMgPSByZWFkQ29udGV4dCh7IF9jdXJyZW50VmFsdWU6IG51bGwgfSk7XG4gICAgICAgICAgaG9va0xvZy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgICAgICAgcHJpbWl0aXZlOiBcIkhvc3RUcmFuc2l0aW9uU3RhdHVzXCIsXG4gICAgICAgICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgICAgICAgdmFsdWU6IHN0YXR1cyxcbiAgICAgICAgICAgIGRlYnVnSW5mbzogbnVsbCxcbiAgICAgICAgICAgIGRpc3BhdGNoZXJIb29rTmFtZTogXCJIb3N0VHJhbnNpdGlvblN0YXR1c1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3ApKSByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICB0YXJnZXQgPSBFcnJvcihcIk1pc3NpbmcgbWV0aG9kIGluIERpc3BhdGNoZXI6IFwiICsgcHJvcCk7XG4gICAgICAgIHRhcmdldC5uYW1lID0gXCJSZWFjdERlYnVnVG9vbHNVbnN1cHBvcnRlZEhvb2tFcnJvclwiO1xuICAgICAgICB0aHJvdyB0YXJnZXQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgRGlzcGF0Y2hlclByb3h5ID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIFByb3h5XG4gICAgICAgICAgPyBEaXNwYXRjaGVyXG4gICAgICAgICAgOiBuZXcgUHJveHkoRGlzcGF0Y2hlciwgUmVhY3QpLFxuICAgICAgbW9zdExpa2VseUFuY2VzdG9ySW5kZXggPSAwO1xuICAgIGV4cG9ydHMuaW5zcGVjdEhvb2tzID0gaW5zcGVjdEhvb2tzO1xuICAgIGV4cG9ydHMuaW5zcGVjdEhvb2tzT2ZGaWJlciA9IGZ1bmN0aW9uIChmaWJlciwgY3VycmVudERpc3BhdGNoZXIpIHtcbiAgICAgIG51bGwgPT0gY3VycmVudERpc3BhdGNoZXIgJiYgKGN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMpO1xuICAgICAgaWYgKDAgIT09IGZpYmVyLnRhZyAmJiAxNSAhPT0gZmliZXIudGFnICYmIDExICE9PSBmaWJlci50YWcpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVW5rbm93biBGaWJlci4gTmVlZHMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdG8gaW5zcGVjdCBob29rcy5cIlxuICAgICAgICApO1xuICAgICAgZ2V0UHJpbWl0aXZlU3RhY2tDYWNoZSgpO1xuICAgICAgY3VycmVudEhvb2sgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50RmliZXIsIFwiZGVwZW5kZW5jaWVzXCIpKSB7XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBjdXJyZW50RmliZXIuZGVwZW5kZW5jaWVzO1xuICAgICAgICBjdXJyZW50Q29udGV4dERlcGVuZGVuY3kgPVxuICAgICAgICAgIG51bGwgIT09IGRlcGVuZGVuY2llcyA/IGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgOiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnRGaWJlciwgXCJkZXBlbmRlbmNpZXNfb2xkXCIpKVxuICAgICAgICAoZGVwZW5kZW5jaWVzID0gY3VycmVudEZpYmVyLmRlcGVuZGVuY2llc19vbGQpLFxuICAgICAgICAgIChjdXJyZW50Q29udGV4dERlcGVuZGVuY3kgPVxuICAgICAgICAgICAgbnVsbCAhPT0gZGVwZW5kZW5jaWVzID8gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dCA6IG51bGwpO1xuICAgICAgZWxzZSBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50RmliZXIsIFwiZGVwZW5kZW5jaWVzX25ld1wiKSlcbiAgICAgICAgKGRlcGVuZGVuY2llcyA9IGN1cnJlbnRGaWJlci5kZXBlbmRlbmNpZXNfbmV3KSxcbiAgICAgICAgICAoY3VycmVudENvbnRleHREZXBlbmRlbmN5ID1cbiAgICAgICAgICAgIG51bGwgIT09IGRlcGVuZGVuY2llcyA/IGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgOiBudWxsKTtcbiAgICAgIGVsc2UgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY3VycmVudEZpYmVyLCBcImNvbnRleHREZXBlbmRlbmNpZXNcIikpXG4gICAgICAgIChkZXBlbmRlbmNpZXMgPSBjdXJyZW50RmliZXIuY29udGV4dERlcGVuZGVuY2llcyksXG4gICAgICAgICAgKGN1cnJlbnRDb250ZXh0RGVwZW5kZW5jeSA9XG4gICAgICAgICAgICBudWxsICE9PSBkZXBlbmRlbmNpZXMgPyBkZXBlbmRlbmNpZXMuZmlyc3QgOiBudWxsKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJVbnN1cHBvcnRlZCBSZWFjdCB2ZXJzaW9uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IERlYnVnIFRvb2xzLlwiXG4gICAgICAgICk7XG4gICAgICBkZXBlbmRlbmNpZXMgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIHByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgIGlmIChcbiAgICAgICAgZGVwZW5kZW5jaWVzICE9PSBmaWJlci5lbGVtZW50VHlwZSAmJlxuICAgICAgICBkZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgZGVwZW5kZW5jaWVzLmRlZmF1bHRQcm9wc1xuICAgICAgKSB7XG4gICAgICAgIHByb3BzID0gYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSBkZXBlbmRlbmNpZXMuZGVmYXVsdFByb3BzO1xuICAgICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICB2b2lkIDAgPT09IHByb3BzW3Byb3BOYW1lXSAmJlxuICAgICAgICAgICAgKHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV0pO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRDb250ZXh0RGVwZW5kZW5jeSAmJlxuICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnRDb250ZXh0RGVwZW5kZW5jeSwgXCJtZW1vaXplZFZhbHVlXCIpXG4gICAgICAgIClcbiAgICAgICAgICBmb3IgKGRlZmF1bHRQcm9wcyA9IGZpYmVyOyBkZWZhdWx0UHJvcHM7ICkge1xuICAgICAgICAgICAgaWYgKDEwID09PSBkZWZhdWx0UHJvcHMudGFnKSB7XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZGVmYXVsdFByb3BzLnR5cGU7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gY29udGV4dC5fY29udGV4dCAmJiAoY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQpO1xuICAgICAgICAgICAgICBwcm9wTmFtZS5oYXMoY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICAocHJvcE5hbWUuc2V0KGNvbnRleHQsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGRlZmF1bHRQcm9wcy5tZW1vaXplZFByb3BzLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKDExID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgICB2YXIgcmVuZGVyRnVuY3Rpb24gPSBkZXBlbmRlbmNpZXMucmVuZGVyO1xuICAgICAgICAgIGNvbnRleHQgPSBwcm9wcztcbiAgICAgICAgICB2YXIgcmVmID0gZmliZXIucmVmO1xuICAgICAgICAgIGZpYmVyID0gY3VycmVudERpc3BhdGNoZXI7XG4gICAgICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IGZpYmVyLkg7XG4gICAgICAgICAgZmliZXIuSCA9IERpc3BhdGNoZXJQcm94eTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9yU3RhY2tFcnJvciA9IEVycm9yKCk7XG4gICAgICAgICAgICByZW5kZXJGdW5jdGlvbihjb250ZXh0LCByZWYpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBoYW5kbGVSZW5kZXJGdW5jdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdmFyIHJlYWRIb29rTG9nID0gaG9va0xvZztcbiAgICAgICAgICAgIGhvb2tMb2cgPSBbXTtcbiAgICAgICAgICAgIGZpYmVyLkggPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByb290U3RhY2sgPSBFcnJvclN0YWNrUGFyc2VyLnBhcnNlKGFuY2VzdG9yU3RhY2tFcnJvcik7XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkVHJlZShyb290U3RhY2ssIHJlYWRIb29rTG9nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zcGVjdEhvb2tzKGRlcGVuZGVuY2llcywgcHJvcHMsIGN1cnJlbnREaXNwYXRjaGVyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChjdXJyZW50Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50SG9vayA9IGN1cnJlbnRGaWJlciA9IG51bGwpLFxuICAgICAgICAgIHJlc3RvcmVDb250ZXh0cyhwcm9wTmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react-debug-tools/index.js":
/*!***************************************************************!*\
  !*** ../../build/oss-experimental/react-debug-tools/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-debug-tools.development.js */ \"../../build/oss-experimental/react-debug-tools/cjs/react-debug-tools.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC1kZWJ1Zy10b29scy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9idWlsZC9vc3MtZXhwZXJpbWVudGFsL3JlYWN0LWRlYnVnLXRvb2xzL2luZGV4LmpzPzM4ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRlYnVnLXRvb2xzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZGVidWctdG9vbHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react-debug-tools/index.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react/cjs/react.development.js":
/*!*******************************************************************!*\
  !*** ../../build/oss-experimental/react/cjs/react.development.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n true && function () {\n  function defineDeprecationWarning(methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function get() {\n        console.warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n      }\n    });\n  }\n\n  function getIteratorFn(maybeIterable) {\n    if (null === maybeIterable || \"object\" !== _typeof(maybeIterable)) return null;\n    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n    return \"function\" === typeof maybeIterable ? maybeIterable : null;\n  }\n\n  function warnNoop(publicInstance, callerName) {\n    publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || \"ReactClass\";\n    var warningKey = publicInstance + \".\" + callerName;\n    didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(\"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = !0);\n  }\n\n  function Component(props, context, updater) {\n    this.props = props;\n    this.context = context;\n    this.refs = emptyObject;\n    this.updater = updater || ReactNoopUpdateQueue;\n  }\n\n  function ComponentDummy() {}\n\n  function PureComponent(props, context, updater) {\n    this.props = props;\n    this.context = context;\n    this.refs = emptyObject;\n    this.updater = updater || ReactNoopUpdateQueue;\n  }\n\n  function testStringCoercion(value) {\n    return \"\" + value;\n  }\n\n  function checkKeyStringCoercion(value) {\n    try {\n      testStringCoercion(value);\n      var JSCompiler_inline_result = !1;\n    } catch (e) {\n      JSCompiler_inline_result = !0;\n    }\n\n    if (JSCompiler_inline_result) {\n      JSCompiler_inline_result = console;\n      var JSCompiler_temp_const = JSCompiler_inline_result.error;\n      var JSCompiler_inline_result$jscomp$0 = \"function\" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n      JSCompiler_temp_const.call(JSCompiler_inline_result, \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", JSCompiler_inline_result$jscomp$0);\n      return testStringCoercion(value);\n    }\n  }\n\n  function getComponentNameFromType(type) {\n    if (null == type) return null;\n    if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$1 ? null : type.displayName || type.name || null;\n    if (\"string\" === typeof type) return type;\n\n    switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return \"Fragment\";\n\n      case REACT_PORTAL_TYPE:\n        return \"Portal\";\n\n      case REACT_PROFILER_TYPE:\n        return \"Profiler\";\n\n      case REACT_STRICT_MODE_TYPE:\n        return \"StrictMode\";\n\n      case REACT_SUSPENSE_TYPE:\n        return \"Suspense\";\n\n      case REACT_SUSPENSE_LIST_TYPE:\n        return \"SuspenseList\";\n\n      case REACT_VIEW_TRANSITION_TYPE:\n        return \"ViewTransition\";\n    }\n\n    if (\"object\" === _typeof(type)) switch (\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return (type.displayName || \"Context\") + \".Provider\";\n\n      case REACT_CONSUMER_TYPE:\n        return (type._context.displayName || \"Context\") + \".Consumer\";\n\n      case REACT_FORWARD_REF_TYPE:\n        var innerType = type.render;\n        type = type.displayName;\n        type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n        return type;\n\n      case REACT_MEMO_TYPE:\n        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n\n      case REACT_LAZY_TYPE:\n        innerType = type._payload;\n        type = type._init;\n\n        try {\n          return getComponentNameFromType(type(innerType));\n        } catch (x) {}\n\n    }\n    return null;\n  }\n\n  function getTaskName(type) {\n    if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n    if (\"object\" === _typeof(type) && null !== type && type.$$typeof === REACT_LAZY_TYPE) return \"<...>\";\n\n    try {\n      var name = getComponentNameFromType(type);\n      return name ? \"<\" + name + \">\" : \"<...>\";\n    } catch (x) {\n      return \"<...>\";\n    }\n  }\n\n  function getOwner() {\n    var dispatcher = ReactSharedInternals.A;\n    return null === dispatcher ? null : dispatcher.getOwner();\n  }\n\n  function hasValidKey(config) {\n    if (hasOwnProperty.call(config, \"key\")) {\n      var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n      if (getter && getter.isReactWarning) return !1;\n    }\n\n    return void 0 !== config.key;\n  }\n\n  function defineKeyPropWarningGetter(props, displayName) {\n    function warnAboutAccessingKey() {\n      specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\", displayName));\n    }\n\n    warnAboutAccessingKey.isReactWarning = !0;\n    Object.defineProperty(props, \"key\", {\n      get: warnAboutAccessingKey,\n      configurable: !0\n    });\n  }\n\n  function elementRefGetterWithDeprecationWarning() {\n    var componentName = getComponentNameFromType(this.type);\n    didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error(\"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"));\n    componentName = this.props.ref;\n    return void 0 !== componentName ? componentName : null;\n  }\n\n  function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {\n    self = props.ref;\n    type = {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key,\n      props: props,\n      _owner: owner\n    };\n    null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, \"ref\", {\n      enumerable: !1,\n      get: elementRefGetterWithDeprecationWarning\n    }) : Object.defineProperty(type, \"ref\", {\n      enumerable: !1,\n      value: null\n    });\n    type._store = {};\n    Object.defineProperty(type._store, \"validated\", {\n      configurable: !1,\n      enumerable: !1,\n      writable: !0,\n      value: 0\n    });\n    Object.defineProperty(type, \"_debugInfo\", {\n      configurable: !1,\n      enumerable: !1,\n      writable: !0,\n      value: null\n    });\n    Object.defineProperty(type, \"_debugStack\", {\n      configurable: !1,\n      enumerable: !1,\n      writable: !0,\n      value: debugStack\n    });\n    Object.defineProperty(type, \"_debugTask\", {\n      configurable: !1,\n      enumerable: !1,\n      writable: !0,\n      value: debugTask\n    });\n    Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n    return type;\n  }\n\n  function cloneAndReplaceKey(oldElement, newKey) {\n    newKey = ReactElement(oldElement.type, newKey, void 0, void 0, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);\n    newKey._store.validated = oldElement._store.validated;\n    return newKey;\n  }\n\n  function isValidElement(object) {\n    return \"object\" === _typeof(object) && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n\n  function escape(key) {\n    var escaperLookup = {\n      \"=\": \"=0\",\n      \":\": \"=2\"\n    };\n    return \"$\" + key.replace(/[=:]/g, function (match) {\n      return escaperLookup[match];\n    });\n  }\n\n  function getElementKey(element, index) {\n    return \"object\" === _typeof(element) && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape(\"\" + element.key)) : index.toString(36);\n  }\n\n  function noop$1() {}\n\n  function resolveThenable(thenable) {\n    switch (thenable.status) {\n      case \"fulfilled\":\n        return thenable.value;\n\n      case \"rejected\":\n        throw thenable.reason;\n\n      default:\n        switch (\"string\" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = \"pending\", thenable.then(function (fulfilledValue) {\n          \"pending\" === thenable.status && (thenable.status = \"fulfilled\", thenable.value = fulfilledValue);\n        }, function (error) {\n          \"pending\" === thenable.status && (thenable.status = \"rejected\", thenable.reason = error);\n        })), thenable.status) {\n          case \"fulfilled\":\n            return thenable.value;\n\n          case \"rejected\":\n            throw thenable.reason;\n        }\n\n    }\n\n    throw thenable;\n  }\n\n  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n    var type = _typeof(children);\n\n    if (\"undefined\" === type || \"boolean\" === type) children = null;\n    var invokeCallback = !1;\n    if (null === children) invokeCallback = !0;else switch (type) {\n      case \"bigint\":\n      case \"string\":\n      case \"number\":\n        invokeCallback = !0;\n        break;\n\n      case \"object\":\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = !0;\n            break;\n\n          case REACT_LAZY_TYPE:\n            return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);\n        }\n\n    }\n\n    if (invokeCallback) {\n      invokeCallback = children;\n      callback = callback(invokeCallback);\n      var childKey = \"\" === nameSoFar ? \".\" + getElementKey(invokeCallback, 0) : nameSoFar;\n      isArrayImpl(callback) ? (escapedPrefix = \"\", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"), mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n        return c;\n      })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? \"\" : (\"\" + callback.key).replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\") + childKey), \"\" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));\n      return 1;\n    }\n\n    invokeCallback = 0;\n    childKey = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n    if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) {\n      nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);\n    } else if (i = getIteratorFn(children), \"function\" === typeof i) for (i === children.entries && (didWarnAboutMaps || console.warn(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0), children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) {\n      nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);\n    } else if (\"object\" === type) {\n      if (\"function\" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);\n      array = String(children);\n      throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === array ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : array) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    return invokeCallback;\n  }\n\n  function mapChildren(children, func, context) {\n    if (null == children) return children;\n    var result = [],\n        count = 0;\n    mapIntoArray(children, result, \"\", \"\", function (child) {\n      return func.call(context, child, count++);\n    });\n    return result;\n  }\n\n  function lazyInitializer(payload) {\n    if (-1 === payload._status) {\n      var ctor = payload._result;\n      ctor = ctor();\n      ctor.then(function (moduleObject) {\n        if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;\n      }, function (error) {\n        if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;\n      });\n      -1 === payload._status && (payload._status = 0, payload._result = ctor);\n    }\n\n    if (1 === payload._status) return ctor = payload._result, void 0 === ctor && console.error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\", ctor), \"default\" in ctor || console.error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\", ctor), ctor.default;\n    throw payload._result;\n  }\n\n  function resolveDispatcher() {\n    var dispatcher = ReactSharedInternals.H;\n    null === dispatcher && console.error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    return dispatcher;\n  }\n\n  function useOptimistic(passthrough, reducer) {\n    return resolveDispatcher().useOptimistic(passthrough, reducer);\n  }\n\n  function noop() {}\n\n  function enqueueTask(task) {\n    if (null === enqueueTaskImpl) try {\n      var requireString = (\"require\" + Math.random()).slice(0, 7);\n      enqueueTaskImpl = (module && module[requireString]).call(module, \"timers\").setImmediate;\n    } catch (_err) {\n      enqueueTaskImpl = function enqueueTaskImpl(callback) {\n        !1 === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = !0, \"undefined\" === typeof MessageChannel && console.error(\"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\"));\n        var channel = new MessageChannel();\n        channel.port1.onmessage = callback;\n        channel.port2.postMessage(void 0);\n      };\n    }\n    return enqueueTaskImpl(task);\n  }\n\n  function aggregateErrors(errors) {\n    return 1 < errors.length && \"function\" === typeof AggregateError ? new AggregateError(errors) : errors[0];\n  }\n\n  function popActScope(prevActQueue, prevActScopeDepth) {\n    prevActScopeDepth !== actScopeDepth - 1 && console.error(\"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \");\n    actScopeDepth = prevActScopeDepth;\n  }\n\n  function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n    var queue = ReactSharedInternals.actQueue;\n    if (null !== queue) if (0 !== queue.length) try {\n      flushActQueue(queue);\n      enqueueTask(function () {\n        return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n      });\n      return;\n    } catch (error) {\n      ReactSharedInternals.thrownErrors.push(error);\n    } else ReactSharedInternals.actQueue = null;\n    0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);\n  }\n\n  function flushActQueue(queue) {\n    if (!isFlushing) {\n      isFlushing = !0;\n      var i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          var callback = queue[i];\n\n          do {\n            ReactSharedInternals.didUsePromise = !1;\n            var continuation = callback(!1);\n\n            if (null !== continuation) {\n              if (ReactSharedInternals.didUsePromise) {\n                queue[i] = callback;\n                queue.splice(0, i);\n                return;\n              }\n\n              callback = continuation;\n            } else break;\n          } while (1);\n        }\n\n        queue.length = 0;\n      } catch (error) {\n        queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);\n      } finally {\n        isFlushing = !1;\n      }\n    }\n  }\n\n  \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n  var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n  Symbol.for(\"react.provider\");\n  var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      REACT_POSTPONE_TYPE = Symbol.for(\"react.postpone\"),\n      REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      didWarnStateUpdateForUnmountedComponent = {},\n      ReactNoopUpdateQueue = {\n    isMounted: function isMounted() {\n      return !1;\n    },\n    enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {\n      warnNoop(publicInstance, \"forceUpdate\");\n    },\n    enqueueReplaceState: function enqueueReplaceState(publicInstance) {\n      warnNoop(publicInstance, \"replaceState\");\n    },\n    enqueueSetState: function enqueueSetState(publicInstance) {\n      warnNoop(publicInstance, \"setState\");\n    }\n  },\n      assign = Object.assign,\n      emptyObject = {};\n  Object.freeze(emptyObject);\n  Component.prototype.isReactComponent = {};\n\n  Component.prototype.setState = function (partialState, callback) {\n    if (\"object\" !== _typeof(partialState) && \"function\" !== typeof partialState && null != partialState) throw Error(\"takes an object of state variables to update or a function which returns an object of state variables.\");\n    this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n  };\n\n  Component.prototype.forceUpdate = function (callback) {\n    this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n  };\n\n  var deprecatedAPIs = {\n    isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"],\n    replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"]\n  },\n      fnName;\n\n  for (fnName in deprecatedAPIs) {\n    deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n  }\n\n  ComponentDummy.prototype = Component.prototype;\n  deprecatedAPIs = PureComponent.prototype = new ComponentDummy();\n  deprecatedAPIs.constructor = PureComponent;\n  assign(deprecatedAPIs, Component.prototype);\n  deprecatedAPIs.isPureReactComponent = !0;\n  var isArrayImpl = Array.isArray,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals = {\n    H: null,\n    A: null,\n    T: null,\n    S: null,\n    actQueue: null,\n    isBatchingLegacy: !1,\n    didScheduleLegacyUpdate: !1,\n    didUsePromise: !1,\n    thrownErrors: [],\n    getCurrentStack: null\n  },\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n  new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n  var createTask = console.createTask ? console.createTask : function () {\n    return null;\n  },\n      specialPropKeyWarningShown,\n      didWarnAboutOldJSXRuntime;\n  var didWarnAboutElementRef = {};\n  var didWarnAboutMaps = !1,\n      userProvidedKeyEscapeRegex = /\\/+/g,\n      reportGlobalError = \"function\" === typeof reportError ? reportError : function (error) {\n    if (\"object\" === (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) && \"function\" === typeof window.ErrorEvent) {\n      var event = new window.ErrorEvent(\"error\", {\n        bubbles: !0,\n        cancelable: !0,\n        message: \"object\" === _typeof(error) && null !== error && \"string\" === typeof error.message ? String(error.message) : String(error),\n        error: error\n      });\n      if (!window.dispatchEvent(event)) return;\n    } else if (\"object\" === (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) && \"function\" === typeof process.emit) {\n      process.emit(\"uncaughtException\", error);\n      return;\n    }\n\n    console.error(error);\n  },\n      didWarnAboutMessageChannel = !1,\n      enqueueTaskImpl = null,\n      actScopeDepth = 0,\n      didWarnNoAwaitAct = !1,\n      isFlushing = !1,\n      queueSeveralMicrotasks = \"function\" === typeof queueMicrotask ? function (callback) {\n    queueMicrotask(function () {\n      return queueMicrotask(callback);\n    });\n  } : enqueueTask;\n  exports.Children = {\n    map: mapChildren,\n    forEach: function forEach(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments);\n      }, forEachContext);\n    },\n    count: function count(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++;\n      });\n      return n;\n    },\n    toArray: function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    },\n    only: function only(children) {\n      if (!isValidElement(children)) throw Error(\"React.Children.only expected to receive a single React element child.\");\n      return children;\n    }\n  };\n  exports.Component = Component;\n  exports.Fragment = REACT_FRAGMENT_TYPE;\n  exports.Profiler = REACT_PROFILER_TYPE;\n  exports.PureComponent = PureComponent;\n  exports.StrictMode = REACT_STRICT_MODE_TYPE;\n  exports.Suspense = REACT_SUSPENSE_TYPE;\n  exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;\n  exports.__COMPILER_RUNTIME = {\n    c: function c(size) {\n      return resolveDispatcher().useMemoCache(size);\n    }\n  };\n\n  exports.act = function (callback) {\n    var prevActQueue = ReactSharedInternals.actQueue,\n        prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n    var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [],\n        didAwaitActCall = !1;\n\n    try {\n      var result = callback();\n    } catch (error) {\n      ReactSharedInternals.thrownErrors.push(error);\n    }\n\n    if (0 < ReactSharedInternals.thrownErrors.length) throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;\n\n    if (null !== result && \"object\" === _typeof(result) && \"function\" === typeof result.then) {\n      var thenable = result;\n      queueSeveralMicrotasks(function () {\n        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error(\"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\"));\n      });\n      return {\n        then: function then(resolve, reject) {\n          didAwaitActCall = !0;\n          thenable.then(function (returnValue) {\n            popActScope(prevActQueue, prevActScopeDepth);\n\n            if (0 === prevActScopeDepth) {\n              try {\n                flushActQueue(queue), enqueueTask(function () {\n                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                });\n              } catch (error$0) {\n                ReactSharedInternals.thrownErrors.push(error$0);\n              }\n\n              if (0 < ReactSharedInternals.thrownErrors.length) {\n                var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);\n\n                ReactSharedInternals.thrownErrors.length = 0;\n                reject(_thrownError);\n              }\n            } else resolve(returnValue);\n          }, function (error) {\n            popActScope(prevActQueue, prevActScopeDepth);\n            0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);\n          });\n        }\n      };\n    }\n\n    var returnValue$jscomp$0 = result;\n    popActScope(prevActQueue, prevActScopeDepth);\n    0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function () {\n      didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error(\"A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\\n\\nawait act(() => ...)\"));\n    }), ReactSharedInternals.actQueue = null);\n    if (0 < ReactSharedInternals.thrownErrors.length) throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;\n    return {\n      then: function then(resolve, reject) {\n        didAwaitActCall = !0;\n        0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function () {\n          return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);\n        })) : resolve(returnValue$jscomp$0);\n      }\n    };\n  };\n\n  exports.cache = function (fn) {\n    return function () {\n      return fn.apply(null, arguments);\n    };\n  };\n\n  exports.captureOwnerStack = function () {\n    var getCurrentStack = ReactSharedInternals.getCurrentStack;\n    return null === getCurrentStack ? null : getCurrentStack();\n  };\n\n  exports.cloneElement = function (element, config, children) {\n    if (null === element || void 0 === element) throw Error(\"The argument must be a React element, but you passed \" + element + \".\");\n    var props = assign({}, element.props),\n        key = element.key,\n        owner = element._owner;\n\n    if (null != config) {\n      var JSCompiler_inline_result;\n\n      a: {\n        if (hasOwnProperty.call(config, \"ref\") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, \"ref\").get) && JSCompiler_inline_result.isReactWarning) {\n          JSCompiler_inline_result = !1;\n          break a;\n        }\n\n        JSCompiler_inline_result = void 0 !== config.ref;\n      }\n\n      JSCompiler_inline_result && (owner = getOwner());\n      hasValidKey(config) && (checkKeyStringCoercion(config.key), key = \"\" + config.key);\n\n      for (propName in config) {\n        !hasOwnProperty.call(config, propName) || \"key\" === propName || \"__self\" === propName || \"__source\" === propName || \"ref\" === propName && void 0 === config.ref || (props[propName] = config[propName]);\n      }\n    }\n\n    var propName = arguments.length - 2;\n    if (1 === propName) props.children = children;else if (1 < propName) {\n      JSCompiler_inline_result = Array(propName);\n\n      for (var i = 0; i < propName; i++) {\n        JSCompiler_inline_result[i] = arguments[i + 2];\n      }\n\n      props.children = JSCompiler_inline_result;\n    }\n    props = ReactElement(element.type, key, void 0, void 0, owner, props, element._debugStack, element._debugTask);\n\n    for (key = 2; key < arguments.length; key++) {\n      owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);\n    }\n\n    return props;\n  };\n\n  exports.createContext = function (defaultValue) {\n    defaultValue = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _currentValue: defaultValue,\n      _currentValue2: defaultValue,\n      _threadCount: 0,\n      Provider: null,\n      Consumer: null\n    };\n    defaultValue.Provider = defaultValue;\n    defaultValue.Consumer = {\n      $$typeof: REACT_CONSUMER_TYPE,\n      _context: defaultValue\n    };\n    defaultValue._currentRenderer = null;\n    defaultValue._currentRenderer2 = null;\n    return defaultValue;\n  };\n\n  exports.createElement = function (type, config, children) {\n    for (var i = 2; i < arguments.length; i++) {\n      var node = arguments[i];\n      isValidElement(node) && node._store && (node._store.validated = 1);\n    }\n\n    var propName;\n    i = {};\n    node = null;\n    if (null != config) for (propName in didWarnAboutOldJSXRuntime || !(\"__self\" in config) || \"key\" in config || (didWarnAboutOldJSXRuntime = !0, console.warn(\"Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform\")), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = \"\" + config.key), config) {\n      hasOwnProperty.call(config, propName) && \"key\" !== propName && \"__self\" !== propName && \"__source\" !== propName && (i[propName] = config[propName]);\n    }\n    var childrenLength = arguments.length - 2;\n    if (1 === childrenLength) i.children = children;else if (1 < childrenLength) {\n      for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++) {\n        childArray[_i] = arguments[_i + 2];\n      }\n\n      Object.freeze && Object.freeze(childArray);\n      i.children = childArray;\n    }\n    if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) {\n      void 0 === i[propName] && (i[propName] = childrenLength[propName]);\n    }\n    node && defineKeyPropWarningGetter(i, \"function\" === typeof type ? type.displayName || type.name || \"Unknown\" : type);\n    return ReactElement(type, node, void 0, void 0, getOwner(), i, Error(\"react-stack-top-frame\"), createTask(getTaskName(type)));\n  };\n\n  exports.createRef = function () {\n    var refObject = {\n      current: null\n    };\n    Object.seal(refObject);\n    return refObject;\n  };\n\n  exports.experimental_useEffectEvent = function (callback) {\n    return resolveDispatcher().useEffectEvent(callback);\n  };\n\n  exports.experimental_useOptimistic = function (passthrough, reducer) {\n    console.error(\"useOptimistic is now in canary. Remove the experimental_ prefix. The prefixed alias will be removed in an upcoming release.\");\n    return useOptimistic(passthrough, reducer);\n  };\n\n  exports.experimental_useResourceEffect = void 0;\n\n  exports.forwardRef = function (render) {\n    null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(\"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\") : \"function\" !== typeof render ? console.error(\"forwardRef requires a render function but was given %s.\", null === render ? \"null\" : _typeof(render)) : 0 !== render.length && 2 !== render.length && console.error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", 1 === render.length ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n    null != render && null != render.defaultProps && console.error(\"forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?\");\n    var elementType = {\n      $$typeof: REACT_FORWARD_REF_TYPE,\n      render: render\n    },\n        ownName;\n    Object.defineProperty(elementType, \"displayName\", {\n      enumerable: !1,\n      configurable: !0,\n      get: function get() {\n        return ownName;\n      },\n      set: function set(name) {\n        ownName = name;\n        render.name || render.displayName || (Object.defineProperty(render, \"name\", {\n          value: name\n        }), render.displayName = name);\n      }\n    });\n    return elementType;\n  };\n\n  exports.isValidElement = isValidElement;\n\n  exports.lazy = function (ctor) {\n    return {\n      $$typeof: REACT_LAZY_TYPE,\n      _payload: {\n        _status: -1,\n        _result: ctor\n      },\n      _init: lazyInitializer\n    };\n  };\n\n  exports.memo = function (type, compare) {\n    \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || type === REACT_VIEW_TRANSITION_TYPE || \"object\" === _typeof(type) && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) || console.error(\"memo: The first argument must be a component. Instead received: %s\", null === type ? \"null\" : _typeof(type));\n    compare = {\n      $$typeof: REACT_MEMO_TYPE,\n      type: type,\n      compare: void 0 === compare ? null : compare\n    };\n    var ownName;\n    Object.defineProperty(compare, \"displayName\", {\n      enumerable: !1,\n      configurable: !0,\n      get: function get() {\n        return ownName;\n      },\n      set: function set(name) {\n        ownName = name;\n        type.name || type.displayName || (Object.defineProperty(type, \"name\", {\n          value: name\n        }), type.displayName = name);\n      }\n    });\n    return compare;\n  };\n\n  exports.startTransition = function (scope) {\n    var prevTransition = ReactSharedInternals.T,\n        currentTransition = {};\n    ReactSharedInternals.T = currentTransition;\n    currentTransition._updatedFibers = new Set();\n\n    try {\n      var returnValue = scope(),\n          onStartTransitionFinish = ReactSharedInternals.S;\n      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n      \"object\" === _typeof(returnValue) && null !== returnValue && \"function\" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);\n    } catch (error) {\n      reportGlobalError(error);\n    } finally {\n      null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\")), ReactSharedInternals.T = prevTransition;\n    }\n  };\n\n  exports.unstable_Activity = REACT_OFFSCREEN_TYPE;\n  exports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n  exports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;\n\n  exports.unstable_getCacheForType = function (resourceType) {\n    var dispatcher = ReactSharedInternals.A;\n    return dispatcher ? dispatcher.getCacheForType(resourceType) : resourceType();\n  };\n\n  exports.unstable_postpone = function (reason) {\n    reason = Error(reason);\n    reason.$$typeof = REACT_POSTPONE_TYPE;\n    throw reason;\n  };\n\n  exports.unstable_useCacheRefresh = function () {\n    return resolveDispatcher().useCacheRefresh();\n  };\n\n  exports.use = function (usable) {\n    return resolveDispatcher().use(usable);\n  };\n\n  exports.useActionState = function (action, initialState, permalink) {\n    return resolveDispatcher().useActionState(action, initialState, permalink);\n  };\n\n  exports.useCallback = function (callback, deps) {\n    return resolveDispatcher().useCallback(callback, deps);\n  };\n\n  exports.useContext = function (Context) {\n    var dispatcher = resolveDispatcher();\n    Context.$$typeof === REACT_CONSUMER_TYPE && console.error(\"Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?\");\n    return dispatcher.useContext(Context);\n  };\n\n  exports.useDebugValue = function (value, formatterFn) {\n    return resolveDispatcher().useDebugValue(value, formatterFn);\n  };\n\n  exports.useDeferredValue = function (value, initialValue) {\n    return resolveDispatcher().useDeferredValue(value, initialValue);\n  };\n\n  exports.useEffect = function (create, deps) {\n    return resolveDispatcher().useEffect(create, deps);\n  };\n\n  exports.useId = function () {\n    return resolveDispatcher().useId();\n  };\n\n  exports.useImperativeHandle = function (ref, create, deps) {\n    return resolveDispatcher().useImperativeHandle(ref, create, deps);\n  };\n\n  exports.useInsertionEffect = function (create, deps) {\n    return resolveDispatcher().useInsertionEffect(create, deps);\n  };\n\n  exports.useLayoutEffect = function (create, deps) {\n    return resolveDispatcher().useLayoutEffect(create, deps);\n  };\n\n  exports.useMemo = function (create, deps) {\n    return resolveDispatcher().useMemo(create, deps);\n  };\n\n  exports.useOptimistic = useOptimistic;\n\n  exports.useReducer = function (reducer, initialArg, init) {\n    return resolveDispatcher().useReducer(reducer, initialArg, init);\n  };\n\n  exports.useRef = function (initialValue) {\n    return resolveDispatcher().useRef(initialValue);\n  };\n\n  exports.useState = function (initialState) {\n    return resolveDispatcher().useState(initialState);\n  };\n\n  exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {\n    return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  };\n\n  exports.useTransition = function () {\n    return resolveDispatcher().useTransition();\n  };\n\n  exports.version = \"19.1.0-experimental-bcee8aae-20250109\";\n  \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7O0FBVUE7Ozs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFQQTtBQVNBOztBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFPQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQWRBOztBQWdCQTtBQVFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUE5QkE7QUFnQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQU1BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7O0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFFQTtBQUNBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFLQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUtBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQU1BO0FBR0E7QUFFQTtBQUdBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBckJBOztBQU5BOztBQThCQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQU5BOztBQVBBOztBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQTJCQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBREE7QUF1QkE7QUFaQTtBQXNCQTtBQVFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7O0FBQ0E7QUFlQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBWkE7QUFBQTtBQTRCQTtBQUNBOztBQUNBO0FBQ0E7QUFRQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSUE7QUFMQTtBQUFBOztBQVdBO0FBQ0E7QUFEQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUZBO0FBQUE7QUFnQkE7QUFDQTtBQUdBO0FBQ0E7QUFKQTtBQUFBO0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFUQTtBQVdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQTlCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBL0JBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFPQTtBQUtBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUVBO0FBdkNBO0FBeUNBOztBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBTUE7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUVBO0FBYkE7QUFlQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFPQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTs7QUFVQTtBQUNBO0FBREE7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBVkE7QUFlQTtBQUNBO0FBRUE7QUFLQTtBQUxBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUVBO0FBT0E7QUFVQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQWlCQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFaQTtBQWNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFaQTtBQWNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFLQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9idWlsZC9vc3MtZXhwZXJpbWVudGFsL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcz9jZDAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIiVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzXCIsXG4gICAgICAgICAgICBpbmZvWzBdLFxuICAgICAgICAgICAgaW5mb1sxXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICAgICAgcHVibGljSW5zdGFuY2UgPVxuICAgICAgICAoKHB1YmxpY0luc3RhbmNlID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IpICYmXG4gICAgICAgICAgKHB1YmxpY0luc3RhbmNlLmRpc3BsYXlOYW1lIHx8IHB1YmxpY0luc3RhbmNlLm5hbWUpKSB8fFxuICAgICAgICBcIlJlYWN0Q2xhc3NcIjtcbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gcHVibGljSW5zdGFuY2UgKyBcIi5cIiArIGNhbGxlck5hbWU7XG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gfHxcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiBJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LlwiLFxuICAgICAgICAgIGNhbGxlck5hbWUsXG4gICAgICAgICAgcHVibGljSW5zdGFuY2VcbiAgICAgICAgKSxcbiAgICAgICAgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9ICEwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuICAgIGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDFcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlZpZXdUcmFuc2l0aW9uXCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgc2VsZixcbiAgICAgIHNvdXJjZSxcbiAgICAgIG93bmVyLFxuICAgICAgcHJvcHMsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgICAgIG5ld0tleSA9IFJlYWN0RWxlbWVudChcbiAgICAgICAgb2xkRWxlbWVudC50eXBlLFxuICAgICAgICBuZXdLZXksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBvbGRFbGVtZW50Ll9vd25lcixcbiAgICAgICAgb2xkRWxlbWVudC5wcm9wcyxcbiAgICAgICAgb2xkRWxlbWVudC5fZGVidWdTdGFjayxcbiAgICAgICAgb2xkRWxlbWVudC5fZGVidWdUYXNrXG4gICAgICApO1xuICAgICAgbmV3S2V5Ll9zdG9yZS52YWxpZGF0ZWQgPSBvbGRFbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQ7XG4gICAgICByZXR1cm4gbmV3S2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvYmplY3QgJiZcbiAgICAgICAgbnVsbCAhPT0gb2JqZWN0ICYmXG4gICAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gICAgICB2YXIgZXNjYXBlckxvb2t1cCA9IHsgXCI9XCI6IFwiPTBcIiwgXCI6XCI6IFwiPTJcIiB9O1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXCIkXCIgK1xuICAgICAgICBrZXkucmVwbGFjZSgvWz06XS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnQgJiZcbiAgICAgICAgbnVsbCAhPT0gZWxlbWVudCAmJlxuICAgICAgICBudWxsICE9IGVsZW1lbnQua2V5XG4gICAgICAgID8gKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oZWxlbWVudC5rZXkpLCBlc2NhcGUoXCJcIiArIGVsZW1lbnQua2V5KSlcbiAgICAgICAgOiBpbmRleC50b1N0cmluZygzNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMSgpIHt9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgdGhlbmFibGUuc3RhdHVzXG4gICAgICAgICAgICAgID8gdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSlcbiAgICAgICAgICAgICAgOiAoKHRoZW5hYmxlLnN0YXR1cyA9IFwicGVuZGluZ1wiKSxcbiAgICAgICAgICAgICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKHRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoKHRoZW5hYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgKHRoZW5hYmxlLnJlYXNvbiA9IGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICB0aGVuYWJsZS5zdGF0dXMpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGUgfHwgXCJib29sZWFuXCIgPT09IHR5cGUpIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZhciBpbnZva2VDYWxsYmFjayA9ICExO1xuICAgICAgaWYgKG51bGwgPT09IGNoaWxkcmVuKSBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gITA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgPSBjaGlsZHJlbi5faW5pdCksXG4gICAgICAgICAgICAgICAgICBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNoaWxkcmVuLl9wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSBjaGlsZHJlbjtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayhpbnZva2VDYWxsYmFjayk7XG4gICAgICAgIHZhciBjaGlsZEtleSA9XG4gICAgICAgICAgXCJcIiA9PT0gbmFtZVNvRmFyID8gXCIuXCIgKyBnZXRFbGVtZW50S2V5KGludm9rZUNhbGxiYWNrLCAwKSA6IG5hbWVTb0ZhcjtcbiAgICAgICAgaXNBcnJheUltcGwoY2FsbGJhY2spXG4gICAgICAgICAgPyAoKGVzY2FwZWRQcmVmaXggPSBcIlwiKSxcbiAgICAgICAgICAgIG51bGwgIT0gY2hpbGRLZXkgJiZcbiAgICAgICAgICAgICAgKGVzY2FwZWRQcmVmaXggPVxuICAgICAgICAgICAgICAgIGNoaWxkS2V5LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsIFwiJCYvXCIpICsgXCIvXCIpLFxuICAgICAgICAgICAgbWFwSW50b0FycmF5KGNhbGxiYWNrLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgXCJcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA6IG51bGwgIT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIChpc1ZhbGlkRWxlbWVudChjYWxsYmFjaykgJiZcbiAgICAgICAgICAgICAgKG51bGwgIT0gY2FsbGJhY2sua2V5ICYmXG4gICAgICAgICAgICAgICAgKChpbnZva2VDYWxsYmFjayAmJiBpbnZva2VDYWxsYmFjay5rZXkgPT09IGNhbGxiYWNrLmtleSkgfHxcbiAgICAgICAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY2FsbGJhY2sua2V5KSksXG4gICAgICAgICAgICAgIChlc2NhcGVkUHJlZml4ID0gY2xvbmVBbmRSZXBsYWNlS2V5KFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXggK1xuICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY2FsbGJhY2sua2V5IHx8XG4gICAgICAgICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgJiYgaW52b2tlQ2FsbGJhY2sua2V5ID09PSBjYWxsYmFjay5rZXkpXG4gICAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICA6IChcIlwiICsgY2FsbGJhY2sua2V5KS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiQmL1wiXG4gICAgICAgICAgICAgICAgICAgICAgKSArIFwiL1wiKSArXG4gICAgICAgICAgICAgICAgICBjaGlsZEtleVxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgXCJcIiAhPT0gbmFtZVNvRmFyICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPSBpbnZva2VDYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgIGlzVmFsaWRFbGVtZW50KGludm9rZUNhbGxiYWNrKSAmJlxuICAgICAgICAgICAgICAgIG51bGwgPT0gaW52b2tlQ2FsbGJhY2sua2V5ICYmXG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2suX3N0b3JlICYmXG4gICAgICAgICAgICAgICAgIWludm9rZUNhbGxiYWNrLl9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoZXNjYXBlZFByZWZpeC5fc3RvcmUudmFsaWRhdGVkID0gMiksXG4gICAgICAgICAgICAgIChjYWxsYmFjayA9IGVzY2FwZWRQcmVmaXgpKSxcbiAgICAgICAgICAgIGFycmF5LnB1c2goY2FsbGJhY2spKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpbnZva2VDYWxsYmFjayA9IDA7XG4gICAgICBjaGlsZEtleSA9IFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiIDogbmFtZVNvRmFyICsgXCI6XCI7XG4gICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIChuYW1lU29GYXIgPSBjaGlsZHJlbltpXSksXG4gICAgICAgICAgICAodHlwZSA9IGNoaWxkS2V5ICsgZ2V0RWxlbWVudEtleShuYW1lU29GYXIsIGkpKSxcbiAgICAgICAgICAgIChpbnZva2VDYWxsYmFjayArPSBtYXBJbnRvQXJyYXkoXG4gICAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgIGVzY2FwZWRQcmVmaXgsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKCgoaSA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSkpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaSA9PT0gY2hpbGRyZW4uZW50cmllcyAmJlxuICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgfHxcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FybkFib3V0TWFwcyA9ICEwKSksXG4gICAgICAgICAgICBjaGlsZHJlbiA9IGkuY2FsbChjaGlsZHJlbiksXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAhKG5hbWVTb0ZhciA9IGNoaWxkcmVuLm5leHQoKSkuZG9uZTtcblxuICAgICAgICApXG4gICAgICAgICAgKG5hbWVTb0ZhciA9IG5hbWVTb0Zhci52YWx1ZSksXG4gICAgICAgICAgICAodHlwZSA9IGNoaWxkS2V5ICsgZ2V0RWxlbWVudEtleShuYW1lU29GYXIsIGkrKykpLFxuICAgICAgICAgICAgKGludm9rZUNhbGxiYWNrICs9IG1hcEludG9BcnJheShcbiAgICAgICAgICAgICAgbmFtZVNvRmFyLFxuICAgICAgICAgICAgICBhcnJheSxcbiAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgICkpO1xuICAgICAgZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZSkge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGRyZW4udGhlbilcbiAgICAgICAgICByZXR1cm4gbWFwSW50b0FycmF5KFxuICAgICAgICAgICAgcmVzb2x2ZVRoZW5hYmxlKGNoaWxkcmVuKSxcbiAgICAgICAgICAgIGFycmF5LFxuICAgICAgICAgICAgZXNjYXBlZFByZWZpeCxcbiAgICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgYXJyYXkgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgK1xuICAgICAgICAgICAgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IGFycmF5XG4gICAgICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgICAgICA6IGFycmF5KSArXG4gICAgICAgICAgICBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICAgICAgaWYgKG51bGwgPT0gY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsIFwiXCIsIFwiXCIsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgICAgIGlmICgtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKSB7XG4gICAgICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgICAgICBjdG9yID0gY3RvcigpO1xuICAgICAgICBjdG9yLnRoZW4oXG4gICAgICAgICAgZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgICAgICAgaWYgKDAgPT09IHBheWxvYWQuX3N0YXR1cyB8fCAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICAgICAgICAocGF5bG9hZC5fc3RhdHVzID0gMSksIChwYXlsb2FkLl9yZXN1bHQgPSBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gcGF5bG9hZC5fc3RhdHVzIHx8IC0xID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgICAgICAgIChwYXlsb2FkLl9zdGF0dXMgPSAyKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIC0xID09PSBwYXlsb2FkLl9zdGF0dXMgJiZcbiAgICAgICAgICAoKHBheWxvYWQuX3N0YXR1cyA9IDApLCAocGF5bG9hZC5fcmVzdWx0ID0gY3RvcikpO1xuICAgICAgfVxuICAgICAgaWYgKDEgPT09IHBheWxvYWQuX3N0YXR1cylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoY3RvciA9IHBheWxvYWQuX3Jlc3VsdCksXG4gICAgICAgICAgdm9pZCAwID09PSBjdG9yICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImxhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcG9ydCgnLi9NeUNvbXBvbmVudCcpKVxcblxcbkRpZCB5b3UgYWNjaWRlbnRhbGx5IHB1dCBjdXJseSBicmFjZXMgYXJvdW5kIHRoZSBpbXBvcnQ/XCIsXG4gICAgICAgICAgICAgIGN0b3JcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXCJkZWZhdWx0XCIgaW4gY3RvciB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gIGNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcIixcbiAgICAgICAgICAgICAgY3RvclxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBjdG9yLmRlZmF1bHRcbiAgICAgICAgKTtcbiAgICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBudWxsID09PSBkaXNwYXRjaGVyICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgaWYgKG51bGwgPT09IGVucXVldWVUYXNrSW1wbClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9IChcInJlcXVpcmVcIiArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDAsIDcpO1xuICAgICAgICAgIGVucXVldWVUYXNrSW1wbCA9IChtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddKS5jYWxsKFxuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgXCJ0aW1lcnNcIlxuICAgICAgICAgICkuc2V0SW1tZWRpYXRlO1xuICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAhMSA9PT0gZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9ICEwKSxcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IGhhdmUgYSBNZXNzYWdlQ2hhbm5lbCBpbXBsZW1lbnRhdGlvbiwgc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMgaWYgeW91IGVuY291bnRlciB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZUVycm9ycyhlcnJvcnMpIHtcbiAgICAgIHJldHVybiAxIDwgZXJyb3JzLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBBZ2dyZWdhdGVFcnJvclxuICAgICAgICA/IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpXG4gICAgICAgIDogZXJyb3JzWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICBwcmV2QWN0U2NvcGVEZXB0aCAhPT0gYWN0U2NvcGVEZXB0aCAtIDEgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIllvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gQmUgc3VyZSB0byBhd2FpdCBwcmV2aW91cyBhY3QoKSBjYWxscyBiZWZvcmUgbWFraW5nIGEgbmV3IG9uZS4gXCJcbiAgICAgICAgKTtcbiAgICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBxdWV1ZSlcbiAgICAgICAgaWYgKDAgIT09IHF1ZXVlLmxlbmd0aClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG4gICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsO1xuICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgPyAoKHF1ZXVlID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgcmVqZWN0KHF1ZXVlKSlcbiAgICAgICAgOiByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hBY3RRdWV1ZShxdWV1ZSkge1xuICAgICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICAgIGlzRmx1c2hpbmcgPSAhMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gITE7XG4gICAgICAgICAgICAgIHZhciBjb250aW51YXRpb24gPSBjYWxsYmFjayghMSk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSBjb250aW51YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgcXVldWVbaV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjb250aW51YXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpICsgMSksIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc0ZsdXNoaW5nID0gITE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgICBSRUFDVF9QT1NUUE9ORV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvc3Rwb25lXCIpLFxuICAgICAgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qudmlld190cmFuc2l0aW9uXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge30sXG4gICAgICBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgXCJyZXBsYWNlU3RhdGVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIFwic2V0U3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgZW1wdHlPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIHBhcnRpYWxTdGF0ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPSBwYXJ0aWFsU3RhdGVcbiAgICAgIClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJ0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIlxuICAgICAgICApO1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBcInNldFN0YXRlXCIpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgXCJmb3JjZVVwZGF0ZVwiKTtcbiAgICB9O1xuICAgIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBbXG4gICAgICAgICAgXCJpc01vdW50ZWRcIixcbiAgICAgICAgICBcIkluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLlwiXG4gICAgICAgIF0sXG4gICAgICAgIHJlcGxhY2VTdGF0ZTogW1xuICAgICAgICAgIFwicmVwbGFjZVN0YXRlXCIsXG4gICAgICAgICAgXCJSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLlwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBmbk5hbWU7XG4gICAgZm9yIChmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpXG4gICAgICBkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpICYmXG4gICAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIENvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgZGVwcmVjYXRlZEFQSXMgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbiAgICBhc3NpZ24oZGVwcmVjYXRlZEFQSXMsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgIGRlcHJlY2F0ZWRBUElzLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gITA7XG4gICAgdmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gICAgICAgIEg6IG51bGwsXG4gICAgICAgIEE6IG51bGwsXG4gICAgICAgIFQ6IG51bGwsXG4gICAgICAgIFM6IG51bGwsXG4gICAgICAgIGFjdFF1ZXVlOiBudWxsLFxuICAgICAgICBpc0JhdGNoaW5nTGVnYWN5OiAhMSxcbiAgICAgICAgZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGU6ICExLFxuICAgICAgICBkaWRVc2VQcm9taXNlOiAhMSxcbiAgICAgICAgdGhyb3duRXJyb3JzOiBbXSxcbiAgICAgICAgZ2V0Q3VycmVudFN0YWNrOiBudWxsXG4gICAgICB9LFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xuICAgIG5ldyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXApKCk7XG4gICAgdmFyIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9LFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sXG4gICAgICBkaWRXYXJuQWJvdXRPbGRKU1hSdW50aW1lO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSAhMSxcbiAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZyxcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICAgICAgICA/IHJlcG9ydEVycm9yXG4gICAgICAgICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSAhMSxcbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG51bGwsXG4gICAgICBhY3RTY29wZURlcHRoID0gMCxcbiAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gITEsXG4gICAgICBpc0ZsdXNoaW5nID0gITEsXG4gICAgICBxdWV1ZVNldmVyYWxNaWNyb3Rhc2tzID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBlbnF1ZXVlVGFzaztcbiAgICBleHBvcnRzLkNoaWxkcmVuID0ge1xuICAgICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gICAgICAgIG1hcENoaWxkcmVuKFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JFYWNoQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGNvdW50OiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSxcbiAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICB9KSB8fCBbXVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9ubHk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICBleHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gICAgZXhwb3J0cy5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPVxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG4gICAgZXhwb3J0cy5fX0NPTVBJTEVSX1JVTlRJTUUgPSB7XG4gICAgICBjOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmFjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHByZXZBY3RRdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLFxuICAgICAgICBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgICBhY3RTY29wZURlcHRoKys7XG4gICAgICB2YXIgcXVldWUgPSAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPVxuICAgICAgICAgIG51bGwgIT09IHByZXZBY3RRdWV1ZSA/IHByZXZBY3RRdWV1ZSA6IFtdKSxcbiAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITE7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmICgwIDwgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgKFxuICAgICAgICAgIChwb3BBY3RTY29wZShwcmV2QWN0UXVldWUsIHByZXZBY3RTY29wZURlcHRoKSxcbiAgICAgICAgICAoY2FsbGJhY2sgPSBhZ2dyZWdhdGVFcnJvcnMoUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzKSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGggPSAwKSxcbiAgICAgICAgICBjYWxsYmFjaylcbiAgICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcmVzdWx0ICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXN1bHQgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVzdWx0LnRoZW5cbiAgICAgICkge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSByZXN1bHQ7XG4gICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCB8fFxuICAgICAgICAgICAgZGlkV2Fybk5vQXdhaXRBY3QgfHxcbiAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIllvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gVGhpcyBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgdGVzdGluZyBiZWhhdmlvdXIsIGludGVybGVhdmluZyBtdWx0aXBsZSBhY3QgY2FsbHMgYW5kIG1peGluZyB0aGVpciBzY29wZXMuIFlvdSBzaG91bGQgLSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKTtcIlxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRpZEF3YWl0QWN0Q2FsbCA9ICEwO1xuICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHByZXZBY3RTY29wZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IkMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aHJvd25FcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAgICAgICAgICAgMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gKChlcnJvciA9IGFnZ3JlZ2F0ZUVycm9ycyhcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcikpXG4gICAgICAgICAgICAgICAgICA6IHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHJldHVyblZhbHVlJGpzY29tcCQwID0gcmVzdWx0O1xuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFF1ZXVlLCBwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICAwID09PSBwcmV2QWN0U2NvcGVEZXB0aCAmJlxuICAgICAgICAoZmx1c2hBY3RRdWV1ZShxdWV1ZSksXG4gICAgICAgIDAgIT09IHF1ZXVlLmxlbmd0aCAmJlxuICAgICAgICAgIHF1ZXVlU2V2ZXJhbE1pY3JvdGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlkQXdhaXRBY3RDYWxsIHx8XG4gICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0IHx8XG4gICAgICAgICAgICAgICgoZGlkV2Fybk5vQXdhaXRBY3QgPSAhMCksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCBzdXNwZW5kZWQgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBidXQgdGhlIGBhY3RgIGNhbGwgd2FzIG5vdCBhd2FpdGVkLiBXaGVuIHRlc3RpbmcgUmVhY3QgY29tcG9uZW50cyB0aGF0IGRlcGVuZCBvbiBhc3luY2hyb25vdXMgZGF0YSwgeW91IG11c3QgYXdhaXQgdGhlIHJlc3VsdDpcXG5cXG5hd2FpdCBhY3QoKCkgPT4gLi4uKVwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPSBudWxsKSk7XG4gICAgICBpZiAoMCA8IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5sZW5ndGgpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAoKGNhbGxiYWNrID0gYWdncmVnYXRlRXJyb3JzKFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycykpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy50aHJvd25FcnJvcnMubGVuZ3RoID0gMCksXG4gICAgICAgICAgY2FsbGJhY2spXG4gICAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgZGlkQXdhaXRBY3RDYWxsID0gITA7XG4gICAgICAgICAgMCA9PT0gcHJldkFjdFNjb3BlRGVwdGhcbiAgICAgICAgICAgID8gKChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9IHF1ZXVlKSxcbiAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA6IHJlc29sdmUocmV0dXJuVmFsdWUkanNjb21wJDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jYWNoZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jYXB0dXJlT3duZXJTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBnZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZ2V0Q3VycmVudFN0YWNrID8gbnVsbCA6IGdldEN1cnJlbnRTdGFjaygpO1xuICAgIH07XG4gICAgZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICAgICAgaWYgKG51bGwgPT09IGVsZW1lbnQgfHwgdm9pZCAwID09PSBlbGVtZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgK1xuICAgICAgICAgICAgZWxlbWVudCArXG4gICAgICAgICAgICBcIi5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKSxcbiAgICAgICAga2V5ID0gZWxlbWVudC5rZXksXG4gICAgICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICBpZiAobnVsbCAhPSBjb25maWcpIHtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgYToge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcInJlZlwiKSAmJlxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgXCJyZWZcIlxuICAgICAgICAgICAgKS5nZXQpICYmXG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuaXNSZWFjdFdhcm5pbmdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdm9pZCAwICE9PSBjb25maWcucmVmO1xuICAgICAgICB9XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJiAob3duZXIgPSBnZXRPd25lcigpKTtcbiAgICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgIWhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgfHxcbiAgICAgICAgICAgIFwia2V5XCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgICAgICBcIl9fc2VsZlwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgXCJfX3NvdXJjZVwiID09PSBwcm9wTmFtZSB8fFxuICAgICAgICAgICAgKFwicmVmXCIgPT09IHByb3BOYW1lICYmIHZvaWQgMCA9PT0gY29uZmlnLnJlZikgfHxcbiAgICAgICAgICAgIChwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgaWYgKDEgPT09IHByb3BOYW1lKSBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZWxzZSBpZiAoMSA8IHByb3BOYW1lKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IEFycmF5KHByb3BOYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wTmFtZTsgaSsrKVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgICAgIHByb3BzLmNoaWxkcmVuID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBSZWFjdEVsZW1lbnQoXG4gICAgICAgIGVsZW1lbnQudHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgb3duZXIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1N0YWNrLFxuICAgICAgICBlbGVtZW50Ll9kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICBmb3IgKGtleSA9IDI7IGtleSA8IGFyZ3VtZW50cy5sZW5ndGg7IGtleSsrKVxuICAgICAgICAob3duZXIgPSBhcmd1bWVudHNba2V5XSksXG4gICAgICAgICAgaXNWYWxpZEVsZW1lbnQob3duZXIpICYmIG93bmVyLl9zdG9yZSAmJiAob3duZXIuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgZGVmYXVsdFZhbHVlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIENvbnN1bWVyOiBudWxsXG4gICAgICB9O1xuICAgICAgZGVmYXVsdFZhbHVlLlByb3ZpZGVyID0gZGVmYXVsdFZhbHVlO1xuICAgICAgZGVmYXVsdFZhbHVlLkNvbnN1bWVyID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OU1VNRVJfVFlQRSxcbiAgICAgICAgX2NvbnRleHQ6IGRlZmF1bHRWYWx1ZVxuICAgICAgfTtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICAgIGRlZmF1bHRWYWx1ZS5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpc1ZhbGlkRWxlbWVudChub2RlKSAmJiBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcE5hbWU7XG4gICAgICBpID0ge307XG4gICAgICBub2RlID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9IGNvbmZpZylcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiAoZGlkV2FybkFib3V0T2xkSlNYUnVudGltZSB8fFxuICAgICAgICAgICEoXCJfX3NlbGZcIiBpbiBjb25maWcpIHx8XG4gICAgICAgICAgXCJrZXlcIiBpbiBjb25maWcgfHxcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dE9sZEpTWFJ1bnRpbWUgPSAhMCksXG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJZb3VyIGFwcCAob3Igb25lIG9mIGl0cyBkZXBlbmRlbmNpZXMpIGlzIHVzaW5nIGFuIG91dGRhdGVkIEpTWCB0cmFuc2Zvcm0uIFVwZGF0ZSB0byB0aGUgbW9kZXJuIEpTWCB0cmFuc2Zvcm0gZm9yIGZhc3RlciBwZXJmb3JtYW5jZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9uZXctanN4LXRyYW5zZm9ybVwiXG4gICAgICAgICAgKSksXG4gICAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKG5vZGUgPSBcIlwiICsgY29uZmlnLmtleSkpLFxuICAgICAgICBjb25maWcpKVxuICAgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmXG4gICAgICAgICAgICBcIl9fc2VsZlwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAgICAgXCJfX3NvdXJjZVwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAgICAgKGlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgIGlmICgxID09PSBjaGlsZHJlbkxlbmd0aCkgaS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZWxzZSBpZiAoMSA8IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCksIF9pID0gMDtcbiAgICAgICAgICBfaSA8IGNoaWxkcmVuTGVuZ3RoO1xuICAgICAgICAgIF9pKytcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkQXJyYXlbX2ldID0gYXJndW1lbnRzW19pICsgMl07XG4gICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgICAgaS5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcylcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiAoKGNoaWxkcmVuTGVuZ3RoID0gdHlwZS5kZWZhdWx0UHJvcHMpLCBjaGlsZHJlbkxlbmd0aCkpXG4gICAgICAgICAgdm9pZCAwID09PSBpW3Byb3BOYW1lXSAmJiAoaVtwcm9wTmFtZV0gPSBjaGlsZHJlbkxlbmd0aFtwcm9wTmFtZV0pO1xuICAgICAgbm9kZSAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIGksXG4gICAgICAgIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpLFxuICAgICAgICBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKHR5cGUpKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlZk9iamVjdCA9IHsgY3VycmVudDogbnVsbCB9O1xuICAgICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgICAgIHJldHVybiByZWZPYmplY3Q7XG4gICAgfTtcbiAgICBleHBvcnRzLmV4cGVyaW1lbnRhbF91c2VFZmZlY3RFdmVudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlRWZmZWN0RXZlbnQoY2FsbGJhY2spO1xuICAgIH07XG4gICAgZXhwb3J0cy5leHBlcmltZW50YWxfdXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJ1c2VPcHRpbWlzdGljIGlzIG5vdyBpbiBjYW5hcnkuIFJlbW92ZSB0aGUgZXhwZXJpbWVudGFsXyBwcmVmaXguIFRoZSBwcmVmaXhlZCBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgcmVsZWFzZS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZXhwZXJpbWVudGFsX3VzZVJlc291cmNlRWZmZWN0ID0gdm9pZCAwO1xuICAgIGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgICAgIG51bGwgIT0gcmVuZGVyICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlIG1lbW8oZm9yd2FyZFJlZiguLi4pKS5cIlxuICAgICAgICAgIClcbiAgICAgICAgOiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLlwiLFxuICAgICAgICAgICAgICBudWxsID09PSByZW5kZXIgPyBcIm51bGxcIiA6IHR5cGVvZiByZW5kZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IDAgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIDIgIT09IHJlbmRlci5sZW5ndGggJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlc1wiLFxuICAgICAgICAgICAgICAxID09PSByZW5kZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBcIkRpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj9cIlxuICAgICAgICAgICAgICAgIDogXCJBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICBudWxsICE9IHJlbmRlciAmJlxuICAgICAgICBudWxsICE9IHJlbmRlci5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBkZWZhdWx0UHJvcHMuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/XCJcbiAgICAgICAgKTtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IHsgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIHJlbmRlcjogcmVuZGVyIH0sXG4gICAgICAgIG93bk5hbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICByZW5kZXIubmFtZSB8fFxuICAgICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlciwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAocmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbiAgICBleHBvcnRzLmxhenkgPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICAgICAgX3BheWxvYWQ6IHsgX3N0YXR1czogLTEsIF9yZXN1bHQ6IGN0b3IgfSxcbiAgICAgICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLmdldE1vZHVsZUlkKSkgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIm1lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkIHJlY2VpdmVkOiAlc1wiLFxuICAgICAgICAgIG51bGwgPT09IHR5cGUgPyBcIm51bGxcIiA6IHR5cGVvZiB0eXBlXG4gICAgICAgICk7XG4gICAgICBjb21wYXJlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb21wYXJlOiB2b2lkIDAgPT09IGNvbXBhcmUgPyBudWxsIDogY29tcGFyZVxuICAgICAgfTtcbiAgICAgIHZhciBvd25OYW1lO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBhcmUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBvd25OYW1lID0gbmFtZTtcbiAgICAgICAgICB0eXBlLm5hbWUgfHxcbiAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHxcbiAgICAgICAgICAgIChPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSksXG4gICAgICAgICAgICAodHlwZS5kaXNwbGF5TmFtZSA9IG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzY29wZSgpLFxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gJiZcbiAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKG5vb3AsIHJlcG9ydEdsb2JhbEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgJiZcbiAgICAgICAgICAoKHNjb3BlID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAxMCA8IHNjb3BlICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9BY3Rpdml0eSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICAgIGV4cG9ydHMudW5zdGFibGVfU3VzcGVuc2VMaXN0ID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICAgIGV4cG9ydHMudW5zdGFibGVfVmlld1RyYW5zaXRpb24gPSBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2dldENhY2hlRm9yVHlwZSA9IGZ1bmN0aW9uIChyZXNvdXJjZVR5cGUpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgICAgID8gZGlzcGF0Y2hlci5nZXRDYWNoZUZvclR5cGUocmVzb3VyY2VUeXBlKVxuICAgICAgICA6IHJlc291cmNlVHlwZSgpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9wb3N0cG9uZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJlYXNvbiA9IEVycm9yKHJlYXNvbik7XG4gICAgICByZWFzb24uJCR0eXBlb2YgPSBSRUFDVF9QT1NUUE9ORV9UWVBFO1xuICAgICAgdGhyb3cgcmVhc29uO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV91c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VDYWNoZVJlZnJlc2goKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlID0gZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlKHVzYWJsZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUFjdGlvblN0YXRlKFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgcGVybWFsaW5rXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VDb250ZXh0ID0gZnVuY3Rpb24gKENvbnRleHQpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICAgIENvbnRleHQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGJ1Z3MuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD9cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJZCgpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHJldHVybiByZXNvbHZlRGlzcGF0Y2hlcigpLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgIH07XG4gICAgZXhwb3J0cy51c2VPcHRpbWlzdGljID0gdXNlT3B0aW1pc3RpYztcbiAgICBleHBvcnRzLnVzZVJlZHVjZXIgPSBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlUmVmID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVN0YXRlID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVEaXNwYXRjaGVyKCkudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPSBmdW5jdGlvbiAoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZURpc3BhdGNoZXIoKS51c2VUcmFuc2l0aW9uKCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcIjE5LjEuMC1leHBlcmltZW50YWwtYmNlZThhYWUtMjAyNTAxMDlcIjtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react/cjs/react.development.js\n");

/***/ }),

/***/ "../../build/oss-experimental/react/index.js":
/*!***************************************************!*\
  !*** ../../build/oss-experimental/react/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"../../build/oss-experimental/react/cjs/react.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vYnVpbGQvb3NzLWV4cGVyaW1lbnRhbC9yZWFjdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9idWlsZC9vc3MtZXhwZXJpbWVudGFsL3JlYWN0L2luZGV4LmpzP2ZmY2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../build/oss-experimental/react/index.js\n");

/***/ }),

/***/ "../../node_modules/compare-versions/lib/esm/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/compare-versions/lib/esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compare\": () => (/* binding */ compare),\n/* harmony export */   \"compareVersions\": () => (/* binding */ compareVersions),\n/* harmony export */   \"satisfies\": () => (/* binding */ satisfies),\n/* harmony export */   \"validate\": () => (/* binding */ validate)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nvar compareVersions = function compareVersions(v1, v2) {\n  // validate input and split into segments\n  var n1 = validateAndParse(v1);\n  var n2 = validateAndParse(v2); // pop off the patch\n\n  var p1 = n1.pop();\n  var p2 = n2.pop(); // validate numbers\n\n  var r = compareSegments(n1, n2);\n  if (r !== 0) return r; // validate pre-release\n\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\n\nvar validate = function validate(version) {\n  return typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n};\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\n\nvar compare = function compare(v1, v2, operator) {\n  // validate input operator\n  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n\n  var res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\n\nvar satisfies = function satisfies(version, range) {\n  // if no range operator then \"=\"\n  var m = range.match(/^([<>=~^]+)/);\n  var op = m ? m[1] : '='; // if gt/lt/eq then operator compare\n\n  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either \"~\" or \"^\" is assumed\n\n  var _validateAndParse = validateAndParse(version),\n      _validateAndParse2 = _slicedToArray(_validateAndParse, 5),\n      v1 = _validateAndParse2[0],\n      v2 = _validateAndParse2[1],\n      v3 = _validateAndParse2[2],\n      vp = _validateAndParse2[4];\n\n  var _validateAndParse3 = validateAndParse(range),\n      _validateAndParse4 = _slicedToArray(_validateAndParse3, 5),\n      r1 = _validateAndParse4[0],\n      r2 = _validateAndParse4[1],\n      r3 = _validateAndParse4[2],\n      rp = _validateAndParse4[4];\n\n  var v = [v1, v2, v3];\n  var r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x']; // validate pre-release\n\n  if (rp) {\n    if (!vp) return false;\n    if (compareSegments(v, r) !== 0) return false;\n    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;\n  } // first non-zero number\n\n\n  var nonZero = r.findIndex(function (v) {\n    return v !== '0';\n  }) + 1; // pointer to where segments can be >=\n\n  var i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1; // before pointer must be equal\n\n  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false; // after pointer must be >=\n\n  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;\n  return true;\n};\nvar semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nvar validateAndParse = function validateAndParse(version) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n\n  var match = version.match(semver);\n\n  if (!match) {\n    throw new Error(\"Invalid argument not valid semver ('\".concat(version, \"' received)\"));\n  }\n\n  match.shift();\n  return match;\n};\n\nvar isWildcard = function isWildcard(s) {\n  return s === '*' || s === 'x' || s === 'X';\n};\n\nvar tryParse = function tryParse(v) {\n  var n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nvar forceType = function forceType(a, b) {\n  return _typeof(a) !== _typeof(b) ? [String(a), String(b)] : [a, b];\n};\n\nvar compareStrings = function compareStrings(a, b) {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n\n  var _forceType = forceType(tryParse(a), tryParse(b)),\n      _forceType2 = _slicedToArray(_forceType, 2),\n      ap = _forceType2[0],\n      bp = _forceType2[1];\n\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nvar compareSegments = function compareSegments(a, b) {\n  for (var i = 0; i < Math.max(a.length, b.length); i++) {\n    var r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n\n  return 0;\n};\n\nvar operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nvar allowedOperators = Object.keys(operatorResMap);\n\nvar assertValidOperator = function assertValidOperator(op) {\n  if (typeof op !== 'string') {\n    throw new TypeError(\"Invalid operator type, expected string but got \".concat(_typeof(op)));\n  }\n\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\"Invalid operator, expected one of \".concat(allowedOperators.join('|')));\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBhcmUtdmVyc2lvbnMvbGliL2VzbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUFBO0FBQUE7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBWUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQUE7O0FBR0E7O0FBR0E7O0FBR0E7QUFFQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7O0FBREE7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7O0FBRUE7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9zcmMvaW5kZXgudHM/MGUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbXBhcmUgW3NlbXZlcl0oaHR0cHM6Ly9zZW12ZXIub3JnLykgdmVyc2lvbiBzdHJpbmdzIHRvIGZpbmQgZ3JlYXRlciwgZXF1YWwgb3IgbGVzc2VyLlxuICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmdWxsIHNlbXZlciBzcGVjaWZpY2F0aW9uLCBpbmNsdWRpbmcgY29tcGFyaW5nIHZlcnNpb25zIHdpdGggZGlmZmVyZW50IG51bWJlciBvZiBkaWdpdHMgbGlrZSBgMS4wLjBgLCBgMS4wYCwgYDFgLCBhbmQgcHJlLXJlbGVhc2UgdmVyc2lvbnMgbGlrZSBgMS4wLjAtYWxwaGFgLlxuICogQHBhcmFtIHYxIC0gRmlyc3QgdmVyc2lvbiB0byBjb21wYXJlXG4gKiBAcGFyYW0gdjIgLSBTZWNvbmQgdmVyc2lvbiB0byBjb21wYXJlXG4gKiBAcmV0dXJucyBOdW1lcmljIHZhbHVlIGNvbXBhdGlibGUgd2l0aCB0aGUgW0FycmF5LnNvcnQoZm4pIGludGVyZmFjZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXBhcmVWZXJzaW9ucyA9ICh2MSwgdjIpID0+IHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dCBhbmQgc3BsaXQgaW50byBzZWdtZW50c1xuICAgIGNvbnN0IG4xID0gdmFsaWRhdGVBbmRQYXJzZSh2MSk7XG4gICAgY29uc3QgbjIgPSB2YWxpZGF0ZUFuZFBhcnNlKHYyKTtcbiAgICAvLyBwb3Agb2ZmIHRoZSBwYXRjaFxuICAgIGNvbnN0IHAxID0gbjEucG9wKCk7XG4gICAgY29uc3QgcDIgPSBuMi5wb3AoKTtcbiAgICAvLyB2YWxpZGF0ZSBudW1iZXJzXG4gICAgY29uc3QgciA9IGNvbXBhcmVTZWdtZW50cyhuMSwgbjIpO1xuICAgIGlmIChyICE9PSAwKVxuICAgICAgICByZXR1cm4gcjtcbiAgICAvLyB2YWxpZGF0ZSBwcmUtcmVsZWFzZVxuICAgIGlmIChwMSAmJiBwMikge1xuICAgICAgICByZXR1cm4gY29tcGFyZVNlZ21lbnRzKHAxLnNwbGl0KCcuJyksIHAyLnNwbGl0KCcuJykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwMSB8fCBwMikge1xuICAgICAgICByZXR1cm4gcDEgPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogVmFsaWRhdGUgW3NlbXZlcl0oaHR0cHM6Ly9zZW12ZXIub3JnLykgdmVyc2lvbiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gbnVtYmVyIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gbnVtYmVyIGlzIGEgdmFsaWQgc2VtdmVyIHZlcnNpb24gbnVtYmVyLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiB2YWxpZGF0ZSgnMS4wLjAtcmMuMScpOyAvLyByZXR1cm4gdHJ1ZVxuICogdmFsaWRhdGUoJzEuMC1yYy4xJyk7IC8vIHJldHVybiBmYWxzZVxuICogdmFsaWRhdGUoJ2ZvbycpOyAvLyByZXR1cm4gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGUgPSAodmVyc2lvbikgPT4gdHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnICYmIC9eW3ZcXGRdLy50ZXN0KHZlcnNpb24pICYmIHNlbXZlci50ZXN0KHZlcnNpb24pO1xuLyoqXG4gKiBDb21wYXJlIFtzZW12ZXJdKGh0dHBzOi8vc2VtdmVyLm9yZy8pIHZlcnNpb24gc3RyaW5ncyB1c2luZyB0aGUgc3BlY2lmaWVkIG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB2MSBGaXJzdCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB2MiBTZWNvbmQgdmVyc2lvbiB0byBjb21wYXJlXG4gKiBAcGFyYW0gb3BlcmF0b3IgQWxsb3dlZCBhcml0aG1ldGljIG9wZXJhdG9yIHRvIHVzZVxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb21wYXJpc29uIGJldHdlZW4gdGhlIGZpcnN0VmVyc2lvbiBhbmQgdGhlIHNlY29uZFZlcnNpb24gc2F0aXNmaWVzIHRoZSBvcGVyYXRvciwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29tcGFyZSgnMTAuMS44JywgJzEwLjAuNCcsICc+Jyk7IC8vIHJldHVybiB0cnVlXG4gKiBjb21wYXJlKCcxMC4wLjEnLCAnMTAuMC4xJywgJz0nKTsgLy8gcmV0dXJuIHRydWVcbiAqIGNvbXBhcmUoJzEwLjEuMScsICcxMC4yLjInLCAnPCcpOyAvLyByZXR1cm4gdHJ1ZVxuICogY29tcGFyZSgnMTAuMS4xJywgJzEwLjIuMicsICc8PScpOyAvLyByZXR1cm4gdHJ1ZVxuICogY29tcGFyZSgnMTAuMS4xJywgJzEwLjIuMicsICc+PScpOyAvLyByZXR1cm4gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgY29tcGFyZSA9ICh2MSwgdjIsIG9wZXJhdG9yKSA9PiB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXQgb3BlcmF0b3JcbiAgICBhc3NlcnRWYWxpZE9wZXJhdG9yKG9wZXJhdG9yKTtcbiAgICAvLyBzaW5jZSByZXN1bHQgb2YgY29tcGFyZVZlcnNpb25zIGNhbiBvbmx5IGJlIC0xIG9yIDAgb3IgMVxuICAgIC8vIGEgc2ltcGxlIG1hcCBjYW4gYmUgdXNlZCB0byByZXBsYWNlIHN3aXRjaFxuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpO1xuICAgIHJldHVybiBvcGVyYXRvclJlc01hcFtvcGVyYXRvcl0uaW5jbHVkZXMocmVzKTtcbn07XG4vKipcbiAqIE1hdGNoIFtucG0gc2VtdmVyXShodHRwczovL2RvY3MubnBtanMuY29tL2NsaS92Ni91c2luZy1ucG0vc2VtdmVyKSB2ZXJzaW9uIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gbnVtYmVyIHRvIG1hdGNoXG4gKiBAcGFyYW0gcmFuZ2UgUmFuZ2UgcGF0dGVybiBmb3IgdmVyc2lvblxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIG51bWJlciBpcyB3aXRoaW4gdGhlIHJhbmdlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBzYXRpc2ZpZXMoJzEuMS4wJywgJ14xLjAuMCcpOyAvLyByZXR1cm4gdHJ1ZVxuICogc2F0aXNmaWVzKCcxLjEuMCcsICd+MS4wLjAnKTsgLy8gcmV0dXJuIGZhbHNlXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSkgPT4ge1xuICAgIC8vIGlmIG5vIHJhbmdlIG9wZXJhdG9yIHRoZW4gXCI9XCJcbiAgICBjb25zdCBtID0gcmFuZ2UubWF0Y2goL14oWzw+PX5eXSspLyk7XG4gICAgY29uc3Qgb3AgPSBtID8gbVsxXSA6ICc9JztcbiAgICAvLyBpZiBndC9sdC9lcSB0aGVuIG9wZXJhdG9yIGNvbXBhcmVcbiAgICBpZiAob3AgIT09ICdeJyAmJiBvcCAhPT0gJ34nKVxuICAgICAgICByZXR1cm4gY29tcGFyZSh2ZXJzaW9uLCByYW5nZSwgb3ApO1xuICAgIC8vIGVsc2UgcmFuZ2Ugb2YgZWl0aGVyIFwiflwiIG9yIFwiXlwiIGlzIGFzc3VtZWRcbiAgICBjb25zdCBbdjEsIHYyLCB2MywgLCB2cF0gPSB2YWxpZGF0ZUFuZFBhcnNlKHZlcnNpb24pO1xuICAgIGNvbnN0IFtyMSwgcjIsIHIzLCAsIHJwXSA9IHZhbGlkYXRlQW5kUGFyc2UocmFuZ2UpO1xuICAgIGNvbnN0IHYgPSBbdjEsIHYyLCB2M107XG4gICAgY29uc3QgciA9IFtyMSwgcjIgIT09IG51bGwgJiYgcjIgIT09IHZvaWQgMCA/IHIyIDogJ3gnLCByMyAhPT0gbnVsbCAmJiByMyAhPT0gdm9pZCAwID8gcjMgOiAneCddO1xuICAgIC8vIHZhbGlkYXRlIHByZS1yZWxlYXNlXG4gICAgaWYgKHJwKSB7XG4gICAgICAgIGlmICghdnApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjb21wYXJlU2VnbWVudHModiwgcikgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjb21wYXJlU2VnbWVudHModnAuc3BsaXQoJy4nKSwgcnAuc3BsaXQoJy4nKSkgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBmaXJzdCBub24temVybyBudW1iZXJcbiAgICBjb25zdCBub25aZXJvID0gci5maW5kSW5kZXgoKHYpID0+IHYgIT09ICcwJykgKyAxO1xuICAgIC8vIHBvaW50ZXIgdG8gd2hlcmUgc2VnbWVudHMgY2FuIGJlID49XG4gICAgY29uc3QgaSA9IG9wID09PSAnficgPyAyIDogbm9uWmVybyA+IDEgPyBub25aZXJvIDogMTtcbiAgICAvLyBiZWZvcmUgcG9pbnRlciBtdXN0IGJlIGVxdWFsXG4gICAgaWYgKGNvbXBhcmVTZWdtZW50cyh2LnNsaWNlKDAsIGkpLCByLnNsaWNlKDAsIGkpKSAhPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFmdGVyIHBvaW50ZXIgbXVzdCBiZSA+PVxuICAgIGlmIChjb21wYXJlU2VnbWVudHModi5zbGljZShpKSwgci5zbGljZShpKSkgPT09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3Qgc2VtdmVyID0gL15bdl5+PD49XSo/KFxcZCspKD86XFwuKFt4Kl18XFxkKykoPzpcXC4oW3gqXXxcXGQrKSg/OlxcLihbeCpdfFxcZCspKT8oPzotKFtcXGRhLXpcXC1dKyg/OlxcLltcXGRhLXpcXC1dKykqKSk/KD86XFwrW1xcZGEtelxcLV0rKD86XFwuW1xcZGEtelxcLV0rKSopPyk/KT8kL2k7XG5jb25zdCB2YWxpZGF0ZUFuZFBhcnNlID0gKHZlcnNpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgZXhwZWN0ZWQgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gdmVyc2lvbi5tYXRjaChzZW12ZXIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50IG5vdCB2YWxpZCBzZW12ZXIgKCcke3ZlcnNpb259JyByZWNlaXZlZClgKTtcbiAgICB9XG4gICAgbWF0Y2guc2hpZnQoKTtcbiAgICByZXR1cm4gbWF0Y2g7XG59O1xuY29uc3QgaXNXaWxkY2FyZCA9IChzKSA9PiBzID09PSAnKicgfHwgcyA9PT0gJ3gnIHx8IHMgPT09ICdYJztcbmNvbnN0IHRyeVBhcnNlID0gKHYpID0+IHtcbiAgICBjb25zdCBuID0gcGFyc2VJbnQodiwgMTApO1xuICAgIHJldHVybiBpc05hTihuKSA/IHYgOiBuO1xufTtcbmNvbnN0IGZvcmNlVHlwZSA9IChhLCBiKSA9PiB0eXBlb2YgYSAhPT0gdHlwZW9mIGIgPyBbU3RyaW5nKGEpLCBTdHJpbmcoYildIDogW2EsIGJdO1xuY29uc3QgY29tcGFyZVN0cmluZ3MgPSAoYSwgYikgPT4ge1xuICAgIGlmIChpc1dpbGRjYXJkKGEpIHx8IGlzV2lsZGNhcmQoYikpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IFthcCwgYnBdID0gZm9yY2VUeXBlKHRyeVBhcnNlKGEpLCB0cnlQYXJzZShiKSk7XG4gICAgaWYgKGFwID4gYnApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChhcCA8IGJwKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3QgY29tcGFyZVNlZ21lbnRzID0gKGEsIGIpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7IGkrKykge1xuICAgICAgICBjb25zdCByID0gY29tcGFyZVN0cmluZ3MoYVtpXSB8fCAnMCcsIGJbaV0gfHwgJzAnKTtcbiAgICAgICAgaWYgKHIgIT09IDApXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3Qgb3BlcmF0b3JSZXNNYXAgPSB7XG4gICAgJz4nOiBbMV0sXG4gICAgJz49JzogWzAsIDFdLFxuICAgICc9JzogWzBdLFxuICAgICc8PSc6IFstMSwgMF0sXG4gICAgJzwnOiBbLTFdLFxufTtcbmNvbnN0IGFsbG93ZWRPcGVyYXRvcnMgPSBPYmplY3Qua2V5cyhvcGVyYXRvclJlc01hcCk7XG5jb25zdCBhc3NlcnRWYWxpZE9wZXJhdG9yID0gKG9wKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvciB0eXBlLCBleHBlY3RlZCBzdHJpbmcgYnV0IGdvdCAke3R5cGVvZiBvcH1gKTtcbiAgICB9XG4gICAgaWYgKGFsbG93ZWRPcGVyYXRvcnMuaW5kZXhPZihvcCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvcGVyYXRvciwgZXhwZWN0ZWQgb25lIG9mICR7YWxsb3dlZE9wZXJhdG9ycy5qb2luKCd8Jyl9YCk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/compare-versions/lib/esm/index.js\n");

/***/ }),

/***/ "../../node_modules/error-stack-parser/error-stack-parser.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/error-stack-parser/error-stack-parser.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ \"../../node_modules/stackframe/stackframe.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n        }\n\n        var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n\n        var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame({\n          functionName: functionName,\n          args: args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    }\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9lcnJvci1zdGFjay1wYXJzZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUdBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBOztBQUNBOztBQUdBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBcExBO0FBc0xBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9lcnJvci1zdGFjay1wYXJzZXIuanM/MTI4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdlcnJvci1zdGFjay1wYXJzZXInLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3N0YWNrZnJhbWUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5FcnJvclN0YWNrUGFyc2VyID0gZmFjdG9yeShyb290LlN0YWNrRnJhbWUpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlcihTdGFja0ZyYW1lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCA9IC8oXnxAKVxcUys6XFxkKy87XG4gICAgdmFyIENIUk9NRV9JRV9TVEFDS19SRUdFWFAgPSAvXlxccyphdCAuKihcXFMrOlxcZCt8XFwobmF0aXZlXFwpKS9tO1xuICAgIHZhciBTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQID0gL14oZXZhbEApPyhcXFtuYXRpdmUgY29kZV0pPyQvO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IG9mIFN0YWNrRnJhbWVzXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2UoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3Iuc3RhY2t0cmFjZSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVycm9yWydvcGVyYSNzb3VyY2Vsb2MnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2sgJiYgZXJyb3Iuc3RhY2subWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVY4T3JJRShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGRk9yU2FmYXJpKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZ2l2ZW4gRXJyb3Igb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU2VwYXJhdGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgZnJvbSBhIHN0cmluZyBvZiB0aGUgZm9ybTogKFVSSTpMaW5lOkNvbHVtbilcbiAgICAgICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24odXJsTGlrZSkge1xuICAgICAgICAgICAgLy8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG4gICAgICAgICAgICBpZiAodXJsTGlrZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1cmxMaWtlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlZ0V4cCA9IC8oLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcmVnRXhwLmV4ZWModXJsTGlrZS5yZXBsYWNlKC9bKCldL2csICcnKSk7XG4gICAgICAgICAgICByZXR1cm4gW3BhcnRzWzFdLCBwYXJ0c1syXSB8fCB1bmRlZmluZWQsIHBhcnRzWzNdIHx8IHVuZGVmaW5lZF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VWOE9ySUU6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlVjhPcklFKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyhldmFsICcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9ldmFsIGNvZGUvZywgJ2V2YWwnKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfChcXCksLiokKS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXChldmFsIGNvZGUvZywgJygnKTtcblxuICAgICAgICAgICAgICAgIC8vIGNhcHR1cmUgYW5kIHByZXNldmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gXCIoL2Zvby9teSBiYXIuanM6MTI6ODcpXCIgaW5cbiAgICAgICAgICAgICAgICAvLyBjYXNlIGl0IGhhcyBzcGFjZXMgaW4gaXQsIGFzIHRoZSBzdHJpbmcgaXMgc3BsaXQgb24gXFxzKyBsYXRlciBvblxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHNhbml0aXplZExpbmUubWF0Y2goLyAoXFwoKC4rKTooXFxkKyk6KFxcZCspXFwpJCkvKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBmcm9tIHRoZSBsaW5lLCBpZiBpdCB3YXMgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvbiA/IHNhbml0aXplZExpbmUucmVwbGFjZShsb2NhdGlvblswXSwgJycpIDogc2FuaXRpemVkTGluZTtcblxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzYW5pdGl6ZWRMaW5lLnNwbGl0KC9cXHMrLykuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgYSBsb2NhdGlvbiB3YXMgbWF0Y2hlZCwgcGFzcyBpdCB0byBleHRyYWN0TG9jYXRpb24oKSBvdGhlcndpc2UgcG9wIHRoZSBsYXN0IHRva2VuXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsb2NhdGlvbiA/IGxvY2F0aW9uWzFdIDogdG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oJyAnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gWydldmFsJywgJzxhbm9ueW1vdXM+J10uaW5kZXhPZihsb2NhdGlvblBhcnRzWzBdKSA+IC0xID8gdW5kZWZpbmVkIDogbG9jYXRpb25QYXJ0c1swXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZUZGT3JTYWZhcmk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlRkZPclNhZmFyaShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFsaW5lLm1hdGNoKFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcgPiBldmFsJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbDpcXGQrOlxcZCsvZywgJzokMScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ0AnKSA9PT0gLTEgJiYgbGluZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBldmFsIGZyYW1lcyBvbmx5IGhhdmUgZnVuY3Rpb24gbmFtZXMgYW5kIG5vdGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWVSZWdleCA9IC8oKC4qXCIuK1wiW15AXSopP1teQF0qKSg/OkApLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsaW5lLm1hdGNoKGZ1bmN0aW9uTmFtZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSA/IG1hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obGluZS5yZXBsYWNlKGZ1bmN0aW9uTmFtZVJlZ2V4LCAnJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5zdGFja3RyYWNlIHx8IChlLm1lc3NhZ2UuaW5kZXhPZignXFxuJykgPiAtMSAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZS5zcGxpdCgnXFxuJykubGVuZ3RoID4gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTkoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTEwKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTEoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmE5KGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhMTA6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMChlKSB7XG4gICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IG1hdGNoWzNdIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3BlcmEgMTAuNjUrIEVycm9yLnN0YWNrIHZlcnkgc2ltaWxhciB0byBGRi9TYWZhcmlcbiAgICAgICAgcGFyc2VPcGVyYTExOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTEoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQKSAmJiAhbGluZS5tYXRjaCgvXkVycm9yIGNyZWF0ZWQgYXQvKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24odG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25DYWxsID0gKHRva2Vucy5zaGlmdCgpIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25DYWxsXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uKDogKFxcdyspKT8+LywgJyQyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKFteKV0qXFwpL2csICcnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3NSYXc7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteKV0qKVxcKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NSYXcgPSBmdW5jdGlvbkNhbGwucmVwbGFjZSgvXlteKF0rXFwoKFteKV0qKVxcKSQvLCAnJDEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSAoYXJnc1JhdyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3NSYXcgPT09ICdbYXJndW1lbnRzIG5vdCBhdmFpbGFibGVdJykgP1xuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiBhcmdzUmF3LnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/error-stack-parser/error-stack-parser.js\n");

/***/ }),

/***/ "../../node_modules/lru-cache/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/lru-cache/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\n\n\nmodule.exports = LRUCache; // This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\n\nvar Map = __webpack_require__(/*! pseudomap */ \"../../node_modules/pseudomap/map.js\");\n\nvar util = __webpack_require__(/*! util */ \"../../node_modules/util/util.js\"); // A linked list to keep track of recently-used-ness\n\n\nvar Yallist = __webpack_require__(/*! yallist */ \"../../node_modules/yallist/yallist.js\"); // use symbols if possible, otherwise just _props\n\n\nvar hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1';\nvar makeSymbol;\n\nif (hasSymbol) {\n  makeSymbol = function makeSymbol(key) {\n    return Symbol(key);\n  };\n} else {\n  makeSymbol = function makeSymbol(key) {\n    return '_' + key;\n  };\n}\n\nvar MAX = makeSymbol('max');\nvar LENGTH = makeSymbol('length');\nvar LENGTH_CALCULATOR = makeSymbol('lengthCalculator');\nvar ALLOW_STALE = makeSymbol('allowStale');\nvar MAX_AGE = makeSymbol('maxAge');\nvar DISPOSE = makeSymbol('dispose');\nvar NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet');\nvar LRU_LIST = makeSymbol('lruList');\nvar CACHE = makeSymbol('cache');\n\nfunction naiveLength() {\n  return 1;\n} // lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\n\n\nfunction LRUCache(options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options);\n  }\n\n  if (typeof options === 'number') {\n    options = {\n      max: options\n    };\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  var max = this[MAX] = options.max; // Kind of weird to have a default max of Infinity, but oh well.\n\n  if (!max || !(typeof max === 'number') || max <= 0) {\n    this[MAX] = Infinity;\n  }\n\n  var lc = options.length || naiveLength;\n\n  if (typeof lc !== 'function') {\n    lc = naiveLength;\n  }\n\n  this[LENGTH_CALCULATOR] = lc;\n  this[ALLOW_STALE] = options.stale || false;\n  this[MAX_AGE] = options.maxAge || 0;\n  this[DISPOSE] = options.dispose;\n  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n  this.reset();\n} // resize the cache when the max changes.\n\n\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function set(mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity;\n    }\n\n    this[MAX] = mL;\n    trim(this);\n  },\n  get: function get() {\n    return this[MAX];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function set(allowStale) {\n    this[ALLOW_STALE] = !!allowStale;\n  },\n  get: function get() {\n    return this[ALLOW_STALE];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function set(mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0;\n    }\n\n    this[MAX_AGE] = mA;\n    trim(this);\n  },\n  get: function get() {\n    return this[MAX_AGE];\n  },\n  enumerable: true\n}); // resize the cache when the lengthCalculator changes.\n\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function set(lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength;\n    }\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC;\n      this[LENGTH] = 0;\n      this[LRU_LIST].forEach(function (hit) {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n        this[LENGTH] += hit.length;\n      }, this);\n    }\n\n    trim(this);\n  },\n  get: function get() {\n    return this[LENGTH_CALCULATOR];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function get() {\n    return this[LENGTH];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function get() {\n    return this[LRU_LIST].length;\n  },\n  enumerable: true\n});\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this[LRU_LIST].tail; walker !== null;) {\n    var prev = walker.prev;\n    forEachStep(this, fn, walker, thisp);\n    walker = prev;\n  }\n};\n\nfunction forEachStep(self, fn, node, thisp) {\n  var hit = node.value;\n\n  if (isStale(self, hit)) {\n    del(self, node);\n\n    if (!self[ALLOW_STALE]) {\n      hit = undefined;\n    }\n  }\n\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self);\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this[LRU_LIST].head; walker !== null;) {\n    var next = walker.next;\n    forEachStep(this, fn, walker, thisp);\n    walker = next;\n  }\n};\n\nLRUCache.prototype.keys = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.key;\n  }, this);\n};\n\nLRUCache.prototype.values = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.value;\n  }, this);\n};\n\nLRUCache.prototype.reset = function () {\n  if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n    this[LRU_LIST].forEach(function (hit) {\n      this[DISPOSE](hit.key, hit.value);\n    }, this);\n  }\n\n  this[CACHE] = new Map(); // hash of items by key\n\n  this[LRU_LIST] = new Yallist(); // list of items in order of use recency\n\n  this[LENGTH] = 0; // length of items in the list\n};\n\nLRUCache.prototype.dump = function () {\n  return this[LRU_LIST].map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      };\n    }\n  }, this).toArray().filter(function (h) {\n    return h;\n  });\n};\n\nLRUCache.prototype.dumpLru = function () {\n  return this[LRU_LIST];\n};\n/* istanbul ignore next */\n\n\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {';\n  var extras = false;\n  var as = this[ALLOW_STALE];\n\n  if (as) {\n    str += '\\n  allowStale: true';\n    extras = true;\n  }\n\n  var max = this[MAX];\n\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  max: ' + util.inspect(max, opts);\n    extras = true;\n  }\n\n  var maxAge = this[MAX_AGE];\n\n  if (maxAge) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts);\n    extras = true;\n  }\n\n  var lc = this[LENGTH_CALCULATOR];\n\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  length: ' + util.inspect(this[LENGTH], opts);\n    extras = true;\n  }\n\n  var didFirst = false;\n  this[LRU_LIST].forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  ';\n    } else {\n      if (extras) {\n        str += ',\\n';\n      }\n\n      didFirst = true;\n      str += '\\n  ';\n    }\n\n    var key = util.inspect(item.key).split('\\n').join('\\n  ');\n    var val = {\n      value: item.value\n    };\n\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge;\n    }\n\n    if (lc !== naiveLength) {\n      val.length = item.length;\n    }\n\n    if (isStale(this, item)) {\n      val.stale = true;\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ');\n    str += key + ' => ' + val;\n  });\n\n  if (didFirst || extras) {\n    str += '\\n';\n  }\n\n  str += '}';\n  return str;\n};\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this[MAX_AGE];\n  var now = maxAge ? Date.now() : 0;\n  var len = this[LENGTH_CALCULATOR](value, key);\n\n  if (this[CACHE].has(key)) {\n    if (len > this[MAX]) {\n      del(this, this[CACHE].get(key));\n      return false;\n    }\n\n    var node = this[CACHE].get(key);\n    var item = node.value; // dispose of the old one before overwriting\n    // split out into 2 ifs for better coverage tracking\n\n    if (this[DISPOSE]) {\n      if (!this[NO_DISPOSE_ON_SET]) {\n        this[DISPOSE](key, item.value);\n      }\n    }\n\n    item.now = now;\n    item.maxAge = maxAge;\n    item.value = value;\n    this[LENGTH] += len - item.length;\n    item.length = len;\n    this.get(key);\n    trim(this);\n    return true;\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n  if (hit.length > this[MAX]) {\n    if (this[DISPOSE]) {\n      this[DISPOSE](key, value);\n    }\n\n    return false;\n  }\n\n  this[LENGTH] += hit.length;\n  this[LRU_LIST].unshift(hit);\n  this[CACHE].set(key, this[LRU_LIST].head);\n  trim(this);\n  return true;\n};\n\nLRUCache.prototype.has = function (key) {\n  if (!this[CACHE].has(key)) return false;\n  var hit = this[CACHE].get(key).value;\n\n  if (isStale(this, hit)) {\n    return false;\n  }\n\n  return true;\n};\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true);\n};\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false);\n};\n\nLRUCache.prototype.pop = function () {\n  var node = this[LRU_LIST].tail;\n  if (!node) return null;\n  del(this, node);\n  return node.value;\n};\n\nLRUCache.prototype.del = function (key) {\n  del(this, this[CACHE].get(key));\n};\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset();\n  var now = Date.now(); // A previous serialized cache has the most recent items first\n\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l];\n    var expiresAt = hit.e || 0;\n\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v);\n    } else {\n      var maxAge = expiresAt - now; // dont add already expired items\n\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge);\n      }\n    }\n  }\n};\n\nLRUCache.prototype.prune = function () {\n  var self = this;\n  this[CACHE].forEach(function (value, key) {\n    get(self, key, false);\n  });\n};\n\nfunction get(self, key, doUse) {\n  var node = self[CACHE].get(key);\n\n  if (node) {\n    var hit = node.value;\n\n    if (isStale(self, hit)) {\n      del(self, node);\n      if (!self[ALLOW_STALE]) hit = undefined;\n    } else {\n      if (doUse) {\n        self[LRU_LIST].unshiftNode(node);\n      }\n    }\n\n    if (hit) hit = hit.value;\n  }\n\n  return hit;\n}\n\nfunction isStale(self, hit) {\n  if (!hit || !hit.maxAge && !self[MAX_AGE]) {\n    return false;\n  }\n\n  var stale = false;\n  var diff = Date.now() - hit.now;\n\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge;\n  } else {\n    stale = self[MAX_AGE] && diff > self[MAX_AGE];\n  }\n\n  return stale;\n}\n\nfunction trim(self) {\n  if (self[LENGTH] > self[MAX]) {\n    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev;\n      del(self, walker);\n      walker = prev;\n    }\n  }\n}\n\nfunction del(self, node) {\n  if (node) {\n    var hit = node.value;\n\n    if (self[DISPOSE]) {\n      self[DISPOSE](hit.key, hit.value);\n    }\n\n    self[LENGTH] -= hit.length;\n    self[CACHE].delete(hit.key);\n    self[LRU_LIST].removeNode(node);\n  }\n} // classy, since V8 prefers predictable objects.\n\n\nfunction Entry(key, value, length, now, maxAge) {\n  this.key = key;\n  this.value = value;\n  this.length = length;\n  this.now = now;\n  this.maxAge = maxAge || 0;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7QUFHQTs7QUFDQTs7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFHQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBOztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFoQkE7QUFtQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBOztBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzPzkwOGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcblxuLy8gVGhpcyB3aWxsIGJlIGEgcHJvcGVyIGl0ZXJhYmxlICdNYXAnIGluIGVuZ2luZXMgdGhhdCBzdXBwb3J0IGl0LFxuLy8gb3IgYSBmYWtleS1mYWtlIFBzZXVkb01hcCBpbiBvbGRlciB2ZXJzaW9ucy5cbnZhciBNYXAgPSByZXF1aXJlKCdwc2V1ZG9tYXAnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xudmFyIFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuLy8gdXNlIHN5bWJvbHMgaWYgcG9zc2libGUsIG90aGVyd2lzZSBqdXN0IF9wcm9wc1xudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvY2Vzcy5lbnYuX25vZGVMUlVDYWNoZUZvcmNlTm9TeW1ib2wgIT09ICcxJ1xudmFyIG1ha2VTeW1ib2xcbmlmIChoYXNTeW1ib2wpIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gU3ltYm9sKGtleSlcbiAgfVxufSBlbHNlIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gJ18nICsga2V5XG4gIH1cbn1cblxudmFyIE1BWCA9IG1ha2VTeW1ib2woJ21heCcpXG52YXIgTEVOR1RIID0gbWFrZVN5bWJvbCgnbGVuZ3RoJylcbnZhciBMRU5HVEhfQ0FMQ1VMQVRPUiA9IG1ha2VTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxudmFyIEFMTE9XX1NUQUxFID0gbWFrZVN5bWJvbCgnYWxsb3dTdGFsZScpXG52YXIgTUFYX0FHRSA9IG1ha2VTeW1ib2woJ21heEFnZScpXG52YXIgRElTUE9TRSA9IG1ha2VTeW1ib2woJ2Rpc3Bvc2UnKVxudmFyIE5PX0RJU1BPU0VfT05fU0VUID0gbWFrZVN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxudmFyIExSVV9MSVNUID0gbWFrZVN5bWJvbCgnbHJ1TGlzdCcpXG52YXIgQ0FDSEUgPSBtYWtlU3ltYm9sKCdjYWNoZScpXG5cbmZ1bmN0aW9uIG5haXZlTGVuZ3RoICgpIHsgcmV0dXJuIDEgfVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmZ1bmN0aW9uIExSVUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlVDYWNoZSkpIHtcbiAgICByZXR1cm4gbmV3IExSVUNhY2hlKG9wdGlvbnMpXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4XG4gIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgaWYgKCFtYXggfHxcbiAgICAgICEodHlwZW9mIG1heCA9PT0gJ251bWJlcicpIHx8XG4gICAgICBtYXggPD0gMCkge1xuICAgIHRoaXNbTUFYXSA9IEluZmluaXR5XG4gIH1cblxuICB2YXIgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICBpZiAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgbGMgPSBuYWl2ZUxlbmd0aFxuICB9XG4gIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbGNcblxuICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbWF4Jywge1xuICBzZXQ6IGZ1bmN0aW9uIChtTCkge1xuICAgIGlmICghbUwgfHwgISh0eXBlb2YgbUwgPT09ICdudW1iZXInKSB8fCBtTCA8PSAwKSB7XG4gICAgICBtTCA9IEluZmluaXR5XG4gICAgfVxuICAgIHRoaXNbTUFYXSA9IG1MXG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdhbGxvd1N0YWxlJywge1xuICBzZXQ6IGZ1bmN0aW9uIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdtYXhBZ2UnLCB7XG4gIHNldDogZnVuY3Rpb24gKG1BKSB7XG4gICAgaWYgKCFtQSB8fCAhKHR5cGVvZiBtQSA9PT0gJ251bWJlcicpIHx8IG1BIDwgMCkge1xuICAgICAgbUEgPSAwXG4gICAgfVxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbGVuZ3RoQ2FsY3VsYXRvcicsIHtcbiAgc2V0OiBmdW5jdGlvbiAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG4gICAgfVxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdpdGVtQ291bnQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbkxSVUNhY2hlLnByb3RvdHlwZS5yZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgd2Fsa2VyID0gcHJldlxuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdGVwIChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApIHtcbiAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIHtcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuICBpZiAoaGl0KSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICB3YWxrZXIgPSBuZXh0XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsua2V5XG4gIH0sIHRoaXMpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsudmFsdWVcbiAgfSwgdGhpcylcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICBpZiAoIWlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpLnRvQXJyYXkoKS5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICByZXR1cm4gaFxuICB9KVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcExydSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5MUlVDYWNoZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIChuLCBvcHRzKSB7XG4gIHZhciBzdHIgPSAnTFJVQ2FjaGUgeydcbiAgdmFyIGV4dHJhcyA9IGZhbHNlXG5cbiAgdmFyIGFzID0gdGhpc1tBTExPV19TVEFMRV1cbiAgaWYgKGFzKSB7XG4gICAgc3RyICs9ICdcXG4gIGFsbG93U3RhbGU6IHRydWUnXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXVxuICBpZiAobWF4ICYmIG1heCAhPT0gSW5maW5pdHkpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXg6ICcgKyB1dGlsLmluc3BlY3QobWF4LCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBtYXhBZ2UgPSB0aGlzW01BWF9BR0VdXG4gIGlmIChtYXhBZ2UpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXhBZ2U6ICcgKyB1dGlsLmluc3BlY3QobWF4QWdlLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBsYyA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdXG4gIGlmIChsYyAmJiBsYyAhPT0gbmFpdmVMZW5ndGgpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBsZW5ndGg6ICcgKyB1dGlsLmluc3BlY3QodGhpc1tMRU5HVEhdLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBkaWRGaXJzdCA9IGZhbHNlXG4gIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoZGlkRmlyc3QpIHtcbiAgICAgIHN0ciArPSAnLFxcbiAgJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXh0cmFzKSB7XG4gICAgICAgIHN0ciArPSAnLFxcbidcbiAgICAgIH1cbiAgICAgIGRpZEZpcnN0ID0gdHJ1ZVxuICAgICAgc3RyICs9ICdcXG4gICdcbiAgICB9XG4gICAgdmFyIGtleSA9IHV0aWwuaW5zcGVjdChpdGVtLmtleSkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgJylcbiAgICB2YXIgdmFsID0geyB2YWx1ZTogaXRlbS52YWx1ZSB9XG4gICAgaWYgKGl0ZW0ubWF4QWdlICE9PSBtYXhBZ2UpIHtcbiAgICAgIHZhbC5tYXhBZ2UgPSBpdGVtLm1heEFnZVxuICAgIH1cbiAgICBpZiAobGMgIT09IG5haXZlTGVuZ3RoKSB7XG4gICAgICB2YWwubGVuZ3RoID0gaXRlbS5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGlzU3RhbGUodGhpcywgaXRlbSkpIHtcbiAgICAgIHZhbC5zdGFsZSA9IHRydWVcbiAgICB9XG5cbiAgICB2YWwgPSB1dGlsLmluc3BlY3QodmFsLCBvcHRzKS5zcGxpdCgnXFxuJykuam9pbignXFxuICAnKVxuICAgIHN0ciArPSBrZXkgKyAnID0+ICcgKyB2YWxcbiAgfSlcblxuICBpZiAoZGlkRmlyc3QgfHwgZXh0cmFzKSB7XG4gICAgc3RyICs9ICdcXG4nXG4gIH1cbiAgc3RyICs9ICd9J1xuXG4gIHJldHVybiBzdHJcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICB2YXIgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgdmFyIGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgIHZhciBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pIHtcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlbS5ub3cgPSBub3dcbiAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgdGhpcy5nZXQoa2V5KVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdmFyIGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgdHJpbSh0aGlzKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgdmFyIGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGxcbiAgZGVsKHRoaXMsIG5vZGUpXG4gIHJldHVybiBub2RlLnZhbHVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIC8vIHJlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KClcblxuICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgdmFyIGhpdCA9IGFycltsXVxuICAgIHZhciBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgaWYgKGV4cGlyZXNBdCA9PT0gMCkge1xuICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBydW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpc1tDQUNIRV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGdldChzZWxmLCBrZXksIGZhbHNlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXQgKHNlbGYsIGtleSwgZG9Vc2UpIHtcbiAgdmFyIG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoaXQpIGhpdCA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuZnVuY3Rpb24gaXNTdGFsZSAoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgc3RhbGUgPSBmYWxzZVxuICB2YXIgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIGlmIChoaXQubWF4QWdlKSB7XG4gICAgc3RhbGUgPSBkaWZmID4gaGl0Lm1heEFnZVxuICB9IGVsc2Uge1xuICAgIHN0YWxlID0gc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG4gIH1cbiAgcmV0dXJuIHN0YWxlXG59XG5cbmZ1bmN0aW9uIHRyaW0gKHNlbGYpIHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAodmFyIHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWwgKHNlbGYsIG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKSB7XG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcbiAgICB9XG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuLy8gY2xhc3N5LCBzaW5jZSBWOCBwcmVmZXJzIHByZWRpY3RhYmxlIG9iamVjdHMuXG5mdW5jdGlvbiBFbnRyeSAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5ub3cgPSBub3dcbiAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/lru-cache/index.js\n");

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!*********************************************!*\
  !*** ../../node_modules/process/browser.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzE3YWQiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSUEsT0FBTyxHQUFHQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsRUFBL0IsQyxDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsUUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIOztBQUNELFNBQVNDLG1CQUFULEdBQWdDO0FBQzVCLFFBQU0sSUFBSUQsS0FBSixDQUFVLG1DQUFWLENBQU47QUFDSDs7QUFDQSxhQUFZO0FBQ1QsTUFBSTtBQUNBLFFBQUksT0FBT0UsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNsQ0wsTUFBQUEsZ0JBQWdCLEdBQUdLLFVBQW5CO0FBQ0gsS0FGRCxNQUVPO0FBQ0hMLE1BQUFBLGdCQUFnQixHQUFHRSxnQkFBbkI7QUFDSDtBQUNKLEdBTkQsQ0FNRSxPQUFPSSxDQUFQLEVBQVU7QUFDUk4sSUFBQUEsZ0JBQWdCLEdBQUdFLGdCQUFuQjtBQUNIOztBQUNELE1BQUk7QUFDQSxRQUFJLE9BQU9LLFlBQVAsS0FBd0IsVUFBNUIsRUFBd0M7QUFDcENOLE1BQUFBLGtCQUFrQixHQUFHTSxZQUFyQjtBQUNILEtBRkQsTUFFTztBQUNITixNQUFBQSxrQkFBa0IsR0FBR0csbUJBQXJCO0FBQ0g7QUFDSixHQU5ELENBTUUsT0FBT0UsQ0FBUCxFQUFVO0FBQ1JMLElBQUFBLGtCQUFrQixHQUFHRyxtQkFBckI7QUFDSDtBQUNKLENBbkJBLEdBQUQ7O0FBb0JBLFNBQVNJLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3JCLE1BQUlULGdCQUFnQixLQUFLSyxVQUF6QixFQUFxQztBQUNqQztBQUNBLFdBQU9BLFVBQVUsQ0FBQ0ksR0FBRCxFQUFNLENBQU4sQ0FBakI7QUFDSCxHQUpvQixDQUtyQjs7O0FBQ0EsTUFBSSxDQUFDVCxnQkFBZ0IsS0FBS0UsZ0JBQXJCLElBQXlDLENBQUNGLGdCQUEzQyxLQUFnRUssVUFBcEUsRUFBZ0Y7QUFDNUVMLElBQUFBLGdCQUFnQixHQUFHSyxVQUFuQjtBQUNBLFdBQU9BLFVBQVUsQ0FBQ0ksR0FBRCxFQUFNLENBQU4sQ0FBakI7QUFDSDs7QUFDRCxNQUFJO0FBQ0E7QUFDQSxXQUFPVCxnQkFBZ0IsQ0FBQ1MsR0FBRCxFQUFNLENBQU4sQ0FBdkI7QUFDSCxHQUhELENBR0UsT0FBTUgsQ0FBTixFQUFRO0FBQ04sUUFBSTtBQUNBO0FBQ0EsYUFBT04sZ0JBQWdCLENBQUNVLElBQWpCLENBQXNCLElBQXRCLEVBQTRCRCxHQUE1QixFQUFpQyxDQUFqQyxDQUFQO0FBQ0gsS0FIRCxDQUdFLE9BQU1ILENBQU4sRUFBUTtBQUNOO0FBQ0EsYUFBT04sZ0JBQWdCLENBQUNVLElBQWpCLENBQXNCLElBQXRCLEVBQTRCRCxHQUE1QixFQUFpQyxDQUFqQyxDQUFQO0FBQ0g7QUFDSjtBQUdKOztBQUNELFNBQVNFLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDO0FBQzdCLE1BQUlYLGtCQUFrQixLQUFLTSxZQUEzQixFQUF5QztBQUNyQztBQUNBLFdBQU9BLFlBQVksQ0FBQ0ssTUFBRCxDQUFuQjtBQUNILEdBSjRCLENBSzdCOzs7QUFDQSxNQUFJLENBQUNYLGtCQUFrQixLQUFLRyxtQkFBdkIsSUFBOEMsQ0FBQ0gsa0JBQWhELEtBQXVFTSxZQUEzRSxFQUF5RjtBQUNyRk4sSUFBQUEsa0JBQWtCLEdBQUdNLFlBQXJCO0FBQ0EsV0FBT0EsWUFBWSxDQUFDSyxNQUFELENBQW5CO0FBQ0g7O0FBQ0QsTUFBSTtBQUNBO0FBQ0EsV0FBT1gsa0JBQWtCLENBQUNXLE1BQUQsQ0FBekI7QUFDSCxHQUhELENBR0UsT0FBT04sQ0FBUCxFQUFTO0FBQ1AsUUFBSTtBQUNBO0FBQ0EsYUFBT0wsa0JBQWtCLENBQUNTLElBQW5CLENBQXdCLElBQXhCLEVBQThCRSxNQUE5QixDQUFQO0FBQ0gsS0FIRCxDQUdFLE9BQU9OLENBQVAsRUFBUztBQUNQO0FBQ0E7QUFDQSxhQUFPTCxrQkFBa0IsQ0FBQ1MsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJFLE1BQTlCLENBQVA7QUFDSDtBQUNKO0FBSUo7O0FBQ0QsSUFBSUMsS0FBSyxHQUFHLEVBQVo7QUFDQSxJQUFJQyxRQUFRLEdBQUcsS0FBZjtBQUNBLElBQUlDLFlBQUo7QUFDQSxJQUFJQyxVQUFVLEdBQUcsQ0FBQyxDQUFsQjs7QUFFQSxTQUFTQyxlQUFULEdBQTJCO0FBQ3ZCLE1BQUksQ0FBQ0gsUUFBRCxJQUFhLENBQUNDLFlBQWxCLEVBQWdDO0FBQzVCO0FBQ0g7O0FBQ0RELEVBQUFBLFFBQVEsR0FBRyxLQUFYOztBQUNBLE1BQUlDLFlBQVksQ0FBQ0csTUFBakIsRUFBeUI7QUFDckJMLElBQUFBLEtBQUssR0FBR0UsWUFBWSxDQUFDSSxNQUFiLENBQW9CTixLQUFwQixDQUFSO0FBQ0gsR0FGRCxNQUVPO0FBQ0hHLElBQUFBLFVBQVUsR0FBRyxDQUFDLENBQWQ7QUFDSDs7QUFDRCxNQUFJSCxLQUFLLENBQUNLLE1BQVYsRUFBa0I7QUFDZEUsSUFBQUEsVUFBVTtBQUNiO0FBQ0o7O0FBRUQsU0FBU0EsVUFBVCxHQUFzQjtBQUNsQixNQUFJTixRQUFKLEVBQWM7QUFDVjtBQUNIOztBQUNELE1BQUlPLE9BQU8sR0FBR2IsVUFBVSxDQUFDUyxlQUFELENBQXhCO0FBQ0FILEVBQUFBLFFBQVEsR0FBRyxJQUFYO0FBRUEsTUFBSVEsR0FBRyxHQUFHVCxLQUFLLENBQUNLLE1BQWhCOztBQUNBLFNBQU1JLEdBQU4sRUFBVztBQUNQUCxJQUFBQSxZQUFZLEdBQUdGLEtBQWY7QUFDQUEsSUFBQUEsS0FBSyxHQUFHLEVBQVI7O0FBQ0EsV0FBTyxFQUFFRyxVQUFGLEdBQWVNLEdBQXRCLEVBQTJCO0FBQ3ZCLFVBQUlQLFlBQUosRUFBa0I7QUFDZEEsUUFBQUEsWUFBWSxDQUFDQyxVQUFELENBQVosQ0FBeUJPLEdBQXpCO0FBQ0g7QUFDSjs7QUFDRFAsSUFBQUEsVUFBVSxHQUFHLENBQUMsQ0FBZDtBQUNBTSxJQUFBQSxHQUFHLEdBQUdULEtBQUssQ0FBQ0ssTUFBWjtBQUNIOztBQUNESCxFQUFBQSxZQUFZLEdBQUcsSUFBZjtBQUNBRCxFQUFBQSxRQUFRLEdBQUcsS0FBWDtBQUNBSCxFQUFBQSxlQUFlLENBQUNVLE9BQUQsQ0FBZjtBQUNIOztBQUVEeEIsT0FBTyxDQUFDMkIsUUFBUixHQUFtQixVQUFVZixHQUFWLEVBQWU7QUFDOUIsTUFBSWdCLElBQUksR0FBRyxJQUFJQyxLQUFKLENBQVVDLFNBQVMsQ0FBQ1QsTUFBVixHQUFtQixDQUE3QixDQUFYOztBQUNBLE1BQUlTLFNBQVMsQ0FBQ1QsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QixTQUFLLElBQUlVLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELFNBQVMsQ0FBQ1QsTUFBOUIsRUFBc0NVLENBQUMsRUFBdkMsRUFBMkM7QUFDdkNILE1BQUFBLElBQUksQ0FBQ0csQ0FBQyxHQUFHLENBQUwsQ0FBSixHQUFjRCxTQUFTLENBQUNDLENBQUQsQ0FBdkI7QUFDSDtBQUNKOztBQUNEZixFQUFBQSxLQUFLLENBQUNnQixJQUFOLENBQVcsSUFBSUMsSUFBSixDQUFTckIsR0FBVCxFQUFjZ0IsSUFBZCxDQUFYOztBQUNBLE1BQUlaLEtBQUssQ0FBQ0ssTUFBTixLQUFpQixDQUFqQixJQUFzQixDQUFDSixRQUEzQixFQUFxQztBQUNqQ04sSUFBQUEsVUFBVSxDQUFDWSxVQUFELENBQVY7QUFDSDtBQUNKLENBWEQsQyxDQWFBOzs7QUFDQSxTQUFTVSxJQUFULENBQWNyQixHQUFkLEVBQW1Cc0IsS0FBbkIsRUFBMEI7QUFDdEIsT0FBS3RCLEdBQUwsR0FBV0EsR0FBWDtBQUNBLE9BQUtzQixLQUFMLEdBQWFBLEtBQWI7QUFDSDs7QUFDREQsSUFBSSxDQUFDRSxTQUFMLENBQWVULEdBQWYsR0FBcUIsWUFBWTtBQUM3QixPQUFLZCxHQUFMLENBQVN3QixLQUFULENBQWUsSUFBZixFQUFxQixLQUFLRixLQUExQjtBQUNILENBRkQ7O0FBR0FsQyxPQUFPLENBQUNxQyxLQUFSLEdBQWdCLFNBQWhCO0FBQ0FyQyxPQUFPLENBQUNzQyxPQUFSLEdBQWtCLElBQWxCO0FBQ0F0QyxPQUFPLENBQUN1QyxHQUFSLEdBQWMsRUFBZDtBQUNBdkMsT0FBTyxDQUFDd0MsSUFBUixHQUFlLEVBQWY7QUFDQXhDLE9BQU8sQ0FBQ3lDLE9BQVIsR0FBa0IsRUFBbEIsQyxDQUFzQjs7QUFDdEJ6QyxPQUFPLENBQUMwQyxRQUFSLEdBQW1CLEVBQW5COztBQUVBLFNBQVNDLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIzQyxPQUFPLENBQUM0QyxFQUFSLEdBQWFELElBQWI7QUFDQTNDLE9BQU8sQ0FBQzZDLFdBQVIsR0FBc0JGLElBQXRCO0FBQ0EzQyxPQUFPLENBQUM4QyxJQUFSLEdBQWVILElBQWY7QUFDQTNDLE9BQU8sQ0FBQytDLEdBQVIsR0FBY0osSUFBZDtBQUNBM0MsT0FBTyxDQUFDZ0QsY0FBUixHQUF5QkwsSUFBekI7QUFDQTNDLE9BQU8sQ0FBQ2lELGtCQUFSLEdBQTZCTixJQUE3QjtBQUNBM0MsT0FBTyxDQUFDa0QsSUFBUixHQUFlUCxJQUFmO0FBQ0EzQyxPQUFPLENBQUNtRCxlQUFSLEdBQTBCUixJQUExQjtBQUNBM0MsT0FBTyxDQUFDb0QsbUJBQVIsR0FBOEJULElBQTlCOztBQUVBM0MsT0FBTyxDQUFDcUQsU0FBUixHQUFvQixVQUFVQyxJQUFWLEVBQWdCO0FBQUUsU0FBTyxFQUFQO0FBQVcsQ0FBakQ7O0FBRUF0RCxPQUFPLENBQUN1RCxPQUFSLEdBQWtCLFVBQVVELElBQVYsRUFBZ0I7QUFDOUIsUUFBTSxJQUFJaEQsS0FBSixDQUFVLGtDQUFWLENBQU47QUFDSCxDQUZEOztBQUlBTixPQUFPLENBQUN3RCxHQUFSLEdBQWMsWUFBWTtBQUFFLFNBQU8sR0FBUDtBQUFZLENBQXhDOztBQUNBeEQsT0FBTyxDQUFDeUQsS0FBUixHQUFnQixVQUFVQyxHQUFWLEVBQWU7QUFDM0IsUUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEOztBQUdBTixPQUFPLENBQUMyRCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxTQUFPLENBQVA7QUFBVyxDQUF4QyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/process/browser.js\n");

/***/ }),

/***/ "../../node_modules/pseudomap/map.js":
/*!*******************************************!*\
  !*** ../../node_modules/pseudomap/map.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\nif (process.env.npm_package_name === 'pseudomap' && process.env.npm_lifecycle_script === 'test') process.env.TEST_PSEUDOMAP = 'true';\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map;\n} else {\n  module.exports = __webpack_require__(/*! ./pseudomap */ \"../../node_modules/pseudomap/pseudomap.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3BzZXVkb21hcC9tYXAuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL21hcC5qcz83MDNjIl0sInNvdXJjZXNDb250ZW50IjpbImlmIChwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lID09PSAncHNldWRvbWFwJyAmJlxuICAgIHByb2Nlc3MuZW52Lm5wbV9saWZlY3ljbGVfc2NyaXB0ID09PSAndGVzdCcpXG4gIHByb2Nlc3MuZW52LlRFU1RfUFNFVURPTUFQID0gJ3RydWUnXG5cbmlmICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmICFwcm9jZXNzLmVudi5URVNUX1BTRVVET01BUCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IE1hcFxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BzZXVkb21hcCcpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/pseudomap/map.js\n");

/***/ }),

/***/ "../../node_modules/pseudomap/pseudomap.js":
/*!*************************************************!*\
  !*** ../../node_modules/pseudomap/pseudomap.js ***!
  \*************************************************/
/***/ ((module) => {

eval("var hasOwnProperty = Object.prototype.hasOwnProperty;\nmodule.exports = PseudoMap;\n\nfunction PseudoMap(set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\");\n  this.clear();\n\n  if (set) {\n    if (set instanceof PseudoMap || typeof Map === 'function' && set instanceof Map) set.forEach(function (value, key) {\n      this.set(key, value);\n    }, this);else if (Array.isArray(set)) set.forEach(function (kv) {\n      this.set(kv[0], kv[1]);\n    }, this);else throw new TypeError('invalid argument');\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size') fn.call(thisp, this._data[k].value, this._data[k].key);\n  }, this);\n};\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k);\n};\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k);\n  return res && res.value;\n};\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v);\n};\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k);\n\n  if (res) {\n    delete this._data[res._index];\n    this._data.size--;\n  }\n};\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null);\n  data.size = 0;\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  });\n};\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function get() {\n    return this._data.size;\n  },\n  set: function set(n) {},\n  enumerable: true,\n  configurable: true\n});\n\nPseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version');\n}; // Either identical, or both NaN\n\n\nfunction same(a, b) {\n  return a === b || a !== a && b !== b;\n}\n\nfunction Entry(k, v, i) {\n  this.key = k;\n  this.value = v;\n  this._index = i;\n}\n\nfunction find(data, k) {\n  for (var i = 0, s = '_' + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n    if (same(data[key].key, k)) return data[key];\n  }\n}\n\nfunction set(data, k, v) {\n  for (var i = 0, s = '_' + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v;\n      return;\n    }\n  }\n\n  data.size++;\n  data[key] = new Entry(k, v, key);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL3BzZXVkb21hcC5qcz9hOTBiIl0sIm5hbWVzIjpbImhhc093blByb3BlcnR5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyIsIlBzZXVkb01hcCIsInNldCIsIlR5cGVFcnJvciIsImNsZWFyIiwiTWFwIiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5Iiwia3YiLCJmbiIsInRoaXNwIiwia2V5cyIsIl9kYXRhIiwiayIsImNhbGwiLCJoYXMiLCJmaW5kIiwiZ2V0IiwicmVzIiwidiIsImRlbGV0ZSIsIl9pbmRleCIsInNpemUiLCJkYXRhIiwiY3JlYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJuIiwidmFsdWVzIiwiZW50cmllcyIsIkVycm9yIiwic2FtZSIsImEiLCJiIiwiRW50cnkiLCJpIiwicyJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxHQUFHQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJGLGNBQXRDO0FBRUFHLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkMsU0FBakI7O0FBRUEsU0FBU0EsU0FBVCxDQUFvQkMsR0FBcEIsRUFBeUI7QUFDdkIsTUFBSSxFQUFFLGdCQUFnQkQsU0FBbEIsQ0FBSixFQUFrQztBQUNoQyxVQUFNLElBQUlFLFNBQUosQ0FBYyxzQ0FBZCxDQUFOO0FBRUYsT0FBS0MsS0FBTDs7QUFFQSxNQUFJRixHQUFKLEVBQVM7QUFDUCxRQUFLQSxHQUFHLFlBQVlELFNBQWhCLElBQ0MsT0FBT0ksR0FBUCxLQUFlLFVBQWYsSUFBNkJILEdBQUcsWUFBWUcsR0FEakQsRUFFRUgsR0FBRyxDQUFDSSxPQUFKLENBQVksVUFBVUMsS0FBVixFQUFpQkMsR0FBakIsRUFBc0I7QUFDaEMsV0FBS04sR0FBTCxDQUFTTSxHQUFULEVBQWNELEtBQWQ7QUFDRCxLQUZELEVBRUcsSUFGSCxFQUZGLEtBS0ssSUFBSUUsS0FBSyxDQUFDQyxPQUFOLENBQWNSLEdBQWQsQ0FBSixFQUNIQSxHQUFHLENBQUNJLE9BQUosQ0FBWSxVQUFVSyxFQUFWLEVBQWM7QUFDeEIsV0FBS1QsR0FBTCxDQUFTUyxFQUFFLENBQUMsQ0FBRCxDQUFYLEVBQWdCQSxFQUFFLENBQUMsQ0FBRCxDQUFsQjtBQUNELEtBRkQsRUFFRyxJQUZILEVBREcsS0FLSCxNQUFNLElBQUlSLFNBQUosQ0FBYyxrQkFBZCxDQUFOO0FBQ0g7QUFDRjs7QUFFREYsU0FBUyxDQUFDSCxTQUFWLENBQW9CUSxPQUFwQixHQUE4QixVQUFVTSxFQUFWLEVBQWNDLEtBQWQsRUFBcUI7QUFDakRBLEVBQUFBLEtBQUssR0FBR0EsS0FBSyxJQUFJLElBQWpCO0FBQ0FoQixFQUFBQSxNQUFNLENBQUNpQixJQUFQLENBQVksS0FBS0MsS0FBakIsRUFBd0JULE9BQXhCLENBQWdDLFVBQVVVLENBQVYsRUFBYTtBQUMzQyxRQUFJQSxDQUFDLEtBQUssTUFBVixFQUNFSixFQUFFLENBQUNLLElBQUgsQ0FBUUosS0FBUixFQUFlLEtBQUtFLEtBQUwsQ0FBV0MsQ0FBWCxFQUFjVCxLQUE3QixFQUFvQyxLQUFLUSxLQUFMLENBQVdDLENBQVgsRUFBY1IsR0FBbEQ7QUFDSCxHQUhELEVBR0csSUFISDtBQUlELENBTkQ7O0FBUUFQLFNBQVMsQ0FBQ0gsU0FBVixDQUFvQm9CLEdBQXBCLEdBQTBCLFVBQVVGLENBQVYsRUFBYTtBQUNyQyxTQUFPLENBQUMsQ0FBQ0csSUFBSSxDQUFDLEtBQUtKLEtBQU4sRUFBYUMsQ0FBYixDQUFiO0FBQ0QsQ0FGRDs7QUFJQWYsU0FBUyxDQUFDSCxTQUFWLENBQW9Cc0IsR0FBcEIsR0FBMEIsVUFBVUosQ0FBVixFQUFhO0FBQ3JDLE1BQUlLLEdBQUcsR0FBR0YsSUFBSSxDQUFDLEtBQUtKLEtBQU4sRUFBYUMsQ0FBYixDQUFkO0FBQ0EsU0FBT0ssR0FBRyxJQUFJQSxHQUFHLENBQUNkLEtBQWxCO0FBQ0QsQ0FIRDs7QUFLQU4sU0FBUyxDQUFDSCxTQUFWLENBQW9CSSxHQUFwQixHQUEwQixVQUFVYyxDQUFWLEVBQWFNLENBQWIsRUFBZ0I7QUFDeENwQixFQUFBQSxHQUFHLENBQUMsS0FBS2EsS0FBTixFQUFhQyxDQUFiLEVBQWdCTSxDQUFoQixDQUFIO0FBQ0QsQ0FGRDs7QUFJQXJCLFNBQVMsQ0FBQ0gsU0FBVixDQUFvQnlCLE1BQXBCLEdBQTZCLFVBQVVQLENBQVYsRUFBYTtBQUN4QyxNQUFJSyxHQUFHLEdBQUdGLElBQUksQ0FBQyxLQUFLSixLQUFOLEVBQWFDLENBQWIsQ0FBZDs7QUFDQSxNQUFJSyxHQUFKLEVBQVM7QUFDUCxXQUFPLEtBQUtOLEtBQUwsQ0FBV00sR0FBRyxDQUFDRyxNQUFmLENBQVA7QUFDQSxTQUFLVCxLQUFMLENBQVdVLElBQVg7QUFDRDtBQUNGLENBTkQ7O0FBUUF4QixTQUFTLENBQUNILFNBQVYsQ0FBb0JNLEtBQXBCLEdBQTRCLFlBQVk7QUFDdEMsTUFBSXNCLElBQUksR0FBRzdCLE1BQU0sQ0FBQzhCLE1BQVAsQ0FBYyxJQUFkLENBQVg7QUFDQUQsRUFBQUEsSUFBSSxDQUFDRCxJQUFMLEdBQVksQ0FBWjtBQUVBNUIsRUFBQUEsTUFBTSxDQUFDK0IsY0FBUCxDQUFzQixJQUF0QixFQUE0QixPQUE1QixFQUFxQztBQUNuQ3JCLElBQUFBLEtBQUssRUFBRW1CLElBRDRCO0FBRW5DRyxJQUFBQSxVQUFVLEVBQUUsS0FGdUI7QUFHbkNDLElBQUFBLFlBQVksRUFBRSxJQUhxQjtBQUluQ0MsSUFBQUEsUUFBUSxFQUFFO0FBSnlCLEdBQXJDO0FBTUQsQ0FWRDs7QUFZQWxDLE1BQU0sQ0FBQytCLGNBQVAsQ0FBc0IzQixTQUFTLENBQUNILFNBQWhDLEVBQTJDLE1BQTNDLEVBQW1EO0FBQ2pEc0IsRUFBQUEsR0FBRyxFQUFFLGVBQVk7QUFDZixXQUFPLEtBQUtMLEtBQUwsQ0FBV1UsSUFBbEI7QUFDRCxHQUhnRDtBQUlqRHZCLEVBQUFBLEdBQUcsRUFBRSxhQUFVOEIsQ0FBVixFQUFhLENBQUUsQ0FKNkI7QUFLakRILEVBQUFBLFVBQVUsRUFBRSxJQUxxQztBQU1qREMsRUFBQUEsWUFBWSxFQUFFO0FBTm1DLENBQW5EOztBQVNBN0IsU0FBUyxDQUFDSCxTQUFWLENBQW9CbUMsTUFBcEIsR0FDQWhDLFNBQVMsQ0FBQ0gsU0FBVixDQUFvQmdCLElBQXBCLEdBQ0FiLFNBQVMsQ0FBQ0gsU0FBVixDQUFvQm9DLE9BQXBCLEdBQThCLFlBQVk7QUFDeEMsUUFBTSxJQUFJQyxLQUFKLENBQVUsK0NBQVYsQ0FBTjtBQUNELENBSkQsQyxDQU1BOzs7QUFDQSxTQUFTQyxJQUFULENBQWVDLENBQWYsRUFBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9ELENBQUMsS0FBS0MsQ0FBTixJQUFXRCxDQUFDLEtBQUtBLENBQU4sSUFBV0MsQ0FBQyxLQUFLQSxDQUFuQztBQUNEOztBQUVELFNBQVNDLEtBQVQsQ0FBZ0J2QixDQUFoQixFQUFtQk0sQ0FBbkIsRUFBc0JrQixDQUF0QixFQUF5QjtBQUN2QixPQUFLaEMsR0FBTCxHQUFXUSxDQUFYO0FBQ0EsT0FBS1QsS0FBTCxHQUFhZSxDQUFiO0FBQ0EsT0FBS0UsTUFBTCxHQUFjZ0IsQ0FBZDtBQUNEOztBQUVELFNBQVNyQixJQUFULENBQWVPLElBQWYsRUFBcUJWLENBQXJCLEVBQXdCO0FBQ3RCLE9BQUssSUFBSXdCLENBQUMsR0FBRyxDQUFSLEVBQVdDLENBQUMsR0FBRyxNQUFNekIsQ0FBckIsRUFBd0JSLEdBQUcsR0FBR2lDLENBQW5DLEVBQ0s3QyxjQUFjLENBQUNxQixJQUFmLENBQW9CUyxJQUFwQixFQUEwQmxCLEdBQTFCLENBREwsRUFFS0EsR0FBRyxHQUFHaUMsQ0FBQyxHQUFHRCxDQUFDLEVBRmhCLEVBRW9CO0FBQ2xCLFFBQUlKLElBQUksQ0FBQ1YsSUFBSSxDQUFDbEIsR0FBRCxDQUFKLENBQVVBLEdBQVgsRUFBZ0JRLENBQWhCLENBQVIsRUFDRSxPQUFPVSxJQUFJLENBQUNsQixHQUFELENBQVg7QUFDSDtBQUNGOztBQUVELFNBQVNOLEdBQVQsQ0FBY3dCLElBQWQsRUFBb0JWLENBQXBCLEVBQXVCTSxDQUF2QixFQUEwQjtBQUN4QixPQUFLLElBQUlrQixDQUFDLEdBQUcsQ0FBUixFQUFXQyxDQUFDLEdBQUcsTUFBTXpCLENBQXJCLEVBQXdCUixHQUFHLEdBQUdpQyxDQUFuQyxFQUNLN0MsY0FBYyxDQUFDcUIsSUFBZixDQUFvQlMsSUFBcEIsRUFBMEJsQixHQUExQixDQURMLEVBRUtBLEdBQUcsR0FBR2lDLENBQUMsR0FBR0QsQ0FBQyxFQUZoQixFQUVvQjtBQUNsQixRQUFJSixJQUFJLENBQUNWLElBQUksQ0FBQ2xCLEdBQUQsQ0FBSixDQUFVQSxHQUFYLEVBQWdCUSxDQUFoQixDQUFSLEVBQTRCO0FBQzFCVSxNQUFBQSxJQUFJLENBQUNsQixHQUFELENBQUosQ0FBVUQsS0FBVixHQUFrQmUsQ0FBbEI7QUFDQTtBQUNEO0FBQ0Y7O0FBQ0RJLEVBQUFBLElBQUksQ0FBQ0QsSUFBTDtBQUNBQyxFQUFBQSxJQUFJLENBQUNsQixHQUFELENBQUosR0FBWSxJQUFJK0IsS0FBSixDQUFVdkIsQ0FBVixFQUFhTSxDQUFiLEVBQWdCZCxHQUFoQixDQUFaO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gUHNldWRvTWFwXG5cbmZ1bmN0aW9uIFBzZXVkb01hcCAoc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQc2V1ZG9NYXApKSAvLyB3aHl5eXl5eXlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgUHNldWRvTWFwIHJlcXVpcmVzICduZXcnXCIpXG5cbiAgdGhpcy5jbGVhcigpXG5cbiAgaWYgKHNldCkge1xuICAgIGlmICgoc2V0IGluc3RhbmNlb2YgUHNldWRvTWFwKSB8fFxuICAgICAgICAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXQgaW5zdGFuY2VvZiBNYXApKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXQpKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKGt2KSB7XG4gICAgICAgIHRoaXMuc2V0KGt2WzBdLCBrdlsxXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpXG4gIH1cbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgT2JqZWN0LmtleXModGhpcy5fZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnc2l6ZScpXG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLl9kYXRhW2tdLnZhbHVlLCB0aGlzLl9kYXRhW2tdLmtleSlcbiAgfSwgdGhpcylcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoaykge1xuICByZXR1cm4gISFmaW5kKHRoaXMuX2RhdGEsIGspXG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGspIHtcbiAgdmFyIHJlcyA9IGZpbmQodGhpcy5fZGF0YSwgaylcbiAgcmV0dXJuIHJlcyAmJiByZXMudmFsdWVcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaywgdikge1xuICBzZXQodGhpcy5fZGF0YSwgaywgdilcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoaykge1xuICB2YXIgcmVzID0gZmluZCh0aGlzLl9kYXRhLCBrKVxuICBpZiAocmVzKSB7XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFbcmVzLl9pbmRleF1cbiAgICB0aGlzLl9kYXRhLnNpemUtLVxuICB9XG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBkYXRhLnNpemUgPSAwXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfZGF0YScsIHtcbiAgICB2YWx1ZTogZGF0YSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQc2V1ZG9NYXAucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChuKSB7fSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLnZhbHVlcyA9XG5Qc2V1ZG9NYXAucHJvdG90eXBlLmtleXMgPVxuUHNldWRvTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9ycyBhcmUgbm90IGltcGxlbWVudGVkIGluIHRoaXMgdmVyc2lvbicpXG59XG5cbi8vIEVpdGhlciBpZGVudGljYWwsIG9yIGJvdGggTmFOXG5mdW5jdGlvbiBzYW1lIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYlxufVxuXG5mdW5jdGlvbiBFbnRyeSAoaywgdiwgaSkge1xuICB0aGlzLmtleSA9IGtcbiAgdGhpcy52YWx1ZSA9IHZcbiAgdGhpcy5faW5kZXggPSBpXG59XG5cbmZ1bmN0aW9uIGZpbmQgKGRhdGEsIGspIHtcbiAgZm9yICh2YXIgaSA9IDAsIHMgPSAnXycgKyBrLCBrZXkgPSBzO1xuICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICAgICBrZXkgPSBzICsgaSsrKSB7XG4gICAgaWYgKHNhbWUoZGF0YVtrZXldLmtleSwgaykpXG4gICAgICByZXR1cm4gZGF0YVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0IChkYXRhLCBrLCB2KSB7XG4gIGZvciAodmFyIGkgPSAwLCBzID0gJ18nICsgaywga2V5ID0gcztcbiAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgICAga2V5ID0gcyArIGkrKykge1xuICAgIGlmIChzYW1lKGRhdGFba2V5XS5rZXksIGspKSB7XG4gICAgICBkYXRhW2tleV0udmFsdWUgPSB2XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgZGF0YS5zaXplKytcbiAgZGF0YVtrZXldID0gbmV3IEVudHJ5KGssIHYsIGtleSlcbn1cbiJdLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3BzZXVkb21hcC9wc2V1ZG9tYXAuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/pseudomap/pseudomap.js\n");

/***/ }),

/***/ "../../node_modules/stackframe/stackframe.js":
/*!***************************************************!*\
  !*** ../../node_modules/stackframe/stackframe.js ***!
  \***************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  'use strict';\n\n  function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  }\n\n  function _getter(p) {\n    return function () {\n      return this[p];\n    };\n  }\n\n  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n  var numericProps = ['columnNumber', 'lineNumber'];\n  var stringProps = ['fileName', 'functionName', 'source'];\n  var arrayProps = ['args'];\n  var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n  function StackFrame(obj) {\n    if (!obj) return;\n\n    for (var i = 0; i < props.length; i++) {\n      if (obj[props[i]] !== undefined) {\n        this['set' + _capitalize(props[i])](obj[props[i]]);\n      }\n    }\n  }\n\n  StackFrame.prototype = {\n    getArgs: function getArgs() {\n      return this.args;\n    },\n    setArgs: function setArgs(v) {\n      if (Object.prototype.toString.call(v) !== '[object Array]') {\n        throw new TypeError('Args must be an Array');\n      }\n\n      this.args = v;\n    },\n    getEvalOrigin: function getEvalOrigin() {\n      return this.evalOrigin;\n    },\n    setEvalOrigin: function setEvalOrigin(v) {\n      if (v instanceof StackFrame) {\n        this.evalOrigin = v;\n      } else if (v instanceof Object) {\n        this.evalOrigin = new StackFrame(v);\n      } else {\n        throw new TypeError('Eval Origin must be an Object or StackFrame');\n      }\n    },\n    toString: function toString() {\n      var fileName = this.getFileName() || '';\n      var lineNumber = this.getLineNumber() || '';\n      var columnNumber = this.getColumnNumber() || '';\n      var functionName = this.getFunctionName() || '';\n\n      if (this.getIsEval()) {\n        if (fileName) {\n          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n        }\n\n        return '[eval]:' + lineNumber + ':' + columnNumber;\n      }\n\n      if (functionName) {\n        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n      }\n\n      return fileName + ':' + lineNumber + ':' + columnNumber;\n    }\n  };\n\n  StackFrame.fromString = function StackFrame$$fromString(str) {\n    var argsStartIndex = str.indexOf('(');\n    var argsEndIndex = str.lastIndexOf(')');\n    var functionName = str.substring(0, argsStartIndex);\n    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n    var locationString = str.substring(argsEndIndex + 1);\n\n    if (locationString.indexOf('@') === 0) {\n      var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n      var fileName = parts[1];\n      var lineNumber = parts[2];\n      var columnNumber = parts[3];\n    }\n\n    return new StackFrame({\n      functionName: functionName,\n      args: args || undefined,\n      fileName: fileName,\n      lineNumber: lineNumber || undefined,\n      columnNumber: columnNumber || undefined\n    });\n  };\n\n  for (var i = 0; i < booleanProps.length; i++) {\n    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\n    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n      return function (v) {\n        this[p] = Boolean(v);\n      };\n    }(booleanProps[i]);\n  }\n\n  for (var j = 0; j < numericProps.length; j++) {\n    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\n    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n      return function (v) {\n        if (!_isNumber(v)) {\n          throw new TypeError(p + ' must be a Number');\n        }\n\n        this[p] = Number(v);\n      };\n    }(numericProps[j]);\n  }\n\n  for (var k = 0; k < stringProps.length; k++) {\n    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\n    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n      return function (v) {\n        this[p] = String(v);\n      };\n    }(stringProps[k]);\n  }\n\n  return StackFrame;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3N0YWNrZnJhbWUvc3RhY2tmcmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBR0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUF2Q0E7O0FBMENBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9zdGFja2ZyYW1lL3N0YWNrZnJhbWUuanM/ZjljZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFja2ZyYW1lJywgW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tGcmFtZSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0dGVyKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICAgIHZhciBudW1lcmljUHJvcHMgPSBbJ2NvbHVtbk51bWJlcicsICdsaW5lTnVtYmVyJ107XG4gICAgdmFyIHN0cmluZ1Byb3BzID0gWydmaWxlTmFtZScsICdmdW5jdGlvbk5hbWUnLCAnc291cmNlJ107XG4gICAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcblxuICAgIHZhciBwcm9wcyA9IGJvb2xlYW5Qcm9wcy5jb25jYXQobnVtZXJpY1Byb3BzLCBzdHJpbmdQcm9wcywgYXJyYXlQcm9wcyk7XG5cbiAgICBmdW5jdGlvbiBTdGFja0ZyYW1lKG9iaikge1xuICAgICAgICBpZiAoIW9iaikgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob2JqW3Byb3BzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1snc2V0JyArIF9jYXBpdGFsaXplKHByb3BzW2ldKV0ob2JqW3Byb3BzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0QXJnczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBcmdzOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSB2O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEV2YWxPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZhbE9yaWdpbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RXZhbE9yaWdpbjogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IG5ldyBTdGFja0ZyYW1lKHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFdmFsIE9yaWdpbiBtdXN0IGJlIGFuIE9iamVjdCBvciBTdGFja0ZyYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRoaXMuZ2V0RnVuY3Rpb25OYW1lKCkgfHwgJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJc0V2YWwoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tldmFsXSAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbZXZhbF06JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSArICcgKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN0YWNrRnJhbWUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIFN0YWNrRnJhbWUkJGZyb21TdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciBhcmdzU3RhcnRJbmRleCA9IHN0ci5pbmRleE9mKCcoJyk7XG4gICAgICAgIHZhciBhcmdzRW5kSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJyknKTtcblxuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gc3RyLnN1YnN0cmluZygwLCBhcmdzU3RhcnRJbmRleCk7XG4gICAgICAgIHZhciBhcmdzID0gc3RyLnN1YnN0cmluZyhhcmdzU3RhcnRJbmRleCArIDEsIGFyZ3NFbmRJbmRleCkuc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uU3RyaW5nID0gc3RyLnN1YnN0cmluZyhhcmdzRW5kSW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobG9jYXRpb25TdHJpbmcuaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSAvQCguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC8uZXhlYyhsb2NhdGlvblN0cmluZywgJycpO1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHBhcnRzWzJdO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHBhcnRzWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogY29sdW1uTnVtYmVyIHx8IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sZWFuUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IF9nZXR0ZXIoYm9vbGVhblByb3BzW2ldKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBCb29sZWFuKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoYm9vbGVhblByb3BzW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bWVyaWNQcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gX2dldHRlcihudW1lcmljUHJvcHNbal0pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNOdW1iZXIodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwICsgJyBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBOdW1iZXIodik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShudW1lcmljUHJvcHNbal0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3RyaW5nUHJvcHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gX2dldHRlcihzdHJpbmdQcm9wc1trXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBTdHJpbmcodik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShzdHJpbmdQcm9wc1trXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0YWNrRnJhbWU7XG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/stackframe/stackframe.js\n");

/***/ }),

/***/ "../../node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n\n    var TempCtor = function TempCtor() {};\n\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcz9lNDQ1Il0sIm5hbWVzIjpbIk9iamVjdCIsImNyZWF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpbmhlcml0cyIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsInZhbHVlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiVGVtcEN0b3IiXSwibWFwcGluZ3MiOiJBQUFBLElBQUksT0FBT0EsTUFBTSxDQUFDQyxNQUFkLEtBQXlCLFVBQTdCLEVBQXlDO0FBQ3ZDO0FBQ0FDLEVBQUFBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixTQUFTQyxRQUFULENBQWtCQyxJQUFsQixFQUF3QkMsU0FBeEIsRUFBbUM7QUFDbERELElBQUFBLElBQUksQ0FBQ0UsTUFBTCxHQUFjRCxTQUFkO0FBQ0FELElBQUFBLElBQUksQ0FBQ0csU0FBTCxHQUFpQlIsTUFBTSxDQUFDQyxNQUFQLENBQWNLLFNBQVMsQ0FBQ0UsU0FBeEIsRUFBbUM7QUFDbERDLE1BQUFBLFdBQVcsRUFBRTtBQUNYQyxRQUFBQSxLQUFLLEVBQUVMLElBREk7QUFFWE0sUUFBQUEsVUFBVSxFQUFFLEtBRkQ7QUFHWEMsUUFBQUEsUUFBUSxFQUFFLElBSEM7QUFJWEMsUUFBQUEsWUFBWSxFQUFFO0FBSkg7QUFEcUMsS0FBbkMsQ0FBakI7QUFRRCxHQVZEO0FBV0QsQ0FiRCxNQWFPO0FBQ0w7QUFDQVgsRUFBQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFNBQVNDLFFBQVQsQ0FBa0JDLElBQWxCLEVBQXdCQyxTQUF4QixFQUFtQztBQUNsREQsSUFBQUEsSUFBSSxDQUFDRSxNQUFMLEdBQWNELFNBQWQ7O0FBQ0EsUUFBSVEsUUFBUSxHQUFHLFNBQVhBLFFBQVcsR0FBWSxDQUFFLENBQTdCOztBQUNBQSxJQUFBQSxRQUFRLENBQUNOLFNBQVQsR0FBcUJGLFNBQVMsQ0FBQ0UsU0FBL0I7QUFDQUgsSUFBQUEsSUFBSSxDQUFDRyxTQUFMLEdBQWlCLElBQUlNLFFBQUosRUFBakI7QUFDQVQsSUFBQUEsSUFBSSxDQUFDRyxTQUFMLENBQWVDLFdBQWYsR0FBNkJKLElBQTdCO0FBQ0QsR0FORDtBQU9EIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iXSwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/util/node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "../../node_modules/util/support/isBufferBrowser.js":
/*!**********************************************************!*\
  !*** ../../node_modules/util/support/isBufferBrowser.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nmodule.exports = function isBuffer(arg) {\n  return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcz8xNDZhIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJpc0J1ZmZlciIsImFyZyIsImNvcHkiLCJmaWxsIiwicmVhZFVJbnQ4Il0sIm1hcHBpbmdzIjoiOztBQUFBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsU0FBU0MsUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUI7QUFDdEMsU0FBT0EsR0FBRyxJQUFJLFFBQU9BLEdBQVAsTUFBZSxRQUF0QixJQUNGLE9BQU9BLEdBQUcsQ0FBQ0MsSUFBWCxLQUFvQixVQURsQixJQUVGLE9BQU9ELEdBQUcsQ0FBQ0UsSUFBWCxLQUFvQixVQUZsQixJQUdGLE9BQU9GLEdBQUcsQ0FBQ0csU0FBWCxLQUF5QixVQUg5QjtBQUlELENBTEQiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59Il0sImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/util/support/isBufferBrowser.js\n");

/***/ }),

/***/ "../../node_modules/util/util.js":
/*!***************************************!*\
  !*** ../../node_modules/util/util.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar formatRegExp = /%[sdj%]/g;\n\nexports.format = function (f) {\n  if (!isString(f)) {\n    var objects = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function (x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n\n    switch (x) {\n      case '%s':\n        return String(args[i++]);\n\n      case '%d':\n        return Number(args[i++]);\n\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n\n      default:\n        return x;\n    }\n  });\n\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n\n  return str;\n}; // Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\n\n\nexports.deprecate = function (fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function () {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n\n      warned = true;\n    }\n\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\nvar debugs = {};\nvar debugEnviron;\n\nexports.debuglog = function (set) {\n  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n\n      debugs[set] = function () {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function () {};\n    }\n  }\n\n  return debugs[set];\n};\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n\n/* legacy: obj, showHidden, depth, colors*/\n\n\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  }; // legacy...\n\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  } // set default options\n\n\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\nexports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\ninspect.colors = {\n  'bold': [1, 22],\n  'italic': [3, 23],\n  'underline': [4, 24],\n  'inverse': [7, 27],\n  'white': [37, 39],\n  'grey': [90, 39],\n  'black': [30, 39],\n  'blue': [34, 39],\n  'cyan': [36, 39],\n  'green': [32, 39],\n  'magenta': [35, 39],\n  'red': [31, 39],\n  'yellow': [33, 39]\n}; // Don't use 'blue' not visible on cmd.exe\n\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return \"\\x1B[\" + inspect.colors[style][0] + 'm' + str + \"\\x1B[\" + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\nfunction arrayToHash(array) {\n  var hash = {};\n  array.forEach(function (val, idx) {\n    hash[val] = true;\n  });\n  return hash;\n}\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n  !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n\n    return ret;\n  } // Primitive types cannot have properties\n\n\n  var primitive = formatPrimitive(ctx, value);\n\n  if (primitive) {\n    return primitive;\n  } // Look up the keys of the object.\n\n\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  } // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\n\n  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  } // Some type of object without properties can be shortcutted.\n\n\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '',\n      array = false,\n      braces = ['{', '}']; // Make Array say that they are Array\n\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  } // Make functions say that they are functions\n\n\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  } // Make RegExps say that they are RegExps\n\n\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  } // Make dates with properties first say the date\n\n\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  } // Make error with message first say the error\n\n\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n  var output;\n\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function (key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n  return reduceToSingleString(output, base, braces);\n}\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n\n  if (isNumber(value)) return ctx.stylize('' + value, 'number');\n  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is \"object\", so special case here.\n\n  if (isNull(value)) return ctx.stylize('null', 'null');\n}\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  keys.forEach(function (key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n    }\n  });\n  return output;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || {\n    value: value[key]\n  };\n\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function (line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function (line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n\n    name = JSON.stringify('' + key);\n\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function (prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n} // NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\n\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\n\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\n\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\n\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return _typeof(arg) === 'symbol';\n}\n\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\n\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return _typeof(arg) === 'object' && arg !== null;\n}\n\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\n\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n}\n\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol\n  typeof arg === 'undefined';\n}\n\nexports.isPrimitive = isPrimitive;\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"../../node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34\n\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n} // log is just a thin wrapper to console.log that prepends a timestamp\n\n\nexports.log = function () {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\n\n\nexports.inherits = __webpack_require__(/*! inherits */ \"../../node_modules/util/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function (origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n  var keys = Object.keys(add);\n  var i = keys.length;\n\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVZBO0FBWUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOzs7Ozs7OztBQU9BOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBOztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBOztBQWFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBRUE7O0FBR0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQU1BOztBQUVBO0FBQ0E7QUFJQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBOztBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFHQTs7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzPzZhMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/util/util.js\n");

/***/ }),

/***/ "../../node_modules/yallist/yallist.js":
/*!*********************************************!*\
  !*** ../../node_modules/yallist/yallist.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = Yallist;\nYallist.Node = Node;\nYallist.create = Yallist;\n\nfunction Yallist(list) {\n  var self = this;\n\n  if (!(self instanceof Yallist)) {\n    self = new Yallist();\n  }\n\n  self.tail = null;\n  self.head = null;\n  self.length = 0;\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item);\n    });\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i]);\n    }\n  }\n\n  return self;\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list');\n  }\n\n  var next = node.next;\n  var prev = node.prev;\n\n  if (next) {\n    next.prev = prev;\n  }\n\n  if (prev) {\n    prev.next = next;\n  }\n\n  if (node === this.head) {\n    this.head = next;\n  }\n\n  if (node === this.tail) {\n    this.tail = prev;\n  }\n\n  node.list.length--;\n  node.next = null;\n  node.prev = null;\n  node.list = null;\n};\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var head = this.head;\n  node.list = this;\n  node.next = head;\n\n  if (head) {\n    head.prev = node;\n  }\n\n  this.head = node;\n\n  if (!this.tail) {\n    this.tail = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var tail = this.tail;\n  node.list = this;\n  node.prev = tail;\n\n  if (tail) {\n    tail.next = node;\n  }\n\n  this.tail = node;\n\n  if (!this.head) {\n    this.head = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined;\n  }\n\n  var res = this.tail.value;\n  this.tail = this.tail.prev;\n\n  if (this.tail) {\n    this.tail.next = null;\n  } else {\n    this.head = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined;\n  }\n\n  var res = this.head.value;\n  this.head = this.head.next;\n\n  if (this.head) {\n    this.head.prev = null;\n  } else {\n    this.tail = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.next;\n  }\n};\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.prev;\n  }\n};\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.next;\n  }\n\n  return res;\n};\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.prev;\n  }\n\n  return res;\n};\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc;\n  var walker = this.head;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.head) {\n    walker = this.head.next;\n    acc = this.head.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.next;\n  }\n\n  return acc;\n};\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc;\n  var walker = this.tail;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.tail) {\n    walker = this.tail.prev;\n    acc = this.tail.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.prev;\n  }\n\n  return acc;\n};\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.next;\n  }\n\n  return arr;\n};\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.prev;\n  }\n\n  return arr;\n};\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next;\n  }\n\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev;\n  }\n\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.reverse = function () {\n  var head = this.head;\n  var tail = this.tail;\n\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev;\n    walker.prev = walker.next;\n    walker.next = p;\n  }\n\n  this.head = tail;\n  this.tail = head;\n  return this;\n};\n\nfunction push(self, item) {\n  self.tail = new Node(item, self.tail, null, self);\n\n  if (!self.head) {\n    self.head = self.tail;\n  }\n\n  self.length++;\n}\n\nfunction unshift(self, item) {\n  self.head = new Node(item, null, self.head, self);\n\n  if (!self.tail) {\n    self.tail = self.head;\n  }\n\n  self.length++;\n}\n\nfunction Node(value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list);\n  }\n\n  this.list = list;\n  this.value = value;\n\n  if (prev) {\n    prev.next = this;\n    this.prev = prev;\n  } else {\n    this.prev = null;\n  }\n\n  if (next) {\n    next.prev = this;\n    this.next = next;\n  } else {\n    this.next = null;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzP2I5YTQiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIllhbGxpc3QiLCJOb2RlIiwiY3JlYXRlIiwibGlzdCIsInNlbGYiLCJ0YWlsIiwiaGVhZCIsImxlbmd0aCIsImZvckVhY2giLCJpdGVtIiwicHVzaCIsImFyZ3VtZW50cyIsImkiLCJsIiwicHJvdG90eXBlIiwicmVtb3ZlTm9kZSIsIm5vZGUiLCJFcnJvciIsIm5leHQiLCJwcmV2IiwidW5zaGlmdE5vZGUiLCJwdXNoTm9kZSIsInVuc2hpZnQiLCJwb3AiLCJ1bmRlZmluZWQiLCJyZXMiLCJ2YWx1ZSIsInNoaWZ0IiwiZm4iLCJ0aGlzcCIsIndhbGtlciIsImNhbGwiLCJmb3JFYWNoUmV2ZXJzZSIsImdldCIsIm4iLCJnZXRSZXZlcnNlIiwibWFwIiwibWFwUmV2ZXJzZSIsInJlZHVjZSIsImluaXRpYWwiLCJhY2MiLCJUeXBlRXJyb3IiLCJyZWR1Y2VSZXZlcnNlIiwidG9BcnJheSIsImFyciIsIkFycmF5IiwidG9BcnJheVJldmVyc2UiLCJzbGljZSIsImZyb20iLCJ0byIsInJldCIsInNsaWNlUmV2ZXJzZSIsInJldmVyc2UiLCJwIl0sIm1hcHBpbmdzIjoiQUFBQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxPQUFqQjtBQUVBQSxPQUFPLENBQUNDLElBQVIsR0FBZUEsSUFBZjtBQUNBRCxPQUFPLENBQUNFLE1BQVIsR0FBaUJGLE9BQWpCOztBQUVBLFNBQVNBLE9BQVQsQ0FBa0JHLElBQWxCLEVBQXdCO0FBQ3RCLE1BQUlDLElBQUksR0FBRyxJQUFYOztBQUNBLE1BQUksRUFBRUEsSUFBSSxZQUFZSixPQUFsQixDQUFKLEVBQWdDO0FBQzlCSSxJQUFBQSxJQUFJLEdBQUcsSUFBSUosT0FBSixFQUFQO0FBQ0Q7O0FBRURJLEVBQUFBLElBQUksQ0FBQ0MsSUFBTCxHQUFZLElBQVo7QUFDQUQsRUFBQUEsSUFBSSxDQUFDRSxJQUFMLEdBQVksSUFBWjtBQUNBRixFQUFBQSxJQUFJLENBQUNHLE1BQUwsR0FBYyxDQUFkOztBQUVBLE1BQUlKLElBQUksSUFBSSxPQUFPQSxJQUFJLENBQUNLLE9BQVosS0FBd0IsVUFBcEMsRUFBZ0Q7QUFDOUNMLElBQUFBLElBQUksQ0FBQ0ssT0FBTCxDQUFhLFVBQVVDLElBQVYsRUFBZ0I7QUFDM0JMLE1BQUFBLElBQUksQ0FBQ00sSUFBTCxDQUFVRCxJQUFWO0FBQ0QsS0FGRDtBQUdELEdBSkQsTUFJTyxJQUFJRSxTQUFTLENBQUNKLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDL0IsU0FBSyxJQUFJSyxDQUFDLEdBQUcsQ0FBUixFQUFXQyxDQUFDLEdBQUdGLFNBQVMsQ0FBQ0osTUFBOUIsRUFBc0NLLENBQUMsR0FBR0MsQ0FBMUMsRUFBNkNELENBQUMsRUFBOUMsRUFBa0Q7QUFDaERSLE1BQUFBLElBQUksQ0FBQ00sSUFBTCxDQUFVQyxTQUFTLENBQUNDLENBQUQsQ0FBbkI7QUFDRDtBQUNGOztBQUVELFNBQU9SLElBQVA7QUFDRDs7QUFFREosT0FBTyxDQUFDYyxTQUFSLENBQWtCQyxVQUFsQixHQUErQixVQUFVQyxJQUFWLEVBQWdCO0FBQzdDLE1BQUlBLElBQUksQ0FBQ2IsSUFBTCxLQUFjLElBQWxCLEVBQXdCO0FBQ3RCLFVBQU0sSUFBSWMsS0FBSixDQUFVLGtEQUFWLENBQU47QUFDRDs7QUFFRCxNQUFJQyxJQUFJLEdBQUdGLElBQUksQ0FBQ0UsSUFBaEI7QUFDQSxNQUFJQyxJQUFJLEdBQUdILElBQUksQ0FBQ0csSUFBaEI7O0FBRUEsTUFBSUQsSUFBSixFQUFVO0FBQ1JBLElBQUFBLElBQUksQ0FBQ0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7O0FBRUQsTUFBSUEsSUFBSixFQUFVO0FBQ1JBLElBQUFBLElBQUksQ0FBQ0QsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7O0FBRUQsTUFBSUYsSUFBSSxLQUFLLEtBQUtWLElBQWxCLEVBQXdCO0FBQ3RCLFNBQUtBLElBQUwsR0FBWVksSUFBWjtBQUNEOztBQUNELE1BQUlGLElBQUksS0FBSyxLQUFLWCxJQUFsQixFQUF3QjtBQUN0QixTQUFLQSxJQUFMLEdBQVljLElBQVo7QUFDRDs7QUFFREgsRUFBQUEsSUFBSSxDQUFDYixJQUFMLENBQVVJLE1BQVY7QUFDQVMsRUFBQUEsSUFBSSxDQUFDRSxJQUFMLEdBQVksSUFBWjtBQUNBRixFQUFBQSxJQUFJLENBQUNHLElBQUwsR0FBWSxJQUFaO0FBQ0FILEVBQUFBLElBQUksQ0FBQ2IsSUFBTCxHQUFZLElBQVo7QUFDRCxDQTNCRDs7QUE2QkFILE9BQU8sQ0FBQ2MsU0FBUixDQUFrQk0sV0FBbEIsR0FBZ0MsVUFBVUosSUFBVixFQUFnQjtBQUM5QyxNQUFJQSxJQUFJLEtBQUssS0FBS1YsSUFBbEIsRUFBd0I7QUFDdEI7QUFDRDs7QUFFRCxNQUFJVSxJQUFJLENBQUNiLElBQVQsRUFBZTtBQUNiYSxJQUFBQSxJQUFJLENBQUNiLElBQUwsQ0FBVVksVUFBVixDQUFxQkMsSUFBckI7QUFDRDs7QUFFRCxNQUFJVixJQUFJLEdBQUcsS0FBS0EsSUFBaEI7QUFDQVUsRUFBQUEsSUFBSSxDQUFDYixJQUFMLEdBQVksSUFBWjtBQUNBYSxFQUFBQSxJQUFJLENBQUNFLElBQUwsR0FBWVosSUFBWjs7QUFDQSxNQUFJQSxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDYSxJQUFMLEdBQVlILElBQVo7QUFDRDs7QUFFRCxPQUFLVixJQUFMLEdBQVlVLElBQVo7O0FBQ0EsTUFBSSxDQUFDLEtBQUtYLElBQVYsRUFBZ0I7QUFDZCxTQUFLQSxJQUFMLEdBQVlXLElBQVo7QUFDRDs7QUFDRCxPQUFLVCxNQUFMO0FBQ0QsQ0FyQkQ7O0FBdUJBUCxPQUFPLENBQUNjLFNBQVIsQ0FBa0JPLFFBQWxCLEdBQTZCLFVBQVVMLElBQVYsRUFBZ0I7QUFDM0MsTUFBSUEsSUFBSSxLQUFLLEtBQUtYLElBQWxCLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBRUQsTUFBSVcsSUFBSSxDQUFDYixJQUFULEVBQWU7QUFDYmEsSUFBQUEsSUFBSSxDQUFDYixJQUFMLENBQVVZLFVBQVYsQ0FBcUJDLElBQXJCO0FBQ0Q7O0FBRUQsTUFBSVgsSUFBSSxHQUFHLEtBQUtBLElBQWhCO0FBQ0FXLEVBQUFBLElBQUksQ0FBQ2IsSUFBTCxHQUFZLElBQVo7QUFDQWEsRUFBQUEsSUFBSSxDQUFDRyxJQUFMLEdBQVlkLElBQVo7O0FBQ0EsTUFBSUEsSUFBSixFQUFVO0FBQ1JBLElBQUFBLElBQUksQ0FBQ2EsSUFBTCxHQUFZRixJQUFaO0FBQ0Q7O0FBRUQsT0FBS1gsSUFBTCxHQUFZVyxJQUFaOztBQUNBLE1BQUksQ0FBQyxLQUFLVixJQUFWLEVBQWdCO0FBQ2QsU0FBS0EsSUFBTCxHQUFZVSxJQUFaO0FBQ0Q7O0FBQ0QsT0FBS1QsTUFBTDtBQUNELENBckJEOztBQXVCQVAsT0FBTyxDQUFDYyxTQUFSLENBQWtCSixJQUFsQixHQUF5QixZQUFZO0FBQ25DLE9BQUssSUFBSUUsQ0FBQyxHQUFHLENBQVIsRUFBV0MsQ0FBQyxHQUFHRixTQUFTLENBQUNKLE1BQTlCLEVBQXNDSyxDQUFDLEdBQUdDLENBQTFDLEVBQTZDRCxDQUFDLEVBQTlDLEVBQWtEO0FBQ2hERixJQUFBQSxJQUFJLENBQUMsSUFBRCxFQUFPQyxTQUFTLENBQUNDLENBQUQsQ0FBaEIsQ0FBSjtBQUNEOztBQUNELFNBQU8sS0FBS0wsTUFBWjtBQUNELENBTEQ7O0FBT0FQLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQlEsT0FBbEIsR0FBNEIsWUFBWTtBQUN0QyxPQUFLLElBQUlWLENBQUMsR0FBRyxDQUFSLEVBQVdDLENBQUMsR0FBR0YsU0FBUyxDQUFDSixNQUE5QixFQUFzQ0ssQ0FBQyxHQUFHQyxDQUExQyxFQUE2Q0QsQ0FBQyxFQUE5QyxFQUFrRDtBQUNoRFUsSUFBQUEsT0FBTyxDQUFDLElBQUQsRUFBT1gsU0FBUyxDQUFDQyxDQUFELENBQWhCLENBQVA7QUFDRDs7QUFDRCxTQUFPLEtBQUtMLE1BQVo7QUFDRCxDQUxEOztBQU9BUCxPQUFPLENBQUNjLFNBQVIsQ0FBa0JTLEdBQWxCLEdBQXdCLFlBQVk7QUFDbEMsTUFBSSxDQUFDLEtBQUtsQixJQUFWLEVBQWdCO0FBQ2QsV0FBT21CLFNBQVA7QUFDRDs7QUFFRCxNQUFJQyxHQUFHLEdBQUcsS0FBS3BCLElBQUwsQ0FBVXFCLEtBQXBCO0FBQ0EsT0FBS3JCLElBQUwsR0FBWSxLQUFLQSxJQUFMLENBQVVjLElBQXRCOztBQUNBLE1BQUksS0FBS2QsSUFBVCxFQUFlO0FBQ2IsU0FBS0EsSUFBTCxDQUFVYSxJQUFWLEdBQWlCLElBQWpCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsU0FBS1osSUFBTCxHQUFZLElBQVo7QUFDRDs7QUFDRCxPQUFLQyxNQUFMO0FBQ0EsU0FBT2tCLEdBQVA7QUFDRCxDQWREOztBQWdCQXpCLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQmEsS0FBbEIsR0FBMEIsWUFBWTtBQUNwQyxNQUFJLENBQUMsS0FBS3JCLElBQVYsRUFBZ0I7QUFDZCxXQUFPa0IsU0FBUDtBQUNEOztBQUVELE1BQUlDLEdBQUcsR0FBRyxLQUFLbkIsSUFBTCxDQUFVb0IsS0FBcEI7QUFDQSxPQUFLcEIsSUFBTCxHQUFZLEtBQUtBLElBQUwsQ0FBVVksSUFBdEI7O0FBQ0EsTUFBSSxLQUFLWixJQUFULEVBQWU7QUFDYixTQUFLQSxJQUFMLENBQVVhLElBQVYsR0FBaUIsSUFBakI7QUFDRCxHQUZELE1BRU87QUFDTCxTQUFLZCxJQUFMLEdBQVksSUFBWjtBQUNEOztBQUNELE9BQUtFLE1BQUw7QUFDQSxTQUFPa0IsR0FBUDtBQUNELENBZEQ7O0FBZ0JBekIsT0FBTyxDQUFDYyxTQUFSLENBQWtCTixPQUFsQixHQUE0QixVQUFVb0IsRUFBVixFQUFjQyxLQUFkLEVBQXFCO0FBQy9DQSxFQUFBQSxLQUFLLEdBQUdBLEtBQUssSUFBSSxJQUFqQjs7QUFDQSxPQUFLLElBQUlDLE1BQU0sR0FBRyxLQUFLeEIsSUFBbEIsRUFBd0JNLENBQUMsR0FBRyxDQUFqQyxFQUFvQ2tCLE1BQU0sS0FBSyxJQUEvQyxFQUFxRGxCLENBQUMsRUFBdEQsRUFBMEQ7QUFDeERnQixJQUFBQSxFQUFFLENBQUNHLElBQUgsQ0FBUUYsS0FBUixFQUFlQyxNQUFNLENBQUNKLEtBQXRCLEVBQTZCZCxDQUE3QixFQUFnQyxJQUFoQztBQUNBa0IsSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNaLElBQWhCO0FBQ0Q7QUFDRixDQU5EOztBQVFBbEIsT0FBTyxDQUFDYyxTQUFSLENBQWtCa0IsY0FBbEIsR0FBbUMsVUFBVUosRUFBVixFQUFjQyxLQUFkLEVBQXFCO0FBQ3REQSxFQUFBQSxLQUFLLEdBQUdBLEtBQUssSUFBSSxJQUFqQjs7QUFDQSxPQUFLLElBQUlDLE1BQU0sR0FBRyxLQUFLekIsSUFBbEIsRUFBd0JPLENBQUMsR0FBRyxLQUFLTCxNQUFMLEdBQWMsQ0FBL0MsRUFBa0R1QixNQUFNLEtBQUssSUFBN0QsRUFBbUVsQixDQUFDLEVBQXBFLEVBQXdFO0FBQ3RFZ0IsSUFBQUEsRUFBRSxDQUFDRyxJQUFILENBQVFGLEtBQVIsRUFBZUMsTUFBTSxDQUFDSixLQUF0QixFQUE2QmQsQ0FBN0IsRUFBZ0MsSUFBaEM7QUFDQWtCLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWCxJQUFoQjtBQUNEO0FBQ0YsQ0FORDs7QUFRQW5CLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQm1CLEdBQWxCLEdBQXdCLFVBQVVDLENBQVYsRUFBYTtBQUNuQyxPQUFLLElBQUl0QixDQUFDLEdBQUcsQ0FBUixFQUFXa0IsTUFBTSxHQUFHLEtBQUt4QixJQUE5QixFQUFvQ3dCLE1BQU0sS0FBSyxJQUFYLElBQW1CbEIsQ0FBQyxHQUFHc0IsQ0FBM0QsRUFBOER0QixDQUFDLEVBQS9ELEVBQW1FO0FBQ2pFO0FBQ0FrQixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ1osSUFBaEI7QUFDRDs7QUFDRCxNQUFJTixDQUFDLEtBQUtzQixDQUFOLElBQVdKLE1BQU0sS0FBSyxJQUExQixFQUFnQztBQUM5QixXQUFPQSxNQUFNLENBQUNKLEtBQWQ7QUFDRDtBQUNGLENBUkQ7O0FBVUExQixPQUFPLENBQUNjLFNBQVIsQ0FBa0JxQixVQUFsQixHQUErQixVQUFVRCxDQUFWLEVBQWE7QUFDMUMsT0FBSyxJQUFJdEIsQ0FBQyxHQUFHLENBQVIsRUFBV2tCLE1BQU0sR0FBRyxLQUFLekIsSUFBOUIsRUFBb0N5QixNQUFNLEtBQUssSUFBWCxJQUFtQmxCLENBQUMsR0FBR3NCLENBQTNELEVBQThEdEIsQ0FBQyxFQUEvRCxFQUFtRTtBQUNqRTtBQUNBa0IsSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNYLElBQWhCO0FBQ0Q7O0FBQ0QsTUFBSVAsQ0FBQyxLQUFLc0IsQ0FBTixJQUFXSixNQUFNLEtBQUssSUFBMUIsRUFBZ0M7QUFDOUIsV0FBT0EsTUFBTSxDQUFDSixLQUFkO0FBQ0Q7QUFDRixDQVJEOztBQVVBMUIsT0FBTyxDQUFDYyxTQUFSLENBQWtCc0IsR0FBbEIsR0FBd0IsVUFBVVIsRUFBVixFQUFjQyxLQUFkLEVBQXFCO0FBQzNDQSxFQUFBQSxLQUFLLEdBQUdBLEtBQUssSUFBSSxJQUFqQjtBQUNBLE1BQUlKLEdBQUcsR0FBRyxJQUFJekIsT0FBSixFQUFWOztBQUNBLE9BQUssSUFBSThCLE1BQU0sR0FBRyxLQUFLeEIsSUFBdkIsRUFBNkJ3QixNQUFNLEtBQUssSUFBeEMsR0FBK0M7QUFDN0NMLElBQUFBLEdBQUcsQ0FBQ2YsSUFBSixDQUFTa0IsRUFBRSxDQUFDRyxJQUFILENBQVFGLEtBQVIsRUFBZUMsTUFBTSxDQUFDSixLQUF0QixFQUE2QixJQUE3QixDQUFUO0FBQ0FJLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWixJQUFoQjtBQUNEOztBQUNELFNBQU9PLEdBQVA7QUFDRCxDQVJEOztBQVVBekIsT0FBTyxDQUFDYyxTQUFSLENBQWtCdUIsVUFBbEIsR0FBK0IsVUFBVVQsRUFBVixFQUFjQyxLQUFkLEVBQXFCO0FBQ2xEQSxFQUFBQSxLQUFLLEdBQUdBLEtBQUssSUFBSSxJQUFqQjtBQUNBLE1BQUlKLEdBQUcsR0FBRyxJQUFJekIsT0FBSixFQUFWOztBQUNBLE9BQUssSUFBSThCLE1BQU0sR0FBRyxLQUFLekIsSUFBdkIsRUFBNkJ5QixNQUFNLEtBQUssSUFBeEMsR0FBK0M7QUFDN0NMLElBQUFBLEdBQUcsQ0FBQ2YsSUFBSixDQUFTa0IsRUFBRSxDQUFDRyxJQUFILENBQVFGLEtBQVIsRUFBZUMsTUFBTSxDQUFDSixLQUF0QixFQUE2QixJQUE3QixDQUFUO0FBQ0FJLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWCxJQUFoQjtBQUNEOztBQUNELFNBQU9NLEdBQVA7QUFDRCxDQVJEOztBQVVBekIsT0FBTyxDQUFDYyxTQUFSLENBQWtCd0IsTUFBbEIsR0FBMkIsVUFBVVYsRUFBVixFQUFjVyxPQUFkLEVBQXVCO0FBQ2hELE1BQUlDLEdBQUo7QUFDQSxNQUFJVixNQUFNLEdBQUcsS0FBS3hCLElBQWxCOztBQUNBLE1BQUlLLFNBQVMsQ0FBQ0osTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QmlDLElBQUFBLEdBQUcsR0FBR0QsT0FBTjtBQUNELEdBRkQsTUFFTyxJQUFJLEtBQUtqQyxJQUFULEVBQWU7QUFDcEJ3QixJQUFBQSxNQUFNLEdBQUcsS0FBS3hCLElBQUwsQ0FBVVksSUFBbkI7QUFDQXNCLElBQUFBLEdBQUcsR0FBRyxLQUFLbEMsSUFBTCxDQUFVb0IsS0FBaEI7QUFDRCxHQUhNLE1BR0E7QUFDTCxVQUFNLElBQUllLFNBQUosQ0FBYyw0Q0FBZCxDQUFOO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJN0IsQ0FBQyxHQUFHLENBQWIsRUFBZ0JrQixNQUFNLEtBQUssSUFBM0IsRUFBaUNsQixDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDNEIsSUFBQUEsR0FBRyxHQUFHWixFQUFFLENBQUNZLEdBQUQsRUFBTVYsTUFBTSxDQUFDSixLQUFiLEVBQW9CZCxDQUFwQixDQUFSO0FBQ0FrQixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ1osSUFBaEI7QUFDRDs7QUFFRCxTQUFPc0IsR0FBUDtBQUNELENBbEJEOztBQW9CQXhDLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQjRCLGFBQWxCLEdBQWtDLFVBQVVkLEVBQVYsRUFBY1csT0FBZCxFQUF1QjtBQUN2RCxNQUFJQyxHQUFKO0FBQ0EsTUFBSVYsTUFBTSxHQUFHLEtBQUt6QixJQUFsQjs7QUFDQSxNQUFJTSxTQUFTLENBQUNKLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEJpQyxJQUFBQSxHQUFHLEdBQUdELE9BQU47QUFDRCxHQUZELE1BRU8sSUFBSSxLQUFLbEMsSUFBVCxFQUFlO0FBQ3BCeUIsSUFBQUEsTUFBTSxHQUFHLEtBQUt6QixJQUFMLENBQVVjLElBQW5CO0FBQ0FxQixJQUFBQSxHQUFHLEdBQUcsS0FBS25DLElBQUwsQ0FBVXFCLEtBQWhCO0FBQ0QsR0FITSxNQUdBO0FBQ0wsVUFBTSxJQUFJZSxTQUFKLENBQWMsNENBQWQsQ0FBTjtBQUNEOztBQUVELE9BQUssSUFBSTdCLENBQUMsR0FBRyxLQUFLTCxNQUFMLEdBQWMsQ0FBM0IsRUFBOEJ1QixNQUFNLEtBQUssSUFBekMsRUFBK0NsQixDQUFDLEVBQWhELEVBQW9EO0FBQ2xENEIsSUFBQUEsR0FBRyxHQUFHWixFQUFFLENBQUNZLEdBQUQsRUFBTVYsTUFBTSxDQUFDSixLQUFiLEVBQW9CZCxDQUFwQixDQUFSO0FBQ0FrQixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ1gsSUFBaEI7QUFDRDs7QUFFRCxTQUFPcUIsR0FBUDtBQUNELENBbEJEOztBQW9CQXhDLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQjZCLE9BQWxCLEdBQTRCLFlBQVk7QUFDdEMsTUFBSUMsR0FBRyxHQUFHLElBQUlDLEtBQUosQ0FBVSxLQUFLdEMsTUFBZixDQUFWOztBQUNBLE9BQUssSUFBSUssQ0FBQyxHQUFHLENBQVIsRUFBV2tCLE1BQU0sR0FBRyxLQUFLeEIsSUFBOUIsRUFBb0N3QixNQUFNLEtBQUssSUFBL0MsRUFBcURsQixDQUFDLEVBQXRELEVBQTBEO0FBQ3hEZ0MsSUFBQUEsR0FBRyxDQUFDaEMsQ0FBRCxDQUFILEdBQVNrQixNQUFNLENBQUNKLEtBQWhCO0FBQ0FJLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWixJQUFoQjtBQUNEOztBQUNELFNBQU8wQixHQUFQO0FBQ0QsQ0FQRDs7QUFTQTVDLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQmdDLGNBQWxCLEdBQW1DLFlBQVk7QUFDN0MsTUFBSUYsR0FBRyxHQUFHLElBQUlDLEtBQUosQ0FBVSxLQUFLdEMsTUFBZixDQUFWOztBQUNBLE9BQUssSUFBSUssQ0FBQyxHQUFHLENBQVIsRUFBV2tCLE1BQU0sR0FBRyxLQUFLekIsSUFBOUIsRUFBb0N5QixNQUFNLEtBQUssSUFBL0MsRUFBcURsQixDQUFDLEVBQXRELEVBQTBEO0FBQ3hEZ0MsSUFBQUEsR0FBRyxDQUFDaEMsQ0FBRCxDQUFILEdBQVNrQixNQUFNLENBQUNKLEtBQWhCO0FBQ0FJLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWCxJQUFoQjtBQUNEOztBQUNELFNBQU95QixHQUFQO0FBQ0QsQ0FQRDs7QUFTQTVDLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQmlDLEtBQWxCLEdBQTBCLFVBQVVDLElBQVYsRUFBZ0JDLEVBQWhCLEVBQW9CO0FBQzVDQSxFQUFBQSxFQUFFLEdBQUdBLEVBQUUsSUFBSSxLQUFLMUMsTUFBaEI7O0FBQ0EsTUFBSTBDLEVBQUUsR0FBRyxDQUFULEVBQVk7QUFDVkEsSUFBQUEsRUFBRSxJQUFJLEtBQUsxQyxNQUFYO0FBQ0Q7O0FBQ0R5QyxFQUFBQSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFmOztBQUNBLE1BQUlBLElBQUksR0FBRyxDQUFYLEVBQWM7QUFDWkEsSUFBQUEsSUFBSSxJQUFJLEtBQUt6QyxNQUFiO0FBQ0Q7O0FBQ0QsTUFBSTJDLEdBQUcsR0FBRyxJQUFJbEQsT0FBSixFQUFWOztBQUNBLE1BQUlpRCxFQUFFLEdBQUdELElBQUwsSUFBYUMsRUFBRSxHQUFHLENBQXRCLEVBQXlCO0FBQ3ZCLFdBQU9DLEdBQVA7QUFDRDs7QUFDRCxNQUFJRixJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ1pBLElBQUFBLElBQUksR0FBRyxDQUFQO0FBQ0Q7O0FBQ0QsTUFBSUMsRUFBRSxHQUFHLEtBQUsxQyxNQUFkLEVBQXNCO0FBQ3BCMEMsSUFBQUEsRUFBRSxHQUFHLEtBQUsxQyxNQUFWO0FBQ0Q7O0FBQ0QsT0FBSyxJQUFJSyxDQUFDLEdBQUcsQ0FBUixFQUFXa0IsTUFBTSxHQUFHLEtBQUt4QixJQUE5QixFQUFvQ3dCLE1BQU0sS0FBSyxJQUFYLElBQW1CbEIsQ0FBQyxHQUFHb0MsSUFBM0QsRUFBaUVwQyxDQUFDLEVBQWxFLEVBQXNFO0FBQ3BFa0IsSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNaLElBQWhCO0FBQ0Q7O0FBQ0QsU0FBT1ksTUFBTSxLQUFLLElBQVgsSUFBbUJsQixDQUFDLEdBQUdxQyxFQUE5QixFQUFrQ3JDLENBQUMsSUFBSWtCLE1BQU0sR0FBR0EsTUFBTSxDQUFDWixJQUF2RCxFQUE2RDtBQUMzRGdDLElBQUFBLEdBQUcsQ0FBQ3hDLElBQUosQ0FBU29CLE1BQU0sQ0FBQ0osS0FBaEI7QUFDRDs7QUFDRCxTQUFPd0IsR0FBUDtBQUNELENBMUJEOztBQTRCQWxELE9BQU8sQ0FBQ2MsU0FBUixDQUFrQnFDLFlBQWxCLEdBQWlDLFVBQVVILElBQVYsRUFBZ0JDLEVBQWhCLEVBQW9CO0FBQ25EQSxFQUFBQSxFQUFFLEdBQUdBLEVBQUUsSUFBSSxLQUFLMUMsTUFBaEI7O0FBQ0EsTUFBSTBDLEVBQUUsR0FBRyxDQUFULEVBQVk7QUFDVkEsSUFBQUEsRUFBRSxJQUFJLEtBQUsxQyxNQUFYO0FBQ0Q7O0FBQ0R5QyxFQUFBQSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFmOztBQUNBLE1BQUlBLElBQUksR0FBRyxDQUFYLEVBQWM7QUFDWkEsSUFBQUEsSUFBSSxJQUFJLEtBQUt6QyxNQUFiO0FBQ0Q7O0FBQ0QsTUFBSTJDLEdBQUcsR0FBRyxJQUFJbEQsT0FBSixFQUFWOztBQUNBLE1BQUlpRCxFQUFFLEdBQUdELElBQUwsSUFBYUMsRUFBRSxHQUFHLENBQXRCLEVBQXlCO0FBQ3ZCLFdBQU9DLEdBQVA7QUFDRDs7QUFDRCxNQUFJRixJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ1pBLElBQUFBLElBQUksR0FBRyxDQUFQO0FBQ0Q7O0FBQ0QsTUFBSUMsRUFBRSxHQUFHLEtBQUsxQyxNQUFkLEVBQXNCO0FBQ3BCMEMsSUFBQUEsRUFBRSxHQUFHLEtBQUsxQyxNQUFWO0FBQ0Q7O0FBQ0QsT0FBSyxJQUFJSyxDQUFDLEdBQUcsS0FBS0wsTUFBYixFQUFxQnVCLE1BQU0sR0FBRyxLQUFLekIsSUFBeEMsRUFBOEN5QixNQUFNLEtBQUssSUFBWCxJQUFtQmxCLENBQUMsR0FBR3FDLEVBQXJFLEVBQXlFckMsQ0FBQyxFQUExRSxFQUE4RTtBQUM1RWtCLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWCxJQUFoQjtBQUNEOztBQUNELFNBQU9XLE1BQU0sS0FBSyxJQUFYLElBQW1CbEIsQ0FBQyxHQUFHb0MsSUFBOUIsRUFBb0NwQyxDQUFDLElBQUlrQixNQUFNLEdBQUdBLE1BQU0sQ0FBQ1gsSUFBekQsRUFBK0Q7QUFDN0QrQixJQUFBQSxHQUFHLENBQUN4QyxJQUFKLENBQVNvQixNQUFNLENBQUNKLEtBQWhCO0FBQ0Q7O0FBQ0QsU0FBT3dCLEdBQVA7QUFDRCxDQTFCRDs7QUE0QkFsRCxPQUFPLENBQUNjLFNBQVIsQ0FBa0JzQyxPQUFsQixHQUE0QixZQUFZO0FBQ3RDLE1BQUk5QyxJQUFJLEdBQUcsS0FBS0EsSUFBaEI7QUFDQSxNQUFJRCxJQUFJLEdBQUcsS0FBS0EsSUFBaEI7O0FBQ0EsT0FBSyxJQUFJeUIsTUFBTSxHQUFHeEIsSUFBbEIsRUFBd0J3QixNQUFNLEtBQUssSUFBbkMsRUFBeUNBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWCxJQUF6RCxFQUErRDtBQUM3RCxRQUFJa0MsQ0FBQyxHQUFHdkIsTUFBTSxDQUFDWCxJQUFmO0FBQ0FXLElBQUFBLE1BQU0sQ0FBQ1gsSUFBUCxHQUFjVyxNQUFNLENBQUNaLElBQXJCO0FBQ0FZLElBQUFBLE1BQU0sQ0FBQ1osSUFBUCxHQUFjbUMsQ0FBZDtBQUNEOztBQUNELE9BQUsvQyxJQUFMLEdBQVlELElBQVo7QUFDQSxPQUFLQSxJQUFMLEdBQVlDLElBQVo7QUFDQSxTQUFPLElBQVA7QUFDRCxDQVhEOztBQWFBLFNBQVNJLElBQVQsQ0FBZU4sSUFBZixFQUFxQkssSUFBckIsRUFBMkI7QUFDekJMLEVBQUFBLElBQUksQ0FBQ0MsSUFBTCxHQUFZLElBQUlKLElBQUosQ0FBU1EsSUFBVCxFQUFlTCxJQUFJLENBQUNDLElBQXBCLEVBQTBCLElBQTFCLEVBQWdDRCxJQUFoQyxDQUFaOztBQUNBLE1BQUksQ0FBQ0EsSUFBSSxDQUFDRSxJQUFWLEVBQWdCO0FBQ2RGLElBQUFBLElBQUksQ0FBQ0UsSUFBTCxHQUFZRixJQUFJLENBQUNDLElBQWpCO0FBQ0Q7O0FBQ0RELEVBQUFBLElBQUksQ0FBQ0csTUFBTDtBQUNEOztBQUVELFNBQVNlLE9BQVQsQ0FBa0JsQixJQUFsQixFQUF3QkssSUFBeEIsRUFBOEI7QUFDNUJMLEVBQUFBLElBQUksQ0FBQ0UsSUFBTCxHQUFZLElBQUlMLElBQUosQ0FBU1EsSUFBVCxFQUFlLElBQWYsRUFBcUJMLElBQUksQ0FBQ0UsSUFBMUIsRUFBZ0NGLElBQWhDLENBQVo7O0FBQ0EsTUFBSSxDQUFDQSxJQUFJLENBQUNDLElBQVYsRUFBZ0I7QUFDZEQsSUFBQUEsSUFBSSxDQUFDQyxJQUFMLEdBQVlELElBQUksQ0FBQ0UsSUFBakI7QUFDRDs7QUFDREYsRUFBQUEsSUFBSSxDQUFDRyxNQUFMO0FBQ0Q7O0FBRUQsU0FBU04sSUFBVCxDQUFleUIsS0FBZixFQUFzQlAsSUFBdEIsRUFBNEJELElBQTVCLEVBQWtDZixJQUFsQyxFQUF3QztBQUN0QyxNQUFJLEVBQUUsZ0JBQWdCRixJQUFsQixDQUFKLEVBQTZCO0FBQzNCLFdBQU8sSUFBSUEsSUFBSixDQUFTeUIsS0FBVCxFQUFnQlAsSUFBaEIsRUFBc0JELElBQXRCLEVBQTRCZixJQUE1QixDQUFQO0FBQ0Q7O0FBRUQsT0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsT0FBS3VCLEtBQUwsR0FBYUEsS0FBYjs7QUFFQSxNQUFJUCxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDRCxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUtDLElBQUwsR0FBWUEsSUFBWjtBQUNELEdBSEQsTUFHTztBQUNMLFNBQUtBLElBQUwsR0FBWSxJQUFaO0FBQ0Q7O0FBRUQsTUFBSUQsSUFBSixFQUFVO0FBQ1JBLElBQUFBLElBQUksQ0FBQ0MsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLRCxJQUFMLEdBQVlBLElBQVo7QUFDRCxHQUhELE1BR087QUFDTCxTQUFLQSxJQUFMLEdBQVksSUFBWjtBQUNEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLm5leHQgPSBoZWFkXG4gIGlmIChoZWFkKSB7XG4gICAgaGVhZC5wcmV2ID0gbm9kZVxuICB9XG5cbiAgdGhpcy5oZWFkID0gbm9kZVxuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2hOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUucHJldiA9IHRhaWxcbiAgaWYgKHRhaWwpIHtcbiAgICB0YWlsLm5leHQgPSBub2RlXG4gIH1cblxuICB0aGlzLnRhaWwgPSBub2RlXG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHVzaCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHVuc2hpZnQodGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMudGFpbC52YWx1ZVxuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldlxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy5oZWFkLnZhbHVlXG4gIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0XG4gIGlmICh0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQucHJldiA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQsIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsLCBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0UmV2ZXJzZSA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLmhlYWRcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMuaGVhZCkge1xuICAgIHdhbGtlciA9IHRoaXMuaGVhZC5uZXh0XG4gICAgYWNjID0gdGhpcy5oZWFkLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZVJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy50YWlsXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWwucHJldlxuICAgIGFjYyA9IHRoaXMudGFpbC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXlSZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBmcm9tOyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHRvOyBpKyssIHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2VSZXZlcnNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiBmcm9tOyBpLS0sIHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgZm9yICh2YXIgd2Fsa2VyID0gaGVhZDsgd2Fsa2VyICE9PSBudWxsOyB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHZhciBwID0gd2Fsa2VyLnByZXZcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0XG4gICAgd2Fsa2VyLm5leHQgPSBwXG4gIH1cbiAgdGhpcy5oZWFkID0gdGFpbFxuICB0aGlzLnRhaWwgPSBoZWFkXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHB1c2ggKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKVxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gdW5zaGlmdCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiBOb2RlICh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpXG4gIH1cblxuICB0aGlzLmxpc3QgPSBsaXN0XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpc1xuICAgIHRoaXMucHJldiA9IHByZXZcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXYgPSBudWxsXG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXNcbiAgICB0aGlzLm5leHQgPSBuZXh0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICB9XG59XG4iXSwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/yallist/yallist.js\n");

/***/ }),

/***/ "./src/backend.js":
/*!************************!*\
  !*** ./src/backend.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"connectToDevTools\": () => (/* binding */ connectToDevTools),\n/* harmony export */   \"connectWithCustomMessagingProtocol\": () => (/* binding */ connectWithCustomMessagingProtocol),\n/* harmony export */   \"initialize\": () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/agent */ \"../react-devtools-shared/src/backend/agent.js\");\n/* harmony import */ var react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/bridge */ \"../react-devtools-shared/src/bridge.js\");\n/* harmony import */ var react_devtools_shared_src_hook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/hook */ \"../react-devtools-shared/src/hook.js\");\n/* harmony import */ var react_devtools_shared_src_backend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/backend */ \"../react-devtools-shared/src/backend/index.js\");\n/* harmony import */ var react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-devtools-shared/src/constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var react_devtools_shared_src_backend_NativeStyleEditor_setupNativeStyleEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor */ \"../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js\");\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\nvar savedComponentFilters = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_6__.getDefaultComponentFilters)();\n\nfunction debug(methodName) {\n  if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_4__.__DEBUG__) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, [\"%c[core/backend] %c\".concat(methodName), 'color: teal; font-weight: bold;', 'font-weight: bold;'].concat(args));\n  }\n}\n\nfunction initialize(maybeSettingsOrSettingsPromise) {\n  var shouldStartProfilingNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var profilingSettings = arguments.length > 2 ? arguments[2] : undefined;\n  (0,react_devtools_shared_src_hook__WEBPACK_IMPORTED_MODULE_2__.installHook)(window, maybeSettingsOrSettingsPromise, shouldStartProfilingNow, profilingSettings);\n}\nfunction connectToDevTools(options) {\n  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n  if (hook == null) {\n    // DevTools didn't get injected into this page (maybe b'c of the contentType).\n    return;\n  }\n\n  var _ref = options || {},\n      _ref$host = _ref.host,\n      host = _ref$host === void 0 ? 'localhost' : _ref$host,\n      nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes,\n      _ref$useHttps = _ref.useHttps,\n      useHttps = _ref$useHttps === void 0 ? false : _ref$useHttps,\n      _ref$port = _ref.port,\n      port = _ref$port === void 0 ? 8097 : _ref$port,\n      websocket = _ref.websocket,\n      _ref$resolveRNStyle = _ref.resolveRNStyle,\n      resolveRNStyle = _ref$resolveRNStyle === void 0 ? null : _ref$resolveRNStyle,\n      _ref$retryConnectionD = _ref.retryConnectionDelay,\n      retryConnectionDelay = _ref$retryConnectionD === void 0 ? 2000 : _ref$retryConnectionD,\n      _ref$isAppActive = _ref.isAppActive,\n      isAppActive = _ref$isAppActive === void 0 ? function () {\n    return true;\n  } : _ref$isAppActive,\n      onSettingsUpdated = _ref.onSettingsUpdated,\n      _ref$isReloadAndProfi = _ref.isReloadAndProfileSupported,\n      isReloadAndProfileSupported = _ref$isReloadAndProfi === void 0 ? (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_6__.getIsReloadAndProfileSupported)() : _ref$isReloadAndProfi,\n      isProfiling = _ref.isProfiling,\n      onReloadAndProfile = _ref.onReloadAndProfile,\n      onReloadAndProfileFlagsReset = _ref.onReloadAndProfileFlagsReset;\n\n  var protocol = useHttps ? 'wss' : 'ws';\n  var retryTimeoutID = null;\n\n  function scheduleRetry() {\n    if (retryTimeoutID === null) {\n      // Two seconds because RN had issues with quick retries.\n      retryTimeoutID = setTimeout(function () {\n        return connectToDevTools(options);\n      }, retryConnectionDelay);\n    }\n  }\n\n  if (!isAppActive()) {\n    // If the app is in background, maybe retry later.\n    // Don't actually attempt to connect until we're in foreground.\n    scheduleRetry();\n    return;\n  }\n\n  var bridge = null;\n  var messageListeners = [];\n  var uri = protocol + '://' + host + ':' + port; // If existing websocket is passed, use it.\n  // This is necessary to support our custom integrations.\n  // See D6251744.\n\n  var ws = websocket ? websocket : new window.WebSocket(uri);\n  ws.onclose = handleClose;\n  ws.onerror = handleFailed;\n  ws.onmessage = handleMessage;\n\n  ws.onopen = function () {\n    bridge = new react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      listen: function listen(fn) {\n        messageListeners.push(fn);\n        return function () {\n          var index = messageListeners.indexOf(fn);\n\n          if (index >= 0) {\n            messageListeners.splice(index, 1);\n          }\n        };\n      },\n      send: function send(event, payload, transferable) {\n        if (ws.readyState === ws.OPEN) {\n          if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_4__.__DEBUG__) {\n            debug('wall.send()', event, payload);\n          }\n\n          ws.send(JSON.stringify({\n            event: event,\n            payload: payload\n          }));\n        } else {\n          if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_4__.__DEBUG__) {\n            debug('wall.send()', 'Shutting down bridge because of closed WebSocket connection');\n          }\n\n          if (bridge !== null) {\n            bridge.shutdown();\n          }\n\n          scheduleRetry();\n        }\n      }\n    });\n    bridge.addListener('updateComponentFilters', function (componentFilters) {\n      // Save filter changes in memory, in case DevTools is reloaded.\n      // In that case, the renderer will already be using the updated values.\n      // We'll lose these in between backend reloads but that can't be helped.\n      savedComponentFilters = componentFilters;\n    }); // The renderer interface doesn't read saved component filters directly,\n    // because they are generally stored in localStorage within the context of the extension.\n    // Because of this it relies on the extension to pass filters.\n    // In the case of the standalone DevTools being used with a website,\n    // saved filters are injected along with the backend script tag so we shouldn't override them here.\n    // This injection strategy doesn't work for React Native though.\n    // Ideally the backend would save the filters itself, but RN doesn't provide a sync storage solution.\n    // So for now we just fall back to using the default filters...\n\n    if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      bridge.send('overrideComponentFilters', savedComponentFilters);\n    } // TODO (npm-packages) Warn if \"isBackendStorageAPISupported\"\n    // $FlowFixMe[incompatible-call] found when upgrading Flow\n\n\n    var agent = new react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bridge, isProfiling, onReloadAndProfile);\n\n    if (typeof onReloadAndProfileFlagsReset === 'function') {\n      onReloadAndProfileFlagsReset();\n    }\n\n    if (onSettingsUpdated != null) {\n      agent.addListener('updateHookSettings', onSettingsUpdated);\n    }\n\n    agent.addListener('shutdown', function () {\n      if (onSettingsUpdated != null) {\n        agent.removeListener('updateHookSettings', onSettingsUpdated);\n      } // If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,\n      // and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.\n\n\n      hook.emit('shutdown');\n    });\n    (0,react_devtools_shared_src_backend__WEBPACK_IMPORTED_MODULE_3__.initBackend)(hook, agent, window, isReloadAndProfileSupported); // Setup React Native style editor if the environment supports it.\n\n    if (resolveRNStyle != null || hook.resolveRNStyle != null) {\n      (0,react_devtools_shared_src_backend_NativeStyleEditor_setupNativeStyleEditor__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( // $FlowFixMe[incompatible-call] found when upgrading Flow\n      bridge, agent, resolveRNStyle || hook.resolveRNStyle, nativeStyleEditorValidAttributes || hook.nativeStyleEditorValidAttributes || null);\n    } else {\n      // Otherwise listen to detect if the environment later supports it.\n      // For example, Flipper does not eagerly inject these values.\n      // Instead it relies on the React Native Inspector to lazily inject them.\n      var lazyResolveRNStyle;\n      var lazyNativeStyleEditorValidAttributes;\n\n      var initAfterTick = function initAfterTick() {\n        if (bridge !== null) {\n          (0,react_devtools_shared_src_backend_NativeStyleEditor_setupNativeStyleEditor__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(bridge, agent, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);\n        }\n      };\n\n      if (!hook.hasOwnProperty('resolveRNStyle')) {\n        Object.defineProperty(hook, 'resolveRNStyle', {\n          enumerable: false,\n          get: function get() {\n            return lazyResolveRNStyle;\n          },\n          set: function set(value) {\n            lazyResolveRNStyle = value;\n            initAfterTick();\n          }\n        });\n      }\n\n      if (!hook.hasOwnProperty('nativeStyleEditorValidAttributes')) {\n        Object.defineProperty(hook, 'nativeStyleEditorValidAttributes', {\n          enumerable: false,\n          get: function get() {\n            return lazyNativeStyleEditorValidAttributes;\n          },\n          set: function set(value) {\n            lazyNativeStyleEditorValidAttributes = value;\n            initAfterTick();\n          }\n        });\n      }\n    }\n  };\n\n  function handleClose() {\n    if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_4__.__DEBUG__) {\n      debug('WebSocket.onclose');\n    }\n\n    if (bridge !== null) {\n      bridge.emit('shutdown');\n    }\n\n    scheduleRetry();\n  }\n\n  function handleFailed() {\n    if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_4__.__DEBUG__) {\n      debug('WebSocket.onerror');\n    }\n\n    scheduleRetry();\n  }\n\n  function handleMessage(event) {\n    var data;\n\n    try {\n      if (typeof event.data === 'string') {\n        data = JSON.parse(event.data);\n\n        if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_4__.__DEBUG__) {\n          debug('WebSocket.onmessage', data);\n        }\n      } else {\n        throw Error();\n      }\n    } catch (e) {\n      console.error('[React DevTools] Failed to parse JSON: ' + event.data);\n      return;\n    }\n\n    messageListeners.forEach(function (fn) {\n      try {\n        fn(data);\n      } catch (error) {\n        // jsc doesn't play so well with tracebacks that go into eval'd code,\n        // so the stack trace here will stop at the `eval()` call. Getting the\n        // message that caused the error is the best we can do for now.\n        console.log('[React DevTools] Error calling listener', data);\n        console.log('error:', error);\n        throw error;\n      }\n    });\n  }\n}\nfunction connectWithCustomMessagingProtocol(_ref2) {\n  var onSubscribe = _ref2.onSubscribe,\n      onUnsubscribe = _ref2.onUnsubscribe,\n      onMessage = _ref2.onMessage,\n      nativeStyleEditorValidAttributes = _ref2.nativeStyleEditorValidAttributes,\n      resolveRNStyle = _ref2.resolveRNStyle,\n      onSettingsUpdated = _ref2.onSettingsUpdated,\n      _ref2$isReloadAndProf = _ref2.isReloadAndProfileSupported,\n      isReloadAndProfileSupported = _ref2$isReloadAndProf === void 0 ? (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_6__.getIsReloadAndProfileSupported)() : _ref2$isReloadAndProf,\n      isProfiling = _ref2.isProfiling,\n      onReloadAndProfile = _ref2.onReloadAndProfile,\n      onReloadAndProfileFlagsReset = _ref2.onReloadAndProfileFlagsReset;\n  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n  if (hook == null) {\n    // DevTools didn't get injected into this page (maybe b'c of the contentType).\n    return;\n  }\n\n  var wall = {\n    listen: function listen(fn) {\n      onSubscribe(fn);\n      return function () {\n        onUnsubscribe(fn);\n      };\n    },\n    send: function send(event, payload) {\n      onMessage(event, payload);\n    }\n  };\n  var bridge = new react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_1__[\"default\"](wall);\n  bridge.addListener('updateComponentFilters', function (componentFilters) {\n    // Save filter changes in memory, in case DevTools is reloaded.\n    // In that case, the renderer will already be using the updated values.\n    // We'll lose these in between backend reloads but that can't be helped.\n    savedComponentFilters = componentFilters;\n  });\n\n  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {\n    bridge.send('overrideComponentFilters', savedComponentFilters);\n  }\n\n  var agent = new react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bridge, isProfiling, onReloadAndProfile);\n\n  if (typeof onReloadAndProfileFlagsReset === 'function') {\n    onReloadAndProfileFlagsReset();\n  }\n\n  if (onSettingsUpdated != null) {\n    agent.addListener('updateHookSettings', onSettingsUpdated);\n  }\n\n  agent.addListener('shutdown', function () {\n    if (onSettingsUpdated != null) {\n      agent.removeListener('updateHookSettings', onSettingsUpdated);\n    } // If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,\n    // and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.\n\n\n    hook.emit('shutdown');\n  });\n  var unsubscribeBackend = (0,react_devtools_shared_src_backend__WEBPACK_IMPORTED_MODULE_3__.initBackend)(hook, agent, window, isReloadAndProfileSupported);\n  var nativeStyleResolver = resolveRNStyle || hook.resolveRNStyle;\n\n  if (nativeStyleResolver != null) {\n    var validAttributes = nativeStyleEditorValidAttributes || hook.nativeStyleEditorValidAttributes || null;\n    (0,react_devtools_shared_src_backend_NativeStyleEditor_setupNativeStyleEditor__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(bridge, agent, nativeStyleResolver, validAttributes);\n  }\n\n  return unsubscribeBackend;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFpQ0E7O0FBR0E7QUFDQTtBQUFBOztBQUFBO0FBREE7QUFDQTs7QUFDQTtBQU1BO0FBQ0E7O0FBRUE7QUFNQTtBQUFBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZUE7QUFBQTtBQWZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF1QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUEvQkE7QUFpQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVdBOztBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQWFBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFFQTtBQU9BOztBQUdBO0FBQ0E7QUFLQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uL3NyYy9iYWNrZW5kLmpzPzUwNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IEFnZW50IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9hZ2VudCc7XG5pbXBvcnQgQnJpZGdlIGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYnJpZGdlJztcbmltcG9ydCB7aW5zdGFsbEhvb2t9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaG9vayc7XG5pbXBvcnQge2luaXRCYWNrZW5kfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQnO1xuaW1wb3J0IHtfX0RFQlVHX199IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvY29uc3RhbnRzJztcbmltcG9ydCBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yIGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9OYXRpdmVTdHlsZUVkaXRvci9zZXR1cE5hdGl2ZVN0eWxlRWRpdG9yJztcbmltcG9ydCB7XG4gIGdldERlZmF1bHRDb21wb25lbnRGaWx0ZXJzLFxuICBnZXRJc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSB7QmFja2VuZEJyaWRnZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UnO1xuaW1wb3J0IHR5cGUge1xuICBDb21wb25lbnRGaWx0ZXIsXG4gIFdhbGwsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBEZXZUb29sc0hvb2ssXG4gIERldlRvb2xzSG9va1NldHRpbmdzLFxuICBQcm9maWxpbmdTZXR0aW5ncyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3R5cGVzJztcbmltcG9ydCB0eXBlIHtSZXNvbHZlTmF0aXZlU3R5bGV9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9OYXRpdmVTdHlsZUVkaXRvci9zZXR1cE5hdGl2ZVN0eWxlRWRpdG9yJztcblxudHlwZSBDb25uZWN0T3B0aW9ucyA9IHtcbiAgaG9zdD86IHN0cmluZyxcbiAgbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXM/OiAkUmVhZE9ubHlBcnJheTxzdHJpbmc+LFxuICBwb3J0PzogbnVtYmVyLFxuICB1c2VIdHRwcz86IGJvb2xlYW4sXG4gIHJlc29sdmVSTlN0eWxlPzogUmVzb2x2ZU5hdGl2ZVN0eWxlLFxuICByZXRyeUNvbm5lY3Rpb25EZWxheT86IG51bWJlcixcbiAgaXNBcHBBY3RpdmU/OiAoKSA9PiBib29sZWFuLFxuICB3ZWJzb2NrZXQ/OiA/V2ViU29ja2V0LFxuICBvblNldHRpbmdzVXBkYXRlZD86IChzZXR0aW5nczogJFJlYWRPbmx5PERldlRvb2xzSG9va1NldHRpbmdzPikgPT4gdm9pZCxcbiAgaXNSZWxvYWRBbmRQcm9maWxlU3VwcG9ydGVkPzogYm9vbGVhbixcbiAgaXNQcm9maWxpbmc/OiBib29sZWFuLFxuICBvblJlbG9hZEFuZFByb2ZpbGU/OiAocmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOiBib29sZWFuKSA9PiB2b2lkLFxuICBvblJlbG9hZEFuZFByb2ZpbGVGbGFnc1Jlc2V0PzogKCkgPT4gdm9pZCxcbn07XG5cbmxldCBzYXZlZENvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4gPVxuICBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycygpO1xuXG5mdW5jdGlvbiBkZWJ1ZyhtZXRob2ROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IEFycmF5PG1peGVkPikge1xuICBpZiAoX19ERUJVR19fKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgJWNbY29yZS9iYWNrZW5kXSAlYyR7bWV0aG9kTmFtZX1gLFxuICAgICAgJ2NvbG9yOiB0ZWFsOyBmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgJ2ZvbnQtd2VpZ2h0OiBib2xkOycsXG4gICAgICAuLi5hcmdzLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemUoXG4gIG1heWJlU2V0dGluZ3NPclNldHRpbmdzUHJvbWlzZT86XG4gICAgfCBEZXZUb29sc0hvb2tTZXR0aW5nc1xuICAgIHwgUHJvbWlzZTxEZXZUb29sc0hvb2tTZXR0aW5ncz4sXG4gIHNob3VsZFN0YXJ0UHJvZmlsaW5nTm93OiBib29sZWFuID0gZmFsc2UsXG4gIHByb2ZpbGluZ1NldHRpbmdzPzogUHJvZmlsaW5nU2V0dGluZ3MsXG4pIHtcbiAgaW5zdGFsbEhvb2soXG4gICAgd2luZG93LFxuICAgIG1heWJlU2V0dGluZ3NPclNldHRpbmdzUHJvbWlzZSxcbiAgICBzaG91bGRTdGFydFByb2ZpbGluZ05vdyxcbiAgICBwcm9maWxpbmdTZXR0aW5ncyxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RUb0RldlRvb2xzKG9wdGlvbnM6ID9Db25uZWN0T3B0aW9ucykge1xuICBjb25zdCBob29rOiA/RGV2VG9vbHNIb29rID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2sgPT0gbnVsbCkge1xuICAgIC8vIERldlRvb2xzIGRpZG4ndCBnZXQgaW5qZWN0ZWQgaW50byB0aGlzIHBhZ2UgKG1heWJlIGInYyBvZiB0aGUgY29udGVudFR5cGUpLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBob3N0ID0gJ2xvY2FsaG9zdCcsXG4gICAgbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMsXG4gICAgdXNlSHR0cHMgPSBmYWxzZSxcbiAgICBwb3J0ID0gODA5NyxcbiAgICB3ZWJzb2NrZXQsXG4gICAgcmVzb2x2ZVJOU3R5bGUgPSAobnVsbDogJEZsb3dGaXhNZSksXG4gICAgcmV0cnlDb25uZWN0aW9uRGVsYXkgPSAyMDAwLFxuICAgIGlzQXBwQWN0aXZlID0gKCkgPT4gdHJ1ZSxcbiAgICBvblNldHRpbmdzVXBkYXRlZCxcbiAgICBpc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQgPSBnZXRJc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQoKSxcbiAgICBpc1Byb2ZpbGluZyxcbiAgICBvblJlbG9hZEFuZFByb2ZpbGUsXG4gICAgb25SZWxvYWRBbmRQcm9maWxlRmxhZ3NSZXNldCxcbiAgfSA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1c2VIdHRwcyA/ICd3c3MnIDogJ3dzJztcbiAgbGV0IHJldHJ5VGltZW91dElEOiBUaW1lb3V0SUQgfCBudWxsID0gbnVsbDtcblxuICBmdW5jdGlvbiBzY2hlZHVsZVJldHJ5KCkge1xuICAgIGlmIChyZXRyeVRpbWVvdXRJRCA9PT0gbnVsbCkge1xuICAgICAgLy8gVHdvIHNlY29uZHMgYmVjYXVzZSBSTiBoYWQgaXNzdWVzIHdpdGggcXVpY2sgcmV0cmllcy5cbiAgICAgIHJldHJ5VGltZW91dElEID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gY29ubmVjdFRvRGV2VG9vbHMob3B0aW9ucyksXG4gICAgICAgIHJldHJ5Q29ubmVjdGlvbkRlbGF5LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzQXBwQWN0aXZlKCkpIHtcbiAgICAvLyBJZiB0aGUgYXBwIGlzIGluIGJhY2tncm91bmQsIG1heWJlIHJldHJ5IGxhdGVyLlxuICAgIC8vIERvbid0IGFjdHVhbGx5IGF0dGVtcHQgdG8gY29ubmVjdCB1bnRpbCB3ZSdyZSBpbiBmb3JlZ3JvdW5kLlxuICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgYnJpZGdlOiBCYWNrZW5kQnJpZGdlIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3QgbWVzc2FnZUxpc3RlbmVycyA9IFtdO1xuICBjb25zdCB1cmkgPSBwcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIHBvcnQ7XG5cbiAgLy8gSWYgZXhpc3Rpbmcgd2Vic29ja2V0IGlzIHBhc3NlZCwgdXNlIGl0LlxuICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0IG91ciBjdXN0b20gaW50ZWdyYXRpb25zLlxuICAvLyBTZWUgRDYyNTE3NDQuXG4gIGNvbnN0IHdzID0gd2Vic29ja2V0ID8gd2Vic29ja2V0IDogbmV3IHdpbmRvdy5XZWJTb2NrZXQodXJpKTtcbiAgd3Mub25jbG9zZSA9IGhhbmRsZUNsb3NlO1xuICB3cy5vbmVycm9yID0gaGFuZGxlRmFpbGVkO1xuICB3cy5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlO1xuICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgYnJpZGdlID0gbmV3IEJyaWRnZSh7XG4gICAgICBsaXN0ZW4oZm4pIHtcbiAgICAgICAgbWVzc2FnZUxpc3RlbmVycy5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG1lc3NhZ2VMaXN0ZW5lcnMuaW5kZXhPZihmbik7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2VMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2VuZChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnksIHRyYW5zZmVyYWJsZT86IEFycmF5PGFueT4pIHtcbiAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4pIHtcbiAgICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgICBkZWJ1Zygnd2FsbC5zZW5kKCknLCBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7ZXZlbnQsIHBheWxvYWR9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAgICd3YWxsLnNlbmQoKScsXG4gICAgICAgICAgICAgICdTaHV0dGluZyBkb3duIGJyaWRnZSBiZWNhdXNlIG9mIGNsb3NlZCBXZWJTb2NrZXQgY29ubmVjdGlvbicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChicmlkZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyaWRnZS5zaHV0ZG93bigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoXG4gICAgICAndXBkYXRlQ29tcG9uZW50RmlsdGVycycsXG4gICAgICAoY29tcG9uZW50RmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPikgPT4ge1xuICAgICAgICAvLyBTYXZlIGZpbHRlciBjaGFuZ2VzIGluIG1lbW9yeSwgaW4gY2FzZSBEZXZUb29scyBpcyByZWxvYWRlZC5cbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgcmVuZGVyZXIgd2lsbCBhbHJlYWR5IGJlIHVzaW5nIHRoZSB1cGRhdGVkIHZhbHVlcy5cbiAgICAgICAgLy8gV2UnbGwgbG9zZSB0aGVzZSBpbiBiZXR3ZWVuIGJhY2tlbmQgcmVsb2FkcyBidXQgdGhhdCBjYW4ndCBiZSBoZWxwZWQuXG4gICAgICAgIHNhdmVkQ29tcG9uZW50RmlsdGVycyA9IGNvbXBvbmVudEZpbHRlcnM7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICAvLyBUaGUgcmVuZGVyZXIgaW50ZXJmYWNlIGRvZXNuJ3QgcmVhZCBzYXZlZCBjb21wb25lbnQgZmlsdGVycyBkaXJlY3RseSxcbiAgICAvLyBiZWNhdXNlIHRoZXkgYXJlIGdlbmVyYWxseSBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZXh0ZW5zaW9uLlxuICAgIC8vIEJlY2F1c2Ugb2YgdGhpcyBpdCByZWxpZXMgb24gdGhlIGV4dGVuc2lvbiB0byBwYXNzIGZpbHRlcnMuXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgdGhlIHN0YW5kYWxvbmUgRGV2VG9vbHMgYmVpbmcgdXNlZCB3aXRoIGEgd2Vic2l0ZSxcbiAgICAvLyBzYXZlZCBmaWx0ZXJzIGFyZSBpbmplY3RlZCBhbG9uZyB3aXRoIHRoZSBiYWNrZW5kIHNjcmlwdCB0YWcgc28gd2Ugc2hvdWxkbid0IG92ZXJyaWRlIHRoZW0gaGVyZS5cbiAgICAvLyBUaGlzIGluamVjdGlvbiBzdHJhdGVneSBkb2Vzbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSB0aG91Z2guXG4gICAgLy8gSWRlYWxseSB0aGUgYmFja2VuZCB3b3VsZCBzYXZlIHRoZSBmaWx0ZXJzIGl0c2VsZiwgYnV0IFJOIGRvZXNuJ3QgcHJvdmlkZSBhIHN5bmMgc3RvcmFnZSBzb2x1dGlvbi5cbiAgICAvLyBTbyBmb3Igbm93IHdlIGp1c3QgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBkZWZhdWx0IGZpbHRlcnMuLi5cbiAgICBpZiAod2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQ09NUE9ORU5UX0ZJTFRFUlNfXyA9PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGJyaWRnZS5zZW5kKCdvdmVycmlkZUNvbXBvbmVudEZpbHRlcnMnLCBzYXZlZENvbXBvbmVudEZpbHRlcnMpO1xuICAgIH1cblxuICAgIC8vIFRPRE8gKG5wbS1wYWNrYWdlcykgV2FybiBpZiBcImlzQmFja2VuZFN0b3JhZ2VBUElTdXBwb3J0ZWRcIlxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBjb25zdCBhZ2VudCA9IG5ldyBBZ2VudChicmlkZ2UsIGlzUHJvZmlsaW5nLCBvblJlbG9hZEFuZFByb2ZpbGUpO1xuICAgIGlmICh0eXBlb2Ygb25SZWxvYWRBbmRQcm9maWxlRmxhZ3NSZXNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25SZWxvYWRBbmRQcm9maWxlRmxhZ3NSZXNldCgpO1xuICAgIH1cblxuICAgIGlmIChvblNldHRpbmdzVXBkYXRlZCAhPSBudWxsKSB7XG4gICAgICBhZ2VudC5hZGRMaXN0ZW5lcigndXBkYXRlSG9va1NldHRpbmdzJywgb25TZXR0aW5nc1VwZGF0ZWQpO1xuICAgIH1cbiAgICBhZ2VudC5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCAoKSA9PiB7XG4gICAgICBpZiAob25TZXR0aW5nc1VwZGF0ZWQgIT0gbnVsbCkge1xuICAgICAgICBhZ2VudC5yZW1vdmVMaXN0ZW5lcigndXBkYXRlSG9va1NldHRpbmdzJywgb25TZXR0aW5nc1VwZGF0ZWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSByZWNlaXZlZCAnc2h1dGRvd24nIGZyb20gYGFnZW50YCwgd2UgYXNzdW1lIHRoZSBgYnJpZGdlYCBpcyBhbHJlYWR5IHNodXR0aW5nIGRvd24sXG4gICAgICAvLyBhbmQgdGhhdCBjYXVzZWQgdGhlICdzaHV0ZG93bicgZXZlbnQgb24gdGhlIGBhZ2VudGAsIHNvIHdlIGRvbid0IG5lZWQgdG8gY2FsbCBgYnJpZGdlLnNodXRkb3duKClgIGhlcmUuXG4gICAgICBob29rLmVtaXQoJ3NodXRkb3duJyk7XG4gICAgfSk7XG5cbiAgICBpbml0QmFja2VuZChob29rLCBhZ2VudCwgd2luZG93LCBpc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQpO1xuXG4gICAgLy8gU2V0dXAgUmVhY3QgTmF0aXZlIHN0eWxlIGVkaXRvciBpZiB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgaXQuXG4gICAgaWYgKHJlc29sdmVSTlN0eWxlICE9IG51bGwgfHwgaG9vay5yZXNvbHZlUk5TdHlsZSAhPSBudWxsKSB7XG4gICAgICBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yKFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGJyaWRnZSxcbiAgICAgICAgYWdlbnQsXG4gICAgICAgICgocmVzb2x2ZVJOU3R5bGUgfHwgaG9vay5yZXNvbHZlUk5TdHlsZTogYW55KTogUmVzb2x2ZU5hdGl2ZVN0eWxlKSxcbiAgICAgICAgbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMgfHxcbiAgICAgICAgICBob29rLm5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzIHx8XG4gICAgICAgICAgbnVsbCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBsaXN0ZW4gdG8gZGV0ZWN0IGlmIHRoZSBlbnZpcm9ubWVudCBsYXRlciBzdXBwb3J0cyBpdC5cbiAgICAgIC8vIEZvciBleGFtcGxlLCBGbGlwcGVyIGRvZXMgbm90IGVhZ2VybHkgaW5qZWN0IHRoZXNlIHZhbHVlcy5cbiAgICAgIC8vIEluc3RlYWQgaXQgcmVsaWVzIG9uIHRoZSBSZWFjdCBOYXRpdmUgSW5zcGVjdG9yIHRvIGxhemlseSBpbmplY3QgdGhlbS5cbiAgICAgIGxldCBsYXp5UmVzb2x2ZVJOU3R5bGU7XG4gICAgICBsZXQgbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzO1xuXG4gICAgICBjb25zdCBpbml0QWZ0ZXJUaWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoYnJpZGdlICE9PSBudWxsKSB7XG4gICAgICAgICAgc2V0dXBOYXRpdmVTdHlsZUVkaXRvcihcbiAgICAgICAgICAgIGJyaWRnZSxcbiAgICAgICAgICAgIGFnZW50LFxuICAgICAgICAgICAgbGF6eVJlc29sdmVSTlN0eWxlLFxuICAgICAgICAgICAgbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICghaG9vay5oYXNPd25Qcm9wZXJ0eSgncmVzb2x2ZVJOU3R5bGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgaG9vayxcbiAgICAgICAgICAncmVzb2x2ZVJOU3R5bGUnLFxuICAgICAgICAgICh7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxhenlSZXNvbHZlUk5TdHlsZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWU6ICRGbG93Rml4TWUpIHtcbiAgICAgICAgICAgICAgbGF6eVJlc29sdmVSTlN0eWxlID0gdmFsdWU7XG4gICAgICAgICAgICAgIGluaXRBZnRlclRpY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTogT2JqZWN0KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghaG9vay5oYXNPd25Qcm9wZXJ0eSgnbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgaG9vayxcbiAgICAgICAgICAnbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMnLFxuICAgICAgICAgICh7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxhenlOYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWU6ICRGbG93Rml4TWUpIHtcbiAgICAgICAgICAgICAgbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzID0gdmFsdWU7XG4gICAgICAgICAgICAgIGluaXRBZnRlclRpY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTogT2JqZWN0KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgZGVidWcoJ1dlYlNvY2tldC5vbmNsb3NlJyk7XG4gICAgfVxuXG4gICAgaWYgKGJyaWRnZSAhPT0gbnVsbCkge1xuICAgICAgYnJpZGdlLmVtaXQoJ3NodXRkb3duJyk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVSZXRyeSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRmFpbGVkKCkge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdXZWJTb2NrZXQub25lcnJvcicpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQ6IE1lc3NhZ2VFdmVudCkge1xuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgZGVidWcoJ1dlYlNvY2tldC5vbm1lc3NhZ2UnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnW1JlYWN0IERldlRvb2xzXSBGYWlsZWQgdG8gcGFyc2UgSlNPTjogJyArIChldmVudC5kYXRhOiBhbnkpLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWVzc2FnZUxpc3RlbmVycy5mb3JFYWNoKGZuID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8ganNjIGRvZXNuJ3QgcGxheSBzbyB3ZWxsIHdpdGggdHJhY2ViYWNrcyB0aGF0IGdvIGludG8gZXZhbCdkIGNvZGUsXG4gICAgICAgIC8vIHNvIHRoZSBzdGFjayB0cmFjZSBoZXJlIHdpbGwgc3RvcCBhdCB0aGUgYGV2YWwoKWAgY2FsbC4gR2V0dGluZyB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgaXMgdGhlIGJlc3Qgd2UgY2FuIGRvIGZvciBub3cuXG4gICAgICAgIGNvbnNvbGUubG9nKCdbUmVhY3QgRGV2VG9vbHNdIEVycm9yIGNhbGxpbmcgbGlzdGVuZXInLCBkYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudHlwZSBDb25uZWN0V2l0aEN1c3RvbU1lc3NhZ2luZ09wdGlvbnMgPSB7XG4gIG9uU3Vic2NyaWJlOiAoY2I6IEZ1bmN0aW9uKSA9PiB2b2lkLFxuICBvblVuc3Vic2NyaWJlOiAoY2I6IEZ1bmN0aW9uKSA9PiB2b2lkLFxuICBvbk1lc3NhZ2U6IChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnkpID0+IHZvaWQsXG4gIG5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzPzogJFJlYWRPbmx5QXJyYXk8c3RyaW5nPixcbiAgcmVzb2x2ZVJOU3R5bGU/OiBSZXNvbHZlTmF0aXZlU3R5bGUsXG4gIG9uU2V0dGluZ3NVcGRhdGVkPzogKHNldHRpbmdzOiAkUmVhZE9ubHk8RGV2VG9vbHNIb29rU2V0dGluZ3M+KSA9PiB2b2lkLFxuICBpc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQ/OiBib29sZWFuLFxuICBpc1Byb2ZpbGluZz86IGJvb2xlYW4sXG4gIG9uUmVsb2FkQW5kUHJvZmlsZT86IChyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM6IGJvb2xlYW4pID0+IHZvaWQsXG4gIG9uUmVsb2FkQW5kUHJvZmlsZUZsYWdzUmVzZXQ/OiAoKSA9PiB2b2lkLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RXaXRoQ3VzdG9tTWVzc2FnaW5nUHJvdG9jb2woe1xuICBvblN1YnNjcmliZSxcbiAgb25VbnN1YnNjcmliZSxcbiAgb25NZXNzYWdlLFxuICBuYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyxcbiAgcmVzb2x2ZVJOU3R5bGUsXG4gIG9uU2V0dGluZ3NVcGRhdGVkLFxuICBpc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQgPSBnZXRJc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQoKSxcbiAgaXNQcm9maWxpbmcsXG4gIG9uUmVsb2FkQW5kUHJvZmlsZSxcbiAgb25SZWxvYWRBbmRQcm9maWxlRmxhZ3NSZXNldCxcbn06IENvbm5lY3RXaXRoQ3VzdG9tTWVzc2FnaW5nT3B0aW9ucyk6IEZ1bmN0aW9uIHtcbiAgY29uc3QgaG9vazogP0RldlRvb2xzSG9vayA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rID09IG51bGwpIHtcbiAgICAvLyBEZXZUb29scyBkaWRuJ3QgZ2V0IGluamVjdGVkIGludG8gdGhpcyBwYWdlIChtYXliZSBiJ2Mgb2YgdGhlIGNvbnRlbnRUeXBlKS5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB3YWxsOiBXYWxsID0ge1xuICAgIGxpc3RlbihmbjogRnVuY3Rpb24pIHtcbiAgICAgIG9uU3Vic2NyaWJlKGZuKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb25VbnN1YnNjcmliZShmbik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2VuZChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnkpIHtcbiAgICAgIG9uTWVzc2FnZShldmVudCwgcGF5bG9hZCk7XG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBicmlkZ2U6IEJhY2tlbmRCcmlkZ2UgPSBuZXcgQnJpZGdlKHdhbGwpO1xuXG4gIGJyaWRnZS5hZGRMaXN0ZW5lcihcbiAgICAndXBkYXRlQ29tcG9uZW50RmlsdGVycycsXG4gICAgKGNvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4pID0+IHtcbiAgICAgIC8vIFNhdmUgZmlsdGVyIGNoYW5nZXMgaW4gbWVtb3J5LCBpbiBjYXNlIERldlRvb2xzIGlzIHJlbG9hZGVkLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgcmVuZGVyZXIgd2lsbCBhbHJlYWR5IGJlIHVzaW5nIHRoZSB1cGRhdGVkIHZhbHVlcy5cbiAgICAgIC8vIFdlJ2xsIGxvc2UgdGhlc2UgaW4gYmV0d2VlbiBiYWNrZW5kIHJlbG9hZHMgYnV0IHRoYXQgY2FuJ3QgYmUgaGVscGVkLlxuICAgICAgc2F2ZWRDb21wb25lbnRGaWx0ZXJzID0gY29tcG9uZW50RmlsdGVycztcbiAgICB9LFxuICApO1xuXG4gIGlmICh3aW5kb3cuX19SRUFDVF9ERVZUT09MU19DT01QT05FTlRfRklMVEVSU19fID09IG51bGwpIHtcbiAgICBicmlkZ2Uuc2VuZCgnb3ZlcnJpZGVDb21wb25lbnRGaWx0ZXJzJywgc2F2ZWRDb21wb25lbnRGaWx0ZXJzKTtcbiAgfVxuXG4gIGNvbnN0IGFnZW50ID0gbmV3IEFnZW50KGJyaWRnZSwgaXNQcm9maWxpbmcsIG9uUmVsb2FkQW5kUHJvZmlsZSk7XG4gIGlmICh0eXBlb2Ygb25SZWxvYWRBbmRQcm9maWxlRmxhZ3NSZXNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uUmVsb2FkQW5kUHJvZmlsZUZsYWdzUmVzZXQoKTtcbiAgfVxuXG4gIGlmIChvblNldHRpbmdzVXBkYXRlZCAhPSBudWxsKSB7XG4gICAgYWdlbnQuYWRkTGlzdGVuZXIoJ3VwZGF0ZUhvb2tTZXR0aW5ncycsIG9uU2V0dGluZ3NVcGRhdGVkKTtcbiAgfVxuICBhZ2VudC5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCAoKSA9PiB7XG4gICAgaWYgKG9uU2V0dGluZ3NVcGRhdGVkICE9IG51bGwpIHtcbiAgICAgIGFnZW50LnJlbW92ZUxpc3RlbmVyKCd1cGRhdGVIb29rU2V0dGluZ3MnLCBvblNldHRpbmdzVXBkYXRlZCk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgcmVjZWl2ZWQgJ3NodXRkb3duJyBmcm9tIGBhZ2VudGAsIHdlIGFzc3VtZSB0aGUgYGJyaWRnZWAgaXMgYWxyZWFkeSBzaHV0dGluZyBkb3duLFxuICAgIC8vIGFuZCB0aGF0IGNhdXNlZCB0aGUgJ3NodXRkb3duJyBldmVudCBvbiB0aGUgYGFnZW50YCwgc28gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIGBicmlkZ2Uuc2h1dGRvd24oKWAgaGVyZS5cbiAgICBob29rLmVtaXQoJ3NodXRkb3duJyk7XG4gIH0pO1xuXG4gIGNvbnN0IHVuc3Vic2NyaWJlQmFja2VuZCA9IGluaXRCYWNrZW5kKFxuICAgIGhvb2ssXG4gICAgYWdlbnQsXG4gICAgd2luZG93LFxuICAgIGlzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZCxcbiAgKTtcblxuICBjb25zdCBuYXRpdmVTdHlsZVJlc29sdmVyOiBSZXNvbHZlTmF0aXZlU3R5bGUgfCB2b2lkID1cbiAgICByZXNvbHZlUk5TdHlsZSB8fCBob29rLnJlc29sdmVSTlN0eWxlO1xuXG4gIGlmIChuYXRpdmVTdHlsZVJlc29sdmVyICE9IG51bGwpIHtcbiAgICBjb25zdCB2YWxpZEF0dHJpYnV0ZXMgPVxuICAgICAgbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMgfHxcbiAgICAgIGhvb2submF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMgfHxcbiAgICAgIG51bGw7XG5cbiAgICBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yKGJyaWRnZSwgYWdlbnQsIG5hdGl2ZVN0eWxlUmVzb2x2ZXIsIHZhbGlkQXR0cmlidXRlcyk7XG4gIH1cblxuICByZXR1cm4gdW5zdWJzY3JpYmVCYWNrZW5kO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/backend.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/attachRenderer.js":
/*!******************************************************!*\
  !*** ../react-devtools-shared/src/attachRenderer.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ attachRenderer)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_backend_flight_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/flight/renderer */ \"../react-devtools-shared/src/backend/flight/renderer.js\");\n/* harmony import */ var react_devtools_shared_src_backend_fiber_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/backend/fiber/renderer */ \"../react-devtools-shared/src/backend/fiber/renderer.js\");\n/* harmony import */ var react_devtools_shared_src_backend_legacy_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/backend/legacy/renderer */ \"../react-devtools-shared/src/backend/legacy/renderer.js\");\n/* harmony import */ var react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/backend/utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n // this is the backend that is compatible with all older React versions\n\nfunction isMatchingRender(version) {\n  return !(0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_3__.hasAssignedBackend)(version);\n}\n\nfunction attachRenderer(hook, id, renderer, global, shouldStartProfilingNow, profilingSettings) {\n  // only attach if the renderer is compatible with the current version of the backend\n  if (!isMatchingRender(renderer.reconcilerVersion || renderer.version)) {\n    return;\n  }\n\n  var rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)\n\n  if (rendererInterface == null) {\n    if (typeof renderer.getCurrentComponentInfo === 'function') {\n      // react-flight/client\n      rendererInterface = (0,react_devtools_shared_src_backend_flight_renderer__WEBPACK_IMPORTED_MODULE_0__.attach)(hook, id, renderer, global);\n    } else if ( // v16-19\n    typeof renderer.findFiberByHostInstance === 'function' || // v16.8+\n    renderer.currentDispatcherRef != null) {\n      // react-reconciler v16+\n      rendererInterface = (0,react_devtools_shared_src_backend_fiber_renderer__WEBPACK_IMPORTED_MODULE_1__.attach)(hook, id, renderer, global, shouldStartProfilingNow, profilingSettings);\n    } else if (renderer.ComponentTree) {\n      // react-dom v15\n      rendererInterface = (0,react_devtools_shared_src_backend_legacy_renderer__WEBPACK_IMPORTED_MODULE_2__.attach)(hook, id, renderer, global);\n    } else {// Older react-dom or other unsupported renderer version\n    }\n  }\n\n  return rendererInterface;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9hdHRhY2hSZW5kZXJlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYXR0YWNoUmVuZGVyZXIuanM/NjQyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWN0UmVuZGVyZXIsXG4gIFJlbmRlcmVySW50ZXJmYWNlLFxuICBEZXZUb29sc0hvb2ssXG4gIFJlbmRlcmVySUQsXG4gIFByb2ZpbGluZ1NldHRpbmdzLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdHlwZXMnO1xuXG5pbXBvcnQge2F0dGFjaCBhcyBhdHRhY2hGbGlnaHR9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9mbGlnaHQvcmVuZGVyZXInO1xuaW1wb3J0IHthdHRhY2ggYXMgYXR0YWNoRmliZXJ9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9maWJlci9yZW5kZXJlcic7XG5pbXBvcnQge2F0dGFjaCBhcyBhdHRhY2hMZWdhY3l9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9sZWdhY3kvcmVuZGVyZXInO1xuaW1wb3J0IHtoYXNBc3NpZ25lZEJhY2tlbmR9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC91dGlscyc7XG5cbi8vIHRoaXMgaXMgdGhlIGJhY2tlbmQgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYWxsIG9sZGVyIFJlYWN0IHZlcnNpb25zXG5mdW5jdGlvbiBpc01hdGNoaW5nUmVuZGVyKHZlcnNpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gIWhhc0Fzc2lnbmVkQmFja2VuZCh2ZXJzaW9uKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXR0YWNoUmVuZGVyZXIoXG4gIGhvb2s6IERldlRvb2xzSG9vayxcbiAgaWQ6IFJlbmRlcmVySUQsXG4gIHJlbmRlcmVyOiBSZWFjdFJlbmRlcmVyLFxuICBnbG9iYWw6IE9iamVjdCxcbiAgc2hvdWxkU3RhcnRQcm9maWxpbmdOb3c6IGJvb2xlYW4sXG4gIHByb2ZpbGluZ1NldHRpbmdzOiBQcm9maWxpbmdTZXR0aW5ncyxcbik6IFJlbmRlcmVySW50ZXJmYWNlIHwgdm9pZCB7XG4gIC8vIG9ubHkgYXR0YWNoIGlmIHRoZSByZW5kZXJlciBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgYmFja2VuZFxuICBpZiAoIWlzTWF0Y2hpbmdSZW5kZXIocmVuZGVyZXIucmVjb25jaWxlclZlcnNpb24gfHwgcmVuZGVyZXIudmVyc2lvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHJlbmRlcmVySW50ZXJmYWNlID0gaG9vay5yZW5kZXJlckludGVyZmFjZXMuZ2V0KGlkKTtcblxuICAvLyBJbmplY3QgYW55IG5vdC15ZXQtaW5qZWN0ZWQgcmVuZGVyZXJzIChpZiB3ZSBkaWRuJ3QgcmVsb2FkLWFuZC1wcm9maWxlKVxuICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuZ2V0Q3VycmVudENvbXBvbmVudEluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHJlYWN0LWZsaWdodC9jbGllbnRcbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlID0gYXR0YWNoRmxpZ2h0KGhvb2ssIGlkLCByZW5kZXJlciwgZ2xvYmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gdjE2LTE5XG4gICAgICB0eXBlb2YgcmVuZGVyZXIuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIC8vIHYxNi44K1xuICAgICAgcmVuZGVyZXIuY3VycmVudERpc3BhdGNoZXJSZWYgIT0gbnVsbFxuICAgICkge1xuICAgICAgLy8gcmVhY3QtcmVjb25jaWxlciB2MTYrXG4gICAgICByZW5kZXJlckludGVyZmFjZSA9IGF0dGFjaEZpYmVyKFxuICAgICAgICBob29rLFxuICAgICAgICBpZCxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgc2hvdWxkU3RhcnRQcm9maWxpbmdOb3csXG4gICAgICAgIHByb2ZpbGluZ1NldHRpbmdzLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHJlbmRlcmVyLkNvbXBvbmVudFRyZWUpIHtcbiAgICAgIC8vIHJlYWN0LWRvbSB2MTVcbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlID0gYXR0YWNoTGVnYWN5KGhvb2ssIGlkLCByZW5kZXJlciwgZ2xvYmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2xkZXIgcmVhY3QtZG9tIG9yIG90aGVyIHVuc3VwcG9ydGVkIHJlbmRlcmVyIHZlcnNpb25cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVuZGVyZXJJbnRlcmZhY2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/attachRenderer.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js":
/*!*********************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resolveBoxStyle)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).\n *\n * Resolve a style property into it's component parts, e.g.\n *\n * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})\n * -> {top: 5, left: 5, right: 5, bottom: 10}\n */\nfunction resolveBoxStyle(prefix, style) {\n  var hasParts = false;\n  var result = {\n    bottom: 0,\n    left: 0,\n    right: 0,\n    top: 0\n  };\n  var styleForAll = style[prefix];\n\n  if (styleForAll != null) {\n    // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n    for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      result[key] = styleForAll;\n    }\n\n    hasParts = true;\n  }\n\n  var styleForHorizontal = style[prefix + 'Horizontal'];\n\n  if (styleForHorizontal != null) {\n    result.left = styleForHorizontal;\n    result.right = styleForHorizontal;\n    hasParts = true;\n  } else {\n    var styleForLeft = style[prefix + 'Left'];\n\n    if (styleForLeft != null) {\n      result.left = styleForLeft;\n      hasParts = true;\n    }\n\n    var styleForRight = style[prefix + 'Right'];\n\n    if (styleForRight != null) {\n      result.right = styleForRight;\n      hasParts = true;\n    }\n\n    var styleForEnd = style[prefix + 'End'];\n\n    if (styleForEnd != null) {\n      // TODO RTL support\n      result.right = styleForEnd;\n      hasParts = true;\n    }\n\n    var styleForStart = style[prefix + 'Start'];\n\n    if (styleForStart != null) {\n      // TODO RTL support\n      result.left = styleForStart;\n      hasParts = true;\n    }\n  }\n\n  var styleForVertical = style[prefix + 'Vertical'];\n\n  if (styleForVertical != null) {\n    result.bottom = styleForVertical;\n    result.top = styleForVertical;\n    hasParts = true;\n  } else {\n    var styleForBottom = style[prefix + 'Bottom'];\n\n    if (styleForBottom != null) {\n      result.bottom = styleForBottom;\n      hasParts = true;\n    }\n\n    var styleForTop = style[prefix + 'Top'];\n\n    if (styleForTop != null) {\n      result.top = styleForTop;\n      hasParts = true;\n    }\n  }\n\n  return hasParts ? result : null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL05hdGl2ZVN0eWxlRWRpdG9yL3Jlc29sdmVCb3hTdHlsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7OztBQVdBOzs7Ozs7OztBQVFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9OYXRpdmVTdHlsZUVkaXRvci9yZXNvbHZlQm94U3R5bGUuanM/NDNhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7Qm94U3R5bGV9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFRoaXMgbWlycm9ycyByZWFjdC1uYXRpdmUvTGlicmFyaWVzL0luc3BlY3Rvci9yZXNvbHZlQm94U3R5bGUuanMgKGJ1dCB3aXRob3V0IFJUTCBzdXBwb3J0KS5cbiAqXG4gKiBSZXNvbHZlIGEgc3R5bGUgcHJvcGVydHkgaW50byBpdCdzIGNvbXBvbmVudCBwYXJ0cywgZS5nLlxuICpcbiAqIHJlc29sdmVCb3hTdHlsZSgnbWFyZ2luJywge21hcmdpbjogNSwgbWFyZ2luQm90dG9tOiAxMH0pXG4gKiAtPiB7dG9wOiA1LCBsZWZ0OiA1LCByaWdodDogNSwgYm90dG9tOiAxMH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZUJveFN0eWxlKFxuICBwcmVmaXg6IHN0cmluZyxcbiAgc3R5bGU6IE9iamVjdCxcbik6IEJveFN0eWxlIHwgbnVsbCB7XG4gIGxldCBoYXNQYXJ0cyA9IGZhbHNlO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICB9O1xuXG4gIGNvbnN0IHN0eWxlRm9yQWxsID0gc3R5bGVbcHJlZml4XTtcbiAgaWYgKHN0eWxlRm9yQWxsICE9IG51bGwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gc3R5bGVGb3JBbGw7XG4gICAgfVxuICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlRm9ySG9yaXpvbnRhbCA9IHN0eWxlW3ByZWZpeCArICdIb3Jpem9udGFsJ107XG4gIGlmIChzdHlsZUZvckhvcml6b250YWwgIT0gbnVsbCkge1xuICAgIHJlc3VsdC5sZWZ0ID0gc3R5bGVGb3JIb3Jpem9udGFsO1xuICAgIHJlc3VsdC5yaWdodCA9IHN0eWxlRm9ySG9yaXpvbnRhbDtcbiAgICBoYXNQYXJ0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3R5bGVGb3JMZWZ0ID0gc3R5bGVbcHJlZml4ICsgJ0xlZnQnXTtcbiAgICBpZiAoc3R5bGVGb3JMZWZ0ICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5sZWZ0ID0gc3R5bGVGb3JMZWZ0O1xuICAgICAgaGFzUGFydHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0eWxlRm9yUmlnaHQgPSBzdHlsZVtwcmVmaXggKyAnUmlnaHQnXTtcbiAgICBpZiAoc3R5bGVGb3JSaWdodCAhPSBudWxsKSB7XG4gICAgICByZXN1bHQucmlnaHQgPSBzdHlsZUZvclJpZ2h0O1xuICAgICAgaGFzUGFydHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0eWxlRm9yRW5kID0gc3R5bGVbcHJlZml4ICsgJ0VuZCddO1xuICAgIGlmIChzdHlsZUZvckVuZCAhPSBudWxsKSB7XG4gICAgICAvLyBUT0RPIFJUTCBzdXBwb3J0XG4gICAgICByZXN1bHQucmlnaHQgPSBzdHlsZUZvckVuZDtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVGb3JTdGFydCA9IHN0eWxlW3ByZWZpeCArICdTdGFydCddO1xuICAgIGlmIChzdHlsZUZvclN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIC8vIFRPRE8gUlRMIHN1cHBvcnRcbiAgICAgIHJlc3VsdC5sZWZ0ID0gc3R5bGVGb3JTdGFydDtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHlsZUZvclZlcnRpY2FsID0gc3R5bGVbcHJlZml4ICsgJ1ZlcnRpY2FsJ107XG4gIGlmIChzdHlsZUZvclZlcnRpY2FsICE9IG51bGwpIHtcbiAgICByZXN1bHQuYm90dG9tID0gc3R5bGVGb3JWZXJ0aWNhbDtcbiAgICByZXN1bHQudG9wID0gc3R5bGVGb3JWZXJ0aWNhbDtcbiAgICBoYXNQYXJ0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3R5bGVGb3JCb3R0b20gPSBzdHlsZVtwcmVmaXggKyAnQm90dG9tJ107XG4gICAgaWYgKHN0eWxlRm9yQm90dG9tICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5ib3R0b20gPSBzdHlsZUZvckJvdHRvbTtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHlsZUZvclRvcCA9IHN0eWxlW3ByZWZpeCArICdUb3AnXTtcbiAgICBpZiAoc3R5bGVGb3JUb3AgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnRvcCA9IHN0eWxlRm9yVG9wO1xuICAgICAgaGFzUGFydHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNQYXJ0cyA/IHJlc3VsdCA6IG51bGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js":
/*!****************************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setupNativeStyleEditor)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/agent */ \"../react-devtools-shared/src/backend/agent.js\");\n/* harmony import */ var _resolveBoxStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolveBoxStyle */ \"../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js\");\n/* harmony import */ var react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/isArray */ \"../react-devtools-shared/src/isArray.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\nfunction setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {\n  bridge.addListener('NativeStyleEditor_measure', function (_ref) {\n    var id = _ref.id,\n        rendererID = _ref.rendererID;\n    measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n  });\n  bridge.addListener('NativeStyleEditor_renameAttribute', function (_ref2) {\n    var id = _ref2.id,\n        rendererID = _ref2.rendererID,\n        oldName = _ref2.oldName,\n        newName = _ref2.newName,\n        value = _ref2.value;\n    renameStyle(agent, id, rendererID, oldName, newName, value);\n    setTimeout(function () {\n      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n    });\n  });\n  bridge.addListener('NativeStyleEditor_setValue', function (_ref3) {\n    var id = _ref3.id,\n        rendererID = _ref3.rendererID,\n        name = _ref3.name,\n        value = _ref3.value;\n    setStyle(agent, id, rendererID, name, value);\n    setTimeout(function () {\n      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n    });\n  });\n  bridge.send('isNativeStyleEditorSupported', {\n    isSupported: true,\n    validAttributes: validAttributes\n  });\n}\nvar EMPTY_BOX_STYLE = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0\n};\nvar componentIDToStyleOverrides = new Map();\n\nfunction measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {\n  var data = agent.getInstanceAndStyle({\n    id: id,\n    rendererID: rendererID\n  });\n\n  if (!data || !data.style) {\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id: id,\n      layout: null,\n      style: null\n    });\n    return;\n  }\n\n  var instance = data.instance,\n      style = data.style;\n  var resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.\n\n  var styleOverrides = componentIDToStyleOverrides.get(id);\n\n  if (styleOverrides != null) {\n    resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);\n  }\n\n  if (!instance || typeof instance.measure !== 'function') {\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id: id,\n      layout: null,\n      style: resolvedStyle || null\n    });\n    return;\n  }\n\n  instance.measure(function (x, y, width, height, left, top) {\n    // RN Android sometimes returns undefined here. Don't send measurements in this case.\n    // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817\n    if (typeof x !== 'number') {\n      bridge.send('NativeStyleEditor_styleAndLayout', {\n        id: id,\n        layout: null,\n        style: resolvedStyle || null\n      });\n      return;\n    }\n\n    var margin = resolvedStyle != null && (0,_resolveBoxStyle__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('margin', resolvedStyle) || EMPTY_BOX_STYLE;\n    var padding = resolvedStyle != null && (0,_resolveBoxStyle__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('padding', resolvedStyle) || EMPTY_BOX_STYLE;\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id: id,\n      layout: {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        left: left,\n        top: top,\n        margin: margin,\n        padding: padding\n      },\n      style: resolvedStyle || null\n    });\n  });\n}\n\nfunction shallowClone(object) {\n  var cloned = {};\n\n  for (var n in object) {\n    cloned[n] = object[n];\n  }\n\n  return cloned;\n}\n\nfunction renameStyle(agent, id, rendererID, oldName, newName, value) {\n  var _ref4;\n\n  var data = agent.getInstanceAndStyle({\n    id: id,\n    rendererID: rendererID\n  });\n\n  if (!data || !data.style) {\n    return;\n  }\n\n  var instance = data.instance,\n      style = data.style;\n  var newStyle = newName ? (_ref4 = {}, _defineProperty(_ref4, oldName, undefined), _defineProperty(_ref4, newName, value), _ref4) : _defineProperty({}, oldName, undefined);\n  var customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n  if (instance !== null && typeof instance.setNativeProps === 'function') {\n    // In the case of a host component, we need to use setNativeProps().\n    // Remember to \"correct\" resolved styles when we read them next time.\n    var styleOverrides = componentIDToStyleOverrides.get(id);\n\n    if (!styleOverrides) {\n      componentIDToStyleOverrides.set(id, newStyle);\n    } else {\n      Object.assign(styleOverrides, newStyle);\n    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n    instance.setNativeProps({\n      style: newStyle\n    });\n  } else if ((0,react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(style)) {\n    var lastIndex = style.length - 1;\n\n    if (_typeof(style[lastIndex]) === 'object' && !(0,react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(style[lastIndex])) {\n      customStyle = shallowClone(style[lastIndex]);\n      delete customStyle[oldName];\n\n      if (newName) {\n        customStyle[newName] = value;\n      } else {\n        customStyle[oldName] = undefined;\n      }\n\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style', lastIndex],\n        value: customStyle\n      });\n    } else {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style'],\n        value: style.concat([newStyle])\n      });\n    }\n  } else if (_typeof(style) === 'object') {\n    customStyle = shallowClone(style);\n    delete customStyle[oldName];\n\n    if (newName) {\n      customStyle[newName] = value;\n    } else {\n      customStyle[oldName] = undefined;\n    }\n\n    agent.overrideValueAtPath({\n      type: 'props',\n      id: id,\n      rendererID: rendererID,\n      path: ['style'],\n      value: customStyle\n    });\n  } else {\n    agent.overrideValueAtPath({\n      type: 'props',\n      id: id,\n      rendererID: rendererID,\n      path: ['style'],\n      value: [style, newStyle]\n    });\n  }\n\n  agent.emit('hideNativeHighlight');\n}\n\nfunction setStyle(agent, id, rendererID, name, value) {\n  var data = agent.getInstanceAndStyle({\n    id: id,\n    rendererID: rendererID\n  });\n\n  if (!data || !data.style) {\n    return;\n  }\n\n  var instance = data.instance,\n      style = data.style;\n\n  var newStyle = _defineProperty({}, name, value); // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n\n  if (instance !== null && typeof instance.setNativeProps === 'function') {\n    // In the case of a host component, we need to use setNativeProps().\n    // Remember to \"correct\" resolved styles when we read them next time.\n    var styleOverrides = componentIDToStyleOverrides.get(id);\n\n    if (!styleOverrides) {\n      componentIDToStyleOverrides.set(id, newStyle);\n    } else {\n      Object.assign(styleOverrides, newStyle);\n    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n    instance.setNativeProps({\n      style: newStyle\n    });\n  } else if ((0,react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(style)) {\n    var lastLength = style.length - 1;\n\n    if (_typeof(style[lastLength]) === 'object' && !(0,react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(style[lastLength])) {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style', lastLength, name],\n        value: value\n      });\n    } else {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id: id,\n        rendererID: rendererID,\n        path: ['style'],\n        value: style.concat([newStyle])\n      });\n    }\n  } else {\n    agent.overrideValueAtPath({\n      type: 'props',\n      id: id,\n      rendererID: rendererID,\n      path: ['style'],\n      value: [style, newStyle]\n    });\n  }\n\n  agent.emit('hideNativeHighlight');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL05hdGl2ZVN0eWxlRWRpdG9yL3NldHVwTmF0aXZlU3R5bGVFZGl0b3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFTQTtBQU1BO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFZQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7O0FBRUE7QUFPQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBOztBQVpBO0FBQUE7QUFnQkE7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTs7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFaQTtBQWVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQU9BOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFKQTtBQUFBO0FBUUE7QUFJQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBRUE7QUFDQTs7QUFFQTtBQU9BO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFKQTtBQUFBOztBQU9BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9OYXRpdmVTdHlsZUVkaXRvci9zZXR1cE5hdGl2ZVN0eWxlRWRpdG9yLmpzPzdhYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IEFnZW50IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9hZ2VudCc7XG5pbXBvcnQgcmVzb2x2ZUJveFN0eWxlIGZyb20gJy4vcmVzb2x2ZUJveFN0eWxlJztcbmltcG9ydCBpc0FycmF5IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaXNBcnJheSc7XG5cbmltcG9ydCB0eXBlIHtCYWNrZW5kQnJpZGdlfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JyaWRnZSc7XG5pbXBvcnQgdHlwZSB7UmVuZGVyZXJJRH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUge1N0eWxlQW5kTGF5b3V0fSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgUmVzb2x2ZU5hdGl2ZVN0eWxlID0gKHN0eWxlc2hlZXRJRDogYW55KSA9PiA/T2JqZWN0O1xuZXhwb3J0IHR5cGUgU2V0dXBOYXRpdmVTdHlsZUVkaXRvciA9IHR5cGVvZiBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yKFxuICBicmlkZ2U6IEJhY2tlbmRCcmlkZ2UsXG4gIGFnZW50OiBBZ2VudCxcbiAgcmVzb2x2ZU5hdGl2ZVN0eWxlOiBSZXNvbHZlTmF0aXZlU3R5bGUsXG4gIHZhbGlkQXR0cmlidXRlcz86ICRSZWFkT25seUFycmF5PHN0cmluZz4gfCBudWxsLFxuKSB7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcihcbiAgICAnTmF0aXZlU3R5bGVFZGl0b3JfbWVhc3VyZScsXG4gICAgKHtpZCwgcmVuZGVyZXJJRH06IHtpZDogbnVtYmVyLCByZW5kZXJlcklEOiBSZW5kZXJlcklEfSkgPT4ge1xuICAgICAgbWVhc3VyZVN0eWxlKGFnZW50LCBicmlkZ2UsIHJlc29sdmVOYXRpdmVTdHlsZSwgaWQsIHJlbmRlcmVySUQpO1xuICAgIH0sXG4gICk7XG5cbiAgYnJpZGdlLmFkZExpc3RlbmVyKFxuICAgICdOYXRpdmVTdHlsZUVkaXRvcl9yZW5hbWVBdHRyaWJ1dGUnLFxuICAgICh7XG4gICAgICBpZCxcbiAgICAgIHJlbmRlcmVySUQsXG4gICAgICBvbGROYW1lLFxuICAgICAgbmV3TmFtZSxcbiAgICAgIHZhbHVlLFxuICAgIH06IHtcbiAgICAgIGlkOiBudW1iZXIsXG4gICAgICByZW5kZXJlcklEOiBSZW5kZXJlcklELFxuICAgICAgb2xkTmFtZTogc3RyaW5nLFxuICAgICAgbmV3TmFtZTogc3RyaW5nLFxuICAgICAgdmFsdWU6IHN0cmluZyxcbiAgICB9KSA9PiB7XG4gICAgICByZW5hbWVTdHlsZShhZ2VudCwgaWQsIHJlbmRlcmVySUQsIG9sZE5hbWUsIG5ld05hbWUsIHZhbHVlKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgbWVhc3VyZVN0eWxlKGFnZW50LCBicmlkZ2UsIHJlc29sdmVOYXRpdmVTdHlsZSwgaWQsIHJlbmRlcmVySUQpLFxuICAgICAgKTtcbiAgICB9LFxuICApO1xuXG4gIGJyaWRnZS5hZGRMaXN0ZW5lcihcbiAgICAnTmF0aXZlU3R5bGVFZGl0b3Jfc2V0VmFsdWUnLFxuICAgICh7XG4gICAgICBpZCxcbiAgICAgIHJlbmRlcmVySUQsXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWUsXG4gICAgfToge1xuICAgICAgaWQ6IG51bWJlcixcbiAgICAgIHJlbmRlcmVySUQ6IG51bWJlcixcbiAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgfSkgPT4ge1xuICAgICAgc2V0U3R5bGUoYWdlbnQsIGlkLCByZW5kZXJlcklELCBuYW1lLCB2YWx1ZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIG1lYXN1cmVTdHlsZShhZ2VudCwgYnJpZGdlLCByZXNvbHZlTmF0aXZlU3R5bGUsIGlkLCByZW5kZXJlcklEKSxcbiAgICAgICk7XG4gICAgfSxcbiAgKTtcblxuICBicmlkZ2Uuc2VuZCgnaXNOYXRpdmVTdHlsZUVkaXRvclN1cHBvcnRlZCcsIHtcbiAgICBpc1N1cHBvcnRlZDogdHJ1ZSxcbiAgICB2YWxpZEF0dHJpYnV0ZXMsXG4gIH0pO1xufVxuXG5jb25zdCBFTVBUWV9CT1hfU1RZTEUgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbn07XG5cbmNvbnN0IGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlczogTWFwPG51bWJlciwgT2JqZWN0PiA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gbWVhc3VyZVN0eWxlKFxuICBhZ2VudDogQWdlbnQsXG4gIGJyaWRnZTogQmFja2VuZEJyaWRnZSxcbiAgcmVzb2x2ZU5hdGl2ZVN0eWxlOiBSZXNvbHZlTmF0aXZlU3R5bGUsXG4gIGlkOiBudW1iZXIsXG4gIHJlbmRlcmVySUQ6IFJlbmRlcmVySUQsXG4pIHtcbiAgY29uc3QgZGF0YSA9IGFnZW50LmdldEluc3RhbmNlQW5kU3R5bGUoe2lkLCByZW5kZXJlcklEfSk7XG4gIGlmICghZGF0YSB8fCAhZGF0YS5zdHlsZSkge1xuICAgIGJyaWRnZS5zZW5kKFxuICAgICAgJ05hdGl2ZVN0eWxlRWRpdG9yX3N0eWxlQW5kTGF5b3V0JyxcbiAgICAgICh7XG4gICAgICAgIGlkLFxuICAgICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICAgIHN0eWxlOiBudWxsLFxuICAgICAgfTogU3R5bGVBbmRMYXlvdXQpLFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge2luc3RhbmNlLCBzdHlsZX0gPSBkYXRhO1xuXG4gIGxldCByZXNvbHZlZFN0eWxlID0gcmVzb2x2ZU5hdGl2ZVN0eWxlKHN0eWxlKTtcblxuICAvLyBJZiBpdCdzIGEgaG9zdCBjb21wb25lbnQgd2UgZWRpdGVkIGJlZm9yZSwgYW1lbmQgc3R5bGVzLlxuICBjb25zdCBzdHlsZU92ZXJyaWRlcyA9IGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5nZXQoaWQpO1xuICBpZiAoc3R5bGVPdmVycmlkZXMgIT0gbnVsbCkge1xuICAgIHJlc29sdmVkU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCByZXNvbHZlZFN0eWxlLCBzdHlsZU92ZXJyaWRlcyk7XG4gIH1cblxuICBpZiAoIWluc3RhbmNlIHx8IHR5cGVvZiBpbnN0YW5jZS5tZWFzdXJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgYnJpZGdlLnNlbmQoXG4gICAgICAnTmF0aXZlU3R5bGVFZGl0b3Jfc3R5bGVBbmRMYXlvdXQnLFxuICAgICAgKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGxheW91dDogbnVsbCxcbiAgICAgICAgc3R5bGU6IHJlc29sdmVkU3R5bGUgfHwgbnVsbCxcbiAgICAgIH06IFN0eWxlQW5kTGF5b3V0KSxcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGluc3RhbmNlLm1lYXN1cmUoKHgsIHksIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCkgPT4ge1xuICAgIC8vIFJOIEFuZHJvaWQgc29tZXRpbWVzIHJldHVybnMgdW5kZWZpbmVkIGhlcmUuIERvbid0IHNlbmQgbWVhc3VyZW1lbnRzIGluIHRoaXMgY2FzZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vamhlbjA0MDkvcmVhY3QtbmF0aXZlLWRlYnVnZ2VyL2lzc3Vlcy84NCNpc3N1ZWNvbW1lbnQtMzA0NjExODE3XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgYnJpZGdlLnNlbmQoXG4gICAgICAgICdOYXRpdmVTdHlsZUVkaXRvcl9zdHlsZUFuZExheW91dCcsXG4gICAgICAgICh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgICAgIHN0eWxlOiByZXNvbHZlZFN0eWxlIHx8IG51bGwsXG4gICAgICAgIH06IFN0eWxlQW5kTGF5b3V0KSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hcmdpbiA9XG4gICAgICAocmVzb2x2ZWRTdHlsZSAhPSBudWxsICYmIHJlc29sdmVCb3hTdHlsZSgnbWFyZ2luJywgcmVzb2x2ZWRTdHlsZSkpIHx8XG4gICAgICBFTVBUWV9CT1hfU1RZTEU7XG4gICAgY29uc3QgcGFkZGluZyA9XG4gICAgICAocmVzb2x2ZWRTdHlsZSAhPSBudWxsICYmIHJlc29sdmVCb3hTdHlsZSgncGFkZGluZycsIHJlc29sdmVkU3R5bGUpKSB8fFxuICAgICAgRU1QVFlfQk9YX1NUWUxFO1xuICAgIGJyaWRnZS5zZW5kKFxuICAgICAgJ05hdGl2ZVN0eWxlRWRpdG9yX3N0eWxlQW5kTGF5b3V0JyxcbiAgICAgICh7XG4gICAgICAgIGlkLFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogcmVzb2x2ZWRTdHlsZSB8fCBudWxsLFxuICAgICAgfTogU3R5bGVBbmRMYXlvdXQpLFxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2JqZWN0OiBPYmplY3QpOiBPYmplY3Qge1xuICBjb25zdCBjbG9uZWQ6IHtbc3RyaW5nXTogJEZsb3dGaXhNZX0gPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIG9iamVjdCkge1xuICAgIGNsb25lZFtuXSA9IG9iamVjdFtuXTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuXG5mdW5jdGlvbiByZW5hbWVTdHlsZShcbiAgYWdlbnQ6IEFnZW50LFxuICBpZDogbnVtYmVyLFxuICByZW5kZXJlcklEOiBSZW5kZXJlcklELFxuICBvbGROYW1lOiBzdHJpbmcsXG4gIG5ld05hbWU6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbik6IHZvaWQge1xuICBjb25zdCBkYXRhID0gYWdlbnQuZ2V0SW5zdGFuY2VBbmRTdHlsZSh7aWQsIHJlbmRlcmVySUR9KTtcbiAgaWYgKCFkYXRhIHx8ICFkYXRhLnN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge2luc3RhbmNlLCBzdHlsZX0gPSBkYXRhO1xuXG4gIGNvbnN0IG5ld1N0eWxlID0gbmV3TmFtZVxuICAgID8ge1tvbGROYW1lXTogdW5kZWZpbmVkLCBbbmV3TmFtZV06IHZhbHVlfVxuICAgIDoge1tvbGROYW1lXTogdW5kZWZpbmVkfTtcblxuICBsZXQgY3VzdG9tU3R5bGU7XG5cbiAgLy8gVE9ETyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSByZW5kZXJlciBpbnRlcmZhY2UgYWJzdHJhY3RlZCB0aGlzIGF3YXkgc29tZWhvdy5cbiAgaWYgKGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5zZXROYXRpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgaG9zdCBjb21wb25lbnQsIHdlIG5lZWQgdG8gdXNlIHNldE5hdGl2ZVByb3BzKCkuXG4gICAgLy8gUmVtZW1iZXIgdG8gXCJjb3JyZWN0XCIgcmVzb2x2ZWQgc3R5bGVzIHdoZW4gd2UgcmVhZCB0aGVtIG5leHQgdGltZS5cbiAgICBjb25zdCBzdHlsZU92ZXJyaWRlcyA9IGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5nZXQoaWQpO1xuICAgIGlmICghc3R5bGVPdmVycmlkZXMpIHtcbiAgICAgIGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5zZXQoaWQsIG5ld1N0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZU92ZXJyaWRlcywgbmV3U3R5bGUpO1xuICAgIH1cbiAgICAvLyBUT0RPIEZhYnJpYyBkb2VzIG5vdCBzdXBwb3J0IHNldE5hdGl2ZVByb3BzOyBjaGF0IHdpdGggU2ViYXN0aWFuIG9yIEVsaVxuICAgIGluc3RhbmNlLnNldE5hdGl2ZVByb3BzKHtzdHlsZTogbmV3U3R5bGV9KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHN0eWxlKSkge1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHN0eWxlLmxlbmd0aCAtIDE7XG4gICAgaWYgKHR5cGVvZiBzdHlsZVtsYXN0SW5kZXhdID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShzdHlsZVtsYXN0SW5kZXhdKSkge1xuICAgICAgY3VzdG9tU3R5bGUgPSBzaGFsbG93Q2xvbmUoc3R5bGVbbGFzdEluZGV4XSk7XG4gICAgICBkZWxldGUgY3VzdG9tU3R5bGVbb2xkTmFtZV07XG4gICAgICBpZiAobmV3TmFtZSkge1xuICAgICAgICBjdXN0b21TdHlsZVtuZXdOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VzdG9tU3R5bGVbb2xkTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgICBpZCxcbiAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgcGF0aDogWydzdHlsZScsIGxhc3RJbmRleF0sXG4gICAgICAgIHZhbHVlOiBjdXN0b21TdHlsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgICAgaWQsXG4gICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgICAgdmFsdWU6IHN0eWxlLmNvbmNhdChbbmV3U3R5bGVdKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgY3VzdG9tU3R5bGUgPSBzaGFsbG93Q2xvbmUoc3R5bGUpO1xuICAgIGRlbGV0ZSBjdXN0b21TdHlsZVtvbGROYW1lXTtcbiAgICBpZiAobmV3TmFtZSkge1xuICAgICAgY3VzdG9tU3R5bGVbbmV3TmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tU3R5bGVbb2xkTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgaWQsXG4gICAgICByZW5kZXJlcklELFxuICAgICAgcGF0aDogWydzdHlsZSddLFxuICAgICAgdmFsdWU6IGN1c3RvbVN0eWxlLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgIGlkLFxuICAgICAgcmVuZGVyZXJJRCxcbiAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgIHZhbHVlOiBbc3R5bGUsIG5ld1N0eWxlXSxcbiAgICB9KTtcbiAgfVxuXG4gIGFnZW50LmVtaXQoJ2hpZGVOYXRpdmVIaWdobGlnaHQnKTtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoXG4gIGFnZW50OiBBZ2VudCxcbiAgaWQ6IG51bWJlcixcbiAgcmVuZGVyZXJJRDogUmVuZGVyZXJJRCxcbiAgbmFtZTogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nLFxuKSB7XG4gIGNvbnN0IGRhdGEgPSBhZ2VudC5nZXRJbnN0YW5jZUFuZFN0eWxlKHtpZCwgcmVuZGVyZXJJRH0pO1xuICBpZiAoIWRhdGEgfHwgIWRhdGEuc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7aW5zdGFuY2UsIHN0eWxlfSA9IGRhdGE7XG4gIGNvbnN0IG5ld1N0eWxlID0ge1tuYW1lXTogdmFsdWV9O1xuXG4gIC8vIFRPRE8gSXQgd291bGQgYmUgbmljZSBpZiB0aGUgcmVuZGVyZXIgaW50ZXJmYWNlIGFic3RyYWN0ZWQgdGhpcyBhd2F5IHNvbWVob3cuXG4gIGlmIChpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2V0TmF0aXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIGhvc3QgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHVzZSBzZXROYXRpdmVQcm9wcygpLlxuICAgIC8vIFJlbWVtYmVyIHRvIFwiY29ycmVjdFwiIHJlc29sdmVkIHN0eWxlcyB3aGVuIHdlIHJlYWQgdGhlbSBuZXh0IHRpbWUuXG4gICAgY29uc3Qgc3R5bGVPdmVycmlkZXMgPSBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMuZ2V0KGlkKTtcbiAgICBpZiAoIXN0eWxlT3ZlcnJpZGVzKSB7XG4gICAgICBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMuc2V0KGlkLCBuZXdTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGVPdmVycmlkZXMsIG5ld1N0eWxlKTtcbiAgICB9XG4gICAgLy8gVE9ETyBGYWJyaWMgZG9lcyBub3Qgc3VwcG9ydCBzZXROYXRpdmVQcm9wczsgY2hhdCB3aXRoIFNlYmFzdGlhbiBvciBFbGlcbiAgICBpbnN0YW5jZS5zZXROYXRpdmVQcm9wcyh7c3R5bGU6IG5ld1N0eWxlfSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShzdHlsZSkpIHtcbiAgICBjb25zdCBsYXN0TGVuZ3RoID0gc3R5bGUubGVuZ3RoIC0gMTtcbiAgICBpZiAodHlwZW9mIHN0eWxlW2xhc3RMZW5ndGhdID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShzdHlsZVtsYXN0TGVuZ3RoXSkpIHtcbiAgICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgICBpZCxcbiAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgcGF0aDogWydzdHlsZScsIGxhc3RMZW5ndGgsIG5hbWVdLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgICAgaWQsXG4gICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgICAgdmFsdWU6IHN0eWxlLmNvbmNhdChbbmV3U3R5bGVdKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICBpZCxcbiAgICAgIHJlbmRlcmVySUQsXG4gICAgICBwYXRoOiBbJ3N0eWxlJ10sXG4gICAgICB2YWx1ZTogW3N0eWxlLCBuZXdTdHlsZV0sXG4gICAgfSk7XG4gIH1cblxuICBhZ2VudC5lbWl0KCdoaWRlTmF0aXZlSGlnaGxpZ2h0Jyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/StyleX/utils.js":
/*!************************************************************!*\
  !*** ../react-devtools-shared/src/backend/StyleX/utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"crawlData\": () => (/* binding */ crawlData),\n/* harmony export */   \"getStyleXData\": () => (/* binding */ getStyleXData)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/isArray */ \"../react-devtools-shared/src/isArray.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar cachedStyleNameToValueMap = new Map();\nfunction getStyleXData(data) {\n  var sources = new Set();\n  var resolvedStyles = {};\n  crawlData(data, sources, resolvedStyles);\n  return {\n    sources: Array.from(sources).sort(),\n    resolvedStyles: resolvedStyles\n  };\n}\nfunction crawlData(data, sources, resolvedStyles) {\n  if (data == null) {\n    return;\n  }\n\n  if ((0,react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(data)) {\n    data.forEach(function (entry) {\n      if (entry == null) {\n        return;\n      }\n\n      if ((0,react_devtools_shared_src_isArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(entry)) {\n        crawlData(entry, sources, resolvedStyles);\n      } else {\n        crawlObjectProperties(entry, sources, resolvedStyles);\n      }\n    });\n  } else {\n    crawlObjectProperties(data, sources, resolvedStyles);\n  }\n\n  resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());\n}\n\nfunction crawlObjectProperties(entry, sources, resolvedStyles) {\n  var keys = Object.keys(entry);\n  keys.forEach(function (key) {\n    var value = entry[key];\n\n    if (typeof value === 'string') {\n      if (key === value) {\n        // Special case; this key is the name of the style's source/file/module.\n        sources.add(key);\n      } else {\n        var propertyValue = getPropertyValueForStyleName(value);\n\n        if (propertyValue != null) {\n          resolvedStyles[key] = propertyValue;\n        }\n      }\n    } else {\n      var nestedStyle = {};\n      resolvedStyles[key] = nestedStyle;\n      crawlData([value], sources, nestedStyle);\n    }\n  });\n}\n\nfunction getPropertyValueForStyleName(styleName) {\n  if (cachedStyleNameToValueMap.has(styleName)) {\n    return cachedStyleNameToValueMap.get(styleName);\n  }\n\n  for (var styleSheetIndex = 0; styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {\n    var styleSheet = document.styleSheets[styleSheetIndex];\n    var rules = null; // this might throw if CORS rules are enforced https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n\n    try {\n      rules = styleSheet.cssRules;\n    } catch (_e) {\n      continue;\n    }\n\n    for (var ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n      if (!(rules[ruleIndex] instanceof CSSStyleRule)) {\n        continue;\n      }\n\n      var rule = rules[ruleIndex];\n      var cssText = rule.cssText,\n          selectorText = rule.selectorText,\n          style = rule.style;\n\n      if (selectorText != null) {\n        if (selectorText.startsWith(\".\".concat(styleName))) {\n          var match = cssText.match(/{ *([a-z\\-]+):/);\n\n          if (match !== null) {\n            var property = match[1];\n            var value = style.getPropertyValue(property);\n            cachedStyleNameToValueMap.set(styleName, value);\n            return value;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n\n  return null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1N0eWxlWC91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7QUFVQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTs7QUFFQTtBQUtBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUpBO0FBQUE7QUFBQTs7QUFPQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvU3R5bGVYL3V0aWxzLmpzPzQ4NjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1N0eWxlWFBsdWdpbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2lzQXJyYXknO1xuXG5jb25zdCBjYWNoZWRTdHlsZU5hbWVUb1ZhbHVlTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGVYRGF0YShkYXRhOiBhbnkpOiBTdHlsZVhQbHVnaW4ge1xuICBjb25zdCBzb3VyY2VzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHJlc29sdmVkU3R5bGVzID0ge307XG5cbiAgY3Jhd2xEYXRhKGRhdGEsIHNvdXJjZXMsIHJlc29sdmVkU3R5bGVzKTtcblxuICByZXR1cm4ge1xuICAgIHNvdXJjZXM6IEFycmF5LmZyb20oc291cmNlcykuc29ydCgpLFxuICAgIHJlc29sdmVkU3R5bGVzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3Jhd2xEYXRhKFxuICBkYXRhOiBhbnksXG4gIHNvdXJjZXM6IFNldDxzdHJpbmc+LFxuICByZXNvbHZlZFN0eWxlczogT2JqZWN0LFxuKTogdm9pZCB7XG4gIGlmIChkYXRhID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIGRhdGEuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICBpZiAoZW50cnkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgICAgICBjcmF3bERhdGEoZW50cnksIHNvdXJjZXMsIHJlc29sdmVkU3R5bGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyYXdsT2JqZWN0UHJvcGVydGllcyhlbnRyeSwgc291cmNlcywgcmVzb2x2ZWRTdHlsZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNyYXdsT2JqZWN0UHJvcGVydGllcyhkYXRhLCBzb3VyY2VzLCByZXNvbHZlZFN0eWxlcyk7XG4gIH1cblxuICByZXNvbHZlZFN0eWxlcyA9IE9iamVjdC5mcm9tRW50cmllczxzdHJpbmcsIGFueT4oXG4gICAgT2JqZWN0LmVudHJpZXMocmVzb2x2ZWRTdHlsZXMpLnNvcnQoKSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gY3Jhd2xPYmplY3RQcm9wZXJ0aWVzKFxuICBlbnRyeTogT2JqZWN0LFxuICBzb3VyY2VzOiBTZXQ8c3RyaW5nPixcbiAgcmVzb2x2ZWRTdHlsZXM6IE9iamVjdCxcbik6IHZvaWQge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZW50cnkpO1xuICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGVudHJ5W2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChrZXkgPT09IHZhbHVlKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTsgdGhpcyBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIHN0eWxlJ3Mgc291cmNlL2ZpbGUvbW9kdWxlLlxuICAgICAgICBzb3VyY2VzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IGdldFByb3BlcnR5VmFsdWVGb3JTdHlsZU5hbWUodmFsdWUpO1xuICAgICAgICBpZiAocHJvcGVydHlWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZWRTdHlsZXNba2V5XSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmVzdGVkU3R5bGUgPSB7fTtcbiAgICAgIHJlc29sdmVkU3R5bGVzW2tleV0gPSBuZXN0ZWRTdHlsZTtcbiAgICAgIGNyYXdsRGF0YShbdmFsdWVdLCBzb3VyY2VzLCBuZXN0ZWRTdHlsZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZUZvclN0eWxlTmFtZShzdHlsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBpZiAoY2FjaGVkU3R5bGVOYW1lVG9WYWx1ZU1hcC5oYXMoc3R5bGVOYW1lKSkge1xuICAgIHJldHVybiAoKGNhY2hlZFN0eWxlTmFtZVRvVmFsdWVNYXAuZ2V0KHN0eWxlTmFtZSk6IGFueSk6IHN0cmluZyk7XG4gIH1cblxuICBmb3IgKFxuICAgIGxldCBzdHlsZVNoZWV0SW5kZXggPSAwO1xuICAgIHN0eWxlU2hlZXRJbmRleCA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDtcbiAgICBzdHlsZVNoZWV0SW5kZXgrK1xuICApIHtcbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gKChkb2N1bWVudC5zdHlsZVNoZWV0c1tcbiAgICAgIHN0eWxlU2hlZXRJbmRleFxuICAgIF06IGFueSk6IENTU1N0eWxlU2hlZXQpO1xuICAgIGxldCBydWxlczogQ1NTUnVsZUxpc3QgfCBudWxsID0gbnVsbDtcbiAgICAvLyB0aGlzIG1pZ2h0IHRocm93IGlmIENPUlMgcnVsZXMgYXJlIGVuZm9yY2VkIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3NvbS0xLyN0aGUtY3Nzc3R5bGVzaGVldC1pbnRlcmZhY2VcbiAgICB0cnkge1xuICAgICAgcnVsZXMgPSBzdHlsZVNoZWV0LmNzc1J1bGVzO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBydWxlSW5kZXggPSAwOyBydWxlSW5kZXggPCBydWxlcy5sZW5ndGg7IHJ1bGVJbmRleCsrKSB7XG4gICAgICBpZiAoIShydWxlc1tydWxlSW5kZXhdIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ1bGUgPSAoKHJ1bGVzW3J1bGVJbmRleF06IGFueSk6IENTU1N0eWxlUnVsZSk7XG4gICAgICBjb25zdCB7Y3NzVGV4dCwgc2VsZWN0b3JUZXh0LCBzdHlsZX0gPSBydWxlO1xuXG4gICAgICBpZiAoc2VsZWN0b3JUZXh0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yVGV4dC5zdGFydHNXaXRoKGAuJHtzdHlsZU5hbWV9YCkpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IGNzc1RleHQubWF0Y2goL3sgKihbYS16XFwtXSspOi8pO1xuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgIGNhY2hlZFN0eWxlTmFtZVRvVmFsdWVNYXAuc2V0KHN0eWxlTmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/StyleX/utils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/agent.js":
/*!*****************************************************!*\
  !*** ../react-devtools-shared/src/backend/agent.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Agent)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ \"../react-devtools-shared/src/events.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var _views_Highlighter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./views/Highlighter */ \"../react-devtools-shared/src/backend/views/Highlighter/index.js\");\n/* harmony import */ var _views_TraceUpdates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./views/TraceUpdates */ \"../react-devtools-shared/src/backend/views/TraceUpdates/index.js\");\n/* harmony import */ var react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-devtools-shared/src/bridge */ \"../react-devtools-shared/src/bridge.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../storage */ \"../react-devtools-shared/src/storage.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\nvar debug = function debug(methodName) {\n  if (_constants__WEBPACK_IMPORTED_MODULE_1__.__DEBUG__) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, [\"%cAgent %c\".concat(methodName), 'color: purple; font-weight: bold;', 'font-weight: bold;'].concat(args));\n  }\n};\n\nvar Agent = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Agent, _EventEmitter);\n\n  var _super = _createSuper(Agent);\n\n  function Agent(bridge) {\n    var _this;\n\n    var isProfiling = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var onReloadAndProfile = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, Agent);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isProfiling\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_rendererInterfaces\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"_persistedSelection\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_persistedSelectionMatch\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_traceUpdatesEnabled\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"clearErrorsAndWarnings\", function (_ref) {\n      var rendererID = _ref.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      } else {\n        renderer.clearErrorsAndWarnings();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clearErrorsForElementID\", function (_ref2) {\n      var id = _ref2.id,\n          rendererID = _ref2.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      } else {\n        renderer.clearErrorsForElementID(id);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clearWarningsForElementID\", function (_ref3) {\n      var id = _ref3.id,\n          rendererID = _ref3.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      } else {\n        renderer.clearWarningsForElementID(id);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"copyElementPath\", function (_ref4) {\n      var id = _ref4.id,\n          path = _ref4.path,\n          rendererID = _ref4.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        var value = renderer.getSerializedElementValueByPath(id, path);\n\n        if (value != null) {\n          _this._bridge.send('saveToClipboard', value);\n        } else {\n          console.warn(\"Unable to obtain serialized value for element \\\"\".concat(id, \"\\\"\"));\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"deletePath\", function (_ref5) {\n      var hookID = _ref5.hookID,\n          id = _ref5.id,\n          path = _ref5.path,\n          rendererID = _ref5.rendererID,\n          type = _ref5.type;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.deletePath(type, id, hookID, path);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getBackendVersion\", function () {\n      var version = \"6.0.1-bcee8aaec5\";\n\n      if (version) {\n        _this._bridge.send('backendVersion', version);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getBridgeProtocol\", function () {\n      _this._bridge.send('bridgeProtocol', react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_4__.currentBridgeProtocol);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getProfilingData\", function (_ref6) {\n      var rendererID = _ref6.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n      }\n\n      _this._bridge.send('profilingData', renderer.getProfilingData());\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getProfilingStatus\", function () {\n      _this._bridge.send('profilingStatus', _this._isProfiling);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getOwnersList\", function (_ref7) {\n      var id = _ref7.id,\n          rendererID = _ref7.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        var owners = renderer.getOwnersList(id);\n\n        _this._bridge.send('ownersList', {\n          id: id,\n          owners: owners\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"inspectElement\", function (_ref8) {\n      var forceFullData = _ref8.forceFullData,\n          id = _ref8.id,\n          path = _ref8.path,\n          rendererID = _ref8.rendererID,\n          requestID = _ref8.requestID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        _this._bridge.send('inspectedElement', renderer.inspectElement(requestID, id, path, forceFullData)); // When user selects an element, stop trying to restore the selection,\n        // and instead remember the current selection for the next reload.\n\n\n        if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {\n          _this._persistedSelection = null;\n          _this._persistedSelectionMatch = null;\n          renderer.setTrackedPath(null); // Throttle persisting the selection.\n\n          _this._lastSelectedElementID = id;\n          _this._lastSelectedRendererID = rendererID;\n\n          if (!_this._persistSelectionTimerScheduled) {\n            _this._persistSelectionTimerScheduled = true;\n            setTimeout(_this._persistSelection, 1000);\n          }\n        } // TODO: If there was a way to change the selected DOM element\n        // in built-in Elements tab without forcing a switch to it, we'd do it here.\n        // For now, it doesn't seem like there is a way to do that:\n        // https://github.com/bvaughn/react-devtools-experimental/issues/102\n        // (Setting $0 doesn't work, and calling inspect() switches the tab.)\n\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"logElementToConsole\", function (_ref9) {\n      var id = _ref9.id,\n          rendererID = _ref9.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.logElementToConsole(id);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideError\", function (_ref10) {\n      var id = _ref10.id,\n          rendererID = _ref10.rendererID,\n          forceError = _ref10.forceError;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.overrideError(id, forceError);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideSuspense\", function (_ref11) {\n      var id = _ref11.id,\n          rendererID = _ref11.rendererID,\n          forceFallback = _ref11.forceFallback;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.overrideSuspense(id, forceFallback);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideValueAtPath\", function (_ref12) {\n      var hookID = _ref12.hookID,\n          id = _ref12.id,\n          path = _ref12.path,\n          rendererID = _ref12.rendererID,\n          type = _ref12.type,\n          value = _ref12.value;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.overrideValueAtPath(type, id, hookID, path, value);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideContext\", function (_ref13) {\n      var id = _ref13.id,\n          path = _ref13.path,\n          rendererID = _ref13.rendererID,\n          wasForwarded = _ref13.wasForwarded,\n          value = _ref13.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'context',\n          value: value\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideHookState\", function (_ref14) {\n      var id = _ref14.id,\n          hookID = _ref14.hookID,\n          path = _ref14.path,\n          rendererID = _ref14.rendererID,\n          wasForwarded = _ref14.wasForwarded,\n          value = _ref14.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'hooks',\n          value: value\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideProps\", function (_ref15) {\n      var id = _ref15.id,\n          path = _ref15.path,\n          rendererID = _ref15.rendererID,\n          wasForwarded = _ref15.wasForwarded,\n          value = _ref15.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'props',\n          value: value\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideState\", function (_ref16) {\n      var id = _ref16.id,\n          path = _ref16.path,\n          rendererID = _ref16.rendererID,\n          wasForwarded = _ref16.wasForwarded,\n          value = _ref16.value;\n\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        _this.overrideValueAtPath({\n          id: id,\n          path: path,\n          rendererID: rendererID,\n          type: 'state',\n          value: value\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onReloadAndProfileSupportedByHost\", function () {\n      _this._bridge.send('isReloadAndProfileSupportedByBackend', true);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"reloadAndProfile\", function (_ref17) {\n      var recordChangeDescriptions = _ref17.recordChangeDescriptions,\n          recordTimeline = _ref17.recordTimeline;\n\n      if (typeof _this._onReloadAndProfile === 'function') {\n        _this._onReloadAndProfile(recordChangeDescriptions, recordTimeline);\n      } // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.\n      // In that case, the shell must also listen for this specific message to know when it needs to reload the app.\n      // The agent can't do this in a way that is renderer agnostic.\n\n\n      _this._bridge.send('reloadAppForProfiling');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"renamePath\", function (_ref18) {\n      var hookID = _ref18.hookID,\n          id = _ref18.id,\n          newPath = _ref18.newPath,\n          oldPath = _ref18.oldPath,\n          rendererID = _ref18.rendererID,\n          type = _ref18.type;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.renamePath(type, id, hookID, oldPath, newPath);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setTraceUpdatesEnabled\", function (traceUpdatesEnabled) {\n      _this._traceUpdatesEnabled = traceUpdatesEnabled;\n      (0,_views_TraceUpdates__WEBPACK_IMPORTED_MODULE_3__.toggleEnabled)(traceUpdatesEnabled);\n\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[rendererID];\n        renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"syncSelectionFromBuiltinElementsPanel\", function () {\n      var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;\n\n      if (target == null) {\n        return;\n      }\n\n      _this.selectNode(target);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"shutdown\", function () {\n      // Clean up the overlay if visible, and associated events.\n      _this.emit('shutdown');\n\n      _this._bridge.removeAllListeners();\n\n      _this.removeAllListeners();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"startProfiling\", function (_ref19) {\n      var recordChangeDescriptions = _ref19.recordChangeDescriptions,\n          recordTimeline = _ref19.recordTimeline;\n      _this._isProfiling = true;\n\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[rendererID];\n        renderer.startProfiling(recordChangeDescriptions, recordTimeline);\n      }\n\n      _this._bridge.send('profilingStatus', _this._isProfiling);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"stopProfiling\", function () {\n      _this._isProfiling = false;\n\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[rendererID];\n        renderer.stopProfiling();\n      }\n\n      _this._bridge.send('profilingStatus', _this._isProfiling);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"stopInspectingNative\", function (selected) {\n      _this._bridge.send('stopInspectingHost', selected);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"storeAsGlobal\", function (_ref20) {\n      var count = _ref20.count,\n          id = _ref20.id,\n          path = _ref20.path,\n          rendererID = _ref20.rendererID;\n      var renderer = _this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      } else {\n        renderer.storeAsGlobal(id, path, count);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateHookSettings\", function (settings) {\n      // Propagate the settings, so Backend can subscribe to it and modify hook\n      _this.emit('updateHookSettings', settings);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getHookSettings\", function () {\n      _this.emit('getHookSettings');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onHookSettings\", function (settings) {\n      _this._bridge.send('hookSettings', settings);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateComponentFilters\", function (componentFilters) {\n      for (var rendererIDString in _this._rendererInterfaces) {\n        var rendererID = +rendererIDString;\n        var renderer = _this._rendererInterfaces[rendererID];\n\n        if (_this._lastSelectedRendererID === rendererID) {\n          // Changing component filters will unmount and remount the DevTools tree.\n          // Track the last selection's path so we can restore the selection.\n          var path = renderer.getPathForElement(_this._lastSelectedElementID);\n\n          if (path !== null) {\n            renderer.setTrackedPath(path);\n            _this._persistedSelection = {\n              rendererID: rendererID,\n              path: path\n            };\n          }\n        }\n\n        renderer.updateComponentFilters(componentFilters);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getEnvironmentNames\", function () {\n      var accumulatedNames = null;\n\n      for (var rendererID in _this._rendererInterfaces) {\n        var renderer = _this._rendererInterfaces[+rendererID];\n        var names = renderer.getEnvironmentNames();\n\n        if (accumulatedNames === null) {\n          accumulatedNames = names;\n        } else {\n          for (var i = 0; i < names.length; i++) {\n            if (accumulatedNames.indexOf(names[i]) === -1) {\n              accumulatedNames.push(names[i]);\n            }\n          }\n        }\n      }\n\n      _this._bridge.send('environmentNames', accumulatedNames || []);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onTraceUpdates\", function (nodes) {\n      _this.emit('traceUpdates', nodes);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onFastRefreshScheduled\", function () {\n      if (_constants__WEBPACK_IMPORTED_MODULE_1__.__DEBUG__) {\n        debug('onFastRefreshScheduled');\n      }\n\n      _this._bridge.send('fastRefreshScheduled');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onHookOperations\", function (operations) {\n      if (_constants__WEBPACK_IMPORTED_MODULE_1__.__DEBUG__) {\n        debug('onHookOperations', \"(\".concat(operations.length, \") [\").concat(operations.join(', '), \"]\"));\n      } // TODO:\n      // The chrome.runtime does not currently support transferables; it forces JSON serialization.\n      // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134\n      //\n      // Regarding transferables, the postMessage doc states:\n      // If the ownership of an object is transferred, it becomes unusable (neutered)\n      // in the context it was sent from and becomes available only to the worker it was sent to.\n      //\n      // Even though Chrome is eventually JSON serializing the array buffer,\n      // using the transferable approach also sometimes causes it to throw:\n      //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.\n      //\n      // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25\n      //\n      // The Store has a fallback in place that parses the message as JSON if the type isn't an array.\n      // For now the simplest fix seems to be to not transfer the array.\n      // This will negatively impact performance on Firefox so it's unfortunate,\n      // but until we're able to fix the Chrome error mentioned above, it seems necessary.\n      //\n      // this._bridge.send('operations', operations, [operations.buffer]);\n\n\n      _this._bridge.send('operations', operations);\n\n      if (_this._persistedSelection !== null) {\n        var rendererID = operations[0];\n\n        if (_this._persistedSelection.rendererID === rendererID) {\n          // Check if we can select a deeper match for the persisted selection.\n          var renderer = _this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n          } else {\n            var prevMatch = _this._persistedSelectionMatch;\n            var nextMatch = renderer.getBestMatchForTrackedPath();\n            _this._persistedSelectionMatch = nextMatch;\n            var prevMatchID = prevMatch !== null ? prevMatch.id : null;\n            var nextMatchID = nextMatch !== null ? nextMatch.id : null;\n\n            if (prevMatchID !== nextMatchID) {\n              if (nextMatchID !== null) {\n                // We moved forward, unlocking a deeper node.\n                _this._bridge.send('selectElement', nextMatchID);\n              }\n            }\n\n            if (nextMatch !== null && nextMatch.isFullMatch) {\n              // We've just unlocked the innermost selected node.\n              // There's no point tracking it further.\n              _this._persistedSelection = null;\n              _this._persistedSelectionMatch = null;\n              renderer.setTrackedPath(null);\n            }\n          }\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getIfHasUnsupportedRendererVersion\", function () {\n      _this.emit('getIfHasUnsupportedRendererVersion');\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_persistSelectionTimerScheduled\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_lastSelectedRendererID\", -1);\n\n    _defineProperty(_assertThisInitialized(_this), \"_lastSelectedElementID\", -1);\n\n    _defineProperty(_assertThisInitialized(_this), \"_persistSelection\", function () {\n      _this._persistSelectionTimerScheduled = false;\n      var rendererID = _this._lastSelectedRendererID;\n      var id = _this._lastSelectedElementID; // This is throttled, so both renderer and selected ID\n      // might not be available by the time we read them.\n      // This is why we need the defensive checks here.\n\n      var renderer = _this._rendererInterfaces[rendererID];\n      var path = renderer != null ? renderer.getPathForElement(id) : null;\n\n      if (path !== null) {\n        (0,_storage__WEBPACK_IMPORTED_MODULE_6__.sessionStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_1__.SESSION_STORAGE_LAST_SELECTION_KEY, JSON.stringify({\n          rendererID: rendererID,\n          path: path\n        }));\n      } else {\n        (0,_storage__WEBPACK_IMPORTED_MODULE_6__.sessionStorageRemoveItem)(_constants__WEBPACK_IMPORTED_MODULE_1__.SESSION_STORAGE_LAST_SELECTION_KEY);\n      }\n    });\n\n    _this._isProfiling = isProfiling;\n    _this._onReloadAndProfile = onReloadAndProfile;\n    var persistedSelectionString = (0,_storage__WEBPACK_IMPORTED_MODULE_6__.sessionStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_1__.SESSION_STORAGE_LAST_SELECTION_KEY);\n\n    if (persistedSelectionString != null) {\n      _this._persistedSelection = JSON.parse(persistedSelectionString);\n    }\n\n    _this._bridge = bridge;\n    bridge.addListener('clearErrorsAndWarnings', _this.clearErrorsAndWarnings);\n    bridge.addListener('clearErrorsForElementID', _this.clearErrorsForElementID);\n    bridge.addListener('clearWarningsForElementID', _this.clearWarningsForElementID);\n    bridge.addListener('copyElementPath', _this.copyElementPath);\n    bridge.addListener('deletePath', _this.deletePath);\n    bridge.addListener('getBackendVersion', _this.getBackendVersion);\n    bridge.addListener('getBridgeProtocol', _this.getBridgeProtocol);\n    bridge.addListener('getProfilingData', _this.getProfilingData);\n    bridge.addListener('getProfilingStatus', _this.getProfilingStatus);\n    bridge.addListener('getOwnersList', _this.getOwnersList);\n    bridge.addListener('inspectElement', _this.inspectElement);\n    bridge.addListener('logElementToConsole', _this.logElementToConsole);\n    bridge.addListener('overrideError', _this.overrideError);\n    bridge.addListener('overrideSuspense', _this.overrideSuspense);\n    bridge.addListener('overrideValueAtPath', _this.overrideValueAtPath);\n    bridge.addListener('reloadAndProfile', _this.reloadAndProfile);\n    bridge.addListener('renamePath', _this.renamePath);\n    bridge.addListener('setTraceUpdatesEnabled', _this.setTraceUpdatesEnabled);\n    bridge.addListener('startProfiling', _this.startProfiling);\n    bridge.addListener('stopProfiling', _this.stopProfiling);\n    bridge.addListener('storeAsGlobal', _this.storeAsGlobal);\n    bridge.addListener('syncSelectionFromBuiltinElementsPanel', _this.syncSelectionFromBuiltinElementsPanel);\n    bridge.addListener('shutdown', _this.shutdown);\n    bridge.addListener('updateHookSettings', _this.updateHookSettings);\n    bridge.addListener('getHookSettings', _this.getHookSettings);\n    bridge.addListener('updateComponentFilters', _this.updateComponentFilters);\n    bridge.addListener('getEnvironmentNames', _this.getEnvironmentNames);\n    bridge.addListener('getIfHasUnsupportedRendererVersion', _this.getIfHasUnsupportedRendererVersion); // Temporarily support older standalone front-ends sending commands to newer embedded backends.\n    // We do this because React Native embeds the React DevTools backend,\n    // but cannot control which version of the frontend users use.\n\n    bridge.addListener('overrideContext', _this.overrideContext);\n    bridge.addListener('overrideHookState', _this.overrideHookState);\n    bridge.addListener('overrideProps', _this.overrideProps);\n    bridge.addListener('overrideState', _this.overrideState);\n    (0,_views_Highlighter__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(bridge, _assertThisInitialized(_this));\n    (0,_views_TraceUpdates__WEBPACK_IMPORTED_MODULE_3__.initialize)(_assertThisInitialized(_this)); // By this time, Store should already be initialized and intercept events\n\n    bridge.send('backendInitialized');\n\n    if (_this._isProfiling) {\n      bridge.send('profilingStatus', true);\n    }\n\n    return _this;\n  }\n\n  _createClass(Agent, [{\n    key: \"getInstanceAndStyle\",\n    value: function getInstanceAndStyle(_ref21) {\n      var id = _ref21.id,\n          rendererID = _ref21.rendererID;\n      var renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\"\"));\n        return null;\n      }\n\n      return renderer.getInstanceAndStyle(id);\n    }\n  }, {\n    key: \"getIDForHostInstance\",\n    value: function getIDForHostInstance(target) {\n      if ((0,_utils__WEBPACK_IMPORTED_MODULE_5__.isReactNativeEnvironment)() || typeof target.nodeType !== 'number') {\n        // In React Native or non-DOM we simply pick any renderer that has a match.\n        for (var rendererID in this._rendererInterfaces) {\n          var renderer = this._rendererInterfaces[rendererID];\n\n          try {\n            var match = renderer.getElementIDForHostInstance(target);\n\n            if (match != null) {\n              return match;\n            }\n          } catch (error) {// Some old React versions might throw if they can't find a match.\n            // If so we should ignore it...\n          }\n        }\n\n        return null;\n      } else {\n        // In the DOM we use a smarter mechanism to find the deepest a DOM node\n        // that is registered if there isn't an exact match.\n        var bestMatch = null;\n        var bestRenderer = null; // Find the nearest ancestor which is mounted by a React.\n\n        for (var _rendererID in this._rendererInterfaces) {\n          var _renderer = this._rendererInterfaces[_rendererID];\n\n          var nearestNode = _renderer.getNearestMountedDOMNode(target);\n\n          if (nearestNode !== null) {\n            if (nearestNode === target) {\n              // Exact match we can exit early.\n              bestMatch = nearestNode;\n              bestRenderer = _renderer;\n              break;\n            }\n\n            if (bestMatch === null || bestMatch.contains(nearestNode)) {\n              // If this is the first match or the previous match contains the new match,\n              // so the new match is a deeper and therefore better match.\n              bestMatch = nearestNode;\n              bestRenderer = _renderer;\n            }\n          }\n        }\n\n        if (bestRenderer != null && bestMatch != null) {\n          try {\n            return bestRenderer.getElementIDForHostInstance(bestMatch);\n          } catch (error) {// Some old React versions might throw if they can't find a match.\n            // If so we should ignore it...\n          }\n        }\n\n        return null;\n      }\n    }\n  }, {\n    key: \"getComponentNameForHostInstance\",\n    value: function getComponentNameForHostInstance(target) {\n      // We duplicate this code from getIDForHostInstance to avoid an object allocation.\n      if ((0,_utils__WEBPACK_IMPORTED_MODULE_5__.isReactNativeEnvironment)() || typeof target.nodeType !== 'number') {\n        // In React Native or non-DOM we simply pick any renderer that has a match.\n        for (var rendererID in this._rendererInterfaces) {\n          var renderer = this._rendererInterfaces[rendererID];\n\n          try {\n            var id = renderer.getElementIDForHostInstance(target);\n\n            if (id) {\n              return renderer.getDisplayNameForElementID(id);\n            }\n          } catch (error) {// Some old React versions might throw if they can't find a match.\n            // If so we should ignore it...\n          }\n        }\n\n        return null;\n      } else {\n        // In the DOM we use a smarter mechanism to find the deepest a DOM node\n        // that is registered if there isn't an exact match.\n        var bestMatch = null;\n        var bestRenderer = null; // Find the nearest ancestor which is mounted by a React.\n\n        for (var _rendererID2 in this._rendererInterfaces) {\n          var _renderer2 = this._rendererInterfaces[_rendererID2];\n\n          var nearestNode = _renderer2.getNearestMountedDOMNode(target);\n\n          if (nearestNode !== null) {\n            if (nearestNode === target) {\n              // Exact match we can exit early.\n              bestMatch = nearestNode;\n              bestRenderer = _renderer2;\n              break;\n            }\n\n            if (bestMatch === null || bestMatch.contains(nearestNode)) {\n              // If this is the first match or the previous match contains the new match,\n              // so the new match is a deeper and therefore better match.\n              bestMatch = nearestNode;\n              bestRenderer = _renderer2;\n            }\n          }\n        }\n\n        if (bestRenderer != null && bestMatch != null) {\n          try {\n            var _id = bestRenderer.getElementIDForHostInstance(bestMatch);\n\n            if (_id) {\n              return bestRenderer.getDisplayNameForElementID(_id);\n            }\n          } catch (error) {// Some old React versions might throw if they can't find a match.\n            // If so we should ignore it...\n          }\n        }\n\n        return null;\n      }\n    }\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(target) {\n      var id = this.getIDForHostInstance(target);\n\n      if (id !== null) {\n        this._bridge.send('selectElement', id);\n      }\n    }\n  }, {\n    key: \"registerRendererInterface\",\n    value: function registerRendererInterface(rendererID, rendererInterface) {\n      this._rendererInterfaces[rendererID] = rendererInterface;\n      rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether\n      // we remember the previous selection that we'd like to restore.\n      // It'll start tracking mounts for matches to the last selection path.\n\n      var selection = this._persistedSelection;\n\n      if (selection !== null && selection.rendererID === rendererID) {\n        rendererInterface.setTrackedPath(selection.path);\n      }\n    }\n  }, {\n    key: \"onUnsupportedRenderer\",\n    value: function onUnsupportedRenderer() {\n      this._bridge.send('unsupportedRendererVersion');\n    }\n  }, {\n    key: \"rendererInterfaces\",\n    get: function get() {\n      return this._rendererInterfaces;\n    }\n  }]);\n\n  return Agent;\n}(_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2FnZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQWVBO0FBQ0E7O0FBTUE7QUFDQTtBQUFBOztBQUFBO0FBREE7QUFDQTs7QUFDQTtBQU1BO0FBQ0E7O0FBMEZBOzs7OztBQXdCQTtBQU9BOztBQUFBO0FBQUE7O0FBQUE7O0FBQ0E7O0FBREE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFnRkE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkZBO0FBNEZBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkdBO0FBd0dBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBL0dBO0FBcUhBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxJQTtBQTBJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpKQTtBQXdSQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1UkE7QUErUkE7QUFDQTs7QUFoU0E7QUFrU0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUF6U0E7QUE0U0E7QUFDQTs7QUE3U0E7QUErU0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUF2VEE7QUErVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7OztBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBaldBO0FBbVdBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMVdBO0FBZ1hBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2WEE7QUE2WEE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBZQTtBQTZZQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcFpBO0FBOFpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQTFhQTtBQXFiQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQWpjQTtBQTJjQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7QUF2ZEE7QUFpZUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7O0FBN2VBO0FBZ2ZBO0FBQ0E7O0FBamZBO0FBc2ZBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUEvZkE7QUF3Z0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvZ0JBO0FBMmlCQTtBQUVBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBcmpCQTtBQXdqQkE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBN2pCQTtBQWdrQkE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQXJrQkE7QUEwa0JBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBOztBQW5sQkE7QUFzbEJBOztBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBOWxCQTtBQWltQkE7QUFDQTs7QUFsbUJBO0FBeW1CQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFobkJBO0FBb25CQTtBQUNBO0FBQ0E7O0FBdG5CQTtBQXluQkE7QUFDQTs7QUExbkJBO0FBOG5CQTtBQUNBOztBQS9uQkE7QUFtb0JBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUF0cEJBO0FBeXBCQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUF4cUJBO0FBMnFCQTtBQUNBOztBQTVxQkE7QUErcUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQXByQkE7QUF1ckJBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWp2QkE7QUFvdkJBO0FBQ0E7O0FBcnZCQTs7QUFBQTs7QUFBQTs7QUFBQTtBQSt2QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUE1d0JBO0FBQ0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUF2RUE7QUF3RUE7Ozs7QUE4RUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQTRQQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUdBO0FBRUE7QUFHQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFnTkE7QUFDQTtBQUNBOzs7QUEvcUJBO0FBQ0E7QUFDQTs7OztBQTNHQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9hZ2VudC5qcz8zY2IxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7U0VTU0lPTl9TVE9SQUdFX0xBU1RfU0VMRUNUSU9OX0tFWSwgX19ERUJVR19ffSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHNldHVwSGlnaGxpZ2h0ZXIgZnJvbSAnLi92aWV3cy9IaWdobGlnaHRlcic7XG5pbXBvcnQge1xuICBpbml0aWFsaXplIGFzIHNldHVwVHJhY2VVcGRhdGVzLFxuICB0b2dnbGVFbmFibGVkIGFzIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQsXG59IGZyb20gJy4vdmlld3MvVHJhY2VVcGRhdGVzJztcbmltcG9ydCB7Y3VycmVudEJyaWRnZVByb3RvY29sfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JyaWRnZSc7XG5cbmltcG9ydCB0eXBlIHtCYWNrZW5kQnJpZGdlfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JyaWRnZSc7XG5pbXBvcnQgdHlwZSB7XG4gIEluc3RhbmNlQW5kU3R5bGUsXG4gIEhvc3RJbnN0YW5jZSxcbiAgT3duZXJzTGlzdCxcbiAgUGF0aEZyYW1lLFxuICBQYXRoTWF0Y2gsXG4gIFJlbmRlcmVySUQsXG4gIFJlbmRlcmVySW50ZXJmYWNlLFxuICBEZXZUb29sc0hvb2tTZXR0aW5ncyxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7Q29tcG9uZW50RmlsdGVyfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2Zyb250ZW5kL3R5cGVzJztcbmltcG9ydCB0eXBlIHtHcm91cEl0ZW19IGZyb20gJy4vdmlld3MvVHJhY2VVcGRhdGVzL2NhbnZhcyc7XG5pbXBvcnQge2lzUmVhY3ROYXRpdmVFbnZpcm9ubWVudH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge1xuICBzZXNzaW9uU3RvcmFnZUdldEl0ZW0sXG4gIHNlc3Npb25TdG9yYWdlUmVtb3ZlSXRlbSxcbiAgc2Vzc2lvblN0b3JhZ2VTZXRJdGVtLFxufSBmcm9tICcuLi9zdG9yYWdlJztcblxuY29uc3QgZGVidWcgPSAobWV0aG9kTmFtZTogc3RyaW5nLCAuLi5hcmdzOiBBcnJheTxzdHJpbmc+KSA9PiB7XG4gIGlmIChfX0RFQlVHX18pIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGAlY0FnZW50ICVjJHttZXRob2ROYW1lfWAsXG4gICAgICAnY29sb3I6IHB1cnBsZTsgZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAgICdmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgLi4uYXJncyxcbiAgICApO1xuICB9XG59O1xuXG50eXBlIEVsZW1lbnRBbmRSZW5kZXJlcklEID0ge1xuICBpZDogbnVtYmVyLFxuICByZW5kZXJlcklEOiBudW1iZXIsXG59O1xuXG50eXBlIFN0b3JlQXNHbG9iYWxQYXJhbXMgPSB7XG4gIGNvdW50OiBudW1iZXIsXG4gIGlkOiBudW1iZXIsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIHJlbmRlcmVySUQ6IG51bWJlcixcbn07XG5cbnR5cGUgQ29weUVsZW1lbnRQYXJhbXMgPSB7XG4gIGlkOiBudW1iZXIsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIHJlbmRlcmVySUQ6IG51bWJlcixcbn07XG5cbnR5cGUgSW5zcGVjdEVsZW1lbnRQYXJhbXMgPSB7XG4gIGZvcmNlRnVsbERhdGE6IGJvb2xlYW4sXG4gIGlkOiBudW1iZXIsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gfCBudWxsLFxuICByZW5kZXJlcklEOiBudW1iZXIsXG4gIHJlcXVlc3RJRDogbnVtYmVyLFxufTtcblxudHlwZSBPdmVycmlkZUhvb2tQYXJhbXMgPSB7XG4gIGlkOiBudW1iZXIsXG4gIGhvb2tJRDogbnVtYmVyLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICByZW5kZXJlcklEOiBudW1iZXIsXG4gIHdhc0ZvcndhcmRlZD86IGJvb2xlYW4sXG4gIHZhbHVlOiBhbnksXG59O1xuXG50eXBlIFNldEluUGFyYW1zID0ge1xuICBpZDogbnVtYmVyLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICByZW5kZXJlcklEOiBudW1iZXIsXG4gIHdhc0ZvcndhcmRlZD86IGJvb2xlYW4sXG4gIHZhbHVlOiBhbnksXG59O1xuXG50eXBlIFBhdGhUeXBlID0gJ3Byb3BzJyB8ICdob29rcycgfCAnc3RhdGUnIHwgJ2NvbnRleHQnO1xuXG50eXBlIERlbGV0ZVBhdGhQYXJhbXMgPSB7XG4gIHR5cGU6IFBhdGhUeXBlLFxuICBob29rSUQ/OiA/bnVtYmVyLFxuICBpZDogbnVtYmVyLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICByZW5kZXJlcklEOiBudW1iZXIsXG59O1xuXG50eXBlIFJlbmFtZVBhdGhQYXJhbXMgPSB7XG4gIHR5cGU6IFBhdGhUeXBlLFxuICBob29rSUQ/OiA/bnVtYmVyLFxuICBpZDogbnVtYmVyLFxuICBvbGRQYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBuZXdQYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICByZW5kZXJlcklEOiBudW1iZXIsXG59O1xuXG50eXBlIE92ZXJyaWRlVmFsdWVBdFBhdGhQYXJhbXMgPSB7XG4gIHR5cGU6IFBhdGhUeXBlLFxuICBob29rSUQ/OiA/bnVtYmVyLFxuICBpZDogbnVtYmVyLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICByZW5kZXJlcklEOiBudW1iZXIsXG4gIHZhbHVlOiBhbnksXG59O1xuXG50eXBlIE92ZXJyaWRlRXJyb3JQYXJhbXMgPSB7XG4gIGlkOiBudW1iZXIsXG4gIHJlbmRlcmVySUQ6IG51bWJlcixcbiAgZm9yY2VFcnJvcjogYm9vbGVhbixcbn07XG5cbnR5cGUgT3ZlcnJpZGVTdXNwZW5zZVBhcmFtcyA9IHtcbiAgaWQ6IG51bWJlcixcbiAgcmVuZGVyZXJJRDogbnVtYmVyLFxuICBmb3JjZUZhbGxiYWNrOiBib29sZWFuLFxufTtcblxudHlwZSBQZXJzaXN0ZWRTZWxlY3Rpb24gPSB7XG4gIHJlbmRlcmVySUQ6IG51bWJlcixcbiAgcGF0aDogQXJyYXk8UGF0aEZyYW1lPixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFnZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyPHtcbiAgaGlkZU5hdGl2ZUhpZ2hsaWdodDogW10sXG4gIHNob3dOYXRpdmVIaWdobGlnaHQ6IFtIb3N0SW5zdGFuY2VdLFxuICBzdGFydEluc3BlY3RpbmdOYXRpdmU6IFtdLFxuICBzdG9wSW5zcGVjdGluZ05hdGl2ZTogW10sXG4gIHNodXRkb3duOiBbXSxcbiAgdHJhY2VVcGRhdGVzOiBbU2V0PEhvc3RJbnN0YW5jZT5dLFxuICBkcmF3VHJhY2VVcGRhdGVzOiBbQXJyYXk8SG9zdEluc3RhbmNlPl0sXG4gIGRyYXdHcm91cGVkVHJhY2VVcGRhdGVzV2l0aE5hbWVzOiBbQXJyYXk8QXJyYXk8R3JvdXBJdGVtPj5dLFxuICBkaXNhYmxlVHJhY2VVcGRhdGVzOiBbXSxcbiAgZ2V0SWZIYXNVbnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbjogW10sXG4gIHVwZGF0ZUhvb2tTZXR0aW5nczogWyRSZWFkT25seTxEZXZUb29sc0hvb2tTZXR0aW5ncz5dLFxuICBnZXRIb29rU2V0dGluZ3M6IFtdLFxufT4ge1xuICBfYnJpZGdlOiBCYWNrZW5kQnJpZGdlO1xuICBfaXNQcm9maWxpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgX3JlbmRlcmVySW50ZXJmYWNlczoge1trZXk6IFJlbmRlcmVySURdOiBSZW5kZXJlckludGVyZmFjZSwgLi4ufSA9IHt9O1xuICBfcGVyc2lzdGVkU2VsZWN0aW9uOiBQZXJzaXN0ZWRTZWxlY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoOiBQYXRoTWF0Y2ggfCBudWxsID0gbnVsbDtcbiAgX3RyYWNlVXBkYXRlc0VuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgX29uUmVsb2FkQW5kUHJvZmlsZTpcbiAgICB8ICgocmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOiBib29sZWFuLCByZWNvcmRUaW1lbGluZTogYm9vbGVhbikgPT4gdm9pZClcbiAgICB8IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgYnJpZGdlOiBCYWNrZW5kQnJpZGdlLFxuICAgIGlzUHJvZmlsaW5nOiBib29sZWFuID0gZmFsc2UsXG4gICAgb25SZWxvYWRBbmRQcm9maWxlPzogKFxuICAgICAgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOiBib29sZWFuLFxuICAgICAgcmVjb3JkVGltZWxpbmU6IGJvb2xlYW4sXG4gICAgKSA9PiB2b2lkLFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faXNQcm9maWxpbmcgPSBpc1Byb2ZpbGluZztcbiAgICB0aGlzLl9vblJlbG9hZEFuZFByb2ZpbGUgPSBvblJlbG9hZEFuZFByb2ZpbGU7XG5cbiAgICBjb25zdCBwZXJzaXN0ZWRTZWxlY3Rpb25TdHJpbmcgPSBzZXNzaW9uU3RvcmFnZUdldEl0ZW0oXG4gICAgICBTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZLFxuICAgICk7XG4gICAgaWYgKHBlcnNpc3RlZFNlbGVjdGlvblN0cmluZyAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gPSBKU09OLnBhcnNlKHBlcnNpc3RlZFNlbGVjdGlvblN0cmluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5fYnJpZGdlID0gYnJpZGdlO1xuXG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjbGVhckVycm9yc0FuZFdhcm5pbmdzJywgdGhpcy5jbGVhckVycm9yc0FuZFdhcm5pbmdzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2NsZWFyRXJyb3JzRm9yRWxlbWVudElEJywgdGhpcy5jbGVhckVycm9yc0ZvckVsZW1lbnRJRCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKFxuICAgICAgJ2NsZWFyV2FybmluZ3NGb3JFbGVtZW50SUQnLFxuICAgICAgdGhpcy5jbGVhcldhcm5pbmdzRm9yRWxlbWVudElELFxuICAgICk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjb3B5RWxlbWVudFBhdGgnLCB0aGlzLmNvcHlFbGVtZW50UGF0aCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdkZWxldGVQYXRoJywgdGhpcy5kZWxldGVQYXRoKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2dldEJhY2tlbmRWZXJzaW9uJywgdGhpcy5nZXRCYWNrZW5kVmVyc2lvbik7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRCcmlkZ2VQcm90b2NvbCcsIHRoaXMuZ2V0QnJpZGdlUHJvdG9jb2wpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZ2V0UHJvZmlsaW5nRGF0YScsIHRoaXMuZ2V0UHJvZmlsaW5nRGF0YSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRQcm9maWxpbmdTdGF0dXMnLCB0aGlzLmdldFByb2ZpbGluZ1N0YXR1cyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRPd25lcnNMaXN0JywgdGhpcy5nZXRPd25lcnNMaXN0KTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2luc3BlY3RFbGVtZW50JywgdGhpcy5pbnNwZWN0RWxlbWVudCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdsb2dFbGVtZW50VG9Db25zb2xlJywgdGhpcy5sb2dFbGVtZW50VG9Db25zb2xlKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlRXJyb3InLCB0aGlzLm92ZXJyaWRlRXJyb3IpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVTdXNwZW5zZScsIHRoaXMub3ZlcnJpZGVTdXNwZW5zZSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZVZhbHVlQXRQYXRoJywgdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3JlbG9hZEFuZFByb2ZpbGUnLCB0aGlzLnJlbG9hZEFuZFByb2ZpbGUpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigncmVuYW1lUGF0aCcsIHRoaXMucmVuYW1lUGF0aCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzZXRUcmFjZVVwZGF0ZXNFbmFibGVkJywgdGhpcy5zZXRUcmFjZVVwZGF0ZXNFbmFibGVkKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0YXJ0UHJvZmlsaW5nJywgdGhpcy5zdGFydFByb2ZpbGluZyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzdG9wUHJvZmlsaW5nJywgdGhpcy5zdG9wUHJvZmlsaW5nKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0b3JlQXNHbG9iYWwnLCB0aGlzLnN0b3JlQXNHbG9iYWwpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcihcbiAgICAgICdzeW5jU2VsZWN0aW9uRnJvbUJ1aWx0aW5FbGVtZW50c1BhbmVsJyxcbiAgICAgIHRoaXMuc3luY1NlbGVjdGlvbkZyb21CdWlsdGluRWxlbWVudHNQYW5lbCxcbiAgICApO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCB0aGlzLnNodXRkb3duKTtcblxuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigndXBkYXRlSG9va1NldHRpbmdzJywgdGhpcy51cGRhdGVIb29rU2V0dGluZ3MpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZ2V0SG9va1NldHRpbmdzJywgdGhpcy5nZXRIb29rU2V0dGluZ3MpO1xuXG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCd1cGRhdGVDb21wb25lbnRGaWx0ZXJzJywgdGhpcy51cGRhdGVDb21wb25lbnRGaWx0ZXJzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2dldEVudmlyb25tZW50TmFtZXMnLCB0aGlzLmdldEVudmlyb25tZW50TmFtZXMpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcihcbiAgICAgICdnZXRJZkhhc1Vuc3VwcG9ydGVkUmVuZGVyZXJWZXJzaW9uJyxcbiAgICAgIHRoaXMuZ2V0SWZIYXNVbnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbixcbiAgICApO1xuXG4gICAgLy8gVGVtcG9yYXJpbHkgc3VwcG9ydCBvbGRlciBzdGFuZGFsb25lIGZyb250LWVuZHMgc2VuZGluZyBjb21tYW5kcyB0byBuZXdlciBlbWJlZGRlZCBiYWNrZW5kcy5cbiAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgUmVhY3QgTmF0aXZlIGVtYmVkcyB0aGUgUmVhY3QgRGV2VG9vbHMgYmFja2VuZCxcbiAgICAvLyBidXQgY2Fubm90IGNvbnRyb2wgd2hpY2ggdmVyc2lvbiBvZiB0aGUgZnJvbnRlbmQgdXNlcnMgdXNlLlxuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVDb250ZXh0JywgdGhpcy5vdmVycmlkZUNvbnRleHQpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVIb29rU3RhdGUnLCB0aGlzLm92ZXJyaWRlSG9va1N0YXRlKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlUHJvcHMnLCB0aGlzLm92ZXJyaWRlUHJvcHMpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVTdGF0ZScsIHRoaXMub3ZlcnJpZGVTdGF0ZSk7XG5cbiAgICBzZXR1cEhpZ2hsaWdodGVyKGJyaWRnZSwgdGhpcyk7XG4gICAgc2V0dXBUcmFjZVVwZGF0ZXModGhpcyk7XG5cbiAgICAvLyBCeSB0aGlzIHRpbWUsIFN0b3JlIHNob3VsZCBhbHJlYWR5IGJlIGluaXRpYWxpemVkIGFuZCBpbnRlcmNlcHQgZXZlbnRzXG4gICAgYnJpZGdlLnNlbmQoJ2JhY2tlbmRJbml0aWFsaXplZCcpO1xuXG4gICAgaWYgKHRoaXMuX2lzUHJvZmlsaW5nKSB7XG4gICAgICBicmlkZ2Uuc2VuZCgncHJvZmlsaW5nU3RhdHVzJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlbmRlcmVySW50ZXJmYWNlcygpOiB7W2tleTogUmVuZGVyZXJJRF06IFJlbmRlcmVySW50ZXJmYWNlLCAuLi59IHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzO1xuICB9XG5cbiAgY2xlYXJFcnJvcnNBbmRXYXJuaW5nczogKHtyZW5kZXJlcklEOiBSZW5kZXJlcklEfSkgPT4gdm9pZCA9ICh7XG4gICAgcmVuZGVyZXJJRCxcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCJgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpO1xuICAgIH1cbiAgfTtcblxuICBjbGVhckVycm9yc0ZvckVsZW1lbnRJRDogRWxlbWVudEFuZFJlbmRlcmVySUQgPT4gdm9pZCA9ICh7XG4gICAgaWQsXG4gICAgcmVuZGVyZXJJRCxcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCJgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuY2xlYXJFcnJvcnNGb3JFbGVtZW50SUQoaWQpO1xuICAgIH1cbiAgfTtcblxuICBjbGVhcldhcm5pbmdzRm9yRWxlbWVudElEOiBFbGVtZW50QW5kUmVuZGVyZXJJRCA9PiB2b2lkID0gKHtcbiAgICBpZCxcbiAgICByZW5kZXJlcklELFxuICB9KSA9PiB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCByZW5kZXJlciBpZCBcIiR7cmVuZGVyZXJJRH1cImApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlci5jbGVhcldhcm5pbmdzRm9yRWxlbWVudElEKGlkKTtcbiAgICB9XG4gIH07XG5cbiAgY29weUVsZW1lbnRQYXRoOiBDb3B5RWxlbWVudFBhcmFtcyA9PiB2b2lkID0gKHtcbiAgICBpZCxcbiAgICBwYXRoLFxuICAgIHJlbmRlcmVySUQsXG4gIH06IENvcHlFbGVtZW50UGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCByZW5kZXJlciBpZCBcIiR7cmVuZGVyZXJJRH1cIiBmb3IgZWxlbWVudCBcIiR7aWR9XCJgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSByZW5kZXJlci5nZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoKGlkLCBwYXRoKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3NhdmVUb0NsaXBib2FyZCcsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5hYmxlIHRvIG9idGFpbiBzZXJpYWxpemVkIHZhbHVlIGZvciBlbGVtZW50IFwiJHtpZH1cImApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBkZWxldGVQYXRoOiBEZWxldGVQYXRoUGFyYW1zID0+IHZvaWQgPSAoe1xuICAgIGhvb2tJRCxcbiAgICBpZCxcbiAgICBwYXRoLFxuICAgIHJlbmRlcmVySUQsXG4gICAgdHlwZSxcbiAgfTogRGVsZXRlUGF0aFBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCIgZm9yIGVsZW1lbnQgXCIke2lkfVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLmRlbGV0ZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCk7XG4gICAgfVxuICB9O1xuXG4gIGdldEluc3RhbmNlQW5kU3R5bGUoe1xuICAgIGlkLFxuICAgIHJlbmRlcmVySUQsXG4gIH06IEVsZW1lbnRBbmRSZW5kZXJlcklEKTogSW5zdGFuY2VBbmRTdHlsZSB8IG51bGwge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCJgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZXIuZ2V0SW5zdGFuY2VBbmRTdHlsZShpZCk7XG4gIH1cblxuICBnZXRJREZvckhvc3RJbnN0YW5jZSh0YXJnZXQ6IEhvc3RJbnN0YW5jZSk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChpc1JlYWN0TmF0aXZlRW52aXJvbm1lbnQoKSB8fCB0eXBlb2YgdGFyZ2V0Lm5vZGVUeXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gSW4gUmVhY3QgTmF0aXZlIG9yIG5vbi1ET00gd2Ugc2ltcGx5IHBpY2sgYW55IHJlbmRlcmVyIHRoYXQgaGFzIGEgbWF0Y2guXG4gICAgICBmb3IgKGNvbnN0IHJlbmRlcmVySUQgaW4gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gKCh0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbXG4gICAgICAgICAgKHJlbmRlcmVySUQ6IGFueSlcbiAgICAgICAgXTogYW55KTogUmVuZGVyZXJJbnRlcmZhY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVuZGVyZXIuZ2V0RWxlbWVudElERm9ySG9zdEluc3RhbmNlKHRhcmdldCk7XG4gICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gU29tZSBvbGQgUmVhY3QgdmVyc2lvbnMgbWlnaHQgdGhyb3cgaWYgdGhleSBjYW4ndCBmaW5kIGEgbWF0Y2guXG4gICAgICAgICAgLy8gSWYgc28gd2Ugc2hvdWxkIGlnbm9yZSBpdC4uLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gdGhlIERPTSB3ZSB1c2UgYSBzbWFydGVyIG1lY2hhbmlzbSB0byBmaW5kIHRoZSBkZWVwZXN0IGEgRE9NIG5vZGVcbiAgICAgIC8vIHRoYXQgaXMgcmVnaXN0ZXJlZCBpZiB0aGVyZSBpc24ndCBhbiBleGFjdCBtYXRjaC5cbiAgICAgIGxldCBiZXN0TWF0Y2g6IG51bGwgfCBFbGVtZW50ID0gbnVsbDtcbiAgICAgIGxldCBiZXN0UmVuZGVyZXI6IG51bGwgfCBSZW5kZXJlckludGVyZmFjZSA9IG51bGw7XG4gICAgICAvLyBGaW5kIHRoZSBuZWFyZXN0IGFuY2VzdG9yIHdoaWNoIGlzIG1vdW50ZWQgYnkgYSBSZWFjdC5cbiAgICAgIGZvciAoY29uc3QgcmVuZGVyZXJJRCBpbiB0aGlzLl9yZW5kZXJlckludGVyZmFjZXMpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSAoKHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tcbiAgICAgICAgICAocmVuZGVyZXJJRDogYW55KVxuICAgICAgICBdOiBhbnkpOiBSZW5kZXJlckludGVyZmFjZSk7XG4gICAgICAgIGNvbnN0IG5lYXJlc3ROb2RlOiBudWxsIHwgRWxlbWVudCA9IHJlbmRlcmVyLmdldE5lYXJlc3RNb3VudGVkRE9NTm9kZShcbiAgICAgICAgICAodGFyZ2V0OiBhbnkpLFxuICAgICAgICApO1xuICAgICAgICBpZiAobmVhcmVzdE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobmVhcmVzdE5vZGUgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgLy8gRXhhY3QgbWF0Y2ggd2UgY2FuIGV4aXQgZWFybHkuXG4gICAgICAgICAgICBiZXN0TWF0Y2ggPSBuZWFyZXN0Tm9kZTtcbiAgICAgICAgICAgIGJlc3RSZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPT09IG51bGwgfHwgYmVzdE1hdGNoLmNvbnRhaW5zKG5lYXJlc3ROb2RlKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgbWF0Y2ggb3IgdGhlIHByZXZpb3VzIG1hdGNoIGNvbnRhaW5zIHRoZSBuZXcgbWF0Y2gsXG4gICAgICAgICAgICAvLyBzbyB0aGUgbmV3IG1hdGNoIGlzIGEgZGVlcGVyIGFuZCB0aGVyZWZvcmUgYmV0dGVyIG1hdGNoLlxuICAgICAgICAgICAgYmVzdE1hdGNoID0gbmVhcmVzdE5vZGU7XG4gICAgICAgICAgICBiZXN0UmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiZXN0UmVuZGVyZXIgIT0gbnVsbCAmJiBiZXN0TWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBiZXN0UmVuZGVyZXIuZ2V0RWxlbWVudElERm9ySG9zdEluc3RhbmNlKGJlc3RNYXRjaCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gU29tZSBvbGQgUmVhY3QgdmVyc2lvbnMgbWlnaHQgdGhyb3cgaWYgdGhleSBjYW4ndCBmaW5kIGEgbWF0Y2guXG4gICAgICAgICAgLy8gSWYgc28gd2Ugc2hvdWxkIGlnbm9yZSBpdC4uLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBnZXRDb21wb25lbnROYW1lRm9ySG9zdEluc3RhbmNlKHRhcmdldDogSG9zdEluc3RhbmNlKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gV2UgZHVwbGljYXRlIHRoaXMgY29kZSBmcm9tIGdldElERm9ySG9zdEluc3RhbmNlIHRvIGF2b2lkIGFuIG9iamVjdCBhbGxvY2F0aW9uLlxuICAgIGlmIChpc1JlYWN0TmF0aXZlRW52aXJvbm1lbnQoKSB8fCB0eXBlb2YgdGFyZ2V0Lm5vZGVUeXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgLy8gSW4gUmVhY3QgTmF0aXZlIG9yIG5vbi1ET00gd2Ugc2ltcGx5IHBpY2sgYW55IHJlbmRlcmVyIHRoYXQgaGFzIGEgbWF0Y2guXG4gICAgICBmb3IgKGNvbnN0IHJlbmRlcmVySUQgaW4gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gKCh0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbXG4gICAgICAgICAgKHJlbmRlcmVySUQ6IGFueSlcbiAgICAgICAgXTogYW55KTogUmVuZGVyZXJJbnRlcmZhY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGlkID0gcmVuZGVyZXIuZ2V0RWxlbWVudElERm9ySG9zdEluc3RhbmNlKHRhcmdldCk7XG4gICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0RGlzcGxheU5hbWVGb3JFbGVtZW50SUQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBTb21lIG9sZCBSZWFjdCB2ZXJzaW9ucyBtaWdodCB0aHJvdyBpZiB0aGV5IGNhbid0IGZpbmQgYSBtYXRjaC5cbiAgICAgICAgICAvLyBJZiBzbyB3ZSBzaG91bGQgaWdub3JlIGl0Li4uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiB0aGUgRE9NIHdlIHVzZSBhIHNtYXJ0ZXIgbWVjaGFuaXNtIHRvIGZpbmQgdGhlIGRlZXBlc3QgYSBET00gbm9kZVxuICAgICAgLy8gdGhhdCBpcyByZWdpc3RlcmVkIGlmIHRoZXJlIGlzbid0IGFuIGV4YWN0IG1hdGNoLlxuICAgICAgbGV0IGJlc3RNYXRjaDogbnVsbCB8IEVsZW1lbnQgPSBudWxsO1xuICAgICAgbGV0IGJlc3RSZW5kZXJlcjogbnVsbCB8IFJlbmRlcmVySW50ZXJmYWNlID0gbnVsbDtcbiAgICAgIC8vIEZpbmQgdGhlIG5lYXJlc3QgYW5jZXN0b3Igd2hpY2ggaXMgbW91bnRlZCBieSBhIFJlYWN0LlxuICAgICAgZm9yIChjb25zdCByZW5kZXJlcklEIGluIHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9ICgodGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW1xuICAgICAgICAgIChyZW5kZXJlcklEOiBhbnkpXG4gICAgICAgIF06IGFueSk6IFJlbmRlcmVySW50ZXJmYWNlKTtcbiAgICAgICAgY29uc3QgbmVhcmVzdE5vZGU6IG51bGwgfCBFbGVtZW50ID0gcmVuZGVyZXIuZ2V0TmVhcmVzdE1vdW50ZWRET01Ob2RlKFxuICAgICAgICAgICh0YXJnZXQ6IGFueSksXG4gICAgICAgICk7XG4gICAgICAgIGlmIChuZWFyZXN0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChuZWFyZXN0Tm9kZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBFeGFjdCBtYXRjaCB3ZSBjYW4gZXhpdCBlYXJseS5cbiAgICAgICAgICAgIGJlc3RNYXRjaCA9IG5lYXJlc3ROb2RlO1xuICAgICAgICAgICAgYmVzdFJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJlc3RNYXRjaCA9PT0gbnVsbCB8fCBiZXN0TWF0Y2guY29udGFpbnMobmVhcmVzdE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBtYXRjaCBvciB0aGUgcHJldmlvdXMgbWF0Y2ggY29udGFpbnMgdGhlIG5ldyBtYXRjaCxcbiAgICAgICAgICAgIC8vIHNvIHRoZSBuZXcgbWF0Y2ggaXMgYSBkZWVwZXIgYW5kIHRoZXJlZm9yZSBiZXR0ZXIgbWF0Y2guXG4gICAgICAgICAgICBiZXN0TWF0Y2ggPSBuZWFyZXN0Tm9kZTtcbiAgICAgICAgICAgIGJlc3RSZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJlc3RSZW5kZXJlciAhPSBudWxsICYmIGJlc3RNYXRjaCAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaWQgPSBiZXN0UmVuZGVyZXIuZ2V0RWxlbWVudElERm9ySG9zdEluc3RhbmNlKGJlc3RNYXRjaCk7XG4gICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdFJlbmRlcmVyLmdldERpc3BsYXlOYW1lRm9yRWxlbWVudElEKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gU29tZSBvbGQgUmVhY3QgdmVyc2lvbnMgbWlnaHQgdGhyb3cgaWYgdGhleSBjYW4ndCBmaW5kIGEgbWF0Y2guXG4gICAgICAgICAgLy8gSWYgc28gd2Ugc2hvdWxkIGlnbm9yZSBpdC4uLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBnZXRCYWNrZW5kVmVyc2lvbjogKCkgPT4gdm9pZCA9ICgpID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uID0gcHJvY2Vzcy5lbnYuREVWVE9PTFNfVkVSU0lPTjtcbiAgICBpZiAodmVyc2lvbikge1xuICAgICAgdGhpcy5fYnJpZGdlLnNlbmQoJ2JhY2tlbmRWZXJzaW9uJywgdmVyc2lvbik7XG4gICAgfVxuICB9O1xuXG4gIGdldEJyaWRnZVByb3RvY29sOiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIHRoaXMuX2JyaWRnZS5zZW5kKCdicmlkZ2VQcm90b2NvbCcsIGN1cnJlbnRCcmlkZ2VQcm90b2NvbCk7XG4gIH07XG5cbiAgZ2V0UHJvZmlsaW5nRGF0YTogKHtyZW5kZXJlcklEOiBSZW5kZXJlcklEfSkgPT4gdm9pZCA9ICh7cmVuZGVyZXJJRH0pID0+IHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlbmRlcmVyIGlkIFwiJHtyZW5kZXJlcklEfVwiYCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ0RhdGEnLCByZW5kZXJlci5nZXRQcm9maWxpbmdEYXRhKCkpO1xuICB9O1xuXG4gIGdldFByb2ZpbGluZ1N0YXR1czogKCkgPT4gdm9pZCA9ICgpID0+IHtcbiAgICB0aGlzLl9icmlkZ2Uuc2VuZCgncHJvZmlsaW5nU3RhdHVzJywgdGhpcy5faXNQcm9maWxpbmcpO1xuICB9O1xuXG4gIGdldE93bmVyc0xpc3Q6IEVsZW1lbnRBbmRSZW5kZXJlcklEID0+IHZvaWQgPSAoe2lkLCByZW5kZXJlcklEfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCIgZm9yIGVsZW1lbnQgXCIke2lkfVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG93bmVycyA9IHJlbmRlcmVyLmdldE93bmVyc0xpc3QoaWQpO1xuICAgICAgdGhpcy5fYnJpZGdlLnNlbmQoJ293bmVyc0xpc3QnLCAoe2lkLCBvd25lcnN9OiBPd25lcnNMaXN0KSk7XG4gICAgfVxuICB9O1xuXG4gIGluc3BlY3RFbGVtZW50OiBJbnNwZWN0RWxlbWVudFBhcmFtcyA9PiB2b2lkID0gKHtcbiAgICBmb3JjZUZ1bGxEYXRhLFxuICAgIGlkLFxuICAgIHBhdGgsXG4gICAgcmVuZGVyZXJJRCxcbiAgICByZXF1ZXN0SUQsXG4gIH0pID0+IHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlbmRlcmVyIGlkIFwiJHtyZW5kZXJlcklEfVwiIGZvciBlbGVtZW50IFwiJHtpZH1cImApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9icmlkZ2Uuc2VuZChcbiAgICAgICAgJ2luc3BlY3RlZEVsZW1lbnQnLFxuICAgICAgICByZW5kZXJlci5pbnNwZWN0RWxlbWVudChyZXF1ZXN0SUQsIGlkLCBwYXRoLCBmb3JjZUZ1bGxEYXRhKSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFdoZW4gdXNlciBzZWxlY3RzIGFuIGVsZW1lbnQsIHN0b3AgdHJ5aW5nIHRvIHJlc3RvcmUgdGhlIHNlbGVjdGlvbixcbiAgICAgIC8vIGFuZCBpbnN0ZWFkIHJlbWVtYmVyIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmb3IgdGhlIG5leHQgcmVsb2FkLlxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaCA9PT0gbnVsbCB8fFxuICAgICAgICB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaC5pZCAhPT0gaWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaCA9IG51bGw7XG4gICAgICAgIHJlbmRlcmVyLnNldFRyYWNrZWRQYXRoKG51bGwpO1xuICAgICAgICAvLyBUaHJvdHRsZSBwZXJzaXN0aW5nIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIHRoaXMuX2xhc3RTZWxlY3RlZEVsZW1lbnRJRCA9IGlkO1xuICAgICAgICB0aGlzLl9sYXN0U2VsZWN0ZWRSZW5kZXJlcklEID0gcmVuZGVyZXJJRDtcbiAgICAgICAgaWYgKCF0aGlzLl9wZXJzaXN0U2VsZWN0aW9uVGltZXJTY2hlZHVsZWQpIHtcbiAgICAgICAgICB0aGlzLl9wZXJzaXN0U2VsZWN0aW9uVGltZXJTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5fcGVyc2lzdFNlbGVjdGlvbiwgMTAwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogSWYgdGhlcmUgd2FzIGEgd2F5IHRvIGNoYW5nZSB0aGUgc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgIC8vIGluIGJ1aWx0LWluIEVsZW1lbnRzIHRhYiB3aXRob3V0IGZvcmNpbmcgYSBzd2l0Y2ggdG8gaXQsIHdlJ2QgZG8gaXQgaGVyZS5cbiAgICAgIC8vIEZvciBub3csIGl0IGRvZXNuJ3Qgc2VlbSBsaWtlIHRoZXJlIGlzIGEgd2F5IHRvIGRvIHRoYXQ6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnZhdWdobi9yZWFjdC1kZXZ0b29scy1leHBlcmltZW50YWwvaXNzdWVzLzEwMlxuICAgICAgLy8gKFNldHRpbmcgJDAgZG9lc24ndCB3b3JrLCBhbmQgY2FsbGluZyBpbnNwZWN0KCkgc3dpdGNoZXMgdGhlIHRhYi4pXG4gICAgfVxuICB9O1xuXG4gIGxvZ0VsZW1lbnRUb0NvbnNvbGU6IEVsZW1lbnRBbmRSZW5kZXJlcklEID0+IHZvaWQgPSAoe2lkLCByZW5kZXJlcklEfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCIgZm9yIGVsZW1lbnQgXCIke2lkfVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLmxvZ0VsZW1lbnRUb0NvbnNvbGUoaWQpO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUVycm9yOiBPdmVycmlkZUVycm9yUGFyYW1zID0+IHZvaWQgPSAoe1xuICAgIGlkLFxuICAgIHJlbmRlcmVySUQsXG4gICAgZm9yY2VFcnJvcixcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCIgZm9yIGVsZW1lbnQgXCIke2lkfVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLm92ZXJyaWRlRXJyb3IoaWQsIGZvcmNlRXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZVN1c3BlbnNlOiBPdmVycmlkZVN1c3BlbnNlUGFyYW1zID0+IHZvaWQgPSAoe1xuICAgIGlkLFxuICAgIHJlbmRlcmVySUQsXG4gICAgZm9yY2VGYWxsYmFjayxcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCIgZm9yIGVsZW1lbnQgXCIke2lkfVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLm92ZXJyaWRlU3VzcGVuc2UoaWQsIGZvcmNlRmFsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZVZhbHVlQXRQYXRoOiBPdmVycmlkZVZhbHVlQXRQYXRoUGFyYW1zID0+IHZvaWQgPSAoe1xuICAgIGhvb2tJRCxcbiAgICBpZCxcbiAgICBwYXRoLFxuICAgIHJlbmRlcmVySUQsXG4gICAgdHlwZSxcbiAgICB2YWx1ZSxcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCIgZm9yIGVsZW1lbnQgXCIke2lkfVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVyLm92ZXJyaWRlVmFsdWVBdFBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBUZW1wb3JhcmlseSBzdXBwb3J0IG9sZGVyIHN0YW5kYWxvbmUgZnJvbnQtZW5kcyBieSBmb3J3YXJkaW5nIHRoZSBvbGRlciBtZXNzYWdlIHR5cGVzXG4gIC8vIHRvIHRoZSBuZXcgXCJvdmVycmlkZVZhbHVlQXRQYXRoXCIgY29tbWFuZCB0aGUgYmFja2VuZCBpcyBub3cgbGlzdGVuaW5nIHRvLlxuICBvdmVycmlkZUNvbnRleHQ6IFNldEluUGFyYW1zID0+IHZvaWQgPSAoe1xuICAgIGlkLFxuICAgIHBhdGgsXG4gICAgcmVuZGVyZXJJRCxcbiAgICB3YXNGb3J3YXJkZWQsXG4gICAgdmFsdWUsXG4gIH0pID0+IHtcbiAgICAvLyBEb24ndCBmb3J3YXJkIGEgbWVzc2FnZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGZvcndhcmRlZCBieSB0aGUgZnJvbnQtZW5kIEJyaWRnZS5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgb3ZlcnJpZGUgY29tbWFuZCBvbmNlIVxuICAgIGlmICghd2FzRm9yd2FyZGVkKSB7XG4gICAgICB0aGlzLm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICBpZCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgdHlwZTogJ2NvbnRleHQnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUZW1wb3JhcmlseSBzdXBwb3J0IG9sZGVyIHN0YW5kYWxvbmUgZnJvbnQtZW5kcyBieSBmb3J3YXJkaW5nIHRoZSBvbGRlciBtZXNzYWdlIHR5cGVzXG4gIC8vIHRvIHRoZSBuZXcgXCJvdmVycmlkZVZhbHVlQXRQYXRoXCIgY29tbWFuZCB0aGUgYmFja2VuZCBpcyBub3cgbGlzdGVuaW5nIHRvLlxuICBvdmVycmlkZUhvb2tTdGF0ZTogT3ZlcnJpZGVIb29rUGFyYW1zID0+IHZvaWQgPSAoe1xuICAgIGlkLFxuICAgIGhvb2tJRCxcbiAgICBwYXRoLFxuICAgIHJlbmRlcmVySUQsXG4gICAgd2FzRm9yd2FyZGVkLFxuICAgIHZhbHVlLFxuICB9KSA9PiB7XG4gICAgLy8gRG9uJ3QgZm9yd2FyZCBhIG1lc3NhZ2UgdGhhdCdzIGFscmVhZHkgYmVlbiBmb3J3YXJkZWQgYnkgdGhlIGZyb250LWVuZCBCcmlkZ2UuXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG92ZXJyaWRlIGNvbW1hbmQgb25jZSFcbiAgICBpZiAoIXdhc0ZvcndhcmRlZCkge1xuICAgICAgdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgIHR5cGU6ICdob29rcycsXG4gICAgICAgIHZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRlbXBvcmFyaWx5IHN1cHBvcnQgb2xkZXIgc3RhbmRhbG9uZSBmcm9udC1lbmRzIGJ5IGZvcndhcmRpbmcgdGhlIG9sZGVyIG1lc3NhZ2UgdHlwZXNcbiAgLy8gdG8gdGhlIG5ldyBcIm92ZXJyaWRlVmFsdWVBdFBhdGhcIiBjb21tYW5kIHRoZSBiYWNrZW5kIGlzIG5vdyBsaXN0ZW5pbmcgdG8uXG4gIG92ZXJyaWRlUHJvcHM6IFNldEluUGFyYW1zID0+IHZvaWQgPSAoe1xuICAgIGlkLFxuICAgIHBhdGgsXG4gICAgcmVuZGVyZXJJRCxcbiAgICB3YXNGb3J3YXJkZWQsXG4gICAgdmFsdWUsXG4gIH0pID0+IHtcbiAgICAvLyBEb24ndCBmb3J3YXJkIGEgbWVzc2FnZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGZvcndhcmRlZCBieSB0aGUgZnJvbnQtZW5kIEJyaWRnZS5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgb3ZlcnJpZGUgY29tbWFuZCBvbmNlIVxuICAgIGlmICghd2FzRm9yd2FyZGVkKSB7XG4gICAgICB0aGlzLm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICBpZCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGVtcG9yYXJpbHkgc3VwcG9ydCBvbGRlciBzdGFuZGFsb25lIGZyb250LWVuZHMgYnkgZm9yd2FyZGluZyB0aGUgb2xkZXIgbWVzc2FnZSB0eXBlc1xuICAvLyB0byB0aGUgbmV3IFwib3ZlcnJpZGVWYWx1ZUF0UGF0aFwiIGNvbW1hbmQgdGhlIGJhY2tlbmQgaXMgbm93IGxpc3RlbmluZyB0by5cbiAgb3ZlcnJpZGVTdGF0ZTogU2V0SW5QYXJhbXMgPT4gdm9pZCA9ICh7XG4gICAgaWQsXG4gICAgcGF0aCxcbiAgICByZW5kZXJlcklELFxuICAgIHdhc0ZvcndhcmRlZCxcbiAgICB2YWx1ZSxcbiAgfSkgPT4ge1xuICAgIC8vIERvbid0IGZvcndhcmQgYSBtZXNzYWdlIHRoYXQncyBhbHJlYWR5IGJlZW4gZm9yd2FyZGVkIGJ5IHRoZSBmcm9udC1lbmQgQnJpZGdlLlxuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBvdmVycmlkZSBjb21tYW5kIG9uY2UhXG4gICAgaWYgKCF3YXNGb3J3YXJkZWQpIHtcbiAgICAgIHRoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgIGlkLFxuICAgICAgICBwYXRoLFxuICAgICAgICByZW5kZXJlcklELFxuICAgICAgICB0eXBlOiAnc3RhdGUnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBvblJlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWRCeUhvc3Q6ICgpID0+IHZvaWQgPSAoKSA9PiB7XG4gICAgdGhpcy5fYnJpZGdlLnNlbmQoJ2lzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZEJ5QmFja2VuZCcsIHRydWUpO1xuICB9O1xuXG4gIHJlbG9hZEFuZFByb2ZpbGU6ICh7XG4gICAgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOiBib29sZWFuLFxuICAgIHJlY29yZFRpbWVsaW5lOiBib29sZWFuLFxuICB9KSA9PiB2b2lkID0gKHtyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMsIHJlY29yZFRpbWVsaW5lfSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fb25SZWxvYWRBbmRQcm9maWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9vblJlbG9hZEFuZFByb2ZpbGUocmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zLCByZWNvcmRUaW1lbGluZSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjb2RlIHBhdGggc2hvdWxkIG9ubHkgYmUgaGl0IGlmIHRoZSBzaGVsbCBoYXMgZXhwbGljaXRseSB0b2xkIHRoZSBTdG9yZSB0aGF0IGl0IHN1cHBvcnRzIHByb2ZpbGluZy5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSBzaGVsbCBtdXN0IGFsc28gbGlzdGVuIGZvciB0aGlzIHNwZWNpZmljIG1lc3NhZ2UgdG8ga25vdyB3aGVuIGl0IG5lZWRzIHRvIHJlbG9hZCB0aGUgYXBwLlxuICAgIC8vIFRoZSBhZ2VudCBjYW4ndCBkbyB0aGlzIGluIGEgd2F5IHRoYXQgaXMgcmVuZGVyZXIgYWdub3N0aWMuXG4gICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3JlbG9hZEFwcEZvclByb2ZpbGluZycpO1xuICB9O1xuXG4gIHJlbmFtZVBhdGg6IFJlbmFtZVBhdGhQYXJhbXMgPT4gdm9pZCA9ICh7XG4gICAgaG9va0lELFxuICAgIGlkLFxuICAgIG5ld1BhdGgsXG4gICAgb2xkUGF0aCxcbiAgICByZW5kZXJlcklELFxuICAgIHR5cGUsXG4gIH0pID0+IHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlbmRlcmVyIGlkIFwiJHtyZW5kZXJlcklEfVwiIGZvciBlbGVtZW50IFwiJHtpZH1cImApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlci5yZW5hbWVQYXRoKHR5cGUsIGlkLCBob29rSUQsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgIH1cbiAgfTtcblxuICBzZWxlY3ROb2RlKHRhcmdldDogSG9zdEluc3RhbmNlKTogdm9pZCB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldElERm9ySG9zdEluc3RhbmNlKHRhcmdldCk7XG4gICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnc2VsZWN0RWxlbWVudCcsIGlkKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RlclJlbmRlcmVySW50ZXJmYWNlKFxuICAgIHJlbmRlcmVySUQ6IFJlbmRlcmVySUQsXG4gICAgcmVuZGVyZXJJbnRlcmZhY2U6IFJlbmRlcmVySW50ZXJmYWNlLFxuICApIHtcbiAgICB0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF0gPSByZW5kZXJlckludGVyZmFjZTtcblxuICAgIHJlbmRlcmVySW50ZXJmYWNlLnNldFRyYWNlVXBkYXRlc0VuYWJsZWQodGhpcy5fdHJhY2VVcGRhdGVzRW5hYmxlZCk7XG5cbiAgICAvLyBXaGVuIHRoZSByZW5kZXJlciBpcyBhdHRhY2hlZCwgd2UgbmVlZCB0byB0ZWxsIGl0IHdoZXRoZXJcbiAgICAvLyB3ZSByZW1lbWJlciB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIHRoYXQgd2UnZCBsaWtlIHRvIHJlc3RvcmUuXG4gICAgLy8gSXQnbGwgc3RhcnQgdHJhY2tpbmcgbW91bnRzIGZvciBtYXRjaGVzIHRvIHRoZSBsYXN0IHNlbGVjdGlvbiBwYXRoLlxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbjtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsICYmIHNlbGVjdGlvbi5yZW5kZXJlcklEID09PSByZW5kZXJlcklEKSB7XG4gICAgICByZW5kZXJlckludGVyZmFjZS5zZXRUcmFja2VkUGF0aChzZWxlY3Rpb24ucGF0aCk7XG4gICAgfVxuICB9XG5cbiAgc2V0VHJhY2VVcGRhdGVzRW5hYmxlZDogKHRyYWNlVXBkYXRlc0VuYWJsZWQ6IGJvb2xlYW4pID0+IHZvaWQgPVxuICAgIHRyYWNlVXBkYXRlc0VuYWJsZWQgPT4ge1xuICAgICAgdGhpcy5fdHJhY2VVcGRhdGVzRW5hYmxlZCA9IHRyYWNlVXBkYXRlc0VuYWJsZWQ7XG5cbiAgICAgIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQodHJhY2VVcGRhdGVzRW5hYmxlZCk7XG5cbiAgICAgIGZvciAoY29uc3QgcmVuZGVyZXJJRCBpbiB0aGlzLl9yZW5kZXJlckludGVyZmFjZXMpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSAoKHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tcbiAgICAgICAgICAocmVuZGVyZXJJRDogYW55KVxuICAgICAgICBdOiBhbnkpOiBSZW5kZXJlckludGVyZmFjZSk7XG4gICAgICAgIHJlbmRlcmVyLnNldFRyYWNlVXBkYXRlc0VuYWJsZWQodHJhY2VVcGRhdGVzRW5hYmxlZCk7XG4gICAgICB9XG4gICAgfTtcblxuICBzeW5jU2VsZWN0aW9uRnJvbUJ1aWx0aW5FbGVtZW50c1BhbmVsOiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uJDA7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0Tm9kZSh0YXJnZXQpO1xuICB9O1xuXG4gIHNodXRkb3duOiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIHRoZSBvdmVybGF5IGlmIHZpc2libGUsIGFuZCBhc3NvY2lhdGVkIGV2ZW50cy5cbiAgICB0aGlzLmVtaXQoJ3NodXRkb3duJyk7XG5cbiAgICB0aGlzLl9icmlkZ2UucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfTtcblxuICBzdGFydFByb2ZpbGluZzogKHtcbiAgICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM6IGJvb2xlYW4sXG4gICAgcmVjb3JkVGltZWxpbmU6IGJvb2xlYW4sXG4gIH0pID0+IHZvaWQgPSAoe3JlY29yZENoYW5nZURlc2NyaXB0aW9ucywgcmVjb3JkVGltZWxpbmV9KSA9PiB7XG4gICAgdGhpcy5faXNQcm9maWxpbmcgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVuZGVyZXJJRCBpbiB0aGlzLl9yZW5kZXJlckludGVyZmFjZXMpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gKCh0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbXG4gICAgICAgIChyZW5kZXJlcklEOiBhbnkpXG4gICAgICBdOiBhbnkpOiBSZW5kZXJlckludGVyZmFjZSk7XG4gICAgICByZW5kZXJlci5zdGFydFByb2ZpbGluZyhyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMsIHJlY29yZFRpbWVsaW5lKTtcbiAgICB9XG4gICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ1N0YXR1cycsIHRoaXMuX2lzUHJvZmlsaW5nKTtcbiAgfTtcblxuICBzdG9wUHJvZmlsaW5nOiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIHRoaXMuX2lzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCByZW5kZXJlcklEIGluIHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSAoKHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tcbiAgICAgICAgKHJlbmRlcmVySUQ6IGFueSlcbiAgICAgIF06IGFueSk6IFJlbmRlcmVySW50ZXJmYWNlKTtcbiAgICAgIHJlbmRlcmVyLnN0b3BQcm9maWxpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ1N0YXR1cycsIHRoaXMuX2lzUHJvZmlsaW5nKTtcbiAgfTtcblxuICBzdG9wSW5zcGVjdGluZ05hdGl2ZTogKHNlbGVjdGVkOiBib29sZWFuKSA9PiB2b2lkID0gc2VsZWN0ZWQgPT4ge1xuICAgIHRoaXMuX2JyaWRnZS5zZW5kKCdzdG9wSW5zcGVjdGluZ0hvc3QnLCBzZWxlY3RlZCk7XG4gIH07XG5cbiAgc3RvcmVBc0dsb2JhbDogU3RvcmVBc0dsb2JhbFBhcmFtcyA9PiB2b2lkID0gKHtcbiAgICBjb3VudCxcbiAgICBpZCxcbiAgICBwYXRoLFxuICAgIHJlbmRlcmVySUQsXG4gIH0pID0+IHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHJlbmRlcmVyIGlkIFwiJHtyZW5kZXJlcklEfVwiIGZvciBlbGVtZW50IFwiJHtpZH1cImApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlci5zdG9yZUFzR2xvYmFsKGlkLCBwYXRoLCBjb3VudCk7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvb2tTZXR0aW5nczogKHNldHRpbmdzOiAkUmVhZE9ubHk8RGV2VG9vbHNIb29rU2V0dGluZ3M+KSA9PiB2b2lkID1cbiAgICBzZXR0aW5ncyA9PiB7XG4gICAgICAvLyBQcm9wYWdhdGUgdGhlIHNldHRpbmdzLCBzbyBCYWNrZW5kIGNhbiBzdWJzY3JpYmUgdG8gaXQgYW5kIG1vZGlmeSBob29rXG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZUhvb2tTZXR0aW5ncycsIHNldHRpbmdzKTtcbiAgICB9O1xuXG4gIGdldEhvb2tTZXR0aW5nczogKCkgPT4gdm9pZCA9ICgpID0+IHtcbiAgICB0aGlzLmVtaXQoJ2dldEhvb2tTZXR0aW5ncycpO1xuICB9O1xuXG4gIG9uSG9va1NldHRpbmdzOiAoc2V0dGluZ3M6ICRSZWFkT25seTxEZXZUb29sc0hvb2tTZXR0aW5ncz4pID0+IHZvaWQgPVxuICAgIHNldHRpbmdzID0+IHtcbiAgICAgIHRoaXMuX2JyaWRnZS5zZW5kKCdob29rU2V0dGluZ3MnLCBzZXR0aW5ncyk7XG4gICAgfTtcblxuICB1cGRhdGVDb21wb25lbnRGaWx0ZXJzOiAoY29tcG9uZW50RmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPikgPT4gdm9pZCA9XG4gICAgY29tcG9uZW50RmlsdGVycyA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHJlbmRlcmVySURTdHJpbmcgaW4gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVySUQgPSArcmVuZGVyZXJJRFN0cmluZztcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSAoKHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tcbiAgICAgICAgICAocmVuZGVyZXJJRDogYW55KVxuICAgICAgICBdOiBhbnkpOiBSZW5kZXJlckludGVyZmFjZSk7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0U2VsZWN0ZWRSZW5kZXJlcklEID09PSByZW5kZXJlcklEKSB7XG4gICAgICAgICAgLy8gQ2hhbmdpbmcgY29tcG9uZW50IGZpbHRlcnMgd2lsbCB1bm1vdW50IGFuZCByZW1vdW50IHRoZSBEZXZUb29scyB0cmVlLlxuICAgICAgICAgIC8vIFRyYWNrIHRoZSBsYXN0IHNlbGVjdGlvbidzIHBhdGggc28gd2UgY2FuIHJlc3RvcmUgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICBjb25zdCBwYXRoID0gcmVuZGVyZXIuZ2V0UGF0aEZvckVsZW1lbnQodGhpcy5fbGFzdFNlbGVjdGVkRWxlbWVudElEKTtcbiAgICAgICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0VHJhY2tlZFBhdGgocGF0aCk7XG4gICAgICAgICAgICB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlci51cGRhdGVDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgZ2V0RW52aXJvbm1lbnROYW1lczogKCkgPT4gdm9pZCA9ICgpID0+IHtcbiAgICBsZXQgYWNjdW11bGF0ZWROYW1lcyA9IG51bGw7XG4gICAgZm9yIChjb25zdCByZW5kZXJlcklEIGluIHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbK3JlbmRlcmVySURdO1xuICAgICAgY29uc3QgbmFtZXMgPSByZW5kZXJlci5nZXRFbnZpcm9ubWVudE5hbWVzKCk7XG4gICAgICBpZiAoYWNjdW11bGF0ZWROYW1lcyA9PT0gbnVsbCkge1xuICAgICAgICBhY2N1bXVsYXRlZE5hbWVzID0gbmFtZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGVkTmFtZXMuaW5kZXhPZihuYW1lc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZE5hbWVzLnB1c2gobmFtZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnZW52aXJvbm1lbnROYW1lcycsIGFjY3VtdWxhdGVkTmFtZXMgfHwgW10pO1xuICB9O1xuXG4gIG9uVHJhY2VVcGRhdGVzOiAobm9kZXM6IFNldDxIb3N0SW5zdGFuY2U+KSA9PiB2b2lkID0gbm9kZXMgPT4ge1xuICAgIHRoaXMuZW1pdCgndHJhY2VVcGRhdGVzJywgbm9kZXMpO1xuICB9O1xuXG4gIG9uRmFzdFJlZnJlc2hTY2hlZHVsZWQ6ICgpID0+IHZvaWQgPSAoKSA9PiB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgZGVidWcoJ29uRmFzdFJlZnJlc2hTY2hlZHVsZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnZmFzdFJlZnJlc2hTY2hlZHVsZWQnKTtcbiAgfTtcblxuICBvbkhvb2tPcGVyYXRpb25zOiAob3BlcmF0aW9uczogQXJyYXk8bnVtYmVyPikgPT4gdm9pZCA9IG9wZXJhdGlvbnMgPT4ge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICAnb25Ib29rT3BlcmF0aW9ucycsXG4gICAgICAgIGAoJHtvcGVyYXRpb25zLmxlbmd0aH0pIFske29wZXJhdGlvbnMuam9pbignLCAnKX1dYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzpcbiAgICAvLyBUaGUgY2hyb21lLnJ1bnRpbWUgZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgdHJhbnNmZXJhYmxlczsgaXQgZm9yY2VzIEpTT04gc2VyaWFsaXphdGlvbi5cbiAgICAvLyBTZWUgYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkyNzEzNFxuICAgIC8vXG4gICAgLy8gUmVnYXJkaW5nIHRyYW5zZmVyYWJsZXMsIHRoZSBwb3N0TWVzc2FnZSBkb2Mgc3RhdGVzOlxuICAgIC8vIElmIHRoZSBvd25lcnNoaXAgb2YgYW4gb2JqZWN0IGlzIHRyYW5zZmVycmVkLCBpdCBiZWNvbWVzIHVudXNhYmxlIChuZXV0ZXJlZClcbiAgICAvLyBpbiB0aGUgY29udGV4dCBpdCB3YXMgc2VudCBmcm9tIGFuZCBiZWNvbWVzIGF2YWlsYWJsZSBvbmx5IHRvIHRoZSB3b3JrZXIgaXQgd2FzIHNlbnQgdG8uXG4gICAgLy9cbiAgICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgaXMgZXZlbnR1YWxseSBKU09OIHNlcmlhbGl6aW5nIHRoZSBhcnJheSBidWZmZXIsXG4gICAgLy8gdXNpbmcgdGhlIHRyYW5zZmVyYWJsZSBhcHByb2FjaCBhbHNvIHNvbWV0aW1lcyBjYXVzZXMgaXQgdG8gdGhyb3c6XG4gICAgLy8gICBET01FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdwb3N0TWVzc2FnZScgb24gJ1dpbmRvdyc6IEFycmF5QnVmZmVyIGF0IGluZGV4IDAgaXMgYWxyZWFkeSBuZXV0ZXJlZC5cbiAgICAvL1xuICAgIC8vIFNlZSBidWcgaHR0cHM6Ly9naXRodWIuY29tL2J2YXVnaG4vcmVhY3QtZGV2dG9vbHMtZXhwZXJpbWVudGFsL2lzc3Vlcy8yNVxuICAgIC8vXG4gICAgLy8gVGhlIFN0b3JlIGhhcyBhIGZhbGxiYWNrIGluIHBsYWNlIHRoYXQgcGFyc2VzIHRoZSBtZXNzYWdlIGFzIEpTT04gaWYgdGhlIHR5cGUgaXNuJ3QgYW4gYXJyYXkuXG4gICAgLy8gRm9yIG5vdyB0aGUgc2ltcGxlc3QgZml4IHNlZW1zIHRvIGJlIHRvIG5vdCB0cmFuc2ZlciB0aGUgYXJyYXkuXG4gICAgLy8gVGhpcyB3aWxsIG5lZ2F0aXZlbHkgaW1wYWN0IHBlcmZvcm1hbmNlIG9uIEZpcmVmb3ggc28gaXQncyB1bmZvcnR1bmF0ZSxcbiAgICAvLyBidXQgdW50aWwgd2UncmUgYWJsZSB0byBmaXggdGhlIENocm9tZSBlcnJvciBtZW50aW9uZWQgYWJvdmUsIGl0IHNlZW1zIG5lY2Vzc2FyeS5cbiAgICAvL1xuICAgIC8vIHRoaXMuX2JyaWRnZS5zZW5kKCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucywgW29wZXJhdGlvbnMuYnVmZmVyXSk7XG4gICAgdGhpcy5fYnJpZGdlLnNlbmQoJ29wZXJhdGlvbnMnLCBvcGVyYXRpb25zKTtcblxuICAgIGlmICh0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVySUQgPSBvcGVyYXRpb25zWzBdO1xuICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbi5yZW5kZXJlcklEID09PSByZW5kZXJlcklEKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBzZWxlY3QgYSBkZWVwZXIgbWF0Y2ggZm9yIHRoZSBwZXJzaXN0ZWQgc2VsZWN0aW9uLlxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcmVuZGVyZXIgaWQgXCIke3JlbmRlcmVySUR9XCJgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcmV2TWF0Y2ggPSB0aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaDtcbiAgICAgICAgICBjb25zdCBuZXh0TWF0Y2ggPSByZW5kZXJlci5nZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCgpO1xuICAgICAgICAgIHRoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoID0gbmV4dE1hdGNoO1xuICAgICAgICAgIGNvbnN0IHByZXZNYXRjaElEID0gcHJldk1hdGNoICE9PSBudWxsID8gcHJldk1hdGNoLmlkIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBuZXh0TWF0Y2hJRCA9IG5leHRNYXRjaCAhPT0gbnVsbCA/IG5leHRNYXRjaC5pZCA6IG51bGw7XG4gICAgICAgICAgaWYgKHByZXZNYXRjaElEICE9PSBuZXh0TWF0Y2hJRCkge1xuICAgICAgICAgICAgaWYgKG5leHRNYXRjaElEICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG1vdmVkIGZvcndhcmQsIHVubG9ja2luZyBhIGRlZXBlciBub2RlLlxuICAgICAgICAgICAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnc2VsZWN0RWxlbWVudCcsIG5leHRNYXRjaElEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRNYXRjaCAhPT0gbnVsbCAmJiBuZXh0TWF0Y2guaXNGdWxsTWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGp1c3QgdW5sb2NrZWQgdGhlIGlubmVybW9zdCBzZWxlY3RlZCBub2RlLlxuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBwb2ludCB0cmFja2luZyBpdCBmdXJ0aGVyLlxuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFRyYWNrZWRQYXRoKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBnZXRJZkhhc1Vuc3VwcG9ydGVkUmVuZGVyZXJWZXJzaW9uOiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdCgnZ2V0SWZIYXNVbnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbicpO1xuICB9O1xuXG4gIG9uVW5zdXBwb3J0ZWRSZW5kZXJlcigpIHtcbiAgICB0aGlzLl9icmlkZ2Uuc2VuZCgndW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb24nKTtcbiAgfVxuXG4gIF9wZXJzaXN0U2VsZWN0aW9uVGltZXJTY2hlZHVsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgX2xhc3RTZWxlY3RlZFJlbmRlcmVySUQ6IG51bWJlciA9IC0xO1xuICBfbGFzdFNlbGVjdGVkRWxlbWVudElEOiBudW1iZXIgPSAtMTtcbiAgX3BlcnNpc3RTZWxlY3Rpb246IGFueSA9ICgpID0+IHtcbiAgICB0aGlzLl9wZXJzaXN0U2VsZWN0aW9uVGltZXJTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjb25zdCByZW5kZXJlcklEID0gdGhpcy5fbGFzdFNlbGVjdGVkUmVuZGVyZXJJRDtcbiAgICBjb25zdCBpZCA9IHRoaXMuX2xhc3RTZWxlY3RlZEVsZW1lbnRJRDtcbiAgICAvLyBUaGlzIGlzIHRocm90dGxlZCwgc28gYm90aCByZW5kZXJlciBhbmQgc2VsZWN0ZWQgSURcbiAgICAvLyBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGJ5IHRoZSB0aW1lIHdlIHJlYWQgdGhlbS5cbiAgICAvLyBUaGlzIGlzIHdoeSB3ZSBuZWVkIHRoZSBkZWZlbnNpdmUgY2hlY2tzIGhlcmUuXG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgY29uc3QgcGF0aCA9IHJlbmRlcmVyICE9IG51bGwgPyByZW5kZXJlci5nZXRQYXRoRm9yRWxlbWVudChpZCkgOiBudWxsO1xuICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZVNldEl0ZW0oXG4gICAgICAgIFNFU1NJT05fU1RPUkFHRV9MQVNUX1NFTEVDVElPTl9LRVksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KCh7cmVuZGVyZXJJRCwgcGF0aH06IFBlcnNpc3RlZFNlbGVjdGlvbikpLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKFNFU1NJT05fU1RPUkFHRV9MQVNUX1NFTEVDVElPTl9LRVkpO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/agent.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/fiber/DevToolsFiberComponentStack.js":
/*!*********************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/fiber/DevToolsFiberComponentStack.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"describeFiber\": () => (/* binding */ describeFiber),\n/* harmony export */   \"getOwnerStackByFiberInDev\": () => (/* binding */ getOwnerStackByFiberInDev),\n/* harmony export */   \"getSourceLocationByFiber\": () => (/* binding */ getSourceLocationByFiber),\n/* harmony export */   \"getStackByFiberInDevAndProd\": () => (/* binding */ getStackByFiberInDevAndProd),\n/* harmony export */   \"supportsConsoleTasks\": () => (/* binding */ supportsConsoleTasks),\n/* harmony export */   \"supportsOwnerStacks\": () => (/* binding */ supportsOwnerStacks)\n/* harmony export */ });\n/* harmony import */ var _shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/DevToolsComponentStackFrame */ \"../react-devtools-shared/src/backend/shared/DevToolsComponentStackFrame.js\");\n/* harmony import */ var _shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/DevToolsOwnerStack */ \"../react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactFiberComponentStack.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n\n\nfunction describeFiber(workTagMap, workInProgress, currentDispatcherRef) {\n  var HostHoistable = workTagMap.HostHoistable,\n      HostSingleton = workTagMap.HostSingleton,\n      HostComponent = workTagMap.HostComponent,\n      LazyComponent = workTagMap.LazyComponent,\n      SuspenseComponent = workTagMap.SuspenseComponent,\n      SuspenseListComponent = workTagMap.SuspenseListComponent,\n      FunctionComponent = workTagMap.FunctionComponent,\n      IndeterminateComponent = workTagMap.IndeterminateComponent,\n      SimpleMemoComponent = workTagMap.SimpleMemoComponent,\n      ForwardRef = workTagMap.ForwardRef,\n      ClassComponent = workTagMap.ClassComponent,\n      ViewTransitionComponent = workTagMap.ViewTransitionComponent;\n\n  switch (workInProgress.tag) {\n    case HostHoistable:\n    case HostSingleton:\n    case HostComponent:\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)(workInProgress.type);\n\n    case LazyComponent:\n      // TODO: When we support Thenables as component types we should rename this.\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)('Lazy');\n\n    case SuspenseComponent:\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)('Suspense');\n\n    case SuspenseListComponent:\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)('SuspenseList');\n\n    case ViewTransitionComponent:\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)('ViewTransition');\n\n    case FunctionComponent:\n    case IndeterminateComponent:\n    case SimpleMemoComponent:\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeFunctionComponentFrame)(workInProgress.type, currentDispatcherRef);\n\n    case ForwardRef:\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeFunctionComponentFrame)(workInProgress.type.render, currentDispatcherRef);\n\n    case ClassComponent:\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeClassComponentFrame)(workInProgress.type, currentDispatcherRef);\n\n    default:\n      return '';\n  }\n}\nfunction getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {\n  try {\n    var info = '';\n    var node = workInProgress;\n\n    do {\n      info += describeFiber(workTagMap, node, currentDispatcherRef); // Add any Server Component stack frames in reverse order.\n\n      var debugInfo = node._debugInfo;\n\n      if (debugInfo) {\n        for (var i = debugInfo.length - 1; i >= 0; i--) {\n          var entry = debugInfo[i];\n\n          if (typeof entry.name === 'string') {\n            info += (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeDebugInfoFrame)(entry.name, entry.env);\n          }\n        }\n      } // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n      node = node.return;\n    } while (node);\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}\nfunction getSourceLocationByFiber(workTagMap, fiber, currentDispatcherRef) {\n  // This is like getStackByFiberInDevAndProd but just the first stack frame.\n  try {\n    var info = describeFiber(workTagMap, fiber, currentDispatcherRef);\n\n    if (info !== '') {\n      return info.slice(1); // skip the leading newline\n    }\n  } catch (x) {\n    console.error(x);\n  }\n\n  return null;\n}\nfunction supportsConsoleTasks(fiber) {\n  // If this Fiber supports native console.createTask then we are already running\n  // inside a native async stack trace if it's active - meaning the DevTools is open.\n  // Ideally we'd detect if this task was created while the DevTools was open or not.\n  return !!fiber._debugTask;\n}\nfunction supportsOwnerStacks(fiber) {\n  // If this Fiber supports owner stacks then it'll have the _debugStack field.\n  // It might be null but that still means we should use the owner stack logic.\n  return fiber._debugStack !== undefined;\n}\nfunction getOwnerStackByFiberInDev(workTagMap, workInProgress, currentDispatcherRef) {\n  var HostHoistable = workTagMap.HostHoistable,\n      HostSingleton = workTagMap.HostSingleton,\n      HostText = workTagMap.HostText,\n      HostComponent = workTagMap.HostComponent,\n      SuspenseComponent = workTagMap.SuspenseComponent,\n      SuspenseListComponent = workTagMap.SuspenseListComponent,\n      ViewTransitionComponent = workTagMap.ViewTransitionComponent;\n\n  try {\n    var info = '';\n\n    if (workInProgress.tag === HostText) {\n      // Text nodes never have an owner/stack because they're not created through JSX.\n      // We use the parent since text nodes are always created through a host parent.\n      workInProgress = workInProgress.return;\n    } // The owner stack of the current fiber will be where it was created, i.e. inside its owner.\n    // There's no actual name of the currently executing component. Instead, that is available\n    // on the regular stack that's currently executing. However, for built-ins there is no such\n    // named stack frame and it would be ignored as being internal anyway. Therefore we add\n    // add one extra frame just to describe the \"current\" built-in component by name.\n\n\n    switch (workInProgress.tag) {\n      case HostHoistable:\n      case HostSingleton:\n      case HostComponent:\n        info += (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)(workInProgress.type);\n        break;\n\n      case SuspenseComponent:\n        info += (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)('Suspense');\n        break;\n\n      case SuspenseListComponent:\n        info += (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)('SuspenseList');\n        break;\n\n      case ViewTransitionComponent:\n        info += (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)('ViewTransition');\n        break;\n    }\n\n    var owner = workInProgress;\n\n    while (owner) {\n      if (typeof owner.tag === 'number') {\n        var fiber = owner;\n        owner = fiber._debugOwner;\n        var debugStack = fiber._debugStack; // If we don't actually print the stack if there is no owner of this JSX element.\n        // In a real app it's typically not useful since the root app is always controlled\n        // by the framework. These also tend to have noisy stacks because they're not rooted\n        // in a React render but in some imperative bootstrapping code. It could be useful\n        // if the element was created in module scope. E.g. hoisted. We could add a a single\n        // stack frame for context for example but it doesn't say much if that's a wrapper.\n\n        if (owner && debugStack) {\n          if (typeof debugStack !== 'string') {\n            debugStack = (0,_shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_1__.formatOwnerStack)(debugStack);\n          }\n\n          if (debugStack !== '') {\n            info += '\\n' + debugStack;\n          }\n        }\n      } else if (owner.debugStack != null) {\n        // Server Component\n        var ownerStack = owner.debugStack;\n        owner = owner.owner;\n\n        if (owner && ownerStack) {\n          info += '\\n' + (0,_shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_1__.formatOwnerStack)(ownerStack);\n        }\n      } else {\n        break;\n      }\n    }\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZpYmVyL0RldlRvb2xzRmliZXJDb21wb25lbnRTdGFjay5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFPQTtBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBOztBQUlBO0FBQ0E7O0FBSUE7QUFDQTtBQWhDQTtBQWtDQTtBQUVBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQWRBOztBQWlCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvZmliZXIvRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrLmpzP2M3NzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLy8gVGhpcyBpcyBhIERldlRvb2xzIGZvcmsgb2YgUmVhY3RGaWJlckNvbXBvbmVudFN0YWNrLlxuLy8gVGhpcyBmb3JrIGVuYWJsZXMgRGV2VG9vbHMgdG8gdXNlIHRoZSBzYW1lIFwibmF0aXZlXCIgY29tcG9uZW50IHN0YWNrIGZvcm1hdCxcbi8vIHdoaWxlIHN0aWxsIG1haW50YWluaW5nIHN1cHBvcnQgZm9yIG11bHRpcGxlIHJlbmRlcmVyIHZlcnNpb25zXG4vLyAod2hpY2ggdXNlIGRpZmZlcmVudCB2YWx1ZXMgZm9yIFJlYWN0VHlwZU9mV29yaykuXG5cbmltcG9ydCB0eXBlIHtGaWJlcn0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RJbnRlcm5hbFR5cGVzJztcbmltcG9ydCB0eXBlIHtDdXJyZW50RGlzcGF0Y2hlclJlZiwgV29ya1RhZ01hcH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgdHlwZSB7UmVhY3RDb21wb25lbnRJbmZvfSBmcm9tICdzaGFyZWQvUmVhY3RUeXBlcyc7XG5cbmltcG9ydCB7XG4gIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lLFxuICBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUsXG4gIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZSxcbiAgZGVzY3JpYmVEZWJ1Z0luZm9GcmFtZSxcbn0gZnJvbSAnLi4vc2hhcmVkL0RldlRvb2xzQ29tcG9uZW50U3RhY2tGcmFtZSc7XG5cbmltcG9ydCB7Zm9ybWF0T3duZXJTdGFja30gZnJvbSAnLi4vc2hhcmVkL0RldlRvb2xzT3duZXJTdGFjayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZUZpYmVyKFxuICB3b3JrVGFnTWFwOiBXb3JrVGFnTWFwLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbik6IHN0cmluZyB7XG4gIGNvbnN0IHtcbiAgICBIb3N0SG9pc3RhYmxlLFxuICAgIEhvc3RTaW5nbGV0b24sXG4gICAgSG9zdENvbXBvbmVudCxcbiAgICBMYXp5Q29tcG9uZW50LFxuICAgIFN1c3BlbnNlQ29tcG9uZW50LFxuICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudCxcbiAgICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgICBJbmRldGVybWluYXRlQ29tcG9uZW50LFxuICAgIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgRm9yd2FyZFJlZixcbiAgICBDbGFzc0NvbXBvbmVudCxcbiAgICBWaWV3VHJhbnNpdGlvbkNvbXBvbmVudCxcbiAgfSA9IHdvcmtUYWdNYXA7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKTtcbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICAvLyBUT0RPOiBXaGVuIHdlIHN1cHBvcnQgVGhlbmFibGVzIGFzIGNvbXBvbmVudCB0eXBlcyB3ZSBzaG91bGQgcmVuYW1lIHRoaXMuXG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknKTtcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgICBjYXNlIFZpZXdUcmFuc2l0aW9uQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdWaWV3VHJhbnNpdGlvbicpO1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmLFxuICAgICAgKTtcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLnJlbmRlcixcbiAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICApO1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKFxuICB3b3JrVGFnTWFwOiBXb3JrVGFnTWFwLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbik6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgbGV0IGluZm8gPSAnJztcbiAgICBsZXQgbm9kZTogRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya1RhZ01hcCwgbm9kZSwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuICAgICAgLy8gQWRkIGFueSBTZXJ2ZXIgQ29tcG9uZW50IHN0YWNrIGZyYW1lcyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgY29uc3QgZGVidWdJbmZvID0gbm9kZS5fZGVidWdJbmZvO1xuICAgICAgaWYgKGRlYnVnSW5mbykge1xuICAgICAgICBmb3IgKGxldCBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5mbyArPSBkZXNjcmliZURlYnVnSW5mb0ZyYW1lKGVudHJ5Lm5hbWUsIGVudHJ5LmVudik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U291cmNlTG9jYXRpb25CeUZpYmVyKFxuICB3b3JrVGFnTWFwOiBXb3JrVGFnTWFwLFxuICBmaWJlcjogRmliZXIsXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbik6IG51bGwgfCBzdHJpbmcge1xuICAvLyBUaGlzIGlzIGxpa2UgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIGJ1dCBqdXN0IHRoZSBmaXJzdCBzdGFjayBmcmFtZS5cbiAgdHJ5IHtcbiAgICBjb25zdCBpbmZvID0gZGVzY3JpYmVGaWJlcih3b3JrVGFnTWFwLCBmaWJlciwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuICAgIGlmIChpbmZvICE9PSAnJykge1xuICAgICAgcmV0dXJuIGluZm8uc2xpY2UoMSk7IC8vIHNraXAgdGhlIGxlYWRpbmcgbmV3bGluZVxuICAgIH1cbiAgfSBjYXRjaCAoeCkge1xuICAgIGNvbnNvbGUuZXJyb3IoeCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0NvbnNvbGVUYXNrcyhmaWJlcjogRmliZXIpOiBib29sZWFuIHtcbiAgLy8gSWYgdGhpcyBGaWJlciBzdXBwb3J0cyBuYXRpdmUgY29uc29sZS5jcmVhdGVUYXNrIHRoZW4gd2UgYXJlIGFscmVhZHkgcnVubmluZ1xuICAvLyBpbnNpZGUgYSBuYXRpdmUgYXN5bmMgc3RhY2sgdHJhY2UgaWYgaXQncyBhY3RpdmUgLSBtZWFuaW5nIHRoZSBEZXZUb29scyBpcyBvcGVuLlxuICAvLyBJZGVhbGx5IHdlJ2QgZGV0ZWN0IGlmIHRoaXMgdGFzayB3YXMgY3JlYXRlZCB3aGlsZSB0aGUgRGV2VG9vbHMgd2FzIG9wZW4gb3Igbm90LlxuICByZXR1cm4gISFmaWJlci5fZGVidWdUYXNrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNPd25lclN0YWNrcyhmaWJlcjogRmliZXIpOiBib29sZWFuIHtcbiAgLy8gSWYgdGhpcyBGaWJlciBzdXBwb3J0cyBvd25lciBzdGFja3MgdGhlbiBpdCdsbCBoYXZlIHRoZSBfZGVidWdTdGFjayBmaWVsZC5cbiAgLy8gSXQgbWlnaHQgYmUgbnVsbCBidXQgdGhhdCBzdGlsbCBtZWFucyB3ZSBzaG91bGQgdXNlIHRoZSBvd25lciBzdGFjayBsb2dpYy5cbiAgcmV0dXJuIGZpYmVyLl9kZWJ1Z1N0YWNrICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lclN0YWNrQnlGaWJlckluRGV2KFxuICB3b3JrVGFnTWFwOiBXb3JrVGFnTWFwLFxuICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbik6IHN0cmluZyB7XG4gIGNvbnN0IHtcbiAgICBIb3N0SG9pc3RhYmxlLFxuICAgIEhvc3RTaW5nbGV0b24sXG4gICAgSG9zdFRleHQsXG4gICAgSG9zdENvbXBvbmVudCxcbiAgICBTdXNwZW5zZUNvbXBvbmVudCxcbiAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQsXG4gICAgVmlld1RyYW5zaXRpb25Db21wb25lbnQsXG4gIH0gPSB3b3JrVGFnTWFwO1xuICB0cnkge1xuICAgIGxldCBpbmZvID0gJyc7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gVGV4dCBub2RlcyBuZXZlciBoYXZlIGFuIG93bmVyL3N0YWNrIGJlY2F1c2UgdGhleSdyZSBub3QgY3JlYXRlZCB0aHJvdWdoIEpTWC5cbiAgICAgIC8vIFdlIHVzZSB0aGUgcGFyZW50IHNpbmNlIHRleHQgbm9kZXMgYXJlIGFsd2F5cyBjcmVhdGVkIHRocm91Z2ggYSBob3N0IHBhcmVudC5cbiAgICAgIHdvcmtJblByb2dyZXNzID0gKHdvcmtJblByb2dyZXNzLnJldHVybjogYW55KTtcbiAgICB9XG5cbiAgICAvLyBUaGUgb3duZXIgc3RhY2sgb2YgdGhlIGN1cnJlbnQgZmliZXIgd2lsbCBiZSB3aGVyZSBpdCB3YXMgY3JlYXRlZCwgaS5lLiBpbnNpZGUgaXRzIG93bmVyLlxuICAgIC8vIFRoZXJlJ3Mgbm8gYWN0dWFsIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgY29tcG9uZW50LiBJbnN0ZWFkLCB0aGF0IGlzIGF2YWlsYWJsZVxuICAgIC8vIG9uIHRoZSByZWd1bGFyIHN0YWNrIHRoYXQncyBjdXJyZW50bHkgZXhlY3V0aW5nLiBIb3dldmVyLCBmb3IgYnVpbHQtaW5zIHRoZXJlIGlzIG5vIHN1Y2hcbiAgICAvLyBuYW1lZCBzdGFjayBmcmFtZSBhbmQgaXQgd291bGQgYmUgaWdub3JlZCBhcyBiZWluZyBpbnRlcm5hbCBhbnl3YXkuIFRoZXJlZm9yZSB3ZSBhZGRcbiAgICAvLyBhZGQgb25lIGV4dHJhIGZyYW1lIGp1c3QgdG8gZGVzY3JpYmUgdGhlIFwiY3VycmVudFwiIGJ1aWx0LWluIGNvbXBvbmVudCBieSBuYW1lLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGluZm8gKz0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUod29ya0luUHJvZ3Jlc3MudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWaWV3VHJhbnNpdGlvbkNvbXBvbmVudDpcbiAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnVmlld1RyYW5zaXRpb24nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGV0IG93bmVyOiB2b2lkIHwgbnVsbCB8IEZpYmVyIHwgUmVhY3RDb21wb25lbnRJbmZvID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICB3aGlsZSAob3duZXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3duZXIudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBmaWJlcjogRmliZXIgPSAob3duZXI6IGFueSk7XG4gICAgICAgIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICAgIGxldCBkZWJ1Z1N0YWNrID0gZmliZXIuX2RlYnVnU3RhY2s7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGFjdHVhbGx5IHByaW50IHRoZSBzdGFjayBpZiB0aGVyZSBpcyBubyBvd25lciBvZiB0aGlzIEpTWCBlbGVtZW50LlxuICAgICAgICAvLyBJbiBhIHJlYWwgYXBwIGl0J3MgdHlwaWNhbGx5IG5vdCB1c2VmdWwgc2luY2UgdGhlIHJvb3QgYXBwIGlzIGFsd2F5cyBjb250cm9sbGVkXG4gICAgICAgIC8vIGJ5IHRoZSBmcmFtZXdvcmsuIFRoZXNlIGFsc28gdGVuZCB0byBoYXZlIG5vaXN5IHN0YWNrcyBiZWNhdXNlIHRoZXkncmUgbm90IHJvb3RlZFxuICAgICAgICAvLyBpbiBhIFJlYWN0IHJlbmRlciBidXQgaW4gc29tZSBpbXBlcmF0aXZlIGJvb3RzdHJhcHBpbmcgY29kZS4gSXQgY291bGQgYmUgdXNlZnVsXG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IHdhcyBjcmVhdGVkIGluIG1vZHVsZSBzY29wZS4gRS5nLiBob2lzdGVkLiBXZSBjb3VsZCBhZGQgYSBhIHNpbmdsZVxuICAgICAgICAvLyBzdGFjayBmcmFtZSBmb3IgY29udGV4dCBmb3IgZXhhbXBsZSBidXQgaXQgZG9lc24ndCBzYXkgbXVjaCBpZiB0aGF0J3MgYSB3cmFwcGVyLlxuICAgICAgICBpZiAob3duZXIgJiYgZGVidWdTdGFjaykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGVidWdTdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRlYnVnU3RhY2sgPSBmb3JtYXRPd25lclN0YWNrKGRlYnVnU3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdTdGFjayAhPT0gJycpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcbicgKyBkZWJ1Z1N0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvd25lci5kZWJ1Z1N0YWNrICE9IG51bGwpIHtcbiAgICAgICAgLy8gU2VydmVyIENvbXBvbmVudFxuICAgICAgICBjb25zdCBvd25lclN0YWNrOiBFcnJvciA9IG93bmVyLmRlYnVnU3RhY2s7XG4gICAgICAgIG93bmVyID0gb3duZXIub3duZXI7XG4gICAgICAgIGlmIChvd25lciAmJiBvd25lclN0YWNrKSB7XG4gICAgICAgICAgaW5mbyArPSAnXFxuJyArIGZvcm1hdE93bmVyU3RhY2sob3duZXJTdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/fiber/DevToolsFiberComponentStack.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/fiber/renderer.js":
/*!**************************************************************!*\
  !*** ../react-devtools-shared/src/backend/fiber/renderer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"attach\": () => (/* binding */ attach),\n/* harmony export */   \"getDispatcherRef\": () => (/* binding */ getDispatcherRef),\n/* harmony export */   \"getInternalReactConstants\": () => (/* binding */ getInternalReactConstants)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/frontend/types */ \"../react-devtools-shared/src/frontend/types.js\");\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/* harmony import */ var react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var react_debug_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-debug-tools */ \"../../build/oss-experimental/react-debug-tools/index.js\");\n/* harmony import */ var _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/ReactSymbols */ \"../react-devtools-shared/src/backend/shared/ReactSymbols.js\");\n/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-devtools-feature-flags */ \"../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js\");\n/* harmony import */ var _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shared/DevToolsServerComponentLogs */ \"../react-devtools-shared/src/backend/shared/DevToolsServerComponentLogs.js\");\n/* harmony import */ var shared_objectIs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! shared/objectIs */ \"../shared/objectIs.js\");\n/* harmony import */ var shared_hasOwnProperty__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! shared/hasOwnProperty */ \"../shared/hasOwnProperty.js\");\n/* harmony import */ var _DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DevToolsFiberComponentStack */ \"../react-devtools-shared/src/backend/fiber/DevToolsFiberComponentStack.js\");\n/* harmony import */ var _StyleX_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../StyleX/utils */ \"../react-devtools-shared/src/backend/StyleX/utils.js\");\n/* harmony import */ var _profilingHooks__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../profilingHooks */ \"../react-devtools-shared/src/backend/profilingHooks.js\");\n/* harmony import */ var _shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../shared/DevToolsOwnerStack */ \"../react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js\");\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\n\n // $FlowFixMe[method-unbinding]\n\nvar toString = Object.prototype.toString;\n\nfunction isError(object) {\n  return toString.call(object) === '[object Error]';\n}\n\n\n\n\n // Kinds\n\nvar FIBER_INSTANCE = 0;\nvar VIRTUAL_INSTANCE = 1;\nvar FILTERED_FIBER_INSTANCE = 2; // This type represents a stateful instance of a Client Component i.e. a Fiber pair.\n// These instances also let us track stateful DevTools meta data like id and warnings.\n\nfunction createFiberInstance(fiber) {\n  return {\n    kind: FIBER_INSTANCE,\n    id: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getUID)(),\n    parent: null,\n    firstChild: null,\n    nextSibling: null,\n    source: null,\n    logCount: 0,\n    treeBaseDuration: 0,\n    data: fiber\n  };\n}\n\n// This is used to represent a filtered Fiber but still lets us find its host instance.\nfunction createFilteredFiberInstance(fiber) {\n  return {\n    kind: FILTERED_FIBER_INSTANCE,\n    id: 0,\n    parent: null,\n    firstChild: null,\n    nextSibling: null,\n    source: null,\n    logCount: 0,\n    treeBaseDuration: 0,\n    data: fiber\n  };\n} // This type represents a stateful instance of a Server Component or a Component\n// that gets optimized away - e.g. call-through without creating a Fiber.\n// It's basically a virtual Fiber. This is not a semantic concept in React.\n// It only exists as a virtual concept to let the same Element in the DevTools\n// persist. To be selectable separately from all ReactComponentInfo and overtime.\n\n\nfunction createVirtualInstance(debugEntry) {\n  return {\n    kind: VIRTUAL_INSTANCE,\n    id: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getUID)(),\n    parent: null,\n    firstChild: null,\n    nextSibling: null,\n    source: null,\n    logCount: 0,\n    treeBaseDuration: 0,\n    data: debugEntry\n  };\n}\n\nfunction getDispatcherRef(renderer) {\n  if (renderer.currentDispatcherRef === undefined) {\n    return undefined;\n  }\n\n  var injectedRef = renderer.currentDispatcherRef;\n\n  if (typeof injectedRef.H === 'undefined' && typeof injectedRef.current !== 'undefined') {\n    // We got a legacy dispatcher injected, let's create a wrapper proxy to translate.\n    return {\n      get H() {\n        return injectedRef.current;\n      },\n\n      set H(value) {\n        injectedRef.current = value;\n      }\n\n    };\n  }\n\n  return injectedRef;\n}\n\nfunction getFiberFlags(fiber) {\n  // The name of this field changed from \"effectTag\" to \"flags\"\n  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;\n} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\nvar getCurrentTime = // $FlowFixMe[method-unbinding]\n(typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction getInternalReactConstants(version) {\n  // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // Technically these priority levels are invalid for versions before 16.9,\n  // but 16.9 is the first version to report priority level to DevTools,\n  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.\n  var ReactPriorityLevels = {\n    ImmediatePriority: 99,\n    UserBlockingPriority: 98,\n    NormalPriority: 97,\n    LowPriority: 96,\n    IdlePriority: 95,\n    NoPriority: 90\n  };\n\n  if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gt)(version, '17.0.2')) {\n    ReactPriorityLevels = {\n      ImmediatePriority: 1,\n      UserBlockingPriority: 2,\n      NormalPriority: 3,\n      LowPriority: 4,\n      IdlePriority: 5,\n      NoPriority: 0\n    };\n  }\n\n  var StrictModeBits = 0;\n\n  if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gte)(version, '18.0.0-alpha')) {\n    // 18+\n    StrictModeBits = 24;\n  } else if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gte)(version, '16.9.0')) {\n    // 16.9 - 17\n    StrictModeBits = 1;\n  } else if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gte)(version, '16.3.0')) {\n    // 16.3 - 16.8\n    StrictModeBits = 2;\n  }\n\n  var ReactTypeOfWork = null; // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // TODO Update the gt() check below to be gte() whichever the next version number is.\n  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).\n\n  if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gt)(version, '17.0.1')) {\n    ReactTypeOfWork = {\n      CacheComponent: 24,\n      // Experimental\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: 26,\n      // In reality, 18.2+. But doesn't hurt to include it here\n      HostSingleton: 27,\n      // Same as above\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IncompleteFunctionComponent: 28,\n      IndeterminateComponent: 2,\n      // removed in 19.0.0\n      LazyComponent: 16,\n      LegacyHiddenComponent: 23,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 22,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: 25,\n      // Experimental - This is technically in 18 but we don't\n      // want to fork again so we're adding it here instead\n      YieldComponent: -1,\n      // Removed\n      Throw: 29,\n      ViewTransitionComponent: 30 // Experimental\n\n    };\n  } else if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gte)(version, '17.0.0-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IncompleteFunctionComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: 24,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 23,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1,\n      // Removed\n      Throw: -1,\n      // Doesn't exist yet\n      ViewTransitionComponent: -1 // Doesn't exist yet\n\n    };\n  } else if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gte)(version, '16.6.0-beta.0')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IncompleteFunctionComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: -1,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1,\n      // Removed\n      Throw: -1,\n      // Doesn't exist yet\n      ViewTransitionComponent: -1 // Doesn't exist yet\n\n    };\n  } else if ((0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.gte)(version, '16.4.3-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 11,\n      ContextProvider: 12,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 13,\n      Fragment: 9,\n      FunctionComponent: 0,\n      HostComponent: 7,\n      HostPortal: 6,\n      HostRoot: 5,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 8,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IncompleteFunctionComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 4,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 10,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1,\n      // Removed\n      Throw: -1,\n      // Doesn't exist yet\n      ViewTransitionComponent: -1 // Doesn't exist yet\n\n    };\n  } else {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 12,\n      ContextProvider: 13,\n      CoroutineComponent: 7,\n      CoroutineHandlerPhase: 8,\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 14,\n      Fragment: 10,\n      FunctionComponent: 1,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostHoistable: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IncompleteFunctionComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 0,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 11,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: 9,\n      Throw: -1,\n      // Doesn't exist yet\n      ViewTransitionComponent: -1 // Doesn't exist yet\n\n    };\n  } // **********************************************************\n  // End of copied code.\n  // **********************************************************\n\n\n  function getTypeSymbol(type) {\n    var symbolOrNumber = _typeof(type) === 'object' && type !== null ? type.$$typeof : type;\n    return _typeof(symbolOrNumber) === 'symbol' ? // $FlowFixMe[incompatible-return] `toString()` doesn't match the type signature?\n    symbolOrNumber.toString() : symbolOrNumber;\n  }\n\n  var _ReactTypeOfWork = ReactTypeOfWork,\n      CacheComponent = _ReactTypeOfWork.CacheComponent,\n      ClassComponent = _ReactTypeOfWork.ClassComponent,\n      IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,\n      IncompleteFunctionComponent = _ReactTypeOfWork.IncompleteFunctionComponent,\n      FunctionComponent = _ReactTypeOfWork.FunctionComponent,\n      IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,\n      ForwardRef = _ReactTypeOfWork.ForwardRef,\n      HostRoot = _ReactTypeOfWork.HostRoot,\n      HostHoistable = _ReactTypeOfWork.HostHoistable,\n      HostSingleton = _ReactTypeOfWork.HostSingleton,\n      HostComponent = _ReactTypeOfWork.HostComponent,\n      HostPortal = _ReactTypeOfWork.HostPortal,\n      HostText = _ReactTypeOfWork.HostText,\n      Fragment = _ReactTypeOfWork.Fragment,\n      LazyComponent = _ReactTypeOfWork.LazyComponent,\n      LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent,\n      MemoComponent = _ReactTypeOfWork.MemoComponent,\n      OffscreenComponent = _ReactTypeOfWork.OffscreenComponent,\n      Profiler = _ReactTypeOfWork.Profiler,\n      ScopeComponent = _ReactTypeOfWork.ScopeComponent,\n      SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,\n      SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,\n      SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent,\n      TracingMarkerComponent = _ReactTypeOfWork.TracingMarkerComponent,\n      Throw = _ReactTypeOfWork.Throw,\n      ViewTransitionComponent = _ReactTypeOfWork.ViewTransitionComponent;\n\n  function resolveFiberType(type) {\n    var typeSymbol = getTypeSymbol(type);\n\n    switch (typeSymbol) {\n      case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.MEMO_NUMBER:\n      case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.MEMO_SYMBOL_STRING:\n        // recursively resolving memo type in case of memo(forwardRef(Component))\n        return resolveFiberType(type.type);\n\n      case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.FORWARD_REF_NUMBER:\n      case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.FORWARD_REF_SYMBOL_STRING:\n        return type.render;\n\n      default:\n        return type;\n    }\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getDisplayNameForFiber(fiber) {\n    var _fiber$updateQueue, _fiber$memoizedState, _fiber$memoizedState$, _fiber$memoizedState2, _fiber$memoizedState3;\n\n    var shouldSkipForgetCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var elementType = fiber.elementType,\n        type = fiber.type,\n        tag = fiber.tag;\n    var resolvedType = type;\n\n    if (_typeof(type) === 'object' && type !== null) {\n      resolvedType = resolveFiberType(type);\n    }\n\n    var resolvedContext = null;\n\n    if (!shouldSkipForgetCheck && ( // $FlowFixMe[incompatible-type] fiber.updateQueue is mixed\n    ((_fiber$updateQueue = fiber.updateQueue) === null || _fiber$updateQueue === void 0 ? void 0 : _fiber$updateQueue.memoCache) != null || Array.isArray((_fiber$memoizedState = fiber.memoizedState) === null || _fiber$memoizedState === void 0 ? void 0 : _fiber$memoizedState.memoizedState) && ((_fiber$memoizedState$ = fiber.memoizedState.memoizedState[0]) === null || _fiber$memoizedState$ === void 0 ? void 0 : _fiber$memoizedState$[_shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.REACT_MEMO_CACHE_SENTINEL]) || ((_fiber$memoizedState2 = fiber.memoizedState) === null || _fiber$memoizedState2 === void 0 ? void 0 : (_fiber$memoizedState3 = _fiber$memoizedState2.memoizedState) === null || _fiber$memoizedState3 === void 0 ? void 0 : _fiber$memoizedState3[_shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.REACT_MEMO_CACHE_SENTINEL]))) {\n      var displayNameWithoutForgetWrapper = getDisplayNameForFiber(fiber, true);\n\n      if (displayNameWithoutForgetWrapper == null) {\n        return null;\n      }\n\n      return \"Forget(\".concat(displayNameWithoutForgetWrapper, \")\");\n    }\n\n    switch (tag) {\n      case CacheComponent:\n        return 'Cache';\n\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IncompleteFunctionComponent:\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getDisplayName)(resolvedType);\n\n      case ForwardRef:\n        return (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getWrappedDisplayName)(elementType, resolvedType, 'ForwardRef', 'Anonymous');\n\n      case HostRoot:\n        var fiberRoot = fiber.stateNode;\n\n        if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n          return fiberRoot._debugRootType;\n        }\n\n        return null;\n\n      case HostComponent:\n      case HostSingleton:\n      case HostHoistable:\n        return type;\n\n      case HostPortal:\n      case HostText:\n        return null;\n\n      case Fragment:\n        return 'Fragment';\n\n      case LazyComponent:\n        // This display name will not be user visible.\n        // Once a Lazy component loads its inner component, React replaces the tag and type.\n        // This display name will only show up in console logs when DevTools DEBUG mode is on.\n        return 'Lazy';\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        // Display name in React does not use `Memo` as a wrapper but fallback name.\n        return (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getWrappedDisplayName)(elementType, resolvedType, 'Memo', 'Anonymous');\n\n      case SuspenseComponent:\n        return 'Suspense';\n\n      case LegacyHiddenComponent:\n        return 'LegacyHidden';\n\n      case OffscreenComponent:\n        return 'Offscreen';\n\n      case ScopeComponent:\n        return 'Scope';\n\n      case SuspenseListComponent:\n        return 'SuspenseList';\n\n      case Profiler:\n        return 'Profiler';\n\n      case TracingMarkerComponent:\n        return 'TracingMarker';\n\n      case ViewTransitionComponent:\n        return 'ViewTransition';\n\n      case Throw:\n        // This should really never be visible.\n        return 'Error';\n\n      default:\n        var typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONCURRENT_MODE_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONCURRENT_MODE_SYMBOL_STRING:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.DEPRECATED_ASYNC_MODE_SYMBOL_STRING:\n            return null;\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROVIDER_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROVIDER_SYMBOL_STRING:\n            // 16.3.0 exposed the context object as \"context\"\n            // PR #12501 changed it to \"_context\" for 16.3.1+\n            // NOTE Keep in sync with inspectElementRaw()\n            resolvedContext = fiber.type._context || fiber.type.context;\n            return \"\".concat(resolvedContext.displayName || 'Context', \".Provider\");\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONTEXT_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONTEXT_SYMBOL_STRING:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.SERVER_CONTEXT_SYMBOL_STRING:\n            if (fiber.type._context === undefined && fiber.type.Provider === fiber.type) {\n              // In 19+, Context.Provider === Context, so this is a provider.\n              resolvedContext = fiber.type;\n              return \"\".concat(resolvedContext.displayName || 'Context', \".Provider\");\n            } // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n            // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n            // NOTE Keep in sync with inspectElementRaw()\n\n\n            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'\n            // If you change the name, figure out a more resilient way to detect it.\n\n            return \"\".concat(resolvedContext.displayName || 'Context', \".Consumer\");\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONSUMER_SYMBOL_STRING:\n            // 19+\n            resolvedContext = fiber.type._context;\n            return \"\".concat(resolvedContext.displayName || 'Context', \".Consumer\");\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.STRICT_MODE_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.STRICT_MODE_SYMBOL_STRING:\n            return null;\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROFILER_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROFILER_SYMBOL_STRING:\n            return \"Profiler(\".concat(fiber.memoizedProps.id, \")\");\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.SCOPE_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.SCOPE_SYMBOL_STRING:\n            return 'Scope';\n\n          default:\n            // Unknown element type.\n            // This may mean a new element type that has not yet been added to DevTools.\n            return null;\n        }\n\n    }\n  }\n\n  return {\n    getDisplayNameForFiber: getDisplayNameForFiber,\n    getTypeSymbol: getTypeSymbol,\n    ReactPriorityLevels: ReactPriorityLevels,\n    ReactTypeOfWork: ReactTypeOfWork,\n    StrictModeBits: StrictModeBits\n  };\n} // All environment names we've seen so far. This lets us create a list of filters to apply.\n// This should ideally include env of filtered Components too so that you can add those as\n// filters at the same time as removing some other filter.\n\nvar knownEnvironmentNames = new Set(); // Map of FiberRoot to their root FiberInstance.\n\nvar rootToFiberInstanceMap = new Map(); // Map of id to FiberInstance or VirtualInstance.\n// This Map is used to e.g. get the display name for a Fiber or schedule an update,\n// operations that should be the same whether the current and work-in-progress Fiber is used.\n\nvar idToDevToolsInstanceMap = new Map(); // Map of canonical HostInstances to the nearest parent DevToolsInstance.\n\nvar publicInstanceToDevToolsInstanceMap = new Map(); // Map of resource DOM nodes to all the nearest DevToolsInstances that depend on it.\n\nvar hostResourceToDevToolsInstanceMap = new Map(); // Ideally, this should be injected from Reconciler config\n\nfunction getPublicInstance(instance) {\n  // Typically the PublicInstance and HostInstance is the same thing but not in Fabric.\n  // So we need to detect this and use that as the public instance.\n  // React Native. Modern. Fabric.\n  if (_typeof(instance) === 'object' && instance !== null) {\n    if (_typeof(instance.canonical) === 'object' && instance.canonical !== null) {\n      if (_typeof(instance.canonical.publicInstance) === 'object' && instance.canonical.publicInstance !== null) {\n        return instance.canonical.publicInstance;\n      }\n    } // React Native. Legacy. Paper.\n\n\n    if (typeof instance._nativeTag === 'number') {\n      return instance._nativeTag;\n    }\n  } // React Web. Usually a DOM element.\n\n\n  return instance;\n}\n\nfunction aquireHostInstance(nearestInstance, hostInstance) {\n  var publicInstance = getPublicInstance(hostInstance);\n  publicInstanceToDevToolsInstanceMap.set(publicInstance, nearestInstance);\n}\n\nfunction releaseHostInstance(nearestInstance, hostInstance) {\n  var publicInstance = getPublicInstance(hostInstance);\n\n  if (publicInstanceToDevToolsInstanceMap.get(publicInstance) === nearestInstance) {\n    publicInstanceToDevToolsInstanceMap.delete(publicInstance);\n  }\n}\n\nfunction aquireHostResource(nearestInstance, resource) {\n  var hostInstance = resource && resource.instance;\n\n  if (hostInstance) {\n    var publicInstance = getPublicInstance(hostInstance);\n    var resourceInstances = hostResourceToDevToolsInstanceMap.get(publicInstance);\n\n    if (resourceInstances === undefined) {\n      resourceInstances = new Set();\n      hostResourceToDevToolsInstanceMap.set(publicInstance, resourceInstances); // Store the first match in the main map for quick access when selecting DOM node.\n\n      publicInstanceToDevToolsInstanceMap.set(publicInstance, nearestInstance);\n    }\n\n    resourceInstances.add(nearestInstance);\n  }\n}\n\nfunction releaseHostResource(nearestInstance, resource) {\n  var hostInstance = resource && resource.instance;\n\n  if (hostInstance) {\n    var publicInstance = getPublicInstance(hostInstance);\n    var resourceInstances = hostResourceToDevToolsInstanceMap.get(publicInstance);\n\n    if (resourceInstances !== undefined) {\n      resourceInstances.delete(nearestInstance);\n\n      if (resourceInstances.size === 0) {\n        hostResourceToDevToolsInstanceMap.delete(publicInstance);\n        publicInstanceToDevToolsInstanceMap.delete(publicInstance);\n      } else if (publicInstanceToDevToolsInstanceMap.get(publicInstance) === nearestInstance) {\n        // This was the first one. Store the next first one in the main map for easy access.\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        var _iterator = _createForOfIteratorHelper(resourceInstances),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var firstInstance = _step.value;\n            publicInstanceToDevToolsInstanceMap.set(firstInstance, nearestInstance);\n            break;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n  }\n}\n\nfunction attach(hook, rendererID, renderer, global, shouldStartProfilingNow, profilingSettings) {\n  // Newer versions of the reconciler package also specific reconciler version.\n  // If that version number is present, use it.\n  // Third party renderer versions may not match the reconciler version,\n  // and the latter is what's important in terms of tags and symbols.\n  var version = renderer.reconcilerVersion || renderer.version;\n\n  var _getInternalReactCons = getInternalReactConstants(version),\n      getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,\n      getTypeSymbol = _getInternalReactCons.getTypeSymbol,\n      ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,\n      ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,\n      StrictModeBits = _getInternalReactCons.StrictModeBits;\n\n  var CacheComponent = ReactTypeOfWork.CacheComponent,\n      ClassComponent = ReactTypeOfWork.ClassComponent,\n      ContextConsumer = ReactTypeOfWork.ContextConsumer,\n      DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,\n      ForwardRef = ReactTypeOfWork.ForwardRef,\n      Fragment = ReactTypeOfWork.Fragment,\n      FunctionComponent = ReactTypeOfWork.FunctionComponent,\n      HostRoot = ReactTypeOfWork.HostRoot,\n      HostHoistable = ReactTypeOfWork.HostHoistable,\n      HostSingleton = ReactTypeOfWork.HostSingleton,\n      HostPortal = ReactTypeOfWork.HostPortal,\n      HostComponent = ReactTypeOfWork.HostComponent,\n      HostText = ReactTypeOfWork.HostText,\n      IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,\n      IncompleteFunctionComponent = ReactTypeOfWork.IncompleteFunctionComponent,\n      IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,\n      LegacyHiddenComponent = ReactTypeOfWork.LegacyHiddenComponent,\n      MemoComponent = ReactTypeOfWork.MemoComponent,\n      OffscreenComponent = ReactTypeOfWork.OffscreenComponent,\n      SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,\n      SuspenseComponent = ReactTypeOfWork.SuspenseComponent,\n      SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent,\n      TracingMarkerComponent = ReactTypeOfWork.TracingMarkerComponent,\n      Throw = ReactTypeOfWork.Throw,\n      ViewTransitionComponent = ReactTypeOfWork.ViewTransitionComponent;\n  var ImmediatePriority = ReactPriorityLevels.ImmediatePriority,\n      UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,\n      NormalPriority = ReactPriorityLevels.NormalPriority,\n      LowPriority = ReactPriorityLevels.LowPriority,\n      IdlePriority = ReactPriorityLevels.IdlePriority,\n      NoPriority = ReactPriorityLevels.NoPriority;\n  var getLaneLabelMap = renderer.getLaneLabelMap,\n      injectProfilingHooks = renderer.injectProfilingHooks,\n      overrideHookState = renderer.overrideHookState,\n      overrideHookStateDeletePath = renderer.overrideHookStateDeletePath,\n      overrideHookStateRenamePath = renderer.overrideHookStateRenamePath,\n      overrideProps = renderer.overrideProps,\n      overridePropsDeletePath = renderer.overridePropsDeletePath,\n      overridePropsRenamePath = renderer.overridePropsRenamePath,\n      scheduleRefresh = renderer.scheduleRefresh,\n      setErrorHandler = renderer.setErrorHandler,\n      setSuspenseHandler = renderer.setSuspenseHandler,\n      scheduleUpdate = renderer.scheduleUpdate,\n      getCurrentFiber = renderer.getCurrentFiber;\n  var supportsTogglingError = typeof setErrorHandler === 'function' && typeof scheduleUpdate === 'function';\n  var supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function';\n\n  if (typeof scheduleRefresh === 'function') {\n    // When Fast Refresh updates a component, the frontend may need to purge cached information.\n    // For example, ASTs cached for the component (for named hooks) may no longer be valid.\n    // Send a signal to the frontend to purge this cached information.\n    // The \"fastRefreshScheduled\" dispatched is global (not Fiber or even Renderer specific).\n    // This is less effecient since it means the front-end will need to purge the entire cache,\n    // but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.\n    renderer.scheduleRefresh = function () {\n      try {\n        hook.emit('fastRefreshScheduled');\n      } finally {\n        return scheduleRefresh.apply(void 0, arguments);\n      }\n    };\n  }\n\n  var getTimelineData = null;\n  var toggleProfilingStatus = null;\n\n  if (typeof injectProfilingHooks === 'function') {\n    var response = (0,_profilingHooks__WEBPACK_IMPORTED_MODULE_12__.createProfilingHooks)({\n      getDisplayNameForFiber: getDisplayNameForFiber,\n      getIsProfiling: function getIsProfiling() {\n        return isProfiling;\n      },\n      getLaneLabelMap: getLaneLabelMap,\n      currentDispatcherRef: getDispatcherRef(renderer),\n      workTagMap: ReactTypeOfWork,\n      reactVersion: version\n    }); // Pass the Profiling hooks to the reconciler for it to call during render.\n\n    injectProfilingHooks(response.profilingHooks); // Hang onto this toggle so we can notify the external methods of profiling status changes.\n\n    getTimelineData = response.getTimelineData;\n    toggleProfilingStatus = response.toggleProfilingStatus;\n  }\n\n  // Tracks Errors/Warnings logs added to a Fiber. They are added before the commit and get\n  // picked up a FiberInstance. This keeps it around as long as the Fiber is alive which\n  // lets the Fiber get reparented/remounted and still observe the previous errors/warnings.\n  // Unless we explicitly clear the logs from a Fiber.\n  var fiberToComponentLogsMap = new WeakMap(); // Tracks whether we've performed a commit since the last log. This is used to know\n  // whether we received any new logs between the commit and post commit phases. I.e.\n  // if any passive effects called console.warn / console.error.\n\n  var needsToFlushComponentLogs = false;\n\n  function bruteForceFlushErrorsAndWarnings() {\n    // Refresh error/warning count for all mounted unfiltered Fibers.\n    var hasChanges = false; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    var _iterator2 = _createForOfIteratorHelper(idToDevToolsInstanceMap.values()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var devtoolsInstance = _step2.value;\n\n        if (devtoolsInstance.kind === FIBER_INSTANCE) {\n          var _fiber = devtoolsInstance.data;\n          var componentLogsEntry = fiberToComponentLogsMap.get(_fiber);\n          var changed = recordConsoleLogs(devtoolsInstance, componentLogsEntry);\n\n          if (changed) {\n            hasChanges = true;\n            updateMostRecentlyInspectedElementIfNecessary(devtoolsInstance.id);\n          }\n        } else {// Virtual Instances cannot log in passive effects and so never appear here.\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    if (hasChanges) {\n      flushPendingEvents();\n    }\n  }\n\n  function clearErrorsAndWarnings() {\n    // Note, this only clears logs for Fibers that have instances. If they're filtered\n    // and then mount, the logs are there. Ensuring we only clear what you've seen.\n    // If we wanted to clear the whole set, we'd replace fiberToComponentLogsMap with a\n    // new WeakMap. It's unclear whether we should clear componentInfoToComponentLogsMap\n    // since it's shared by other renderers but presumably it would.\n    // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n    var _iterator3 = _createForOfIteratorHelper(idToDevToolsInstanceMap.values()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var devtoolsInstance = _step3.value;\n\n        if (devtoolsInstance.kind === FIBER_INSTANCE) {\n          var _fiber2 = devtoolsInstance.data;\n          fiberToComponentLogsMap.delete(_fiber2);\n\n          if (_fiber2.alternate) {\n            fiberToComponentLogsMap.delete(_fiber2.alternate);\n          }\n        } else {\n          _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_7__.componentInfoToComponentLogsMap[\"delete\"](devtoolsInstance.data);\n        }\n\n        var changed = recordConsoleLogs(devtoolsInstance, undefined);\n\n        if (changed) {\n          updateMostRecentlyInspectedElementIfNecessary(devtoolsInstance.id);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    flushPendingEvents();\n  }\n\n  function clearConsoleLogsHelper(instanceID, type) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(instanceID);\n\n    if (devtoolsInstance !== undefined) {\n      var componentLogsEntry;\n\n      if (devtoolsInstance.kind === FIBER_INSTANCE) {\n        var _fiber3 = devtoolsInstance.data;\n        componentLogsEntry = fiberToComponentLogsMap.get(_fiber3);\n\n        if (componentLogsEntry === undefined && _fiber3.alternate !== null) {\n          componentLogsEntry = fiberToComponentLogsMap.get(_fiber3.alternate);\n        }\n      } else {\n        var componentInfo = devtoolsInstance.data;\n        componentLogsEntry = _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_7__.componentInfoToComponentLogsMap.get(componentInfo);\n      }\n\n      if (componentLogsEntry !== undefined) {\n        if (type === 'error') {\n          componentLogsEntry.errors.clear();\n          componentLogsEntry.errorsCount = 0;\n        } else {\n          componentLogsEntry.warnings.clear();\n          componentLogsEntry.warningsCount = 0;\n        }\n\n        var changed = recordConsoleLogs(devtoolsInstance, componentLogsEntry);\n\n        if (changed) {\n          flushPendingEvents();\n          updateMostRecentlyInspectedElementIfNecessary(devtoolsInstance.id);\n        }\n      }\n    }\n  }\n\n  function clearErrorsForElementID(instanceID) {\n    clearConsoleLogsHelper(instanceID, 'error');\n  }\n\n  function clearWarningsForElementID(instanceID) {\n    clearConsoleLogsHelper(instanceID, 'warn');\n  }\n\n  function updateMostRecentlyInspectedElementIfNecessary(fiberID) {\n    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {\n      hasElementUpdatedSinceLastInspected = true;\n    }\n  }\n\n  function getComponentStack(topFrame) {\n    if (getCurrentFiber == null) {\n      // Expected this to be part of the renderer. Ignore.\n      return null;\n    }\n\n    var current = getCurrentFiber();\n\n    if (current === null) {\n      // Outside of our render scope.\n      return null;\n    }\n\n    if ((0,_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_10__.supportsConsoleTasks)(current)) {\n      // This will be handled natively by console.createTask. No need for\n      // DevTools to add it.\n      return null;\n    }\n\n    var dispatcherRef = getDispatcherRef(renderer);\n\n    if (dispatcherRef === undefined) {\n      return null;\n    }\n\n    var enableOwnerStacks = (0,_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_10__.supportsOwnerStacks)(current);\n    var componentStack = '';\n\n    if (enableOwnerStacks) {\n      // Prefix the owner stack with the current stack. I.e. what called\n      // console.error. While this will also be part of the native stack,\n      // it is hidden and not presented alongside this argument so we print\n      // them all together.\n      var topStackFrames = (0,_shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_13__.formatOwnerStack)(topFrame);\n\n      if (topStackFrames) {\n        componentStack += '\\n' + topStackFrames;\n      }\n\n      componentStack += (0,_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_10__.getOwnerStackByFiberInDev)(ReactTypeOfWork, current, dispatcherRef);\n    } else {\n      componentStack = (0,_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_10__.getStackByFiberInDevAndProd)(ReactTypeOfWork, current, dispatcherRef);\n    }\n\n    return {\n      enableOwnerStacks: enableOwnerStacks,\n      componentStack: componentStack\n    };\n  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).\n\n\n  function onErrorOrWarning(type, args) {\n    if (getCurrentFiber == null) {\n      // Expected this to be part of the renderer. Ignore.\n      return;\n    }\n\n    var fiber = getCurrentFiber();\n\n    if (fiber === null) {\n      // Outside of our render scope.\n      return;\n    }\n\n    if (type === 'error') {\n      // if this is an error simulated by us to trigger error boundary, ignore\n      if (forceErrorForFibers.get(fiber) === true || fiber.alternate !== null && forceErrorForFibers.get(fiber.alternate) === true) {\n        return;\n      }\n    } // We can't really use this message as a unique key, since we can't distinguish\n    // different objects in this implementation. We have to delegate displaying of the objects\n    // to the environment, the browser console, for example, so this is why this should be kept\n    // as an array of arguments, instead of the plain string.\n    // [Warning: %o, {...}] and [Warning: %o, {...}] will be considered as the same message,\n    // even if objects are different\n\n\n    var message = react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.formatConsoleArgumentsToSingleString.apply(void 0, _toConsumableArray(args)); // Track the warning/error for later.\n\n    var componentLogsEntry = fiberToComponentLogsMap.get(fiber);\n\n    if (componentLogsEntry === undefined && fiber.alternate !== null) {\n      componentLogsEntry = fiberToComponentLogsMap.get(fiber.alternate);\n\n      if (componentLogsEntry !== undefined) {\n        // Use the same set for both Fibers.\n        fiberToComponentLogsMap.set(fiber, componentLogsEntry);\n      }\n    }\n\n    if (componentLogsEntry === undefined) {\n      componentLogsEntry = {\n        errors: new Map(),\n        errorsCount: 0,\n        warnings: new Map(),\n        warningsCount: 0\n      };\n      fiberToComponentLogsMap.set(fiber, componentLogsEntry);\n    }\n\n    var messageMap = type === 'error' ? componentLogsEntry.errors : componentLogsEntry.warnings;\n    var count = messageMap.get(message) || 0;\n    messageMap.set(message, count + 1);\n\n    if (type === 'error') {\n      componentLogsEntry.errorsCount++;\n    } else {\n      componentLogsEntry.warningsCount++;\n    } // The changes will be flushed later when we commit.\n    // If the log happened in a passive effect, then this happens after we've\n    // already committed the new tree so the change won't show up until we rerender\n    // that component again. We need to visit a Component with passive effects in\n    // handlePostCommitFiberRoot again to ensure that we flush the changes after passive.\n\n\n    needsToFlushComponentLogs = true;\n  }\n\n  function debug(name, instance, parentInstance) {\n    var extraString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      var displayName = instance.kind === VIRTUAL_INSTANCE ? instance.data.name || 'null' : instance.data.tag + ':' + (getDisplayNameForFiber(instance.data) || 'null');\n      var maybeID = instance.kind === FILTERED_FIBER_INSTANCE ? '<no id>' : instance.id;\n      var parentDisplayName = parentInstance === null ? '' : parentInstance.kind === VIRTUAL_INSTANCE ? parentInstance.data.name || 'null' : parentInstance.data.tag + ':' + (getDisplayNameForFiber(parentInstance.data) || 'null');\n      var maybeParentID = parentInstance === null || parentInstance.kind === FILTERED_FIBER_INSTANCE ? '<no id>' : parentInstance.id;\n      console.groupCollapsed(\"[renderer] %c\".concat(name, \" %c\").concat(displayName, \" (\").concat(maybeID, \") %c\").concat(parentInstance ? \"\".concat(parentDisplayName, \" (\").concat(maybeParentID, \")\") : '', \" %c\").concat(extraString), 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;', 'color: black;');\n      console.log(new Error().stack.split('\\n').slice(1).join('\\n'));\n      console.groupEnd();\n    }\n  } // eslint-disable-next-line no-unused-vars\n\n\n  function debugTree(instance) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      var name = (instance.kind !== VIRTUAL_INSTANCE ? getDisplayNameForFiber(instance.data) : instance.data.name) || '';\n      console.log('  '.repeat(indent) + '- ' + (instance.kind === FILTERED_FIBER_INSTANCE ? 0 : instance.id) + ' (' + name + ')', 'parent', instance.parent === null ? ' ' : instance.parent.kind === FILTERED_FIBER_INSTANCE ? 0 : instance.parent.id, 'next', instance.nextSibling === null ? ' ' : instance.nextSibling.id);\n      var child = instance.firstChild;\n\n      while (child !== null) {\n        debugTree(child, indent + 1);\n        child = child.nextSibling;\n      }\n    }\n  } // Configurable Components tree filters.\n\n\n  var hideElementsWithDisplayNames = new Set();\n  var hideElementsWithPaths = new Set();\n  var hideElementsWithTypes = new Set();\n  var hideElementsWithEnvs = new Set(); // Highlight updates\n\n  var traceUpdatesEnabled = false;\n  var traceUpdatesForNodes = new Set();\n\n  function applyComponentFilters(componentFilters) {\n    hideElementsWithTypes.clear();\n    hideElementsWithDisplayNames.clear();\n    hideElementsWithPaths.clear();\n    hideElementsWithEnvs.clear();\n    componentFilters.forEach(function (componentFilter) {\n      if (!componentFilter.isEnabled) {\n        return;\n      }\n\n      switch (componentFilter.type) {\n        case react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ComponentFilterDisplayName:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ComponentFilterElementType:\n          hideElementsWithTypes.add(componentFilter.value);\n          break;\n\n        case react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ComponentFilterLocation:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ComponentFilterHOC:\n          hideElementsWithDisplayNames.add(new RegExp('\\\\('));\n          break;\n\n        case react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ComponentFilterEnvironmentName:\n          hideElementsWithEnvs.add(componentFilter.value);\n          break;\n\n        default:\n          console.warn(\"Invalid component filter type \\\"\".concat(componentFilter.type, \"\\\"\"));\n          break;\n      }\n    });\n  } // The renderer interface can't read saved component filters directly,\n  // because they are stored in localStorage within the context of the extension.\n  // Instead it relies on the extension to pass filters through.\n\n\n  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {\n    var componentFiltersWithoutLocationBasedOnes = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.filterOutLocationComponentFilters)(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);\n    applyComponentFilters(componentFiltersWithoutLocationBasedOnes);\n  } else {\n    // Unfortunately this feature is not expected to work for React Native for now.\n    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,\n    // so for now just skip this message...\n    //console.warn('⚛ DevTools: Could not locate saved component filters');\n    // Fallback to assuming the default filters in this case.\n    applyComponentFilters((0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getDefaultComponentFilters)());\n  } // If necessary, we can revisit optimizing this operation.\n  // For example, we could add a new recursive unmount tree operation.\n  // The unmount operations are already significantly smaller than mount operations though.\n  // This is something to keep in mind for later.\n\n\n  function updateComponentFilters(componentFilters) {\n    if (isProfiling) {\n      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.\n      // If necessary, we could support this- but it doesn't seem like a necessary use case.\n      throw Error('Cannot modify filter preferences while profiling');\n    } // Recursively unmount all roots.\n\n\n    hook.getFiberRoots(rendererID).forEach(function (root) {\n      var rootInstance = rootToFiberInstanceMap.get(root);\n\n      if (rootInstance === undefined) {\n        throw new Error('Expected the root instance to already exist when applying filters');\n      }\n\n      currentRoot = rootInstance;\n      unmountInstanceRecursively(rootInstance);\n      rootToFiberInstanceMap.delete(root);\n      flushPendingEvents(root);\n      currentRoot = null;\n    });\n    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.\n\n    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.\n\n    hook.getFiberRoots(rendererID).forEach(function (root) {\n      var current = root.current;\n      var newRoot = createFiberInstance(current);\n      rootToFiberInstanceMap.set(root, newRoot);\n      idToDevToolsInstanceMap.set(newRoot.id, newRoot); // Before the traversals, remember to start tracking\n      // our path in case we have selection to restore.\n\n      if (trackedPath !== null) {\n        mightBeOnTrackedPath = true;\n      }\n\n      currentRoot = newRoot;\n      setRootPseudoKey(currentRoot.id, root.current);\n      mountFiberRecursively(root.current, false);\n      flushPendingEvents(root);\n      currentRoot = null;\n    });\n    flushPendingEvents();\n    needsToFlushComponentLogs = false;\n  }\n\n  function getEnvironmentNames() {\n    return Array.from(knownEnvironmentNames);\n  }\n\n  function shouldFilterVirtual(data, secondaryEnv) {\n    // For purposes of filtering Server Components are always Function Components.\n    // Environment will be used to filter Server vs Client.\n    // Technically they can be forwardRef and memo too but those filters will go away\n    // as those become just plain user space function components like any HoC.\n    if (hideElementsWithTypes.has(react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeFunction)) {\n      return true;\n    }\n\n    if (hideElementsWithDisplayNames.size > 0) {\n      var displayName = data.name;\n\n      if (displayName != null) {\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        var _iterator4 = _createForOfIteratorHelper(hideElementsWithDisplayNames),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var displayNameRegExp = _step4.value;\n\n            if (displayNameRegExp.test(displayName)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n\n    if ((data.env == null || hideElementsWithEnvs.has(data.env)) && (secondaryEnv === null || hideElementsWithEnvs.has(secondaryEnv))) {\n      // If a Component has two environments, you have to filter both for it not to appear.\n      return true;\n    }\n\n    return false;\n  } // NOTICE Keep in sync with get*ForFiber methods\n\n\n  function shouldFilterFiber(fiber) {\n    var tag = fiber.tag,\n        type = fiber.type,\n        key = fiber.key;\n\n    switch (tag) {\n      case DehydratedSuspenseComponent:\n        // TODO: ideally we would show dehydrated Suspense immediately.\n        // However, it has some special behavior (like disconnecting\n        // an alternate and turning into real Suspense) which breaks DevTools.\n        // For now, ignore it, and only show it once it gets hydrated.\n        // https://github.com/bvaughn/react-devtools-experimental/issues/197\n        return true;\n\n      case HostPortal:\n      case HostText:\n      case LegacyHiddenComponent:\n      case OffscreenComponent:\n      case Throw:\n        return true;\n\n      case HostRoot:\n        // It is never valid to filter the root element.\n        return false;\n\n      case Fragment:\n        return key === null;\n\n      default:\n        var typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONCURRENT_MODE_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONCURRENT_MODE_SYMBOL_STRING:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.DEPRECATED_ASYNC_MODE_SYMBOL_STRING:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.STRICT_MODE_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.STRICT_MODE_SYMBOL_STRING:\n            return true;\n\n          default:\n            break;\n        }\n\n    }\n\n    var elementType = getElementTypeForFiber(fiber);\n\n    if (hideElementsWithTypes.has(elementType)) {\n      return true;\n    }\n\n    if (hideElementsWithDisplayNames.size > 0) {\n      var displayName = getDisplayNameForFiber(fiber);\n\n      if (displayName != null) {\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        var _iterator5 = _createForOfIteratorHelper(hideElementsWithDisplayNames),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var displayNameRegExp = _step5.value;\n\n            if (displayNameRegExp.test(displayName)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n\n    if (hideElementsWithEnvs.has('Client')) {\n      // If we're filtering out the Client environment we should filter out all\n      // \"Client Components\". Technically that also includes the built-ins but\n      // since that doesn't actually include any additional code loading it's\n      // useful to not filter out the built-ins. Those can be filtered separately.\n      // There's no other way to filter out just Function components on the Client.\n      // Therefore, this only filters Class and Function components.\n      switch (tag) {\n        case ClassComponent:\n        case IncompleteClassComponent:\n        case IncompleteFunctionComponent:\n        case FunctionComponent:\n        case IndeterminateComponent:\n        case ForwardRef:\n        case MemoComponent:\n        case SimpleMemoComponent:\n          return true;\n      }\n    }\n    /* DISABLED: https://github.com/facebook/react/pull/28417\n    if (hideElementsWithPaths.size > 0) {\n      const source = getSourceForFiber(fiber);\n       if (source != null) {\n        const {fileName} = source;\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        for (const pathRegExp of hideElementsWithPaths) {\n          if (pathRegExp.test(fileName)) {\n            return true;\n          }\n        }\n      }\n    }\n    */\n\n\n    return false;\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getElementTypeForFiber(fiber) {\n    var type = fiber.type,\n        tag = fiber.tag;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeClass;\n\n      case IncompleteFunctionComponent:\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeFunction;\n\n      case ForwardRef:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeForwardRef;\n\n      case HostRoot:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeRoot;\n\n      case HostComponent:\n      case HostHoistable:\n      case HostSingleton:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeHostComponent;\n\n      case HostPortal:\n      case HostText:\n      case Fragment:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeMemo;\n\n      case SuspenseComponent:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeSuspense;\n\n      case SuspenseListComponent:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeSuspenseList;\n\n      case TracingMarkerComponent:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeTracingMarker;\n\n      case ViewTransitionComponent:\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeViewTransition;\n\n      default:\n        var typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONCURRENT_MODE_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONCURRENT_MODE_SYMBOL_STRING:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.DEPRECATED_ASYNC_MODE_SYMBOL_STRING:\n            return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown;\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROVIDER_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROVIDER_SYMBOL_STRING:\n            return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeContext;\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONTEXT_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONTEXT_SYMBOL_STRING:\n            return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeContext;\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.STRICT_MODE_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.STRICT_MODE_SYMBOL_STRING:\n            return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown;\n\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROFILER_NUMBER:\n          case _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROFILER_SYMBOL_STRING:\n            return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeProfiler;\n\n          default:\n            return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown;\n        }\n\n    }\n  } // When a mount or update is in progress, this value tracks the root that is being operated on.\n\n\n  var currentRoot = null; // Removes a Fiber (and its alternate) from the Maps used to track their id.\n  // This method should always be called when a Fiber is unmounting.\n\n  function untrackFiber(nearestInstance, fiber) {\n    if (forceErrorForFibers.size > 0) {\n      forceErrorForFibers.delete(fiber);\n\n      if (fiber.alternate) {\n        forceErrorForFibers.delete(fiber.alternate);\n      }\n\n      if (forceErrorForFibers.size === 0 && setErrorHandler != null) {\n        setErrorHandler(shouldErrorFiberAlwaysNull);\n      }\n    }\n\n    if (forceFallbackForFibers.size > 0) {\n      forceFallbackForFibers.delete(fiber);\n\n      if (fiber.alternate) {\n        forceFallbackForFibers.delete(fiber.alternate);\n      }\n\n      if (forceFallbackForFibers.size === 0 && setSuspenseHandler != null) {\n        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);\n      }\n    } // TODO: Consider using a WeakMap instead. The only thing where that doesn't work\n    // is React Native Paper which tracks tags but that support is eventually going away\n    // and can use the old findFiberByHostInstance strategy.\n\n\n    if (fiber.tag === HostHoistable) {\n      releaseHostResource(nearestInstance, fiber.memoizedState);\n    } else if (fiber.tag === HostComponent || fiber.tag === HostText || fiber.tag === HostSingleton) {\n      releaseHostInstance(nearestInstance, fiber.stateNode);\n    } // Recursively clean up any filtered Fibers below this one as well since\n    // we won't recordUnmount on those.\n\n\n    for (var child = fiber.child; child !== null; child = child.sibling) {\n      if (shouldFilterFiber(child)) {\n        untrackFiber(nearestInstance, child);\n      }\n    }\n  }\n\n  function getChangeDescription(prevFiber, nextFiber) {\n    switch (nextFiber.tag) {\n      case ClassComponent:\n        if (prevFiber === null) {\n          return {\n            context: null,\n            didHooksChange: false,\n            isFirstMount: true,\n            props: null,\n            state: null\n          };\n        } else {\n          var data = {\n            context: getContextChanged(prevFiber, nextFiber),\n            didHooksChange: false,\n            isFirstMount: false,\n            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),\n            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)\n          };\n          return data;\n        }\n\n      case IncompleteFunctionComponent:\n      case FunctionComponent:\n      case IndeterminateComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        if (prevFiber === null) {\n          return {\n            context: null,\n            didHooksChange: false,\n            isFirstMount: true,\n            props: null,\n            state: null\n          };\n        } else {\n          var indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);\n          var _data = {\n            context: getContextChanged(prevFiber, nextFiber),\n            didHooksChange: indices !== null && indices.length > 0,\n            isFirstMount: false,\n            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),\n            state: null,\n            hooks: indices\n          }; // Only traverse the hooks list once, depending on what info we're returning.\n\n          return _data;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  function getContextChanged(prevFiber, nextFiber) {\n    var prevContext = prevFiber.dependencies && prevFiber.dependencies.firstContext;\n    var nextContext = nextFiber.dependencies && nextFiber.dependencies.firstContext;\n\n    while (prevContext && nextContext) {\n      // Note this only works for versions of React that support this key (e.v. 18+)\n      // For older versions, there's no good way to read the current context value after render has completed.\n      // This is because React maintains a stack of context values during render,\n      // but by the time DevTools is called, render has finished and the stack is empty.\n      if (prevContext.context !== nextContext.context) {\n        // If the order of context has changed, then the later context values might have\n        // changed too but the main reason it rerendered was earlier. Either an earlier\n        // context changed value but then we would have exited already. If we end up here\n        // it's because a state or props change caused the order of contexts used to change.\n        // So the main cause is not the contexts themselves.\n        return false;\n      }\n\n      if (!(0,shared_objectIs__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(prevContext.memoizedValue, nextContext.memoizedValue)) {\n        return true;\n      }\n\n      prevContext = prevContext.next;\n      nextContext = nextContext.next;\n    }\n\n    return false;\n  }\n\n  function isHookThatCanScheduleUpdate(hookObject) {\n    var queue = hookObject.queue;\n\n    if (!queue) {\n      return false;\n    }\n\n    var boundHasOwnProperty = shared_hasOwnProperty__WEBPACK_IMPORTED_MODULE_9__[\"default\"].bind(queue); // Detect the shape of useState() / useReducer() / useTransition()\n    // using the attributes that are unique to these hooks\n    // but also stable (e.g. not tied to current Lanes implementation)\n    // We don't check for dispatch property, because useTransition doesn't have it\n\n    if (boundHasOwnProperty('pending')) {\n      return true;\n    } // Detect useSyncExternalStore()\n\n\n    return boundHasOwnProperty('value') && boundHasOwnProperty('getSnapshot') && typeof queue.getSnapshot === 'function';\n  }\n\n  function didStatefulHookChange(prev, next) {\n    var prevMemoizedState = prev.memoizedState;\n    var nextMemoizedState = next.memoizedState;\n\n    if (isHookThatCanScheduleUpdate(prev)) {\n      return prevMemoizedState !== nextMemoizedState;\n    }\n\n    return false;\n  }\n\n  function getChangedHooksIndices(prev, next) {\n    if (prev == null || next == null) {\n      return null;\n    }\n\n    var indices = [];\n    var index = 0;\n\n    while (next !== null) {\n      if (didStatefulHookChange(prev, next)) {\n        indices.push(index);\n      }\n\n      next = next.next;\n      prev = prev.next;\n      index++;\n    }\n\n    return indices;\n  }\n\n  function getChangedKeys(prev, next) {\n    if (prev == null || next == null) {\n      return null;\n    }\n\n    var keys = new Set([].concat(_toConsumableArray(Object.keys(prev)), _toConsumableArray(Object.keys(next))));\n    var changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    var _iterator6 = _createForOfIteratorHelper(keys),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var key = _step6.value;\n\n        if (prev[key] !== next[key]) {\n          changedKeys.push(key);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    return changedKeys;\n  }\n\n  function didFiberRender(prevFiber, nextFiber) {\n    switch (nextFiber.tag) {\n      case ClassComponent:\n      case FunctionComponent:\n      case ContextConsumer:\n      case MemoComponent:\n      case SimpleMemoComponent:\n      case ForwardRef:\n        // For types that execute user code, we check PerformedWork effect.\n        // We don't reflect bailouts (either referential or sCU) in DevTools.\n        // TODO: This flag is a leaked implementation detail. Once we start\n        // releasing DevTools in lockstep with React, we should import a\n        // function from the reconciler instead.\n        var PerformedWork = 1;\n        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;\n      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+\n      // so it won't get highlighted with React 16.3.0 to 16.3.2.\n\n      default:\n        // For host components and other types, we compare inputs\n        // to determine whether something is an update.\n        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;\n    }\n  }\n\n  var pendingOperations = [];\n  var pendingRealUnmountedIDs = [];\n  var pendingOperationsQueue = [];\n  var pendingStringTable = new Map();\n  var pendingStringTableLength = 0;\n  var pendingUnmountedRootID = null;\n\n  function pushOperation(op) {\n    if (true) {\n      if (!Number.isInteger(op)) {\n        console.error('pushOperation() was called but the value is not an integer.', op);\n      }\n    }\n\n    pendingOperations.push(op);\n  }\n\n  function shouldBailoutWithPendingOperations() {\n    if (isProfiling) {\n      if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {\n        return false;\n      }\n    }\n\n    return pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingUnmountedRootID === null;\n  }\n\n  function flushOrQueueOperations(operations) {\n    if (shouldBailoutWithPendingOperations()) {\n      return;\n    }\n\n    if (pendingOperationsQueue !== null) {\n      pendingOperationsQueue.push(operations);\n    } else {\n      hook.emit('operations', operations);\n    }\n  }\n\n  function recordConsoleLogs(instance, componentLogsEntry) {\n    if (componentLogsEntry === undefined) {\n      if (instance.logCount === 0) {\n        // Nothing has changed.\n        return false;\n      } // Reset to zero.\n\n\n      instance.logCount = 0;\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);\n      pushOperation(instance.id);\n      pushOperation(0);\n      pushOperation(0);\n      return true;\n    } else {\n      var totalCount = componentLogsEntry.errorsCount + componentLogsEntry.warningsCount;\n\n      if (instance.logCount === totalCount) {\n        // Nothing has changed.\n        return false;\n      } // Update counts.\n\n\n      instance.logCount = totalCount;\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);\n      pushOperation(instance.id);\n      pushOperation(componentLogsEntry.errorsCount);\n      pushOperation(componentLogsEntry.warningsCount);\n      return true;\n    }\n  }\n\n  function flushPendingEvents(root) {\n    if (shouldBailoutWithPendingOperations()) {\n      // If we aren't profiling, we can just bail out here.\n      // No use sending an empty update over the bridge.\n      //\n      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:\n      // (1) an initial tree snapshot and\n      // (2) the operations array for each commit\n      // Because of this, it's important that the operations and metadata arrays align,\n      // So it's important not to omit even empty operations while profiling is active.\n      return;\n    }\n\n    var numUnmountIDs = pendingRealUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n    var operations = new Array( // Identify which renderer this update is coming from.\n    2 + // [rendererID, rootFiberID]\n    // How big is the string table?\n    1 + // [stringTableLength]\n    // Then goes the actual string table.\n    pendingStringTableLength + ( // All unmounts are batched in a single message.\n    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations\n    pendingOperations.length); // Identify which renderer this update is coming from.\n    // This enables roots to be mapped to renderers,\n    // Which in turn enables fiber props, states, and hooks to be inspected.\n\n    var i = 0;\n    operations[i++] = rendererID;\n\n    if (currentRoot === null) {\n      // TODO: This is not always safe so this field is probably not needed.\n      operations[i++] = -1;\n    } else {\n      operations[i++] = currentRoot.id;\n    } // Now fill in the string table.\n    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n\n    operations[i++] = pendingStringTableLength;\n    pendingStringTable.forEach(function (entry, stringKey) {\n      var encodedString = entry.encodedString; // Don't use the string length.\n      // It won't work for multibyte characters (like emoji).\n\n      var length = encodedString.length;\n      operations[i++] = length;\n\n      for (var j = 0; j < length; j++) {\n        operations[i + j] = encodedString[j];\n      }\n\n      i += length;\n    });\n\n    if (numUnmountIDs > 0) {\n      // All unmounts except roots are batched in a single message.\n      operations[i++] = _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE; // The first number is how many unmounted IDs we're gonna send.\n\n      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.\n      // They were inserted parents-first by React, but we want children-first.\n      // So we traverse our array backwards.\n\n      for (var j = 0; j < pendingRealUnmountedIDs.length; j++) {\n        operations[i++] = pendingRealUnmountedIDs[j];\n      } // The root ID should always be unmounted last.\n\n\n      if (pendingUnmountedRootID !== null) {\n        operations[i] = pendingUnmountedRootID;\n        i++;\n      }\n    } // Fill in the rest of the operations.\n\n\n    for (var _j = 0; _j < pendingOperations.length; _j++) {\n      operations[i + _j] = pendingOperations[_j];\n    }\n\n    i += pendingOperations.length; // Let the frontend know about tree operations.\n\n    flushOrQueueOperations(operations); // Reset all of the pending state now that we've told the frontend about it.\n\n    pendingOperations.length = 0;\n    pendingRealUnmountedIDs.length = 0;\n    pendingUnmountedRootID = null;\n    pendingStringTable.clear();\n    pendingStringTableLength = 0;\n  }\n\n  function getStringID(string) {\n    if (string === null) {\n      return 0;\n    }\n\n    var existingEntry = pendingStringTable.get(string);\n\n    if (existingEntry !== undefined) {\n      return existingEntry.id;\n    }\n\n    var id = pendingStringTable.size + 1;\n    var encodedString = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.utfEncodeString)(string);\n    pendingStringTable.set(string, {\n      encodedString: encodedString,\n      id: id\n    }); // The string table total length needs to account both for the string length,\n    // and for the array item that contains the length itself.\n    //\n    // Don't use string length for this table.\n    // It won't work for multibyte characters (like emoji).\n\n    pendingStringTableLength += encodedString.length + 1;\n    return id;\n  }\n\n  function recordMount(fiber, parentInstance) {\n    var isRoot = fiber.tag === HostRoot;\n    var fiberInstance;\n\n    if (isRoot) {\n      var entry = rootToFiberInstanceMap.get(fiber.stateNode);\n\n      if (entry === undefined) {\n        throw new Error('The root should have been registered at this point');\n      }\n\n      fiberInstance = entry;\n    } else {\n      fiberInstance = createFiberInstance(fiber);\n    }\n\n    idToDevToolsInstanceMap.set(fiberInstance.id, fiberInstance);\n    var id = fiberInstance.id;\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      debug('recordMount()', fiberInstance, parentInstance);\n    }\n\n    var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');\n\n    if (isRoot) {\n      var hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner'); // Adding a new field here would require a bridge protocol version bump (a backwads breaking change).\n      // Instead let's re-purpose a pre-existing field to carry more information.\n\n      var profilingFlags = 0;\n\n      if (isProfilingSupported) {\n        profilingFlags = _constants__WEBPACK_IMPORTED_MODULE_3__.PROFILING_FLAG_BASIC_SUPPORT;\n\n        if (typeof injectProfilingHooks === 'function') {\n          profilingFlags |= _constants__WEBPACK_IMPORTED_MODULE_3__.PROFILING_FLAG_TIMELINE_SUPPORT;\n        }\n      } // Set supportsStrictMode to false for production renderer builds\n\n\n      var isProductionBuildOfRenderer = renderer.bundleType === 0;\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeRoot);\n      pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);\n      pushOperation(profilingFlags);\n      pushOperation(!isProductionBuildOfRenderer && StrictModeBits !== 0 ? 1 : 0);\n      pushOperation(hasOwnerMetadata ? 1 : 0);\n\n      if (isProfiling) {\n        if (displayNamesByRootID !== null) {\n          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));\n        }\n      }\n    } else {\n      var key = fiber.key;\n      var displayName = getDisplayNameForFiber(fiber);\n      var elementType = getElementTypeForFiber(fiber); // Finding the owner instance might require traversing the whole parent path which\n      // doesn't have great big O notation. Ideally we'd lazily fetch the owner when we\n      // need it but we have some synchronous operations in the front end like Alt+Left\n      // which selects the owner immediately. Typically most owners are only a few parents\n      // away so maybe it's not so bad.\n\n      var debugOwner = getUnfilteredOwner(fiber);\n      var ownerInstance = findNearestOwnerInstance(parentInstance, debugOwner);\n\n      if (ownerInstance !== null && debugOwner === fiber._debugOwner && fiber._debugStack != null && ownerInstance.source === null) {\n        // The new Fiber is directly owned by the ownerInstance. Therefore somewhere on\n        // the debugStack will be a stack frame inside the ownerInstance's source.\n        ownerInstance.source = fiber._debugStack;\n      }\n\n      var ownerID = ownerInstance === null ? 0 : ownerInstance.id;\n      var parentID = parentInstance ? parentInstance.kind === FILTERED_FIBER_INSTANCE ? // A Filtered Fiber Instance will always have a Virtual Instance as a parent.\n      parentInstance.parent.id : parentInstance.id : 0;\n      var displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified\n      // in such a way as to bypass the default stringification of the \"key\" property.\n\n      var keyString = key === null ? null : String(key);\n      var keyStringID = getStringID(keyString);\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(elementType);\n      pushOperation(parentID);\n      pushOperation(ownerID);\n      pushOperation(displayNameStringID);\n      pushOperation(keyStringID); // If this subtree has a new mode, let the frontend know.\n\n      if ((fiber.mode & StrictModeBits) !== 0) {\n        var parentFiber = null;\n        var parentFiberInstance = parentInstance;\n\n        while (parentFiberInstance !== null) {\n          if (parentFiberInstance.kind === FIBER_INSTANCE) {\n            parentFiber = parentFiberInstance.data;\n            break;\n          }\n\n          parentFiberInstance = parentFiberInstance.parent;\n        }\n\n        if (parentFiber === null || (parentFiber.mode & StrictModeBits) === 0) {\n          pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_SET_SUBTREE_MODE);\n          pushOperation(id);\n          pushOperation(react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.StrictMode);\n        }\n      }\n    }\n\n    var componentLogsEntry = fiberToComponentLogsMap.get(fiber);\n\n    if (componentLogsEntry === undefined && fiber.alternate !== null) {\n      componentLogsEntry = fiberToComponentLogsMap.get(fiber.alternate);\n    }\n\n    recordConsoleLogs(fiberInstance, componentLogsEntry);\n\n    if (isProfilingSupported) {\n      recordProfilingDurations(fiberInstance, null);\n    }\n\n    return fiberInstance;\n  }\n\n  function recordVirtualMount(instance, parentInstance, secondaryEnv) {\n    var id = instance.id;\n    idToDevToolsInstanceMap.set(id, instance);\n    var componentInfo = instance.data;\n    var key = typeof componentInfo.key === 'string' ? componentInfo.key : null;\n    var env = componentInfo.env;\n    var displayName = componentInfo.name || '';\n\n    if (typeof env === 'string') {\n      // We model environment as an HoC name for now.\n      if (secondaryEnv !== null) {\n        displayName = secondaryEnv + '(' + displayName + ')';\n      }\n\n      displayName = env + '(' + displayName + ')';\n    }\n\n    var elementType = react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeVirtual; // Finding the owner instance might require traversing the whole parent path which\n    // doesn't have great big O notation. Ideally we'd lazily fetch the owner when we\n    // need it but we have some synchronous operations in the front end like Alt+Left\n    // which selects the owner immediately. Typically most owners are only a few parents\n    // away so maybe it's not so bad.\n\n    var debugOwner = getUnfilteredOwner(componentInfo);\n    var ownerInstance = findNearestOwnerInstance(parentInstance, debugOwner);\n\n    if (ownerInstance !== null && debugOwner === componentInfo.owner && componentInfo.debugStack != null && ownerInstance.source === null) {\n      // The new Fiber is directly owned by the ownerInstance. Therefore somewhere on\n      // the debugStack will be a stack frame inside the ownerInstance's source.\n      ownerInstance.source = componentInfo.debugStack;\n    }\n\n    var ownerID = ownerInstance === null ? 0 : ownerInstance.id;\n    var parentID = parentInstance ? parentInstance.kind === FILTERED_FIBER_INSTANCE ? // A Filtered Fiber Instance will always have a Virtual Instance as a parent.\n    parentInstance.parent.id : parentInstance.id : 0;\n    var displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified\n    // in such a way as to bypass the default stringification of the \"key\" property.\n\n    var keyString = key === null ? null : String(key);\n    var keyStringID = getStringID(keyString);\n    pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD);\n    pushOperation(id);\n    pushOperation(elementType);\n    pushOperation(parentID);\n    pushOperation(ownerID);\n    pushOperation(displayNameStringID);\n    pushOperation(keyStringID);\n    var componentLogsEntry = _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_7__.componentInfoToComponentLogsMap.get(componentInfo);\n    recordConsoleLogs(instance, componentLogsEntry);\n  }\n\n  function recordUnmount(fiberInstance) {\n    var fiber = fiberInstance.data;\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      debug('recordUnmount()', fiberInstance, reconcilingParent);\n    }\n\n    if (trackedPathMatchInstance === fiberInstance) {\n      // We're in the process of trying to restore previous selection.\n      // If this fiber matched but is being unmounted, there's no use trying.\n      // Reset the state so we don't keep holding onto it.\n      setTrackedPath(null);\n    }\n\n    var id = fiberInstance.id;\n    var isRoot = fiber.tag === HostRoot;\n\n    if (isRoot) {\n      // Roots must be removed only after all children have been removed.\n      // So we track it separately.\n      pendingUnmountedRootID = id;\n    } else {\n      // To maintain child-first ordering,\n      // we'll push it into one of these queues,\n      // and later arrange them in the correct order.\n      pendingRealUnmountedIDs.push(id);\n    }\n\n    idToDevToolsInstanceMap.delete(fiberInstance.id);\n    untrackFiber(fiberInstance, fiber);\n  } // Running state of the remaining children from the previous version of this parent that\n  // we haven't yet added back. This should be reset anytime we change parent.\n  // Any remaining ones at the end will be deleted.\n\n\n  var remainingReconcilingChildren = null; // The previously placed child.\n\n  var previouslyReconciledSibling = null; // To save on stack allocation and ensure that they are updated as a pair, we also store\n  // the current parent here as well.\n\n  var reconcilingParent = null;\n\n  function insertChild(instance) {\n    var parentInstance = reconcilingParent;\n\n    if (parentInstance === null) {\n      // This instance is at the root.\n      return;\n    } // Place it in the parent.\n\n\n    instance.parent = parentInstance;\n\n    if (previouslyReconciledSibling === null) {\n      previouslyReconciledSibling = instance;\n      parentInstance.firstChild = instance;\n    } else {\n      previouslyReconciledSibling.nextSibling = instance;\n      previouslyReconciledSibling = instance;\n    }\n\n    instance.nextSibling = null;\n  }\n\n  function moveChild(instance, previousSibling) {\n    removeChild(instance, previousSibling);\n    insertChild(instance);\n  }\n\n  function removeChild(instance, previousSibling) {\n    if (instance.parent === null) {\n      if (remainingReconcilingChildren === instance) {\n        throw new Error('Remaining children should not have items with no parent');\n      } else if (instance.nextSibling !== null) {\n        throw new Error('A deleted instance should not have next siblings');\n      } // Already deleted.\n\n\n      return;\n    }\n\n    var parentInstance = reconcilingParent;\n\n    if (parentInstance === null) {\n      throw new Error('Should not have a parent if we are at the root');\n    }\n\n    if (instance.parent !== parentInstance) {\n      throw new Error('Cannot remove a node from a different parent than is being reconciled.');\n    } // Remove an existing child from its current position, which we assume is in the\n    // remainingReconcilingChildren set.\n\n\n    if (previousSibling === null) {\n      // We're first in the remaining set. Remove us.\n      if (remainingReconcilingChildren !== instance) {\n        throw new Error('Expected a placed child to be moved from the remaining set.');\n      }\n\n      remainingReconcilingChildren = instance.nextSibling;\n    } else {\n      previousSibling.nextSibling = instance.nextSibling;\n    }\n\n    instance.nextSibling = null;\n    instance.parent = null;\n  }\n\n  function unmountRemainingChildren() {\n    var child = remainingReconcilingChildren;\n\n    while (child !== null) {\n      unmountInstanceRecursively(child);\n      child = remainingReconcilingChildren;\n    }\n  }\n\n  function mountVirtualInstanceRecursively(virtualInstance, firstChild, lastChild, // non-inclusive\n  traceNearestHostComponentUpdate, virtualLevel) {\n    // If we have the tree selection from previous reload, try to match this Instance.\n    // Also remember whether to do the same for siblings.\n    var mightSiblingsBeOnTrackedPath = updateVirtualTrackedPathStateBeforeMount(virtualInstance, reconcilingParent);\n    var stashedParent = reconcilingParent;\n    var stashedPrevious = previouslyReconciledSibling;\n    var stashedRemaining = remainingReconcilingChildren; // Push a new DevTools instance parent while reconciling this subtree.\n\n    reconcilingParent = virtualInstance;\n    previouslyReconciledSibling = null;\n    remainingReconcilingChildren = null;\n\n    try {\n      mountVirtualChildrenRecursively(firstChild, lastChild, traceNearestHostComponentUpdate, virtualLevel + 1); // Must be called after all children have been appended.\n\n      recordVirtualProfilingDurations(virtualInstance);\n    } finally {\n      reconcilingParent = stashedParent;\n      previouslyReconciledSibling = stashedPrevious;\n      remainingReconcilingChildren = stashedRemaining;\n      updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);\n    }\n  }\n\n  function recordVirtualUnmount(instance) {\n    if (trackedPathMatchInstance === instance) {\n      // We're in the process of trying to restore previous selection.\n      // If this fiber matched but is being unmounted, there's no use trying.\n      // Reset the state so we don't keep holding onto it.\n      setTrackedPath(null);\n    }\n\n    var id = instance.id;\n    pendingRealUnmountedIDs.push(id);\n  }\n\n  function getSecondaryEnvironmentName(debugInfo, index) {\n    if (debugInfo != null) {\n      var componentInfo = debugInfo[index];\n\n      for (var i = index + 1; i < debugInfo.length; i++) {\n        var debugEntry = debugInfo[i];\n\n        if (typeof debugEntry.env === 'string') {\n          // If the next environment is different then this component was the boundary\n          // and it changed before entering the next component. So we assign this\n          // component a secondary environment.\n          return componentInfo.env !== debugEntry.env ? debugEntry.env : null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function mountVirtualChildrenRecursively(firstChild, lastChild, // non-inclusive\n  traceNearestHostComponentUpdate, virtualLevel) {\n    // Iterate over siblings rather than recursing.\n    // This reduces the chance of stack overflow for wide trees (e.g. lists with many items).\n    var fiber = firstChild;\n    var previousVirtualInstance = null;\n    var previousVirtualInstanceFirstFiber = firstChild;\n\n    while (fiber !== null && fiber !== lastChild) {\n      var level = 0;\n\n      if (fiber._debugInfo) {\n        for (var i = 0; i < fiber._debugInfo.length; i++) {\n          var debugEntry = fiber._debugInfo[i];\n\n          if (typeof debugEntry.name !== 'string') {\n            // Not a Component. Some other Debug Info.\n            continue;\n          } // Scan up until the next Component to see if this component changed environment.\n\n\n          var componentInfo = debugEntry;\n          var secondaryEnv = getSecondaryEnvironmentName(fiber._debugInfo, i);\n\n          if (componentInfo.env != null) {\n            knownEnvironmentNames.add(componentInfo.env);\n          }\n\n          if (secondaryEnv !== null) {\n            knownEnvironmentNames.add(secondaryEnv);\n          }\n\n          if (shouldFilterVirtual(componentInfo, secondaryEnv)) {\n            // Skip.\n            continue;\n          }\n\n          if (level === virtualLevel) {\n            if (previousVirtualInstance === null || // Consecutive children with the same debug entry as a parent gets\n            // treated as if they share the same virtual instance.\n            previousVirtualInstance.data !== debugEntry) {\n              if (previousVirtualInstance !== null) {\n                // Mount any previous children that should go into the previous parent.\n                mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceFirstFiber, fiber, traceNearestHostComponentUpdate, virtualLevel);\n              }\n\n              previousVirtualInstance = createVirtualInstance(componentInfo);\n              recordVirtualMount(previousVirtualInstance, reconcilingParent, secondaryEnv);\n              insertChild(previousVirtualInstance);\n              previousVirtualInstanceFirstFiber = fiber;\n            }\n\n            level++;\n            break;\n          } else {\n            level++;\n          }\n        }\n      }\n\n      if (level === virtualLevel) {\n        if (previousVirtualInstance !== null) {\n          // If we were working on a virtual instance and this is not a virtual\n          // instance, then we end the sequence and mount any previous children\n          // that should go into the previous virtual instance.\n          mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceFirstFiber, fiber, traceNearestHostComponentUpdate, virtualLevel);\n          previousVirtualInstance = null;\n        } // We've reached the end of the virtual levels, but not beyond,\n        // and now continue with the regular fiber.\n\n\n        mountFiberRecursively(fiber, traceNearestHostComponentUpdate);\n      }\n\n      fiber = fiber.sibling;\n    }\n\n    if (previousVirtualInstance !== null) {\n      // Mount any previous children that should go into the previous parent.\n      mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceFirstFiber, null, traceNearestHostComponentUpdate, virtualLevel);\n    }\n  }\n\n  function mountChildrenRecursively(firstChild, traceNearestHostComponentUpdate) {\n    mountVirtualChildrenRecursively(firstChild, null, traceNearestHostComponentUpdate, 0 // first level\n    );\n  }\n\n  function mountFiberRecursively(fiber, traceNearestHostComponentUpdate) {\n    var shouldIncludeInTree = !shouldFilterFiber(fiber);\n    var newInstance = null;\n\n    if (shouldIncludeInTree) {\n      newInstance = recordMount(fiber, reconcilingParent);\n      insertChild(newInstance);\n\n      if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n        debug('mountFiberRecursively()', newInstance, reconcilingParent);\n      }\n    } else if (reconcilingParent !== null && reconcilingParent.kind === VIRTUAL_INSTANCE) {\n      // If the parent is a Virtual Instance and we filtered this Fiber we include a\n      // hidden node.\n      if (reconcilingParent.data === fiber._debugOwner && fiber._debugStack != null && reconcilingParent.source === null) {\n        // The new Fiber is directly owned by the parent. Therefore somewhere on the\n        // debugStack will be a stack frame inside parent that we can use as its soruce.\n        reconcilingParent.source = fiber._debugStack;\n      }\n\n      newInstance = createFilteredFiberInstance(fiber);\n      insertChild(newInstance);\n\n      if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n        debug('mountFiberRecursively()', newInstance, reconcilingParent);\n      }\n    } // If we have the tree selection from previous reload, try to match this Fiber.\n    // Also remember whether to do the same for siblings.\n\n\n    var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber, newInstance);\n    var stashedParent = reconcilingParent;\n    var stashedPrevious = previouslyReconciledSibling;\n    var stashedRemaining = remainingReconcilingChildren;\n\n    if (newInstance !== null) {\n      // Push a new DevTools instance parent while reconciling this subtree.\n      reconcilingParent = newInstance;\n      previouslyReconciledSibling = null;\n      remainingReconcilingChildren = null;\n    }\n\n    try {\n      if (traceUpdatesEnabled) {\n        if (traceNearestHostComponentUpdate) {\n          var elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n\n          if (elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeHostComponent) {\n            traceUpdatesForNodes.add(fiber.stateNode);\n            traceNearestHostComponentUpdate = false;\n          }\n        } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,\n        // because we don't want to highlight every host node inside of a newly mounted subtree.\n\n      }\n\n      if (fiber.tag === HostHoistable) {\n        var nearestInstance = reconcilingParent;\n\n        if (nearestInstance === null) {\n          throw new Error('Did not expect a host hoistable to be the root');\n        }\n\n        aquireHostResource(nearestInstance, fiber.memoizedState);\n      } else if (fiber.tag === HostComponent || fiber.tag === HostText || fiber.tag === HostSingleton) {\n        var _nearestInstance = reconcilingParent;\n\n        if (_nearestInstance === null) {\n          throw new Error('Did not expect a host hoistable to be the root');\n        }\n\n        aquireHostInstance(_nearestInstance, fiber.stateNode);\n      }\n\n      if (fiber.tag === SuspenseComponent) {\n        var isTimedOut = fiber.memoizedState !== null;\n\n        if (isTimedOut) {\n          // Special case: if Suspense mounts in a timed-out state,\n          // get the fallback child from the inner fragment and mount\n          // it as if it was our own child. Updates handle this too.\n          var primaryChildFragment = fiber.child;\n          var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n\n          if (fallbackChildFragment) {\n            var fallbackChild = fallbackChildFragment.child;\n\n            if (fallbackChild !== null) {\n              updateTrackedPathStateBeforeMount(fallbackChildFragment, null);\n              mountChildrenRecursively(fallbackChild, traceNearestHostComponentUpdate);\n            }\n          }\n        } else {\n          var primaryChild = null;\n          var areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;\n\n          if (areSuspenseChildrenConditionallyWrapped) {\n            primaryChild = fiber.child;\n          } else if (fiber.child !== null) {\n            primaryChild = fiber.child.child;\n            updateTrackedPathStateBeforeMount(fiber.child, null);\n          }\n\n          if (primaryChild !== null) {\n            mountChildrenRecursively(primaryChild, traceNearestHostComponentUpdate);\n          }\n        }\n      } else {\n        if (fiber.child !== null) {\n          mountChildrenRecursively(fiber.child, traceNearestHostComponentUpdate);\n        }\n      }\n    } finally {\n      if (newInstance !== null) {\n        reconcilingParent = stashedParent;\n        previouslyReconciledSibling = stashedPrevious;\n        remainingReconcilingChildren = stashedRemaining;\n      }\n    } // We're exiting this Fiber now, and entering its siblings.\n    // If we have selection to restore, we might need to re-activate tracking.\n\n\n    updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);\n  } // We use this to simulate unmounting for Suspense trees\n  // when we switch from primary to fallback, or deleting a subtree.\n\n\n  function unmountInstanceRecursively(instance) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      debug('unmountInstanceRecursively()', instance, reconcilingParent);\n    }\n\n    var stashedParent = reconcilingParent;\n    var stashedPrevious = previouslyReconciledSibling;\n    var stashedRemaining = remainingReconcilingChildren; // Push a new DevTools instance parent while reconciling this subtree.\n\n    reconcilingParent = instance;\n    previouslyReconciledSibling = null; // Move all the children of this instance to the remaining set.\n\n    remainingReconcilingChildren = instance.firstChild;\n    instance.firstChild = null;\n\n    try {\n      // Unmount the remaining set.\n      unmountRemainingChildren();\n    } finally {\n      reconcilingParent = stashedParent;\n      previouslyReconciledSibling = stashedPrevious;\n      remainingReconcilingChildren = stashedRemaining;\n    }\n\n    if (instance.kind === FIBER_INSTANCE) {\n      recordUnmount(instance);\n    } else if (instance.kind === VIRTUAL_INSTANCE) {\n      recordVirtualUnmount(instance);\n    } else {\n      untrackFiber(instance, instance.data);\n    }\n\n    removeChild(instance, null);\n  }\n\n  function recordProfilingDurations(fiberInstance, prevFiber) {\n    var id = fiberInstance.id;\n    var fiber = fiberInstance.data;\n    var actualDuration = fiber.actualDuration,\n        treeBaseDuration = fiber.treeBaseDuration;\n    fiberInstance.treeBaseDuration = treeBaseDuration || 0;\n\n    if (isProfiling) {\n      // It's important to update treeBaseDuration even if the current Fiber did not render,\n      // because it's possible that one of its descendants did.\n      if (prevFiber == null || treeBaseDuration !== prevFiber.treeBaseDuration) {\n        // Tree base duration updates are included in the operations typed array.\n        // So we have to convert them from milliseconds to microseconds so we can send them as ints.\n        var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);\n        pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_TREE_BASE_DURATION);\n        pushOperation(id);\n        pushOperation(convertedTreeBaseDuration);\n      }\n\n      if (prevFiber == null || didFiberRender(prevFiber, fiber)) {\n        if (actualDuration != null) {\n          // The actual duration reported by React includes time spent working on children.\n          // This is useful information, but it's also useful to be able to exclude child durations.\n          // The frontend can't compute this, since the immediate children may have been filtered out.\n          // So we need to do this on the backend.\n          // Note that this calculated self duration is not the same thing as the base duration.\n          // The two are calculated differently (tree duration does not accumulate).\n          var selfDuration = actualDuration;\n          var child = fiber.child;\n\n          while (child !== null) {\n            selfDuration -= child.actualDuration || 0;\n            child = child.sibling;\n          } // If profiling is active, store durations for elements that were rendered during the commit.\n          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.\n          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)\n          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we \"bailed out\".\n\n\n          var metadata = currentCommitProfilingMetadata;\n          metadata.durations.push(id, actualDuration, selfDuration);\n          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);\n\n          if (recordChangeDescriptions) {\n            var changeDescription = getChangeDescription(prevFiber, fiber);\n\n            if (changeDescription !== null) {\n              if (metadata.changeDescriptions !== null) {\n                metadata.changeDescriptions.set(id, changeDescription);\n              }\n            }\n          }\n        }\n      } // If this Fiber was in the set of memoizedUpdaters we need to record\n      // it to be included in the description of the commit.\n\n\n      var fiberRoot = currentRoot.data.stateNode;\n      var updaters = fiberRoot.memoizedUpdaters;\n\n      if (updaters != null && (updaters.has(fiber) || // We check the alternate here because we're matching identity and\n      // prevFiber might be same as fiber.\n      fiber.alternate !== null && updaters.has(fiber.alternate))) {\n        var _metadata = currentCommitProfilingMetadata;\n\n        if (_metadata.updaters === null) {\n          _metadata.updaters = [];\n        }\n\n        _metadata.updaters.push(instanceToSerializedElement(fiberInstance));\n      }\n    }\n  }\n\n  function recordVirtualProfilingDurations(virtualInstance) {\n    var id = virtualInstance.id;\n    var treeBaseDuration = 0; // Add up the base duration of the child instances. The virtual base duration\n    // will be the same as children's duration since we don't take up any render\n    // time in the virtual instance.\n\n    for (var child = virtualInstance.firstChild; child !== null; child = child.nextSibling) {\n      treeBaseDuration += child.treeBaseDuration;\n    }\n\n    if (isProfiling) {\n      var previousTreeBaseDuration = virtualInstance.treeBaseDuration;\n\n      if (treeBaseDuration !== previousTreeBaseDuration) {\n        // Tree base duration updates are included in the operations typed array.\n        // So we have to convert them from milliseconds to microseconds so we can send them as ints.\n        var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);\n        pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_TREE_BASE_DURATION);\n        pushOperation(id);\n        pushOperation(convertedTreeBaseDuration);\n      }\n    }\n\n    virtualInstance.treeBaseDuration = treeBaseDuration;\n  }\n\n  function recordResetChildren(parentInstance) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      if (parentInstance.firstChild !== null) {\n        debug('recordResetChildren()', parentInstance.firstChild, parentInstance);\n      }\n    } // The frontend only really cares about the displayName, key, and children.\n    // The first two don't really change, so we are only concerned with the order of children here.\n    // This is trickier than a simple comparison though, since certain types of fibers are filtered.\n\n\n    var nextChildren = [];\n    var child = parentInstance.firstChild;\n\n    while (child !== null) {\n      if (child.kind === FILTERED_FIBER_INSTANCE) {\n        for (var innerChild = parentInstance.firstChild; innerChild !== null; innerChild = innerChild.nextSibling) {\n          nextChildren.push(innerChild.id);\n        }\n      } else {\n        nextChildren.push(child.id);\n      }\n\n      child = child.nextSibling;\n    }\n\n    var numChildren = nextChildren.length;\n\n    if (numChildren < 2) {\n      // No need to reorder.\n      return;\n    }\n\n    pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REORDER_CHILDREN);\n    pushOperation(parentInstance.id);\n    pushOperation(numChildren);\n\n    for (var i = 0; i < nextChildren.length; i++) {\n      pushOperation(nextChildren[i]);\n    }\n  }\n\n  function updateVirtualInstanceRecursively(virtualInstance, nextFirstChild, nextLastChild, // non-inclusive\n  prevFirstChild, traceNearestHostComponentUpdate, virtualLevel) {\n    var stashedParent = reconcilingParent;\n    var stashedPrevious = previouslyReconciledSibling;\n    var stashedRemaining = remainingReconcilingChildren; // Push a new DevTools instance parent while reconciling this subtree.\n\n    reconcilingParent = virtualInstance;\n    previouslyReconciledSibling = null; // Move all the children of this instance to the remaining set.\n    // We'll move them back one by one, and anything that remains is deleted.\n\n    remainingReconcilingChildren = virtualInstance.firstChild;\n    virtualInstance.firstChild = null;\n\n    try {\n      if (updateVirtualChildrenRecursively(nextFirstChild, nextLastChild, prevFirstChild, traceNearestHostComponentUpdate, virtualLevel + 1)) {\n        recordResetChildren(virtualInstance);\n      } // Update the errors/warnings count. If this Instance has switched to a different\n      // ReactComponentInfo instance, such as when refreshing Server Components, then\n      // we replace all the previous logs with the ones associated with the new ones rather\n      // than merging. Because deduping is expected to happen at the request level.\n\n\n      var componentLogsEntry = _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_7__.componentInfoToComponentLogsMap.get(virtualInstance.data);\n      recordConsoleLogs(virtualInstance, componentLogsEntry); // Must be called after all children have been appended.\n\n      recordVirtualProfilingDurations(virtualInstance);\n    } finally {\n      unmountRemainingChildren();\n      reconcilingParent = stashedParent;\n      previouslyReconciledSibling = stashedPrevious;\n      remainingReconcilingChildren = stashedRemaining;\n    }\n  }\n\n  function updateVirtualChildrenRecursively(nextFirstChild, nextLastChild, // non-inclusive\n  prevFirstChild, traceNearestHostComponentUpdate, virtualLevel) {\n    var shouldResetChildren = false; // If the first child is different, we need to traverse them.\n    // Each next child will be either a new child (mount) or an alternate (update).\n\n    var nextChild = nextFirstChild;\n    var prevChildAtSameIndex = prevFirstChild;\n    var previousVirtualInstance = null;\n    var previousVirtualInstanceWasMount = false;\n    var previousVirtualInstanceNextFirstFiber = nextFirstChild;\n    var previousVirtualInstancePrevFirstFiber = prevFirstChild;\n\n    while (nextChild !== null && nextChild !== nextLastChild) {\n      var level = 0;\n\n      if (nextChild._debugInfo) {\n        for (var i = 0; i < nextChild._debugInfo.length; i++) {\n          var debugEntry = nextChild._debugInfo[i];\n\n          if (typeof debugEntry.name !== 'string') {\n            // Not a Component. Some other Debug Info.\n            continue;\n          }\n\n          var componentInfo = debugEntry;\n          var secondaryEnv = getSecondaryEnvironmentName(nextChild._debugInfo, i);\n\n          if (componentInfo.env != null) {\n            knownEnvironmentNames.add(componentInfo.env);\n          }\n\n          if (secondaryEnv !== null) {\n            knownEnvironmentNames.add(secondaryEnv);\n          }\n\n          if (shouldFilterVirtual(componentInfo, secondaryEnv)) {\n            continue;\n          }\n\n          if (level === virtualLevel) {\n            if (previousVirtualInstance === null || // Consecutive children with the same debug entry as a parent gets\n            // treated as if they share the same virtual instance.\n            previousVirtualInstance.data !== componentInfo) {\n              if (previousVirtualInstance !== null) {\n                // Mount any previous children that should go into the previous parent.\n                if (previousVirtualInstanceWasMount) {\n                  mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, traceNearestHostComponentUpdate, virtualLevel);\n                } else {\n                  updateVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, previousVirtualInstancePrevFirstFiber, traceNearestHostComponentUpdate, virtualLevel);\n                }\n              }\n\n              var previousSiblingOfBestMatch = null;\n              var bestMatch = remainingReconcilingChildren;\n\n              if (componentInfo.key != null) {\n                // If there is a key try to find a matching key in the set.\n                bestMatch = remainingReconcilingChildren;\n\n                while (bestMatch !== null) {\n                  if (bestMatch.kind === VIRTUAL_INSTANCE && bestMatch.data.key === componentInfo.key) {\n                    break;\n                  }\n\n                  previousSiblingOfBestMatch = bestMatch;\n                  bestMatch = bestMatch.nextSibling;\n                }\n              }\n\n              if (bestMatch !== null && bestMatch.kind === VIRTUAL_INSTANCE && bestMatch.data.name === componentInfo.name && bestMatch.data.env === componentInfo.env && bestMatch.data.key === componentInfo.key) {\n                // If the previous children had a virtual instance in the same slot\n                // with the same name, then we claim it and reuse it for this update.\n                // Update it with the latest entry.\n                bestMatch.data = componentInfo;\n                moveChild(bestMatch, previousSiblingOfBestMatch);\n                previousVirtualInstance = bestMatch;\n                previousVirtualInstanceWasMount = false;\n              } else {\n                // Otherwise we create a new instance.\n                var newVirtualInstance = createVirtualInstance(componentInfo);\n                recordVirtualMount(newVirtualInstance, reconcilingParent, secondaryEnv);\n                insertChild(newVirtualInstance);\n                previousVirtualInstance = newVirtualInstance;\n                previousVirtualInstanceWasMount = true;\n                shouldResetChildren = true;\n              } // Existing children might be reparented into this new virtual instance.\n              // TODO: This will cause the front end to error which needs to be fixed.\n\n\n              previousVirtualInstanceNextFirstFiber = nextChild;\n              previousVirtualInstancePrevFirstFiber = prevChildAtSameIndex;\n            }\n\n            level++;\n            break;\n          } else {\n            level++;\n          }\n        }\n      }\n\n      if (level === virtualLevel) {\n        if (previousVirtualInstance !== null) {\n          // If we were working on a virtual instance and this is not a virtual\n          // instance, then we end the sequence and update any previous children\n          // that should go into the previous virtual instance.\n          if (previousVirtualInstanceWasMount) {\n            mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, traceNearestHostComponentUpdate, virtualLevel);\n          } else {\n            updateVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, previousVirtualInstancePrevFirstFiber, traceNearestHostComponentUpdate, virtualLevel);\n          }\n\n          previousVirtualInstance = null;\n        } // We've reached the end of the virtual levels, but not beyond,\n        // and now continue with the regular fiber.\n        // Do a fast pass over the remaining children to find the previous instance.\n        // TODO: This doesn't have the best O(n) for a large set of children that are\n        // reordered. Consider using a temporary map if it's not the very next one.\n\n\n        var prevChild = void 0;\n\n        if (prevChildAtSameIndex === nextChild) {\n          // This set is unchanged. We're just going through it to place all the\n          // children again.\n          prevChild = nextChild;\n        } else {\n          // We don't actually need to rely on the alternate here. We could also\n          // reconcile against stateNode, key or whatever. Doesn't have to be same\n          // Fiber pair.\n          prevChild = nextChild.alternate;\n        }\n\n        var previousSiblingOfExistingInstance = null;\n        var existingInstance = null;\n\n        if (prevChild !== null) {\n          existingInstance = remainingReconcilingChildren;\n\n          while (existingInstance !== null) {\n            if (existingInstance.data === prevChild) {\n              break;\n            }\n\n            previousSiblingOfExistingInstance = existingInstance;\n            existingInstance = existingInstance.nextSibling;\n          }\n        }\n\n        if (existingInstance !== null) {\n          // Common case. Match in the same parent.\n          var fiberInstance = existingInstance; // Only matches if it's a Fiber.\n          // We keep track if the order of the children matches the previous order.\n          // They are always different referentially, but if the instances line up\n          // conceptually we'll want to know that.\n\n          if (prevChild !== prevChildAtSameIndex) {\n            shouldResetChildren = true;\n          }\n\n          moveChild(fiberInstance, previousSiblingOfExistingInstance);\n\n          if (updateFiberRecursively(fiberInstance, nextChild, prevChild, traceNearestHostComponentUpdate)) {\n            // If a nested tree child order changed but it can't handle its own\n            // child order invalidation (e.g. because it's filtered out like host nodes),\n            // propagate the need to reset child order upwards to this Fiber.\n            shouldResetChildren = true;\n          }\n        } else if (prevChild !== null && shouldFilterFiber(nextChild)) {\n          // If this Fiber should be filtered, we need to still update its children.\n          // This relies on an alternate since we don't have an Instance with the previous\n          // child on it. Ideally, the reconciliation wouldn't need previous Fibers that\n          // are filtered from the tree.\n          if (updateFiberRecursively(null, nextChild, prevChild, traceNearestHostComponentUpdate)) {\n            shouldResetChildren = true;\n          }\n        } else {\n          // It's possible for a FiberInstance to be reparented when virtual parents\n          // get their sequence split or change structure with the same render result.\n          // In this case we unmount the and remount the FiberInstances.\n          // This might cause us to lose the selection but it's an edge case.\n          // We let the previous instance remain in the \"remaining queue\" it is\n          // in to be deleted at the end since it'll have no match.\n          mountFiberRecursively(nextChild, traceNearestHostComponentUpdate); // Need to mark the parent set to remount the new instance.\n\n          shouldResetChildren = true;\n        }\n      } // Try the next child.\n\n\n      nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can\n      // keep comparing if they line up.\n\n      if (!shouldResetChildren && prevChildAtSameIndex !== null) {\n        prevChildAtSameIndex = prevChildAtSameIndex.sibling;\n      }\n    }\n\n    if (previousVirtualInstance !== null) {\n      if (previousVirtualInstanceWasMount) {\n        mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, null, traceNearestHostComponentUpdate, virtualLevel);\n      } else {\n        updateVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, null, previousVirtualInstancePrevFirstFiber, traceNearestHostComponentUpdate, virtualLevel);\n      }\n    } // If we have no more children, but used to, they don't line up.\n\n\n    if (prevChildAtSameIndex !== null) {\n      shouldResetChildren = true;\n    }\n\n    return shouldResetChildren;\n  } // Returns whether closest unfiltered fiber parent needs to reset its child list.\n\n\n  function updateChildrenRecursively(nextFirstChild, prevFirstChild, traceNearestHostComponentUpdate) {\n    if (nextFirstChild === null) {\n      return prevFirstChild !== null;\n    }\n\n    return updateVirtualChildrenRecursively(nextFirstChild, null, prevFirstChild, traceNearestHostComponentUpdate, 0);\n  } // Returns whether closest unfiltered fiber parent needs to reset its child list.\n\n\n  function updateFiberRecursively(fiberInstance, // null if this should be filtered\n  nextFiber, prevFiber, traceNearestHostComponentUpdate) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      if (fiberInstance !== null) {\n        debug('updateFiberRecursively()', fiberInstance, reconcilingParent);\n      }\n    }\n\n    if (traceUpdatesEnabled) {\n      var elementType = getElementTypeForFiber(nextFiber);\n\n      if (traceNearestHostComponentUpdate) {\n        // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n        if (elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeHostComponent) {\n          traceUpdatesForNodes.add(nextFiber.stateNode);\n          traceNearestHostComponentUpdate = false;\n        }\n      } else {\n        if (elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeFunction || elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeClass || elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeContext || elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeMemo || elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeForwardRef) {\n          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).\n          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);\n        }\n      }\n    }\n\n    var stashedParent = reconcilingParent;\n    var stashedPrevious = previouslyReconciledSibling;\n    var stashedRemaining = remainingReconcilingChildren;\n\n    if (fiberInstance !== null) {\n      // Update the Fiber so we that we always keep the current Fiber on the data.\n      fiberInstance.data = nextFiber;\n\n      if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberInstance.id && didFiberRender(prevFiber, nextFiber)) {\n        // If this Fiber has updated, clear cached inspected data.\n        // If it is inspected again, it may need to be re-run to obtain updated hooks values.\n        hasElementUpdatedSinceLastInspected = true;\n      } // Push a new DevTools instance parent while reconciling this subtree.\n\n\n      reconcilingParent = fiberInstance;\n      previouslyReconciledSibling = null; // Move all the children of this instance to the remaining set.\n      // We'll move them back one by one, and anything that remains is deleted.\n\n      remainingReconcilingChildren = fiberInstance.firstChild;\n      fiberInstance.firstChild = null;\n    }\n\n    try {\n      if (nextFiber.tag === HostHoistable) {\n        var nearestInstance = reconcilingParent;\n\n        if (nearestInstance === null) {\n          throw new Error('Did not expect a host hoistable to be the root');\n        }\n\n        releaseHostResource(nearestInstance, prevFiber.memoizedState);\n        aquireHostResource(nearestInstance, nextFiber.memoizedState);\n      }\n\n      var isSuspense = nextFiber.tag === SuspenseComponent;\n      var shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.\n      // Rather than unmount the timed out content (and possibly lose important state),\n      // React re-parents this content within a hidden Fragment while the fallback is showing.\n      // This behavior doesn't need to be observable in the DevTools though.\n      // It might even result in a bad user experience for e.g. node selection in the Elements panel.\n      // The easiest fix is to strip out the intermediate Fragment fibers,\n      // so the Elements panel and Profiler don't need to special case them.\n      // Suspense components only have a non-null memoizedState if they're timed-out.\n\n      var prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n      var nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()\n      // inside ReactFiberBeginWork in the React source code.\n\n      if (prevDidTimeout && nextDidTimeOut) {\n        // Fallback -> Fallback:\n        // 1. Reconcile fallback set.\n        var nextFiberChild = nextFiber.child;\n        var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate\n        // because the set is special and alternate may not exist.\n\n        var prevFiberChild = prevFiber.child;\n        var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;\n\n        if (prevFallbackChildSet == null && nextFallbackChildSet != null) {\n          mountChildrenRecursively(nextFallbackChildSet, traceNearestHostComponentUpdate);\n          shouldResetChildren = true;\n        }\n\n        if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateChildrenRecursively(nextFallbackChildSet, prevFallbackChildSet, traceNearestHostComponentUpdate)) {\n          shouldResetChildren = true;\n        }\n      } else if (prevDidTimeout && !nextDidTimeOut) {\n        // Fallback -> Primary:\n        // 1. Unmount fallback set\n        // Note: don't emulate fallback unmount because React actually did it.\n        // 2. Mount primary set\n        var nextPrimaryChildSet = nextFiber.child;\n\n        if (nextPrimaryChildSet !== null) {\n          mountChildrenRecursively(nextPrimaryChildSet, traceNearestHostComponentUpdate);\n        }\n\n        shouldResetChildren = true;\n      } else if (!prevDidTimeout && nextDidTimeOut) {\n        // Primary -> Fallback:\n        // 1. Hide primary set\n        // We simply don't re-add the fallback children and let\n        // unmountRemainingChildren() handle it.\n        // 2. Mount fallback set\n        var _nextFiberChild = nextFiber.child;\n\n        var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;\n\n        if (_nextFallbackChildSet != null) {\n          mountChildrenRecursively(_nextFallbackChildSet, traceNearestHostComponentUpdate);\n          shouldResetChildren = true;\n        }\n      } else {\n        // Common case: Primary -> Primary.\n        // This is the same code path as for non-Suspense fibers.\n        if (nextFiber.child !== prevFiber.child) {\n          if (updateChildrenRecursively(nextFiber.child, prevFiber.child, traceNearestHostComponentUpdate)) {\n            shouldResetChildren = true;\n          }\n        } else {\n          // Children are unchanged.\n          if (fiberInstance !== null) {\n            // All the remaining children will be children of this same fiber so we can just reuse them.\n            // I.e. we just restore them by undoing what we did above.\n            fiberInstance.firstChild = remainingReconcilingChildren;\n            remainingReconcilingChildren = null;\n\n            if (traceUpdatesEnabled) {\n              // If we're tracing updates and we've bailed out before reaching a host node,\n              // we should fall back to recursively marking the nearest host descendants for highlight.\n              if (traceNearestHostComponentUpdate) {\n                var hostInstances = findAllCurrentHostInstances(fiberInstance);\n                hostInstances.forEach(function (hostInstance) {\n                  traceUpdatesForNodes.add(hostInstance);\n                });\n              }\n            }\n          } else {\n            // If this fiber is filtered there might be changes to this set elsewhere so we have\n            // to visit each child to place it back in the set. We let the child bail out instead.\n            if (updateChildrenRecursively(nextFiber.child, prevFiber.child, false)) {\n              throw new Error('The children should not have changed if we pass in the same set.');\n            }\n          }\n        }\n      }\n\n      if (fiberInstance !== null) {\n        var componentLogsEntry = fiberToComponentLogsMap.get(fiberInstance.data);\n\n        if (componentLogsEntry === undefined && fiberInstance.data.alternate) {\n          componentLogsEntry = fiberToComponentLogsMap.get(fiberInstance.data.alternate);\n        }\n\n        recordConsoleLogs(fiberInstance, componentLogsEntry);\n        var isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');\n\n        if (isProfilingSupported) {\n          recordProfilingDurations(fiberInstance, prevFiber);\n        }\n      }\n\n      if (shouldResetChildren) {\n        // We need to crawl the subtree for closest non-filtered Fibers\n        // so that we can display them in a flat children set.\n        if (fiberInstance !== null) {\n          recordResetChildren(fiberInstance); // We've handled the child order change for this Fiber.\n          // Since it's included, there's no need to invalidate parent child order.\n\n          return false;\n        } else {\n          // Let the closest unfiltered parent Fiber reset its child order instead.\n          return true;\n        }\n      } else {\n        return false;\n      }\n    } finally {\n      if (fiberInstance !== null) {\n        unmountRemainingChildren();\n        reconcilingParent = stashedParent;\n        previouslyReconciledSibling = stashedPrevious;\n        remainingReconcilingChildren = stashedRemaining;\n      }\n    }\n  }\n\n  function cleanup() {\n    isProfiling = false;\n  }\n\n  function rootSupportsProfiling(root) {\n    if (root.memoizedInteractions != null) {\n      // v16 builds include this field for the scheduler/tracing API.\n      return true;\n    } else if (root.current != null && root.current.hasOwnProperty('treeBaseDuration')) {\n      // The scheduler/tracing API was removed in v17 though\n      // so we need to check a non-root Fiber.\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function flushInitialOperations() {\n    var localPendingOperationsQueue = pendingOperationsQueue;\n    pendingOperationsQueue = null;\n\n    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {\n      // We may have already queued up some operations before the frontend connected\n      // If so, let the frontend know about them.\n      localPendingOperationsQueue.forEach(function (operations) {\n        hook.emit('operations', operations);\n      });\n    } else {\n      // Before the traversals, remember to start tracking\n      // our path in case we have selection to restore.\n      if (trackedPath !== null) {\n        mightBeOnTrackedPath = true;\n      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.\n\n\n      hook.getFiberRoots(rendererID).forEach(function (root) {\n        var current = root.current;\n        var newRoot = createFiberInstance(current);\n        rootToFiberInstanceMap.set(root, newRoot);\n        idToDevToolsInstanceMap.set(newRoot.id, newRoot);\n        currentRoot = newRoot;\n        setRootPseudoKey(currentRoot.id, root.current); // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n        if (isProfiling && rootSupportsProfiling(root)) {\n          // If profiling is active, store commit time and duration.\n          // The frontend may request this information after profiling has stopped.\n          currentCommitProfilingMetadata = {\n            changeDescriptions: recordChangeDescriptions ? new Map() : null,\n            durations: [],\n            commitTime: getCurrentTime() - profilingStartTime,\n            maxActualDuration: 0,\n            priorityLevel: null,\n            updaters: null,\n            effectDuration: null,\n            passiveEffectDuration: null\n          };\n        }\n\n        mountFiberRecursively(root.current, false);\n        flushPendingEvents(root);\n        needsToFlushComponentLogs = false;\n        currentRoot = null;\n      });\n    }\n  }\n\n  function handleCommitFiberUnmount(fiber) {// This Hook is no longer used. After having shipped DevTools everywhere it is\n    // safe to stop calling it from Fiber.\n  }\n\n  function handlePostCommitFiberRoot(root) {\n    if (isProfiling && rootSupportsProfiling(root)) {\n      if (currentCommitProfilingMetadata !== null) {\n        var _getEffectDurations = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.getEffectDurations)(root),\n            effectDuration = _getEffectDurations.effectDuration,\n            passiveEffectDuration = _getEffectDurations.passiveEffectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentCommitProfilingMetadata.effectDuration = effectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;\n      }\n    }\n\n    if (needsToFlushComponentLogs) {\n      // We received new logs after commit. I.e. in a passive effect. We need to\n      // traverse the tree to find the affected ones. If we just moved the whole\n      // tree traversal from handleCommitFiberRoot to handlePostCommitFiberRoot\n      // this wouldn't be needed. For now we just brute force check all instances.\n      // This is not that common of a case.\n      bruteForceFlushErrorsAndWarnings();\n    }\n  }\n\n  function handleCommitFiberRoot(root, priorityLevel) {\n    var current = root.current;\n    var prevFiber = null;\n    var rootInstance = rootToFiberInstanceMap.get(root);\n\n    if (!rootInstance) {\n      rootInstance = createFiberInstance(current);\n      rootToFiberInstanceMap.set(root, rootInstance);\n      idToDevToolsInstanceMap.set(rootInstance.id, rootInstance);\n    } else {\n      prevFiber = rootInstance.data;\n    }\n\n    currentRoot = rootInstance; // Before the traversals, remember to start tracking\n    // our path in case we have selection to restore.\n\n    if (trackedPath !== null) {\n      mightBeOnTrackedPath = true;\n    }\n\n    if (traceUpdatesEnabled) {\n      traceUpdatesForNodes.clear();\n    } // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n\n    var isProfilingSupported = rootSupportsProfiling(root);\n\n    if (isProfiling && isProfilingSupported) {\n      // If profiling is active, store commit time and duration.\n      // The frontend may request this information after profiling has stopped.\n      currentCommitProfilingMetadata = {\n        changeDescriptions: recordChangeDescriptions ? new Map() : null,\n        durations: [],\n        commitTime: getCurrentTime() - profilingStartTime,\n        maxActualDuration: 0,\n        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),\n        updaters: null,\n        // Initialize to null; if new enough React version is running,\n        // these values will be read during separate handlePostCommitFiberRoot() call.\n        effectDuration: null,\n        passiveEffectDuration: null\n      };\n    }\n\n    if (prevFiber !== null) {\n      // TODO: relying on this seems a bit fishy.\n      var wasMounted = prevFiber.memoizedState != null && prevFiber.memoizedState.element != null && // A dehydrated root is not considered mounted\n      prevFiber.memoizedState.isDehydrated !== true;\n      var isMounted = current.memoizedState != null && current.memoizedState.element != null && // A dehydrated root is not considered mounted\n      current.memoizedState.isDehydrated !== true;\n\n      if (!wasMounted && isMounted) {\n        // Mount a new root.\n        setRootPseudoKey(currentRoot.id, current);\n        mountFiberRecursively(current, false);\n      } else if (wasMounted && isMounted) {\n        // Update an existing root.\n        updateFiberRecursively(rootInstance, current, prevFiber, false);\n      } else if (wasMounted && !isMounted) {\n        // Unmount an existing root.\n        unmountInstanceRecursively(rootInstance);\n        removeRootPseudoKey(currentRoot.id);\n        rootToFiberInstanceMap.delete(root);\n      }\n    } else {\n      // Mount a new root.\n      setRootPseudoKey(currentRoot.id, current);\n      mountFiberRecursively(current, false);\n    }\n\n    if (isProfiling && isProfilingSupported) {\n      if (!shouldBailoutWithPendingOperations()) {\n        var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRoot.id);\n\n        if (commitProfilingMetadata != null) {\n          commitProfilingMetadata.push(currentCommitProfilingMetadata);\n        } else {\n          rootToCommitProfilingMetadataMap.set(currentRoot.id, [currentCommitProfilingMetadata]);\n        }\n      }\n    } // We're done here.\n\n\n    flushPendingEvents(root);\n    needsToFlushComponentLogs = false;\n\n    if (traceUpdatesEnabled) {\n      hook.emit('traceUpdates', traceUpdatesForNodes);\n    }\n\n    currentRoot = null;\n  }\n\n  function getResourceInstance(fiber) {\n    if (fiber.tag === HostHoistable) {\n      var resource = fiber.memoizedState; // Feature Detect a DOM Specific Instance of a Resource\n\n      if (_typeof(resource) === 'object' && resource !== null && resource.instance != null) {\n        return resource.instance;\n      }\n    }\n\n    return null;\n  }\n\n  function appendHostInstancesByDevToolsInstance(devtoolsInstance, hostInstances) {\n    if (devtoolsInstance.kind !== VIRTUAL_INSTANCE) {\n      var _fiber4 = devtoolsInstance.data;\n      appendHostInstancesByFiber(_fiber4, hostInstances);\n      return;\n    } // Search the tree for the nearest child Fiber and add all its host instances.\n    // TODO: If the true nearest Fiber is filtered, we might skip it and instead include all\n    // the children below it. In the extreme case, searching the whole tree.\n\n\n    for (var child = devtoolsInstance.firstChild; child !== null; child = child.nextSibling) {\n      appendHostInstancesByDevToolsInstance(child, hostInstances);\n    }\n  }\n\n  function appendHostInstancesByFiber(fiber, hostInstances) {\n    // Next we'll drill down this component to find all HostComponent/Text.\n    var node = fiber;\n\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostSingleton || node.tag === HostHoistable) {\n        var hostInstance = node.stateNode || getResourceInstance(node);\n\n        if (hostInstance) {\n          hostInstances.push(hostInstance);\n        }\n      } else if (node.child) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return;\n      }\n\n      while (!node.sibling) {\n        if (!node.return || node.return === fiber) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  function findAllCurrentHostInstances(devtoolsInstance) {\n    var hostInstances = [];\n    appendHostInstancesByDevToolsInstance(devtoolsInstance, hostInstances);\n    return hostInstances;\n  }\n\n  function findHostInstancesForElementID(id) {\n    try {\n      var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n      if (devtoolsInstance === undefined) {\n        console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n        return null;\n      }\n\n      return findAllCurrentHostInstances(devtoolsInstance);\n    } catch (err) {\n      // The fiber might have unmounted by now.\n      return null;\n    }\n  }\n\n  function getDisplayNameForElementID(id) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      return null;\n    }\n\n    if (devtoolsInstance.kind === FIBER_INSTANCE) {\n      return getDisplayNameForFiber(devtoolsInstance.data);\n    } else {\n      return devtoolsInstance.data.name || '';\n    }\n  }\n\n  function getNearestMountedDOMNode(publicInstance) {\n    var domNode = publicInstance;\n\n    while (domNode && !publicInstanceToDevToolsInstanceMap.has(domNode)) {\n      // $FlowFixMe: In practice this is either null or Element.\n      domNode = domNode.parentNode;\n    }\n\n    return domNode;\n  }\n\n  function getElementIDForHostInstance(publicInstance) {\n    var instance = publicInstanceToDevToolsInstanceMap.get(publicInstance);\n\n    if (instance !== undefined) {\n      if (instance.kind === FILTERED_FIBER_INSTANCE) {\n        // A Filtered Fiber Instance will always have a Virtual Instance as a parent.\n        return instance.parent.id;\n      }\n\n      return instance.id;\n    }\n\n    return null;\n  }\n\n  function getElementAttributeByPath(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      return (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getInObject)(mostRecentlyInspectedElement, path);\n    }\n\n    return undefined;\n  }\n\n  function getElementSourceFunctionById(id) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return null;\n    }\n\n    if (devtoolsInstance.kind !== FIBER_INSTANCE) {\n      // TODO: Handle VirtualInstance.\n      return null;\n    }\n\n    var fiber = devtoolsInstance.data;\n    var elementType = fiber.elementType,\n        tag = fiber.tag,\n        type = fiber.type;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IncompleteFunctionComponent:\n      case IndeterminateComponent:\n      case FunctionComponent:\n        return type;\n\n      case ForwardRef:\n        return type.render;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        return elementType != null && elementType.type != null ? elementType.type : type;\n\n      default:\n        return null;\n    }\n  }\n\n  function instanceToSerializedElement(instance) {\n    if (instance.kind === FIBER_INSTANCE) {\n      var _fiber5 = instance.data;\n      return {\n        displayName: getDisplayNameForFiber(_fiber5) || 'Anonymous',\n        id: instance.id,\n        key: _fiber5.key,\n        type: getElementTypeForFiber(_fiber5)\n      };\n    } else {\n      var componentInfo = instance.data;\n      return {\n        displayName: componentInfo.name || 'Anonymous',\n        id: instance.id,\n        key: componentInfo.key == null ? null : componentInfo.key,\n        type: react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeVirtual\n      };\n    }\n  }\n\n  function getOwnersList(id) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return null;\n    }\n\n    var self = instanceToSerializedElement(devtoolsInstance);\n    var owners = getOwnersListFromInstance(devtoolsInstance); // This is particular API is prefixed with the current instance too for some reason.\n\n    if (owners === null) {\n      return [self];\n    }\n\n    owners.unshift(self);\n    owners.reverse();\n    return owners;\n  }\n\n  function getOwnersListFromInstance(instance) {\n    var owner = getUnfilteredOwner(instance.data);\n\n    if (owner === null) {\n      return null;\n    }\n\n    var owners = [];\n    var parentInstance = instance.parent;\n\n    while (parentInstance !== null && owner !== null) {\n      var ownerInstance = findNearestOwnerInstance(parentInstance, owner);\n\n      if (ownerInstance !== null) {\n        owners.push(instanceToSerializedElement(ownerInstance)); // Get the next owner and keep searching from the previous match.\n\n        owner = getUnfilteredOwner(owner);\n        parentInstance = ownerInstance.parent;\n      } else {\n        break;\n      }\n    }\n\n    return owners;\n  }\n\n  function getUnfilteredOwner(owner) {\n    if (owner == null) {\n      return null;\n    }\n\n    if (typeof owner.tag === 'number') {\n      var ownerFiber = owner; // Refined\n\n      owner = ownerFiber._debugOwner;\n    } else {\n      var ownerInfo = owner; // Refined\n\n      owner = ownerInfo.owner;\n    }\n\n    while (owner) {\n      if (typeof owner.tag === 'number') {\n        var _ownerFiber = owner; // Refined\n\n        if (!shouldFilterFiber(_ownerFiber)) {\n          return _ownerFiber;\n        }\n\n        owner = _ownerFiber._debugOwner;\n      } else {\n        var _ownerInfo = owner; // Refined\n\n        if (!shouldFilterVirtual(_ownerInfo, null)) {\n          return _ownerInfo;\n        }\n\n        owner = _ownerInfo.owner;\n      }\n    }\n\n    return null;\n  }\n\n  function findNearestOwnerInstance(parentInstance, owner) {\n    if (owner == null) {\n      return null;\n    } // Search the parent path for any instance that matches this kind of owner.\n\n\n    while (parentInstance !== null) {\n      if (parentInstance.data === owner || // Typically both owner and instance.data would refer to the current version of a Fiber\n      // but it is possible for memoization to ignore the owner on the JSX. Then the new Fiber\n      // isn't propagated down as the new owner. In that case we might match the alternate\n      // instead. This is a bit hacky but the fastest check since type casting owner to a Fiber\n      // needs a duck type check anyway.\n      parentInstance.data === owner.alternate) {\n        if (parentInstance.kind === FILTERED_FIBER_INSTANCE) {\n          return null;\n        }\n\n        return parentInstance;\n      }\n\n      parentInstance = parentInstance.parent;\n    } // It is technically possible to create an element and render it in a different parent\n    // but this is a weird edge case and it is worth not having to scan the tree or keep\n    // a register for every fiber/component info.\n\n\n    return null;\n  } // Fast path props lookup for React Native style editor.\n  // Could use inspectElementRaw() but that would require shallow rendering hooks components,\n  // and could also mess with memoization.\n\n\n  function getInstanceAndStyle(id) {\n    var instance = null;\n    var style = null;\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return {\n        instance: instance,\n        style: style\n      };\n    }\n\n    if (devtoolsInstance.kind !== FIBER_INSTANCE) {\n      // TODO: Handle VirtualInstance.\n      return {\n        instance: instance,\n        style: style\n      };\n    }\n\n    var fiber = devtoolsInstance.data;\n\n    if (fiber !== null) {\n      instance = fiber.stateNode;\n\n      if (fiber.memoizedProps !== null) {\n        style = fiber.memoizedProps.style;\n      }\n    }\n\n    return {\n      instance: instance,\n      style: style\n    };\n  }\n\n  function isErrorBoundary(fiber) {\n    var tag = fiber.tag,\n        type = fiber.type;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        var instance = fiber.stateNode;\n        return typeof type.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function';\n\n      default:\n        return false;\n    }\n  }\n\n  function inspectElementRaw(id) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return null;\n    }\n\n    if (devtoolsInstance.kind === VIRTUAL_INSTANCE) {\n      return inspectVirtualInstanceRaw(devtoolsInstance);\n    }\n\n    if (devtoolsInstance.kind === FIBER_INSTANCE) {\n      return inspectFiberInstanceRaw(devtoolsInstance);\n    }\n\n    devtoolsInstance; // assert exhaustive\n\n    throw new Error('Unsupported instance kind');\n  }\n\n  function inspectFiberInstanceRaw(fiberInstance) {\n    var fiber = fiberInstance.data;\n\n    if (fiber == null) {\n      return null;\n    }\n\n    var stateNode = fiber.stateNode,\n        key = fiber.key,\n        memoizedProps = fiber.memoizedProps,\n        memoizedState = fiber.memoizedState,\n        dependencies = fiber.dependencies,\n        tag = fiber.tag,\n        type = fiber.type;\n    var elementType = getElementTypeForFiber(fiber);\n    var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies); // TODO Show custom UI for Cache like we do for Suspense\n    // For now, just hide state data entirely since it's not meant to be inspected.\n\n    var showState = !usesHooks && tag !== CacheComponent;\n    var typeSymbol = getTypeSymbol(type);\n    var canViewSource = false;\n    var context = null;\n\n    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IncompleteFunctionComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {\n      canViewSource = true;\n\n      if (stateNode && stateNode.context != null) {\n        // Don't show an empty context object for class components that don't use the context API.\n        var shouldHideContext = elementType === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeClass && !(type.contextTypes || type.contextType);\n\n        if (!shouldHideContext) {\n          context = stateNode.context;\n        }\n      }\n    } else if ( // Detect pre-19 Context Consumers\n    (typeSymbol === _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONTEXT_NUMBER || typeSymbol === _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONTEXT_SYMBOL_STRING) && !( // In 19+, CONTEXT_SYMBOL_STRING means a Provider instead.\n    // It will be handled in a different branch below.\n    // Eventually, this entire branch can be removed.\n    type._context === undefined && type.Provider === type)) {\n      // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n      // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n      // NOTE Keep in sync with getDisplayNameForFiber()\n      var consumerResolvedContext = type._context || type; // Global context value.\n\n      context = consumerResolvedContext._currentValue || null; // Look for overridden value.\n\n      var _current = fiber.return;\n\n      while (_current !== null) {\n        var currentType = _current.type;\n        var currentTypeSymbol = getTypeSymbol(currentType);\n\n        if (currentTypeSymbol === _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROVIDER_NUMBER || currentTypeSymbol === _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.PROVIDER_SYMBOL_STRING) {\n          // 16.3.0 exposed the context object as \"context\"\n          // PR #12501 changed it to \"_context\" for 16.3.1+\n          // NOTE Keep in sync with getDisplayNameForFiber()\n          var providerResolvedContext = currentType._context || currentType.context;\n\n          if (providerResolvedContext === consumerResolvedContext) {\n            context = _current.memoizedProps.value;\n            break;\n          }\n        }\n\n        _current = _current.return;\n      }\n    } else if ( // Detect 19+ Context Consumers\n    typeSymbol === _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONSUMER_SYMBOL_STRING) {\n      // This branch is 19+ only, where Context.Provider === Context.\n      // NOTE Keep in sync with getDisplayNameForFiber()\n      var _consumerResolvedContext = type._context; // Global context value.\n\n      context = _consumerResolvedContext._currentValue || null; // Look for overridden value.\n\n      var _current2 = fiber.return;\n\n      while (_current2 !== null) {\n        var _currentType = _current2.type;\n\n        var _currentTypeSymbol = getTypeSymbol(_currentType);\n\n        if ( // In 19+, these are Context Providers\n        _currentTypeSymbol === _shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_5__.CONTEXT_SYMBOL_STRING) {\n          var _providerResolvedContext = _currentType;\n\n          if (_providerResolvedContext === _consumerResolvedContext) {\n            context = _current2.memoizedProps.value;\n            break;\n          }\n        }\n\n        _current2 = _current2.return;\n      }\n    }\n\n    var hasLegacyContext = false;\n\n    if (context !== null) {\n      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.\n      // Otherwise simple values (e.g. strings, booleans) become harder to handle.\n\n      context = {\n        value: context\n      };\n    }\n\n    var owners = getOwnersListFromInstance(fiberInstance);\n    var hooks = null;\n\n    if (usesHooks) {\n      var originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.\n\n      for (var method in console) {\n        try {\n          // $FlowFixMe[invalid-computed-prop]\n          originalConsoleMethods[method] = console[method]; // $FlowFixMe[prop-missing]\n\n          console[method] = function () {};\n        } catch (error) {}\n      }\n\n      try {\n        hooks = (0,react_debug_tools__WEBPACK_IMPORTED_MODULE_4__.inspectHooksOfFiber)(fiber, getDispatcherRef(renderer));\n      } finally {\n        // Restore original console functionality.\n        for (var _method in originalConsoleMethods) {\n          try {\n            // $FlowFixMe[prop-missing]\n            console[_method] = originalConsoleMethods[_method];\n          } catch (error) {}\n        }\n      }\n    }\n\n    var rootType = null;\n    var current = fiber;\n    var hasErrorBoundary = false;\n    var hasSuspenseBoundary = false;\n\n    while (current.return !== null) {\n      var temp = current;\n      current = current.return;\n\n      if (temp.tag === SuspenseComponent) {\n        hasSuspenseBoundary = true;\n      } else if (isErrorBoundary(temp)) {\n        hasErrorBoundary = true;\n      }\n    }\n\n    var fiberRoot = current.stateNode;\n\n    if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n      rootType = fiberRoot._debugRootType;\n    }\n\n    var isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;\n    var isErrored = false;\n\n    if (isErrorBoundary(fiber)) {\n      // if the current inspected element is an error boundary,\n      // either that we want to use it to toggle off error state\n      // or that we allow to force error state on it if it's within another\n      // error boundary\n      //\n      // TODO: This flag is a leaked implementation detail. Once we start\n      // releasing DevTools in lockstep with React, we should import a function\n      // from the reconciler instead.\n      var DidCapture = 128;\n      isErrored = (fiber.flags & DidCapture) !== 0 || forceErrorForFibers.get(fiber) === true || fiber.alternate !== null && forceErrorForFibers.get(fiber.alternate) === true;\n    }\n\n    var plugins = {\n      stylex: null\n    };\n\n    if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_6__.enableStyleXFeatures) {\n      if (memoizedProps != null && memoizedProps.hasOwnProperty('xstyle')) {\n        plugins.stylex = (0,_StyleX_utils__WEBPACK_IMPORTED_MODULE_11__.getStyleXData)(memoizedProps.xstyle);\n      }\n    }\n\n    var source = null;\n\n    if (canViewSource) {\n      source = getSourceForFiberInstance(fiberInstance);\n    }\n\n    var componentLogsEntry = fiberToComponentLogsMap.get(fiber);\n\n    if (componentLogsEntry === undefined && fiber.alternate !== null) {\n      componentLogsEntry = fiberToComponentLogsMap.get(fiber.alternate);\n    }\n\n    return {\n      id: fiberInstance.id,\n      // Does the current renderer support editable hooks and function props?\n      canEditHooks: typeof overrideHookState === 'function',\n      canEditFunctionProps: typeof overrideProps === 'function',\n      // Does the current renderer support advanced editing interface?\n      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',\n      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',\n      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',\n      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',\n      canToggleError: supportsTogglingError && hasErrorBoundary,\n      // Is this error boundary in error state.\n      isErrored: isErrored,\n      canToggleSuspense: supportsTogglingSuspense && hasSuspenseBoundary && ( // If it's showing the real content, we can always flip fallback.\n      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,\n      // allow toggling it back to remove the fallback override.\n      forceFallbackForFibers.has(fiber) || fiber.alternate !== null && forceFallbackForFibers.has(fiber.alternate)),\n      // Can view component source location.\n      canViewSource: canViewSource,\n      source: source,\n      // Does the component have legacy context attached to it.\n      hasLegacyContext: hasLegacyContext,\n      key: key != null ? key : null,\n      type: elementType,\n      // Inspectable properties.\n      // TODO Review sanitization approach for the below inspectable values.\n      context: context,\n      hooks: hooks,\n      props: memoizedProps,\n      state: showState ? memoizedState : null,\n      errors: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.errors.entries()),\n      warnings: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.warnings.entries()),\n      // List of owners\n      owners: owners,\n      rootType: rootType,\n      rendererPackageName: renderer.rendererPackageName,\n      rendererVersion: renderer.version,\n      plugins: plugins\n    };\n  }\n\n  function inspectVirtualInstanceRaw(virtualInstance) {\n    var canViewSource = true;\n    var source = getSourceForInstance(virtualInstance);\n    var componentInfo = virtualInstance.data;\n    var key = typeof componentInfo.key === 'string' ? componentInfo.key : null;\n    var props = componentInfo.props == null ? null : componentInfo.props;\n    var owners = getOwnersListFromInstance(virtualInstance);\n    var rootType = null;\n    var hasErrorBoundary = false;\n    var hasSuspenseBoundary = false;\n    var nearestFiber = getNearestFiber(virtualInstance);\n\n    if (nearestFiber !== null) {\n      var current = nearestFiber;\n\n      while (current.return !== null) {\n        var temp = current;\n        current = current.return;\n\n        if (temp.tag === SuspenseComponent) {\n          hasSuspenseBoundary = true;\n        } else if (isErrorBoundary(temp)) {\n          hasErrorBoundary = true;\n        }\n      }\n\n      var fiberRoot = current.stateNode;\n\n      if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n        rootType = fiberRoot._debugRootType;\n      }\n    }\n\n    var plugins = {\n      stylex: null\n    };\n    var componentLogsEntry = _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_7__.componentInfoToComponentLogsMap.get(componentInfo);\n    return {\n      id: virtualInstance.id,\n      canEditHooks: false,\n      canEditFunctionProps: false,\n      canEditHooksAndDeletePaths: false,\n      canEditHooksAndRenamePaths: false,\n      canEditFunctionPropsDeletePaths: false,\n      canEditFunctionPropsRenamePaths: false,\n      canToggleError: supportsTogglingError && hasErrorBoundary,\n      isErrored: false,\n      canToggleSuspense: supportsTogglingSuspense && hasSuspenseBoundary,\n      // Can view component source location.\n      canViewSource: canViewSource,\n      source: source,\n      // Does the component have legacy context attached to it.\n      hasLegacyContext: false,\n      key: key,\n      type: react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeVirtual,\n      // Inspectable properties.\n      // TODO Review sanitization approach for the below inspectable values.\n      context: null,\n      hooks: null,\n      props: props,\n      state: null,\n      errors: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.errors.entries()),\n      warnings: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.warnings.entries()),\n      // List of owners\n      owners: owners,\n      rootType: rootType,\n      rendererPackageName: renderer.rendererPackageName,\n      rendererVersion: renderer.version,\n      plugins: plugins\n    };\n  }\n\n  var mostRecentlyInspectedElement = null;\n  var hasElementUpdatedSinceLastInspected = false;\n  var currentlyInspectedPaths = {};\n\n  function isMostRecentlyInspectedElement(id) {\n    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;\n  }\n\n  function isMostRecentlyInspectedElementCurrent(id) {\n    return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;\n  } // Track the intersection of currently inspected paths,\n  // so that we can send their data along if the element is re-rendered.\n\n\n  function mergeInspectedPaths(path) {\n    var current = currentlyInspectedPaths;\n    path.forEach(function (key) {\n      if (!current[key]) {\n        current[key] = {};\n      }\n\n      current = current[key];\n    });\n  }\n\n  function createIsPathAllowed(key, secondaryCategory) {\n    // This function helps prevent previously-inspected paths from being dehydrated in updates.\n    // This is important to avoid a bad user experience where expanded toggles collapse on update.\n    return function isPathAllowed(path) {\n      switch (secondaryCategory) {\n        case 'hooks':\n          if (path.length === 1) {\n            // Never dehydrate the \"hooks\" object at the top levels.\n            return true;\n          }\n\n          if (path[path.length - 2] === 'hookSource' && path[path.length - 1] === 'fileName') {\n            // It's important to preserve the full file name (URL) for hook sources\n            // in case the user has enabled the named hooks feature.\n            // Otherwise the frontend may end up with a partial URL which it can't load.\n            return true;\n          }\n\n          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {\n            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,\n            // so it's easiest for now if we just don't break on this boundary.\n            // We can always dehydrate a level deeper (in the value object).\n            return true;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];\n\n      if (!current) {\n        return false;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        current = current[path[i]];\n\n        if (!current) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  }\n\n  function updateSelectedElement(inspectedElement) {\n    var hooks = inspectedElement.hooks,\n        id = inspectedElement.id,\n        props = inspectedElement.props;\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    if (devtoolsInstance.kind !== FIBER_INSTANCE) {\n      // TODO: Handle VirtualInstance.\n      return;\n    }\n\n    var fiber = devtoolsInstance.data;\n    var elementType = fiber.elementType,\n        stateNode = fiber.stateNode,\n        tag = fiber.tag,\n        type = fiber.type;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IndeterminateComponent:\n        global.$r = stateNode;\n        break;\n\n      case IncompleteFunctionComponent:\n      case FunctionComponent:\n        global.$r = {\n          hooks: hooks,\n          props: props,\n          type: type\n        };\n        break;\n\n      case ForwardRef:\n        global.$r = {\n          hooks: hooks,\n          props: props,\n          type: type.render\n        };\n        break;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        global.$r = {\n          hooks: hooks,\n          props: props,\n          type: elementType != null && elementType.type != null ? elementType.type : type\n        };\n        break;\n\n      default:\n        global.$r = null;\n        break;\n    }\n  }\n\n  function storeAsGlobal(id, path, count) {\n    if (isMostRecentlyInspectedElement(id)) {\n      var value = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getInObject)(mostRecentlyInspectedElement, path);\n      var key = \"$reactTemp\".concat(count);\n      window[key] = value;\n      console.log(key);\n      console.log(value);\n    }\n  }\n\n  function getSerializedElementValueByPath(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      var valueToCopy = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getInObject)(mostRecentlyInspectedElement, path);\n      return (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.serializeToString)(valueToCopy);\n    }\n  }\n\n  function inspectElement(requestID, id, path, forceFullData) {\n    if (path !== null) {\n      mergeInspectedPaths(path);\n    }\n\n    if (isMostRecentlyInspectedElement(id) && !forceFullData) {\n      if (!hasElementUpdatedSinceLastInspected) {\n        if (path !== null) {\n          var secondaryCategory = null;\n\n          if (path[0] === 'hooks') {\n            secondaryCategory = 'hooks';\n          } // If this element has not been updated since it was last inspected,\n          // we can just return the subset of data in the newly-inspected path.\n\n\n          return {\n            id: id,\n            responseID: requestID,\n            type: 'hydrated-path',\n            path: path,\n            value: (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)((0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.getInObject)(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)\n          };\n        } else {\n          // If this element has not been updated since it was last inspected, we don't need to return it.\n          // Instead we can just return the ID to indicate that it has not changed.\n          return {\n            id: id,\n            responseID: requestID,\n            type: 'no-change'\n          };\n        }\n      }\n    } else {\n      currentlyInspectedPaths = {};\n    }\n\n    hasElementUpdatedSinceLastInspected = false;\n\n    try {\n      mostRecentlyInspectedElement = inspectElementRaw(id);\n    } catch (error) {\n      // the error name is synced with ReactDebugHooks\n      if (error.name === 'ReactDebugToolsRenderError') {\n        var message = 'Error rendering inspected element.';\n        var stack; // Log error & cause for user to debug\n\n        console.error(message + '\\n\\n', error);\n\n        if (error.cause != null) {\n          var componentName = getDisplayNameForElementID(id);\n          console.error('React DevTools encountered an error while trying to inspect hooks. ' + 'This is most likely caused by an error in current inspected component' + (componentName != null ? \": \\\"\".concat(componentName, \"\\\".\") : '.') + '\\nThe error thrown in the component is: \\n\\n', error.cause);\n\n          if (error.cause instanceof Error) {\n            message = error.cause.message || message;\n            stack = error.cause.stack;\n          }\n        }\n\n        return {\n          type: 'error',\n          errorType: 'user',\n          id: id,\n          responseID: requestID,\n          message: message,\n          stack: stack\n        };\n      } // the error name is synced with ReactDebugHooks\n\n\n      if (error.name === 'ReactDebugToolsUnsupportedHookError') {\n        return {\n          type: 'error',\n          errorType: 'unknown-hook',\n          id: id,\n          responseID: requestID,\n          message: 'Unsupported hook in the react-debug-tools package: ' + error.message\n        };\n      } // Log Uncaught Error\n\n\n      console.error('Error inspecting element.\\n\\n', error);\n      return {\n        type: 'error',\n        errorType: 'uncaught',\n        id: id,\n        responseID: requestID,\n        message: error.message,\n        stack: error.stack\n      };\n    }\n\n    if (mostRecentlyInspectedElement === null) {\n      return {\n        id: id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    } // Any time an inspected element has an update,\n    // we should update the selected $r value as wel.\n    // Do this before dehydration (cleanForBridge).\n\n\n    updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.\n    // This will enable us to send patches without re-inspecting if hydrated paths are requested.\n    // (Reducing how often we shallow-render is a better DX for function components that use hooks.)\n\n    var cleanedInspectedElement = _objectSpread({}, mostRecentlyInspectedElement); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n    cleanedInspectedElement.context = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)(cleanedInspectedElement.context, createIsPathAllowed('context', null)); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.hooks = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks')); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.props = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)(cleanedInspectedElement.props, createIsPathAllowed('props', null)); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.state = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)(cleanedInspectedElement.state, createIsPathAllowed('state', null));\n    return {\n      id: id,\n      responseID: requestID,\n      type: 'full-data',\n      // $FlowFixMe[prop-missing] found when upgrading Flow\n      value: cleanedInspectedElement\n    };\n  }\n\n  function logElementToConsole(id) {\n    var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);\n\n    if (result === null) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    var displayName = getDisplayNameForElementID(id);\n    var supportsGroup = typeof console.groupCollapsed === 'function';\n\n    if (supportsGroup) {\n      console.groupCollapsed(\"[Click to expand] %c<\".concat(displayName || 'Component', \" />\"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n      'color: var(--dom-tag-name-color); font-weight: normal;');\n    }\n\n    if (result.props !== null) {\n      console.log('Props:', result.props);\n    }\n\n    if (result.state !== null) {\n      console.log('State:', result.state);\n    }\n\n    if (result.hooks !== null) {\n      console.log('Hooks:', result.hooks);\n    }\n\n    var hostInstances = findHostInstancesForElementID(id);\n\n    if (hostInstances !== null) {\n      console.log('Nodes:', hostInstances);\n    }\n\n    if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n      console.log('Right-click any value to save it as a global variable for further inspection.');\n    }\n\n    if (supportsGroup) {\n      console.groupEnd();\n    }\n  }\n\n  function deletePath(type, id, hookID, path) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    if (devtoolsInstance.kind !== FIBER_INSTANCE) {\n      // TODO: Handle VirtualInstance.\n      return;\n    }\n\n    var fiber = devtoolsInstance.data;\n\n    if (fiber !== null) {\n      var instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {// Simple context value (noop)\n              } else {\n                (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.deletePathInObject)(instance.context, path);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateDeletePath === 'function') {\n            overrideHookStateDeletePath(fiber, hookID, path);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsDeletePath === 'function') {\n              overridePropsDeletePath(fiber, path);\n            }\n          } else {\n            fiber.pendingProps = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.copyWithDelete)(instance.props, path);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.deletePathInObject)(instance.state, path);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function renamePath(type, id, hookID, oldPath, newPath) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    if (devtoolsInstance.kind !== FIBER_INSTANCE) {\n      // TODO: Handle VirtualInstance.\n      return;\n    }\n\n    var fiber = devtoolsInstance.data;\n\n    if (fiber !== null) {\n      var instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          oldPath = oldPath.slice(1);\n          newPath = newPath.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (oldPath.length === 0) {// Simple context value (noop)\n              } else {\n                (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.renamePathInObject)(instance.context, oldPath, newPath);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateRenamePath === 'function') {\n            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsRenamePath === 'function') {\n              overridePropsRenamePath(fiber, oldPath, newPath);\n            }\n          } else {\n            fiber.pendingProps = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.copyWithRename)(instance.props, oldPath, newPath);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.renamePathInObject)(instance.state, oldPath, newPath);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function overrideValueAtPath(type, id, hookID, path, value) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      console.warn(\"Could not find DevToolsInstance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    if (devtoolsInstance.kind !== FIBER_INSTANCE) {\n      // TODO: Handle VirtualInstance.\n      return;\n    }\n\n    var fiber = devtoolsInstance.data;\n\n    if (fiber !== null) {\n      var instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {\n                // Simple context value\n                instance.context = value;\n              } else {\n                (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.setInObject)(instance.context, path, value);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookState === 'function') {\n            overrideHookState(fiber, hookID, path, value);\n          }\n\n          break;\n\n        case 'props':\n          switch (fiber.tag) {\n            case ClassComponent:\n              fiber.pendingProps = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.copyWithSet)(instance.props, path, value);\n              instance.forceUpdate();\n              break;\n\n            default:\n              if (typeof overrideProps === 'function') {\n                overrideProps(fiber, path, value);\n              }\n\n              break;\n          }\n\n          break;\n\n        case 'state':\n          switch (fiber.tag) {\n            case ClassComponent:\n              (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.setInObject)(instance.state, path, value);\n              instance.forceUpdate();\n              break;\n          }\n\n          break;\n      }\n    }\n  }\n\n  var currentCommitProfilingMetadata = null;\n  var displayNamesByRootID = null;\n  var initialTreeBaseDurationsMap = null;\n  var isProfiling = false;\n  var profilingStartTime = 0;\n  var recordChangeDescriptions = false;\n  var recordTimeline = false;\n  var rootToCommitProfilingMetadataMap = null;\n\n  function getProfilingData() {\n    var dataForRoots = [];\n\n    if (rootToCommitProfilingMetadataMap === null) {\n      throw Error('getProfilingData() called before any profiling data was recorded');\n    }\n\n    rootToCommitProfilingMetadataMap.forEach(function (commitProfilingMetadata, rootID) {\n      var commitData = [];\n      var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';\n      var initialTreeBaseDurations = initialTreeBaseDurationsMap !== null && initialTreeBaseDurationsMap.get(rootID) || [];\n      commitProfilingMetadata.forEach(function (commitProfilingData, commitIndex) {\n        var changeDescriptions = commitProfilingData.changeDescriptions,\n            durations = commitProfilingData.durations,\n            effectDuration = commitProfilingData.effectDuration,\n            maxActualDuration = commitProfilingData.maxActualDuration,\n            passiveEffectDuration = commitProfilingData.passiveEffectDuration,\n            priorityLevel = commitProfilingData.priorityLevel,\n            commitTime = commitProfilingData.commitTime,\n            updaters = commitProfilingData.updaters;\n        var fiberActualDurations = [];\n        var fiberSelfDurations = [];\n\n        for (var i = 0; i < durations.length; i += 3) {\n          var fiberID = durations[i];\n          fiberActualDurations.push([fiberID, (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.formatDurationToMicrosecondsGranularity)(durations[i + 1])]);\n          fiberSelfDurations.push([fiberID, (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.formatDurationToMicrosecondsGranularity)(durations[i + 2])]);\n        }\n\n        commitData.push({\n          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,\n          duration: (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.formatDurationToMicrosecondsGranularity)(maxActualDuration),\n          effectDuration: effectDuration !== null ? (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.formatDurationToMicrosecondsGranularity)(effectDuration) : null,\n          fiberActualDurations: fiberActualDurations,\n          fiberSelfDurations: fiberSelfDurations,\n          passiveEffectDuration: passiveEffectDuration !== null ? (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.formatDurationToMicrosecondsGranularity)(passiveEffectDuration) : null,\n          priorityLevel: priorityLevel,\n          timestamp: commitTime,\n          updaters: updaters\n        });\n      });\n      dataForRoots.push({\n        commitData: commitData,\n        displayName: displayName,\n        initialTreeBaseDurations: initialTreeBaseDurations,\n        rootID: rootID\n      });\n    });\n    var timelineData = null;\n\n    if (typeof getTimelineData === 'function') {\n      var currentTimelineData = getTimelineData();\n\n      if (currentTimelineData) {\n        var batchUIDToMeasuresMap = currentTimelineData.batchUIDToMeasuresMap,\n            internalModuleSourceToRanges = currentTimelineData.internalModuleSourceToRanges,\n            laneToLabelMap = currentTimelineData.laneToLabelMap,\n            laneToReactMeasureMap = currentTimelineData.laneToReactMeasureMap,\n            rest = _objectWithoutProperties(currentTimelineData, [\"batchUIDToMeasuresMap\", \"internalModuleSourceToRanges\", \"laneToLabelMap\", \"laneToReactMeasureMap\"]);\n\n        timelineData = _objectSpread(_objectSpread({}, rest), {}, {\n          // Most of the data is safe to parse as-is,\n          // but we need to convert the nested Arrays back to Maps.\n          // Most of the data is safe to serialize as-is,\n          // but we need to convert the Maps to nested Arrays.\n          batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),\n          internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),\n          laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),\n          laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())\n        });\n      }\n    }\n\n    return {\n      dataForRoots: dataForRoots,\n      rendererID: rendererID,\n      timelineData: timelineData\n    };\n  }\n\n  function snapshotTreeBaseDurations(instance, target) {\n    // We don't need to convert milliseconds to microseconds in this case,\n    // because the profiling summary is JSON serialized.\n    if (instance.kind !== FILTERED_FIBER_INSTANCE) {\n      target.push([instance.id, instance.treeBaseDuration]);\n    }\n\n    for (var child = instance.firstChild; child !== null; child = child.nextSibling) {\n      snapshotTreeBaseDurations(child, target);\n    }\n  }\n\n  function startProfiling(shouldRecordChangeDescriptions, shouldRecordTimeline) {\n    if (isProfiling) {\n      return;\n    }\n\n    recordChangeDescriptions = shouldRecordChangeDescriptions;\n    recordTimeline = shouldRecordTimeline; // Capture initial values as of the time profiling starts.\n    // It's important we snapshot both the durations and the id-to-root map,\n    // since either of these may change during the profiling session\n    // (e.g. when a fiber is re-rendered or when a fiber gets removed).\n\n    displayNamesByRootID = new Map();\n    initialTreeBaseDurationsMap = new Map();\n    hook.getFiberRoots(rendererID).forEach(function (root) {\n      var rootInstance = rootToFiberInstanceMap.get(root);\n\n      if (rootInstance === undefined) {\n        throw new Error('Expected the root instance to already exist when starting profiling');\n      }\n\n      var rootID = rootInstance.id;\n      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));\n      var initialTreeBaseDurations = [];\n      snapshotTreeBaseDurations(rootInstance, initialTreeBaseDurations);\n      initialTreeBaseDurationsMap.set(rootID, initialTreeBaseDurations);\n    });\n    isProfiling = true;\n    profilingStartTime = getCurrentTime();\n    rootToCommitProfilingMetadataMap = new Map();\n\n    if (toggleProfilingStatus !== null) {\n      toggleProfilingStatus(true, recordTimeline);\n    }\n  }\n\n  function stopProfiling() {\n    isProfiling = false;\n    recordChangeDescriptions = false;\n\n    if (toggleProfilingStatus !== null) {\n      toggleProfilingStatus(false, recordTimeline);\n    }\n\n    recordTimeline = false;\n  } // Automatically start profiling so that we don't miss timing info from initial \"mount\".\n\n\n  if (shouldStartProfilingNow) {\n    startProfiling(profilingSettings.recordChangeDescriptions, profilingSettings.recordTimeline);\n  }\n\n  function getNearestFiber(devtoolsInstance) {\n    if (devtoolsInstance.kind === VIRTUAL_INSTANCE) {\n      var inst = devtoolsInstance;\n\n      while (inst.kind === VIRTUAL_INSTANCE) {\n        // For virtual instances, we search deeper until we find a Fiber instance.\n        // Then we search upwards from that Fiber. That's because Virtual Instances\n        // will always have an Fiber child filtered or not. If we searched its parents\n        // we might skip through a filtered Error Boundary before we hit a FiberInstance.\n        if (inst.firstChild === null) {\n          return null;\n        }\n\n        inst = inst.firstChild;\n      }\n\n      return inst.data.return;\n    } else {\n      return devtoolsInstance.data;\n    }\n  } // React will switch between these implementations depending on whether\n  // we have any manually suspended/errored-out Fibers or not.\n\n\n  function shouldErrorFiberAlwaysNull() {\n    return null;\n  } // Map of Fiber and its force error status: true (error), false (toggled off)\n\n\n  var forceErrorForFibers = new Map();\n\n  function shouldErrorFiberAccordingToMap(fiber) {\n    if (typeof setErrorHandler !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    var status = forceErrorForFibers.get(fiber);\n\n    if (status === false) {\n      // TRICKY overrideError adds entries to this Map,\n      // so ideally it would be the method that clears them too,\n      // but that would break the functionality of the feature,\n      // since DevTools needs to tell React to act differently than it normally would\n      // (don't just re-render the failed boundary, but reset its errored state too).\n      // So we can only clear it after telling React to reset the state.\n      // Technically this is premature and we should schedule it for later,\n      // since the render could always fail without committing the updated error boundary,\n      // but since this is a DEV-only feature, the simplicity is worth the trade off.\n      forceErrorForFibers.delete(fiber);\n\n      if (forceErrorForFibers.size === 0) {\n        // Last override is gone. Switch React back to fast path.\n        setErrorHandler(shouldErrorFiberAlwaysNull);\n      }\n\n      return false;\n    }\n\n    if (status === undefined && fiber.alternate !== null) {\n      status = forceErrorForFibers.get(fiber.alternate);\n\n      if (status === false) {\n        forceErrorForFibers.delete(fiber.alternate);\n\n        if (forceErrorForFibers.size === 0) {\n          // Last override is gone. Switch React back to fast path.\n          setErrorHandler(shouldErrorFiberAlwaysNull);\n        }\n      }\n    }\n\n    if (status === undefined) {\n      return false;\n    }\n\n    return status;\n  }\n\n  function overrideError(id, forceError) {\n    if (typeof setErrorHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      return;\n    }\n\n    var nearestFiber = getNearestFiber(devtoolsInstance);\n\n    if (nearestFiber === null) {\n      return;\n    }\n\n    var fiber = nearestFiber;\n\n    while (!isErrorBoundary(fiber)) {\n      if (fiber.return === null) {\n        return;\n      }\n\n      fiber = fiber.return;\n    }\n\n    forceErrorForFibers.set(fiber, forceError);\n\n    if (fiber.alternate !== null) {\n      // We only need one of the Fibers in the set.\n      forceErrorForFibers.delete(fiber.alternate);\n    }\n\n    if (forceErrorForFibers.size === 1) {\n      // First override is added. Switch React to slower path.\n      setErrorHandler(shouldErrorFiberAccordingToMap);\n    }\n\n    scheduleUpdate(fiber);\n  }\n\n  function shouldSuspendFiberAlwaysFalse() {\n    return false;\n  }\n\n  var forceFallbackForFibers = new Set();\n\n  function shouldSuspendFiberAccordingToSet(fiber) {\n    return forceFallbackForFibers.has(fiber) || fiber.alternate !== null && forceFallbackForFibers.has(fiber.alternate);\n  }\n\n  function overrideSuspense(id, forceFallback) {\n    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');\n    }\n\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      return;\n    }\n\n    var nearestFiber = getNearestFiber(devtoolsInstance);\n\n    if (nearestFiber === null) {\n      return;\n    }\n\n    var fiber = nearestFiber;\n\n    while (fiber.tag !== SuspenseComponent) {\n      if (fiber.return === null) {\n        return;\n      }\n\n      fiber = fiber.return;\n    }\n\n    if (fiber.alternate !== null) {\n      // We only need one of the Fibers in the set.\n      forceFallbackForFibers.delete(fiber.alternate);\n    }\n\n    if (forceFallback) {\n      forceFallbackForFibers.add(fiber);\n\n      if (forceFallbackForFibers.size === 1) {\n        // First override is added. Switch React to slower path.\n        setSuspenseHandler(shouldSuspendFiberAccordingToSet);\n      }\n    } else {\n      forceFallbackForFibers.delete(fiber);\n\n      if (forceFallbackForFibers.size === 0) {\n        // Last override is gone. Switch React back to fast path.\n        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);\n      }\n    }\n\n    scheduleUpdate(fiber);\n  } // Remember if we're trying to restore the selection after reload.\n  // In that case, we'll do some extra checks for matching mounts.\n\n\n  var trackedPath = null;\n  var trackedPathMatchFiber = null; // This is the deepest unfiltered match of a Fiber.\n\n  var trackedPathMatchInstance = null; // This is the deepest matched filtered Instance.\n\n  var trackedPathMatchDepth = -1;\n  var mightBeOnTrackedPath = false;\n\n  function setTrackedPath(path) {\n    if (path === null) {\n      trackedPathMatchFiber = null;\n      trackedPathMatchInstance = null;\n      trackedPathMatchDepth = -1;\n      mightBeOnTrackedPath = false;\n    }\n\n    trackedPath = path;\n  } // We call this before traversing a new mount.\n  // It remembers whether this Fiber is the next best match for tracked path.\n  // The return value signals whether we should keep matching siblings or not.\n\n\n  function updateTrackedPathStateBeforeMount(fiber, fiberInstance) {\n    if (trackedPath === null || !mightBeOnTrackedPath) {\n      // Fast path: there's nothing to track so do nothing and ignore siblings.\n      return false;\n    }\n\n    var returnFiber = fiber.return;\n    var returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.\n    // Is this newly mounted Fiber a direct child of the current best match?\n    // (This will also be true for new roots if we haven't matched anything yet.)\n\n    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {\n      // Is this the next Fiber we should select? Let's compare the frames.\n      var actualFrame = getPathFrame(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      var expectedFrame = trackedPath[trackedPathMatchDepth + 1];\n\n      if (expectedFrame === undefined) {\n        throw new Error('Expected to see a frame at the next depth.');\n      }\n\n      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {\n        // We have our next match.\n        trackedPathMatchFiber = fiber;\n\n        if (fiberInstance !== null && fiberInstance.kind === FIBER_INSTANCE) {\n          trackedPathMatchInstance = fiberInstance;\n        }\n\n        trackedPathMatchDepth++; // Are we out of frames to match?\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        if (trackedPathMatchDepth === trackedPath.length - 1) {\n          // There's nothing that can possibly match afterwards.\n          // Don't check the children.\n          mightBeOnTrackedPath = false;\n        } else {\n          // Check the children, as they might reveal the next match.\n          mightBeOnTrackedPath = true;\n        } // In either case, since we have a match, we don't need\n        // to check the siblings. They'll never match.\n\n\n        return false;\n      }\n    }\n\n    if (trackedPathMatchFiber === null && fiberInstance === null) {\n      // We're now looking for a Virtual Instance. It might be inside filtered Fibers\n      // so we keep looking below.\n      return true;\n    } // This Fiber's parent is on the path, but this Fiber itself isn't.\n    // There's no need to check its children--they won't be on the path either.\n\n\n    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.\n\n    return true;\n  }\n\n  function updateVirtualTrackedPathStateBeforeMount(virtualInstance, parentInstance) {\n    if (trackedPath === null || !mightBeOnTrackedPath) {\n      // Fast path: there's nothing to track so do nothing and ignore siblings.\n      return false;\n    } // Check if we've matched our nearest unfiltered parent so far.\n\n\n    if (trackedPathMatchInstance === parentInstance) {\n      var actualFrame = getVirtualPathFrame(virtualInstance); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      var expectedFrame = trackedPath[trackedPathMatchDepth + 1];\n\n      if (expectedFrame === undefined) {\n        throw new Error('Expected to see a frame at the next depth.');\n      }\n\n      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {\n        // We have our next match.\n        trackedPathMatchFiber = null; // Don't bother looking in Fibers anymore. We're deeper now.\n\n        trackedPathMatchInstance = virtualInstance;\n        trackedPathMatchDepth++; // Are we out of frames to match?\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        if (trackedPathMatchDepth === trackedPath.length - 1) {\n          // There's nothing that can possibly match afterwards.\n          // Don't check the children.\n          mightBeOnTrackedPath = false;\n        } else {\n          // Check the children, as they might reveal the next match.\n          mightBeOnTrackedPath = true;\n        } // In either case, since we have a match, we don't need\n        // to check the siblings. They'll never match.\n\n\n        return false;\n      }\n    }\n\n    if (trackedPathMatchFiber !== null) {\n      // We're still looking for a Fiber which might be underneath this instance.\n      return true;\n    } // This Instance's parent is on the path, but this Instance itself isn't.\n    // There's no need to check its children--they won't be on the path either.\n\n\n    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.\n\n    return true;\n  }\n\n  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {\n    // updateTrackedPathStateBeforeMount() told us whether to match siblings.\n    // Now that we're entering siblings, let's use that information.\n    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;\n  } // Roots don't have a real persistent identity.\n  // A root's \"pseudo key\" is \"childDisplayName:indexWithThatName\".\n  // For example, \"App:0\" or, in case of similar roots, \"Story:0\", \"Story:1\", etc.\n  // We will use this to try to disambiguate roots when restoring selection between reloads.\n\n\n  var rootPseudoKeys = new Map();\n  var rootDisplayNameCounter = new Map();\n\n  function setRootPseudoKey(id, fiber) {\n    var name = getDisplayNameForRoot(fiber);\n    var counter = rootDisplayNameCounter.get(name) || 0;\n    rootDisplayNameCounter.set(name, counter + 1);\n    var pseudoKey = \"\".concat(name, \":\").concat(counter);\n    rootPseudoKeys.set(id, pseudoKey);\n  }\n\n  function removeRootPseudoKey(id) {\n    var pseudoKey = rootPseudoKeys.get(id);\n\n    if (pseudoKey === undefined) {\n      throw new Error('Expected root pseudo key to be known.');\n    }\n\n    var name = pseudoKey.slice(0, pseudoKey.lastIndexOf(':'));\n    var counter = rootDisplayNameCounter.get(name);\n\n    if (counter === undefined) {\n      throw new Error('Expected counter to be known.');\n    }\n\n    if (counter > 1) {\n      rootDisplayNameCounter.set(name, counter - 1);\n    } else {\n      rootDisplayNameCounter.delete(name);\n    }\n\n    rootPseudoKeys.delete(id);\n  }\n\n  function getDisplayNameForRoot(fiber) {\n    var preferredDisplayName = null;\n    var fallbackDisplayName = null;\n    var child = fiber.child; // Go at most three levels deep into direct children\n    // while searching for a child that has a displayName.\n\n    for (var i = 0; i < 3; i++) {\n      if (child === null) {\n        break;\n      }\n\n      var displayName = getDisplayNameForFiber(child);\n\n      if (displayName !== null) {\n        // Prefer display names that we get from user-defined components.\n        // We want to avoid using e.g. 'Suspense' unless we find nothing else.\n        if (typeof child.type === 'function') {\n          // There's a few user-defined tags, but we'll prefer the ones\n          // that are usually explicitly named (function or class components).\n          preferredDisplayName = displayName;\n        } else if (fallbackDisplayName === null) {\n          fallbackDisplayName = displayName;\n        }\n      }\n\n      if (preferredDisplayName !== null) {\n        break;\n      }\n\n      child = child.child;\n    }\n\n    return preferredDisplayName || fallbackDisplayName || 'Anonymous';\n  }\n\n  function getPathFrame(fiber) {\n    var key = fiber.key;\n    var displayName = getDisplayNameForFiber(fiber);\n    var index = fiber.index;\n\n    switch (fiber.tag) {\n      case HostRoot:\n        // Roots don't have a real displayName, index, or key.\n        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).\n        var rootInstance = rootToFiberInstanceMap.get(fiber.stateNode);\n\n        if (rootInstance === undefined) {\n          throw new Error('Expected the root instance to exist when computing a path');\n        }\n\n        var pseudoKey = rootPseudoKeys.get(rootInstance.id);\n\n        if (pseudoKey === undefined) {\n          throw new Error('Expected mounted root to have known pseudo key.');\n        }\n\n        displayName = pseudoKey;\n        break;\n\n      case HostComponent:\n        displayName = fiber.type;\n        break;\n\n      default:\n        break;\n    }\n\n    return {\n      displayName: displayName,\n      key: key,\n      index: index\n    };\n  }\n\n  function getVirtualPathFrame(virtualInstance) {\n    return {\n      displayName: virtualInstance.data.name || '',\n      key: virtualInstance.data.key == null ? null : virtualInstance.data.key,\n      index: -1 // We use -1 to indicate that this is a virtual path frame.\n\n    };\n  } // Produces a serializable representation that does a best effort\n  // of identifying a particular Fiber between page reloads.\n  // The return path will contain Fibers that are \"invisible\" to the store\n  // because their keys and indexes are important to restoring the selection.\n\n\n  function getPathForElement(id) {\n    var devtoolsInstance = idToDevToolsInstanceMap.get(id);\n\n    if (devtoolsInstance === undefined) {\n      return null;\n    }\n\n    var keyPath = [];\n    var inst = devtoolsInstance;\n\n    while (inst.kind === VIRTUAL_INSTANCE) {\n      keyPath.push(getVirtualPathFrame(inst));\n\n      if (inst.parent === null) {\n        // This is a bug but non-essential. We should've found a root instance.\n        return null;\n      }\n\n      inst = inst.parent;\n    }\n\n    var fiber = inst.data;\n\n    while (fiber !== null) {\n      // $FlowFixMe[incompatible-call] found when upgrading Flow\n      keyPath.push(getPathFrame(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      fiber = fiber.return;\n    }\n\n    keyPath.reverse();\n    return keyPath;\n  }\n\n  function getBestMatchForTrackedPath() {\n    if (trackedPath === null) {\n      // Nothing to match.\n      return null;\n    }\n\n    if (trackedPathMatchInstance === null) {\n      // We didn't find anything.\n      return null;\n    }\n\n    return {\n      id: trackedPathMatchInstance.id,\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1\n    };\n  }\n\n  var formatPriorityLevel = function formatPriorityLevel(priorityLevel) {\n    if (priorityLevel == null) {\n      return 'Unknown';\n    }\n\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        return 'Immediate';\n\n      case UserBlockingPriority:\n        return 'User-Blocking';\n\n      case NormalPriority:\n        return 'Normal';\n\n      case LowPriority:\n        return 'Low';\n\n      case IdlePriority:\n        return 'Idle';\n\n      case NoPriority:\n      default:\n        return 'Unknown';\n    }\n  };\n\n  function setTraceUpdatesEnabled(isEnabled) {\n    traceUpdatesEnabled = isEnabled;\n  }\n\n  function hasElementWithId(id) {\n    return idToDevToolsInstanceMap.has(id);\n  }\n\n  function getSourceForFiberInstance(fiberInstance) {\n    var unresolvedSource = fiberInstance.source;\n\n    if (unresolvedSource !== null && _typeof(unresolvedSource) === 'object' && !isError(unresolvedSource)) {\n      // $FlowFixMe: isError should have refined it.\n      return unresolvedSource;\n    }\n\n    var dispatcherRef = getDispatcherRef(renderer);\n    var stackFrame = dispatcherRef == null ? null : (0,_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_10__.getSourceLocationByFiber)(ReactTypeOfWork, fiberInstance.data, dispatcherRef);\n\n    if (stackFrame === null) {\n      // If we don't find a source location by throwing, try to get one\n      // from an owned child if possible. This is the same branch as\n      // for virtual instances.\n      return getSourceForInstance(fiberInstance);\n    }\n\n    var source = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.parseSourceFromComponentStack)(stackFrame);\n    fiberInstance.source = source;\n    return source;\n  }\n\n  function getSourceForInstance(instance) {\n    var unresolvedSource = instance.source;\n\n    if (unresolvedSource === null) {\n      // We don't have any source yet. We can try again later in case an owned child mounts later.\n      // TODO: We won't have any information here if the child is filtered.\n      return null;\n    } // If we have the debug stack (the creation stack of the JSX) for any owned child of this\n    // component, then at the bottom of that stack will be a stack frame that is somewhere within\n    // the component's function body. Typically it would be the callsite of the JSX unless there's\n    // any intermediate utility functions. This won't point to the top of the component function\n    // but it's at least somewhere within it.\n\n\n    if (isError(unresolvedSource)) {\n      unresolvedSource = (0,_shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_13__.formatOwnerStack)(unresolvedSource);\n    }\n\n    if (typeof unresolvedSource === 'string') {\n      var idx = unresolvedSource.lastIndexOf('\\n');\n      var lastLine = idx === -1 ? unresolvedSource : unresolvedSource.slice(idx + 1);\n      return instance.source = (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_2__.parseSourceFromComponentStack)(lastLine);\n    } // $FlowFixMe: refined.\n\n\n    return unresolvedSource;\n  }\n\n  return {\n    cleanup: cleanup,\n    clearErrorsAndWarnings: clearErrorsAndWarnings,\n    clearErrorsForElementID: clearErrorsForElementID,\n    clearWarningsForElementID: clearWarningsForElementID,\n    getSerializedElementValueByPath: getSerializedElementValueByPath,\n    deletePath: deletePath,\n    findHostInstancesForElementID: findHostInstancesForElementID,\n    flushInitialOperations: flushInitialOperations,\n    getBestMatchForTrackedPath: getBestMatchForTrackedPath,\n    getDisplayNameForElementID: getDisplayNameForElementID,\n    getNearestMountedDOMNode: getNearestMountedDOMNode,\n    getElementIDForHostInstance: getElementIDForHostInstance,\n    getInstanceAndStyle: getInstanceAndStyle,\n    getOwnersList: getOwnersList,\n    getPathForElement: getPathForElement,\n    getProfilingData: getProfilingData,\n    handleCommitFiberRoot: handleCommitFiberRoot,\n    handleCommitFiberUnmount: handleCommitFiberUnmount,\n    handlePostCommitFiberRoot: handlePostCommitFiberRoot,\n    hasElementWithId: hasElementWithId,\n    inspectElement: inspectElement,\n    logElementToConsole: logElementToConsole,\n    getComponentStack: getComponentStack,\n    getElementAttributeByPath: getElementAttributeByPath,\n    getElementSourceFunctionById: getElementSourceFunctionById,\n    onErrorOrWarning: onErrorOrWarning,\n    overrideError: overrideError,\n    overrideSuspense: overrideSuspense,\n    overrideValueAtPath: overrideValueAtPath,\n    renamePath: renamePath,\n    renderer: renderer,\n    setTraceUpdatesEnabled: setTraceUpdatesEnabled,\n    setTrackedPath: setTrackedPath,\n    startProfiling: startProfiling,\n    stopProfiling: stopProfiling,\n    storeAsGlobal: storeAsGlobal,\n    updateComponentFilters: updateComponentFilters,\n    getEnvironmentNames: getEnvironmentNames\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZpYmVyL3JlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFXQTtBQXNCQTtBQVlBO0FBUUE7QUFPQTtBQVdBO0FBQ0E7QUFzQkE7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7QUFRQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQThCQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUdBOztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQWVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBOztBQWdCQTtBQUlBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBUUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFsQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQWpDQTtBQW1DQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBakNBO0FBbUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQWpDQTtBQW1DQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFqQ0E7QUFtQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUVBOztBQWxQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaVJBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVRBO0FBV0E7OztBQUdBO0FBR0E7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFHQTtBQUtBOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFNQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1BO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUdBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaERBOztBQW5FQTtBQXNIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBR0E7QUFDQTs7QUFDQTs7QUFHQTtBQUdBO0FBQ0E7O0FBQ0E7O0FBSUE7O0FBR0E7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRkE7QUFBQTs7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUVBO0FBR0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTs7QUFVQTs7QUFHQTtBQUNBO0FBQ0E7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUZBO0FBQUE7O0FBQUE7QUFJQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUEE7QUFBQTs7QUFBQTtBQVFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXVCQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFLQTtBQUNBO0FBS0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUVBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFLQTs7QUFDQTtBQUNBO0FBT0E7QUFHQTtBQVNBO0FBTUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTs7QUFDQTtBQUNBO0FBSUE7QUFnQkE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQTFCQTtBQTRCQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVJBOztBQXRCQTs7QUFrQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBOzs7QUFHQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQWxCQTs7QUFsQ0E7QUF1REE7OztBQUdBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVJBO0FBYUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBVEE7O0FBWUE7QUFDQTs7QUFDQTtBQUNBO0FBNURBO0FBOERBOztBQUVBO0FBQ0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFOQTtBQUFBOztBQUFBO0FBUUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBY0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBeUJBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUdBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBSUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBR0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUlBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFHQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBR0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7OztBQUNBOztBQUVBO0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBT0E7O0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBOztBQUVBO0FBSUE7QUFBQTtBQU1BOztBQUVBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFGQTtBQUFBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFFQTtBQUNBOztBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBOztBQUNBO0FBSUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBS0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUlBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFRQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQVFBOztBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFRQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBR0E7QUFLQTtBQUNBO0FBQ0E7O0FBQ0E7QUFPQTs7O0FBR0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBS0E7QUFDQTs7QUFFQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUdBOztBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7OztBQUlBOztBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFhQTs7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQU1BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFWQTtBQUFBO0FBQUE7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQWZBO0FBaUJBOztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7QUFDQTtBQVZBO0FBWUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQkE7QUFFQTtBQU9BOztBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBVUE7O0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7O0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBR0E7O0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQWpFQTtBQW1FQTs7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFJQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFoREE7QUFrREE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBR0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUE1QkE7O0FBK0JBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBYkE7QUFBQTtBQUFBO0FBQUE7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBUUE7O0FBQ0E7QUFDQTtBQUNBO0FBbENBO0FBb0NBOztBQUVBO0FBS0E7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBR0E7QUFDQTs7O0FBQ0E7QUFHQTtBQUNBOztBQUNBOzs7QUFFQTs7QUFLQTs7QUFLQTs7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFHQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFNQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBOztBQWNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhDQTtBQTBDQTtBQUNBOztBQUVBO0FBT0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBOztBQWNBOztBQUNBO0FBQ0E7QUFDQTtBQU1BOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxEQTtBQW9EQTtBQUNBOztBQUVBO0FBT0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7O0FBZUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBVEE7O0FBV0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBTUE7QUFoREE7QUFrREE7QUFDQTs7QUFnQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFFQTtBQUVBO0FBRUE7QUFJQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTs7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBU0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBZEE7QUFrQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7QUFHQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFJQTtBQUdBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBSUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFwQkE7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTs7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdENBO0FBd0NBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZpYmVyL3JlbmRlcmVyLmpzP2JiYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1JlYWN0Q29tcG9uZW50SW5mbywgUmVhY3REZWJ1Z0luZm99IGZyb20gJ3NoYXJlZC9SZWFjdFR5cGVzJztcblxuaW1wb3J0IHtcbiAgQ29tcG9uZW50RmlsdGVyRGlzcGxheU5hbWUsXG4gIENvbXBvbmVudEZpbHRlckVsZW1lbnRUeXBlLFxuICBDb21wb25lbnRGaWx0ZXJIT0MsXG4gIENvbXBvbmVudEZpbHRlckxvY2F0aW9uLFxuICBDb21wb25lbnRGaWx0ZXJFbnZpcm9ubWVudE5hbWUsXG4gIEVsZW1lbnRUeXBlQ2xhc3MsXG4gIEVsZW1lbnRUeXBlQ29udGV4dCxcbiAgRWxlbWVudFR5cGVGdW5jdGlvbixcbiAgRWxlbWVudFR5cGVGb3J3YXJkUmVmLFxuICBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQsXG4gIEVsZW1lbnRUeXBlTWVtbyxcbiAgRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bixcbiAgRWxlbWVudFR5cGVQcm9maWxlcixcbiAgRWxlbWVudFR5cGVSb290LFxuICBFbGVtZW50VHlwZVN1c3BlbnNlLFxuICBFbGVtZW50VHlwZVN1c3BlbnNlTGlzdCxcbiAgRWxlbWVudFR5cGVUcmFjaW5nTWFya2VyLFxuICBFbGVtZW50VHlwZVZpZXdUcmFuc2l0aW9uLFxuICBFbGVtZW50VHlwZVZpcnR1YWwsXG4gIFN0cmljdE1vZGUsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHtcbiAgZGVsZXRlUGF0aEluT2JqZWN0LFxuICBnZXREaXNwbGF5TmFtZSxcbiAgZ2V0V3JhcHBlZERpc3BsYXlOYW1lLFxuICBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycyxcbiAgZ2V0SW5PYmplY3QsXG4gIGdldFVJRCxcbiAgcmVuYW1lUGF0aEluT2JqZWN0LFxuICBzZXRJbk9iamVjdCxcbiAgdXRmRW5jb2RlU3RyaW5nLFxuICBmaWx0ZXJPdXRMb2NhdGlvbkNvbXBvbmVudEZpbHRlcnMsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdXRpbHMnO1xuaW1wb3J0IHtcbiAgZm9ybWF0Q29uc29sZUFyZ3VtZW50c1RvU2luZ2xlU3RyaW5nLFxuICBmb3JtYXREdXJhdGlvblRvTWljcm9zZWNvbmRzR3JhbnVsYXJpdHksXG4gIGd0LFxuICBndGUsXG4gIHBhcnNlU291cmNlRnJvbUNvbXBvbmVudFN0YWNrLFxuICBzZXJpYWxpemVUb1N0cmluZyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzJztcbmltcG9ydCB7XG4gIGNsZWFuRm9yQnJpZGdlLFxuICBjb3B5V2l0aERlbGV0ZSxcbiAgY29weVdpdGhSZW5hbWUsXG4gIGNvcHlXaXRoU2V0LFxuICBnZXRFZmZlY3REdXJhdGlvbnMsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIF9fREVCVUdfXyxcbiAgUFJPRklMSU5HX0ZMQUdfQkFTSUNfU1VQUE9SVCxcbiAgUFJPRklMSU5HX0ZMQUdfVElNRUxJTkVfU1VQUE9SVCxcbiAgVFJFRV9PUEVSQVRJT05fQURELFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkUsXG4gIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4sXG4gIFRSRUVfT1BFUkFUSU9OX1NFVF9TVUJUUkVFX01PREUsXG4gIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1MsXG4gIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT04sXG59IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQge2luc3BlY3RIb29rc09mRmliZXJ9IGZyb20gJ3JlYWN0LWRlYnVnLXRvb2xzJztcbmltcG9ydCB7XG4gIENPTkNVUlJFTlRfTU9ERV9OVU1CRVIsXG4gIENPTkNVUlJFTlRfTU9ERV9TWU1CT0xfU1RSSU5HLFxuICBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORyxcbiAgUFJPVklERVJfTlVNQkVSLFxuICBQUk9WSURFUl9TWU1CT0xfU1RSSU5HLFxuICBDT05URVhUX05VTUJFUixcbiAgQ09OVEVYVF9TWU1CT0xfU1RSSU5HLFxuICBDT05TVU1FUl9TWU1CT0xfU1RSSU5HLFxuICBTVFJJQ1RfTU9ERV9OVU1CRVIsXG4gIFNUUklDVF9NT0RFX1NZTUJPTF9TVFJJTkcsXG4gIFBST0ZJTEVSX05VTUJFUixcbiAgUFJPRklMRVJfU1lNQk9MX1NUUklORyxcbiAgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCxcbiAgU0NPUEVfTlVNQkVSLFxuICBTQ09QRV9TWU1CT0xfU1RSSU5HLFxuICBGT1JXQVJEX1JFRl9OVU1CRVIsXG4gIEZPUldBUkRfUkVGX1NZTUJPTF9TVFJJTkcsXG4gIE1FTU9fTlVNQkVSLFxuICBNRU1PX1NZTUJPTF9TVFJJTkcsXG4gIFNFUlZFUl9DT05URVhUX1NZTUJPTF9TVFJJTkcsXG59IGZyb20gJy4uL3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuaW1wb3J0IHtlbmFibGVTdHlsZVhGZWF0dXJlc30gZnJvbSAncmVhY3QtZGV2dG9vbHMtZmVhdHVyZS1mbGFncyc7XG5cbmltcG9ydCB7Y29tcG9uZW50SW5mb1RvQ29tcG9uZW50TG9nc01hcH0gZnJvbSAnLi4vc2hhcmVkL0RldlRvb2xzU2VydmVyQ29tcG9uZW50TG9ncyc7XG5cbmltcG9ydCBpcyBmcm9tICdzaGFyZWQvb2JqZWN0SXMnO1xuaW1wb3J0IGhhc093blByb3BlcnR5IGZyb20gJ3NoYXJlZC9oYXNPd25Qcm9wZXJ0eSc7XG5cbmltcG9ydCB7XG4gIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCxcbiAgZ2V0T3duZXJTdGFja0J5RmliZXJJbkRldixcbiAgc3VwcG9ydHNPd25lclN0YWNrcyxcbiAgc3VwcG9ydHNDb25zb2xlVGFza3MsXG59IGZyb20gJy4vRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrJztcblxuLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiBpc0Vycm9yKG9iamVjdDogbWl4ZWQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbn1cblxuaW1wb3J0IHtnZXRTdHlsZVhEYXRhfSBmcm9tICcuLi9TdHlsZVgvdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVQcm9maWxpbmdIb29rc30gZnJvbSAnLi4vcHJvZmlsaW5nSG9va3MnO1xuXG5pbXBvcnQgdHlwZSB7R2V0VGltZWxpbmVEYXRhLCBUb2dnbGVQcm9maWxpbmdTdGF0dXN9IGZyb20gJy4uL3Byb2ZpbGluZ0hvb2tzJztcbmltcG9ydCB0eXBlIHtGaWJlciwgRmliZXJSb290fSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEludGVybmFsVHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBDaGFuZ2VEZXNjcmlwdGlvbixcbiAgQ29tbWl0RGF0YUJhY2tlbmQsXG4gIERldlRvb2xzSG9vayxcbiAgSW5zcGVjdGVkRWxlbWVudCxcbiAgSW5zcGVjdGVkRWxlbWVudFBheWxvYWQsXG4gIEluc3RhbmNlQW5kU3R5bGUsXG4gIEhvc3RJbnN0YW5jZSxcbiAgUGF0aEZyYW1lLFxuICBQYXRoTWF0Y2gsXG4gIFByb2ZpbGluZ0RhdGFCYWNrZW5kLFxuICBQcm9maWxpbmdEYXRhRm9yUm9vdEJhY2tlbmQsXG4gIFJlYWN0UmVuZGVyZXIsXG4gIFJlbmRlcmVySW50ZXJmYWNlLFxuICBTZXJpYWxpemVkRWxlbWVudCxcbiAgV29ya1RhZ01hcCxcbiAgQ3VycmVudERpc3BhdGNoZXJSZWYsXG4gIExlZ2FjeURpc3BhdGNoZXJSZWYsXG4gIFByb2ZpbGluZ1NldHRpbmdzLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIENvbXBvbmVudEZpbHRlcixcbiAgRWxlbWVudFR5cGUsXG4gIFBsdWdpbnMsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1NvdXJjZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHtnZXRTb3VyY2VMb2NhdGlvbkJ5RmliZXJ9IGZyb20gJy4vRGV2VG9vbHNGaWJlckNvbXBvbmVudFN0YWNrJztcbmltcG9ydCB7Zm9ybWF0T3duZXJTdGFja30gZnJvbSAnLi4vc2hhcmVkL0RldlRvb2xzT3duZXJTdGFjayc7XG5cbi8vIEtpbmRzXG5jb25zdCBGSUJFUl9JTlNUQU5DRSA9IDA7XG5jb25zdCBWSVJUVUFMX0lOU1RBTkNFID0gMTtcbmNvbnN0IEZJTFRFUkVEX0ZJQkVSX0lOU1RBTkNFID0gMjtcblxuLy8gVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBzdGF0ZWZ1bCBpbnN0YW5jZSBvZiBhIENsaWVudCBDb21wb25lbnQgaS5lLiBhIEZpYmVyIHBhaXIuXG4vLyBUaGVzZSBpbnN0YW5jZXMgYWxzbyBsZXQgdXMgdHJhY2sgc3RhdGVmdWwgRGV2VG9vbHMgbWV0YSBkYXRhIGxpa2UgaWQgYW5kIHdhcm5pbmdzLlxudHlwZSBGaWJlckluc3RhbmNlID0ge1xuICBraW5kOiAwLFxuICBpZDogbnVtYmVyLFxuICBwYXJlbnQ6IG51bGwgfCBEZXZUb29sc0luc3RhbmNlLFxuICBmaXJzdENoaWxkOiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgbmV4dFNpYmxpbmc6IG51bGwgfCBEZXZUb29sc0luc3RhbmNlLFxuICBzb3VyY2U6IG51bGwgfCBzdHJpbmcgfCBFcnJvciB8IFNvdXJjZSwgLy8gc291cmNlIGxvY2F0aW9uIG9mIHRoaXMgY29tcG9uZW50IGZ1bmN0aW9uLCBvciBvd25lZCBjaGlsZCBzdGFja1xuICBsb2dDb3VudDogbnVtYmVyLCAvLyB0b3RhbCBudW1iZXIgb2YgZXJyb3JzL3dhcm5pbmdzIGxhc3Qgc2VlblxuICB0cmVlQmFzZUR1cmF0aW9uOiBudW1iZXIsIC8vIHRoZSBwcm9maWxlZCB0aW1lIG9mIHRoZSBsYXN0IHJlbmRlciBvZiB0aGlzIHN1YnRyZWVcbiAgZGF0YTogRmliZXIsIC8vIG9uZSBvZiBhIEZpYmVyIHBhaXJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVySW5zdGFuY2UoZmliZXI6IEZpYmVyKTogRmliZXJJbnN0YW5jZSB7XG4gIHJldHVybiB7XG4gICAga2luZDogRklCRVJfSU5TVEFOQ0UsXG4gICAgaWQ6IGdldFVJRCgpLFxuICAgIHBhcmVudDogbnVsbCxcbiAgICBmaXJzdENoaWxkOiBudWxsLFxuICAgIG5leHRTaWJsaW5nOiBudWxsLFxuICAgIHNvdXJjZTogbnVsbCxcbiAgICBsb2dDb3VudDogMCxcbiAgICB0cmVlQmFzZUR1cmF0aW9uOiAwLFxuICAgIGRhdGE6IGZpYmVyLFxuICB9O1xufVxuXG50eXBlIEZpbHRlcmVkRmliZXJJbnN0YW5jZSA9IHtcbiAga2luZDogMixcbiAgLy8gV2UgZXhjbHVkZSBpZCBmcm9tIHRoZSB0eXBlIHRvIGdldCBlcnJvcnMgaWYgd2UgdHJ5IHRvIGFjY2VzcyBpdC5cbiAgLy8gSG93ZXZlciBpdCBpcyBzdGlsbCBpbiB0aGUgb2JqZWN0IHRvIHByZXNlcnZlIGhpZGRlbiBjbGFzcy5cbiAgLy8gaWQ6IG51bWJlcixcbiAgcGFyZW50OiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgZmlyc3RDaGlsZDogbnVsbCB8IERldlRvb2xzSW5zdGFuY2UsXG4gIG5leHRTaWJsaW5nOiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgc291cmNlOiBudWxsIHwgc3RyaW5nIHwgRXJyb3IgfCBTb3VyY2UsIC8vIGFsd2F5cyBudWxsIGhlcmUuXG4gIGxvZ0NvdW50OiBudW1iZXIsIC8vIHRvdGFsIG51bWJlciBvZiBlcnJvcnMvd2FybmluZ3MgbGFzdCBzZWVuXG4gIHRyZWVCYXNlRHVyYXRpb246IG51bWJlciwgLy8gdGhlIHByb2ZpbGVkIHRpbWUgb2YgdGhlIGxhc3QgcmVuZGVyIG9mIHRoaXMgc3VidHJlZVxuICBkYXRhOiBGaWJlciwgLy8gb25lIG9mIGEgRmliZXIgcGFpclxufTtcblxuLy8gVGhpcyBpcyB1c2VkIHRvIHJlcHJlc2VudCBhIGZpbHRlcmVkIEZpYmVyIGJ1dCBzdGlsbCBsZXRzIHVzIGZpbmQgaXRzIGhvc3QgaW5zdGFuY2UuXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXJlZEZpYmVySW5zdGFuY2UoZmliZXI6IEZpYmVyKTogRmlsdGVyZWRGaWJlckluc3RhbmNlIHtcbiAgcmV0dXJuICh7XG4gICAga2luZDogRklMVEVSRURfRklCRVJfSU5TVEFOQ0UsXG4gICAgaWQ6IDAsXG4gICAgcGFyZW50OiBudWxsLFxuICAgIGZpcnN0Q2hpbGQ6IG51bGwsXG4gICAgbmV4dFNpYmxpbmc6IG51bGwsXG4gICAgc291cmNlOiBudWxsLFxuICAgIGxvZ0NvdW50OiAwLFxuICAgIHRyZWVCYXNlRHVyYXRpb246IDAsXG4gICAgZGF0YTogZmliZXIsXG4gIH06IGFueSk7XG59XG5cbi8vIFRoaXMgdHlwZSByZXByZXNlbnRzIGEgc3RhdGVmdWwgaW5zdGFuY2Ugb2YgYSBTZXJ2ZXIgQ29tcG9uZW50IG9yIGEgQ29tcG9uZW50XG4vLyB0aGF0IGdldHMgb3B0aW1pemVkIGF3YXkgLSBlLmcuIGNhbGwtdGhyb3VnaCB3aXRob3V0IGNyZWF0aW5nIGEgRmliZXIuXG4vLyBJdCdzIGJhc2ljYWxseSBhIHZpcnR1YWwgRmliZXIuIFRoaXMgaXMgbm90IGEgc2VtYW50aWMgY29uY2VwdCBpbiBSZWFjdC5cbi8vIEl0IG9ubHkgZXhpc3RzIGFzIGEgdmlydHVhbCBjb25jZXB0IHRvIGxldCB0aGUgc2FtZSBFbGVtZW50IGluIHRoZSBEZXZUb29sc1xuLy8gcGVyc2lzdC4gVG8gYmUgc2VsZWN0YWJsZSBzZXBhcmF0ZWx5IGZyb20gYWxsIFJlYWN0Q29tcG9uZW50SW5mbyBhbmQgb3ZlcnRpbWUuXG50eXBlIFZpcnR1YWxJbnN0YW5jZSA9IHtcbiAga2luZDogMSxcbiAgaWQ6IG51bWJlcixcbiAgcGFyZW50OiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgZmlyc3RDaGlsZDogbnVsbCB8IERldlRvb2xzSW5zdGFuY2UsXG4gIG5leHRTaWJsaW5nOiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgc291cmNlOiBudWxsIHwgc3RyaW5nIHwgRXJyb3IgfCBTb3VyY2UsIC8vIHNvdXJjZSBsb2NhdGlvbiBvZiB0aGlzIHNlcnZlciBjb21wb25lbnQsIG9yIG93bmVkIGNoaWxkIHN0YWNrXG4gIGxvZ0NvdW50OiBudW1iZXIsIC8vIHRvdGFsIG51bWJlciBvZiBlcnJvcnMvd2FybmluZ3MgbGFzdCBzZWVuXG4gIHRyZWVCYXNlRHVyYXRpb246IG51bWJlciwgLy8gdGhlIHByb2ZpbGVkIHRpbWUgb2YgdGhlIGxhc3QgcmVuZGVyIG9mIHRoaXMgc3VidHJlZVxuICAvLyBUaGUgbGF0ZXN0IGluZm8gZm9yIHRoaXMgaW5zdGFuY2UuIFRoaXMgY2FuIGJlIHVwZGF0ZWQgb3ZlciB0aW1lIGFuZCB0aGVcbiAgLy8gc2FtZSBpbmZvIGNhbiBhcHBlYXIgaW4gbW9yZSB0aGFuIG9uY2UgU2VydmVyQ29tcG9uZW50SW5zdGFuY2UuXG4gIGRhdGE6IFJlYWN0Q29tcG9uZW50SW5mbyxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxJbnN0YW5jZShcbiAgZGVidWdFbnRyeTogUmVhY3RDb21wb25lbnRJbmZvLFxuKTogVmlydHVhbEluc3RhbmNlIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBWSVJUVUFMX0lOU1RBTkNFLFxuICAgIGlkOiBnZXRVSUQoKSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgZmlyc3RDaGlsZDogbnVsbCxcbiAgICBuZXh0U2libGluZzogbnVsbCxcbiAgICBzb3VyY2U6IG51bGwsXG4gICAgbG9nQ291bnQ6IDAsXG4gICAgdHJlZUJhc2VEdXJhdGlvbjogMCxcbiAgICBkYXRhOiBkZWJ1Z0VudHJ5LFxuICB9O1xufVxuXG50eXBlIERldlRvb2xzSW5zdGFuY2UgPSBGaWJlckluc3RhbmNlIHwgVmlydHVhbEluc3RhbmNlIHwgRmlsdGVyZWRGaWJlckluc3RhbmNlO1xuXG50eXBlIGdldERpc3BsYXlOYW1lRm9yRmliZXJUeXBlID0gKGZpYmVyOiBGaWJlcikgPT4gc3RyaW5nIHwgbnVsbDtcbnR5cGUgZ2V0VHlwZVN5bWJvbFR5cGUgPSAodHlwZTogYW55KSA9PiBzeW1ib2wgfCBudW1iZXI7XG5cbnR5cGUgUmVhY3RQcmlvcml0eUxldmVsc1R5cGUgPSB7XG4gIEltbWVkaWF0ZVByaW9yaXR5OiBudW1iZXIsXG4gIFVzZXJCbG9ja2luZ1ByaW9yaXR5OiBudW1iZXIsXG4gIE5vcm1hbFByaW9yaXR5OiBudW1iZXIsXG4gIExvd1ByaW9yaXR5OiBudW1iZXIsXG4gIElkbGVQcmlvcml0eTogbnVtYmVyLFxuICBOb1ByaW9yaXR5OiBudW1iZXIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGF0Y2hlclJlZihyZW5kZXJlcjoge1xuICArY3VycmVudERpc3BhdGNoZXJSZWY/OiBMZWdhY3lEaXNwYXRjaGVyUmVmIHwgQ3VycmVudERpc3BhdGNoZXJSZWYsXG4gIC4uLlxufSk6IHZvaWQgfCBDdXJyZW50RGlzcGF0Y2hlclJlZiB7XG4gIGlmIChyZW5kZXJlci5jdXJyZW50RGlzcGF0Y2hlclJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBpbmplY3RlZFJlZiA9IHJlbmRlcmVyLmN1cnJlbnREaXNwYXRjaGVyUmVmO1xuICBpZiAoXG4gICAgdHlwZW9mIGluamVjdGVkUmVmLkggPT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGluamVjdGVkUmVmLmN1cnJlbnQgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIC8vIFdlIGdvdCBhIGxlZ2FjeSBkaXNwYXRjaGVyIGluamVjdGVkLCBsZXQncyBjcmVhdGUgYSB3cmFwcGVyIHByb3h5IHRvIHRyYW5zbGF0ZS5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IEgoKSB7XG4gICAgICAgIHJldHVybiAoaW5qZWN0ZWRSZWY6IGFueSkuY3VycmVudDtcbiAgICAgIH0sXG4gICAgICBzZXQgSCh2YWx1ZSkge1xuICAgICAgICAoaW5qZWN0ZWRSZWY6IGFueSkuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIHJldHVybiAoaW5qZWN0ZWRSZWY6IGFueSk7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyRmxhZ3MoZmliZXI6IEZpYmVyKTogbnVtYmVyIHtcbiAgLy8gVGhlIG5hbWUgb2YgdGhpcyBmaWVsZCBjaGFuZ2VkIGZyb20gXCJlZmZlY3RUYWdcIiB0byBcImZsYWdzXCJcbiAgcmV0dXJuIGZpYmVyLmZsYWdzICE9PSB1bmRlZmluZWQgPyBmaWJlci5mbGFncyA6IChmaWJlcjogYW55KS5lZmZlY3RUYWc7XG59XG5cbi8vIFNvbWUgZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSAvIEhlcm1lcykgZG9uJ3Qgc3VwcG9ydCB0aGUgcGVyZm9ybWFuY2UgQVBJIHlldC5cbmNvbnN0IGdldEN1cnJlbnRUaW1lID1cbiAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbidcbiAgICA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgOiAoKSA9PiBEYXRlLm5vdygpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxSZWFjdENvbnN0YW50cyh2ZXJzaW9uOiBzdHJpbmcpOiB7XG4gIGdldERpc3BsYXlOYW1lRm9yRmliZXI6IGdldERpc3BsYXlOYW1lRm9yRmliZXJUeXBlLFxuICBnZXRUeXBlU3ltYm9sOiBnZXRUeXBlU3ltYm9sVHlwZSxcbiAgUmVhY3RQcmlvcml0eUxldmVsczogUmVhY3RQcmlvcml0eUxldmVsc1R5cGUsXG4gIFJlYWN0VHlwZU9mV29yazogV29ya1RhZ01hcCxcbiAgU3RyaWN0TW9kZUJpdHM6IG51bWJlcixcbn0ge1xuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIFRoZSBzZWN0aW9uIGJlbG93IGlzIGNvcGllZCBmcm9tIGZpbGVzIGluIFJlYWN0IHJlcG8uXG4gIC8vIEtlZXAgaXQgaW4gc3luYywgYW5kIGFkZCB2ZXJzaW9uIGd1YXJkcyBpZiBpdCBjaGFuZ2VzLlxuICAvL1xuICAvLyBUZWNobmljYWxseSB0aGVzZSBwcmlvcml0eSBsZXZlbHMgYXJlIGludmFsaWQgZm9yIHZlcnNpb25zIGJlZm9yZSAxNi45LFxuICAvLyBidXQgMTYuOSBpcyB0aGUgZmlyc3QgdmVyc2lvbiB0byByZXBvcnQgcHJpb3JpdHkgbGV2ZWwgdG8gRGV2VG9vbHMsXG4gIC8vIHNvIHdlIGNhbiBhdm9pZCBjaGVja2luZyBmb3IgZWFybGllciB2ZXJzaW9ucyBhbmQgc3VwcG9ydCBwcmUtMTYuOSBjYW5hcnkgcmVsZWFzZXMgaW4gdGhlIHByb2Nlc3MuXG4gIGxldCBSZWFjdFByaW9yaXR5TGV2ZWxzOiBSZWFjdFByaW9yaXR5TGV2ZWxzVHlwZSA9IHtcbiAgICBJbW1lZGlhdGVQcmlvcml0eTogOTksXG4gICAgVXNlckJsb2NraW5nUHJpb3JpdHk6IDk4LFxuICAgIE5vcm1hbFByaW9yaXR5OiA5NyxcbiAgICBMb3dQcmlvcml0eTogOTYsXG4gICAgSWRsZVByaW9yaXR5OiA5NSxcbiAgICBOb1ByaW9yaXR5OiA5MCxcbiAgfTtcblxuICBpZiAoZ3QodmVyc2lvbiwgJzE3LjAuMicpKSB7XG4gICAgUmVhY3RQcmlvcml0eUxldmVscyA9IHtcbiAgICAgIEltbWVkaWF0ZVByaW9yaXR5OiAxLFxuICAgICAgVXNlckJsb2NraW5nUHJpb3JpdHk6IDIsXG4gICAgICBOb3JtYWxQcmlvcml0eTogMyxcbiAgICAgIExvd1ByaW9yaXR5OiA0LFxuICAgICAgSWRsZVByaW9yaXR5OiA1LFxuICAgICAgTm9Qcmlvcml0eTogMCxcbiAgICB9O1xuICB9XG5cbiAgbGV0IFN0cmljdE1vZGVCaXRzID0gMDtcbiAgaWYgKGd0ZSh2ZXJzaW9uLCAnMTguMC4wLWFscGhhJykpIHtcbiAgICAvLyAxOCtcbiAgICBTdHJpY3RNb2RlQml0cyA9IDBiMDExMDAwO1xuICB9IGVsc2UgaWYgKGd0ZSh2ZXJzaW9uLCAnMTYuOS4wJykpIHtcbiAgICAvLyAxNi45IC0gMTdcbiAgICBTdHJpY3RNb2RlQml0cyA9IDBiMTtcbiAgfSBlbHNlIGlmIChndGUodmVyc2lvbiwgJzE2LjMuMCcpKSB7XG4gICAgLy8gMTYuMyAtIDE2LjhcbiAgICBTdHJpY3RNb2RlQml0cyA9IDBiMTA7XG4gIH1cblxuICBsZXQgUmVhY3RUeXBlT2ZXb3JrOiBXb3JrVGFnTWFwID0gKChudWxsOiBhbnkpOiBXb3JrVGFnTWFwKTtcblxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIFRoZSBzZWN0aW9uIGJlbG93IGlzIGNvcGllZCBmcm9tIGZpbGVzIGluIFJlYWN0IHJlcG8uXG4gIC8vIEtlZXAgaXQgaW4gc3luYywgYW5kIGFkZCB2ZXJzaW9uIGd1YXJkcyBpZiBpdCBjaGFuZ2VzLlxuICAvL1xuICAvLyBUT0RPIFVwZGF0ZSB0aGUgZ3QoKSBjaGVjayBiZWxvdyB0byBiZSBndGUoKSB3aGljaGV2ZXIgdGhlIG5leHQgdmVyc2lvbiBudW1iZXIgaXMuXG4gIC8vIEN1cnJlbnRseSB0aGUgdmVyc2lvbiBpbiBHaXQgaXMgMTcuMC4yIChidXQgdGhhdCB2ZXJzaW9uIGhhcyBub3QgYmVlbi9tYXkgbm90IGVuZCB1cCBiZWluZyByZWxlYXNlZCkuXG4gIGlmIChndCh2ZXJzaW9uLCAnMTcuMC4xJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogMjQsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDEsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDksXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEwLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiAtMSwgLy8gUmVtb3ZlZFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiAtMSwgLy8gUmVtb3ZlZFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAxOCwgLy8gQmVoaW5kIGEgZmxhZ1xuICAgICAgRm9yd2FyZFJlZjogMTEsXG4gICAgICBGcmFnbWVudDogNyxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RIb2lzdGFibGU6IDI2LCAvLyBJbiByZWFsaXR5LCAxOC4yKy4gQnV0IGRvZXNuJ3QgaHVydCB0byBpbmNsdWRlIGl0IGhlcmVcbiAgICAgIEhvc3RTaW5nbGV0b246IDI3LCAvLyBTYW1lIGFzIGFib3ZlXG4gICAgICBIb3N0VGV4dDogNixcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDogMTcsXG4gICAgICBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQ6IDI4LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDogMiwgLy8gcmVtb3ZlZCBpbiAxOS4wLjBcbiAgICAgIExhenlDb21wb25lbnQ6IDE2LFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAyMyxcbiAgICAgIE1lbW9Db21wb25lbnQ6IDE0LFxuICAgICAgTW9kZTogOCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogMjIsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDEyLFxuICAgICAgU2NvcGVDb21wb25lbnQ6IDIxLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBUcmFjaW5nTWFya2VyQ29tcG9uZW50OiAyNSwgLy8gRXhwZXJpbWVudGFsIC0gVGhpcyBpcyB0ZWNobmljYWxseSBpbiAxOCBidXQgd2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gZm9yayBhZ2FpbiBzbyB3ZSdyZSBhZGRpbmcgaXQgaGVyZSBpbnN0ZWFkXG4gICAgICBZaWVsZENvbXBvbmVudDogLTEsIC8vIFJlbW92ZWRcbiAgICAgIFRocm93OiAyOSxcbiAgICAgIFZpZXdUcmFuc2l0aW9uQ29tcG9uZW50OiAzMCwgLy8gRXhwZXJpbWVudGFsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChndGUodmVyc2lvbiwgJzE3LjAuMC1hbHBoYScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDEsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDksXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEwLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiAtMSwgLy8gUmVtb3ZlZFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiAtMSwgLy8gUmVtb3ZlZFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAxOCwgLy8gQmVoaW5kIGEgZmxhZ1xuICAgICAgRm9yd2FyZFJlZjogMTEsXG4gICAgICBGcmFnbWVudDogNyxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RIb2lzdGFibGU6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSG9zdFNpbmdsZXRvbjogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBIb3N0VGV4dDogNixcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDogMTcsXG4gICAgICBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDogMixcbiAgICAgIExhenlDb21wb25lbnQ6IDE2LFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAyNCxcbiAgICAgIE1lbW9Db21wb25lbnQ6IDE0LFxuICAgICAgTW9kZTogOCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogMjMsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDEyLFxuICAgICAgU2NvcGVDb21wb25lbnQ6IDIxLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBUcmFjaW5nTWFya2VyQ29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFlpZWxkQ29tcG9uZW50OiAtMSwgLy8gUmVtb3ZlZFxuICAgICAgVGhyb3c6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgVmlld1RyYW5zaXRpb25Db21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZ3RlKHZlcnNpb24sICcxNi42LjAtYmV0YS4wJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBDbGFzc0NvbXBvbmVudDogMSxcbiAgICAgIENvbnRleHRDb25zdW1lcjogOSxcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTAsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IDE4LCAvLyBCZWhpbmQgYSBmbGFnXG4gICAgICBGb3J3YXJkUmVmOiAxMSxcbiAgICAgIEZyYWdtZW50OiA3LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA1LFxuICAgICAgSG9zdFBvcnRhbDogNCxcbiAgICAgIEhvc3RSb290OiAzLFxuICAgICAgSG9zdEhvaXN0YWJsZTogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBIb3N0U2luZ2xldG9uOiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAxNyxcbiAgICAgIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAyLFxuICAgICAgTGF6eUNvbXBvbmVudDogMTYsXG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IC0xLFxuICAgICAgTWVtb0NvbXBvbmVudDogMTQsXG4gICAgICBNb2RlOiA4LFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAtMSwgLy8gRXhwZXJpbWVudGFsXG4gICAgICBQcm9maWxlcjogMTIsXG4gICAgICBTY29wZUNvbXBvbmVudDogLTEsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgU2ltcGxlTWVtb0NvbXBvbmVudDogMTUsXG4gICAgICBTdXNwZW5zZUNvbXBvbmVudDogMTMsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQ6IDE5LCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBUaHJvdzogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBWaWV3VHJhbnNpdGlvbkNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChndGUodmVyc2lvbiwgJzE2LjQuMy1hbHBoYScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDIsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDExLFxuICAgICAgQ29udGV4dFByb3ZpZGVyOiAxMixcbiAgICAgIENvcm91dGluZUNvbXBvbmVudDogLTEsIC8vIFJlbW92ZWRcbiAgICAgIENvcm91dGluZUhhbmRsZXJQaGFzZTogLTEsIC8vIFJlbW92ZWRcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBGb3J3YXJkUmVmOiAxMyxcbiAgICAgIEZyYWdtZW50OiA5LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDAsXG4gICAgICBIb3N0Q29tcG9uZW50OiA3LFxuICAgICAgSG9zdFBvcnRhbDogNixcbiAgICAgIEhvc3RSb290OiA1LFxuICAgICAgSG9zdEhvaXN0YWJsZTogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBIb3N0U2luZ2xldG9uOiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RUZXh0OiA4LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiA0LFxuICAgICAgTGF6eUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IC0xLFxuICAgICAgTWVtb0NvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBNb2RlOiAxMCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogLTEsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDE1LFxuICAgICAgU2NvcGVDb21wb25lbnQ6IC0xLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDE2LFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xLCAvLyBSZW1vdmVkXG4gICAgICBUaHJvdzogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBWaWV3VHJhbnNpdGlvbkNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBDbGFzc0NvbXBvbmVudDogMixcbiAgICAgIENvbnRleHRDb25zdW1lcjogMTIsXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEzLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiA3LFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiA4LFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEZvcndhcmRSZWY6IDE0LFxuICAgICAgRnJhZ21lbnQ6IDEwLFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQ6IDEsXG4gICAgICBIb3N0Q29tcG9uZW50OiA1LFxuICAgICAgSG9zdFBvcnRhbDogNCxcbiAgICAgIEhvc3RSb290OiAzLFxuICAgICAgSG9zdEhvaXN0YWJsZTogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBIb3N0U2luZ2xldG9uOiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAwLFxuICAgICAgTGF6eUNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IC0xLFxuICAgICAgTWVtb0NvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBNb2RlOiAxMSxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudDogLTEsIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDE1LFxuICAgICAgU2NvcGVDb21wb25lbnQ6IC0xLCAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDE2LFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAtMSwgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6IC0xLCAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgWWllbGRDb21wb25lbnQ6IDksXG4gICAgICBUaHJvdzogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBWaWV3VHJhbnNpdGlvbkNvbXBvbmVudDogLTEsIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgfTtcbiAgfVxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIEVuZCBvZiBjb3BpZWQgY29kZS5cbiAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIGZ1bmN0aW9uIGdldFR5cGVTeW1ib2wodHlwZTogYW55KTogc3ltYm9sIHwgbnVtYmVyIHtcbiAgICBjb25zdCBzeW1ib2xPck51bWJlciA9XG4gICAgICB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCA/IHR5cGUuJCR0eXBlb2YgOiB0eXBlO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBzeW1ib2xPck51bWJlciA9PT0gJ3N5bWJvbCdcbiAgICAgID8gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBgdG9TdHJpbmcoKWAgZG9lc24ndCBtYXRjaCB0aGUgdHlwZSBzaWduYXR1cmU/XG4gICAgICAgIHN5bWJvbE9yTnVtYmVyLnRvU3RyaW5nKClcbiAgICAgIDogc3ltYm9sT3JOdW1iZXI7XG4gIH1cblxuICBjb25zdCB7XG4gICAgQ2FjaGVDb21wb25lbnQsXG4gICAgQ2xhc3NDb21wb25lbnQsXG4gICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50LFxuICAgIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudCxcbiAgICBGdW5jdGlvbkNvbXBvbmVudCxcbiAgICBJbmRldGVybWluYXRlQ29tcG9uZW50LFxuICAgIEZvcndhcmRSZWYsXG4gICAgSG9zdFJvb3QsXG4gICAgSG9zdEhvaXN0YWJsZSxcbiAgICBIb3N0U2luZ2xldG9uLFxuICAgIEhvc3RDb21wb25lbnQsXG4gICAgSG9zdFBvcnRhbCxcbiAgICBIb3N0VGV4dCxcbiAgICBGcmFnbWVudCxcbiAgICBMYXp5Q29tcG9uZW50LFxuICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudCxcbiAgICBNZW1vQ29tcG9uZW50LFxuICAgIE9mZnNjcmVlbkNvbXBvbmVudCxcbiAgICBQcm9maWxlcixcbiAgICBTY29wZUNvbXBvbmVudCxcbiAgICBTaW1wbGVNZW1vQ29tcG9uZW50LFxuICAgIFN1c3BlbnNlQ29tcG9uZW50LFxuICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudCxcbiAgICBUcmFjaW5nTWFya2VyQ29tcG9uZW50LFxuICAgIFRocm93LFxuICAgIFZpZXdUcmFuc2l0aW9uQ29tcG9uZW50LFxuICB9ID0gUmVhY3RUeXBlT2ZXb3JrO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVGaWJlclR5cGUodHlwZTogYW55KTogJEZsb3dGaXhNZSB7XG4gICAgY29uc3QgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG4gICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICBjYXNlIE1FTU9fTlVNQkVSOlxuICAgICAgY2FzZSBNRU1PX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHJlc29sdmluZyBtZW1vIHR5cGUgaW4gY2FzZSBvZiBtZW1vKGZvcndhcmRSZWYoQ29tcG9uZW50KSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmVGaWJlclR5cGUodHlwZS50eXBlKTtcbiAgICAgIGNhc2UgRk9SV0FSRF9SRUZfTlVNQkVSOlxuICAgICAgY2FzZSBGT1JXQVJEX1JFRl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICByZXR1cm4gdHlwZS5yZW5kZXI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBOT1RJQ0UgS2VlcCBpbiBzeW5jIHdpdGggc2hvdWxkRmlsdGVyRmliZXIoKSBhbmQgb3RoZXIgZ2V0KkZvckZpYmVyIG1ldGhvZHNcbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihcbiAgICBmaWJlcjogRmliZXIsXG4gICAgc2hvdWxkU2tpcEZvcmdldENoZWNrOiBib29sZWFuID0gZmFsc2UsXG4gICk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IHtlbGVtZW50VHlwZSwgdHlwZSwgdGFnfSA9IGZpYmVyO1xuXG4gICAgbGV0IHJlc29sdmVkVHlwZSA9IHR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRmliZXJUeXBlKHR5cGUpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlZENvbnRleHQ6IGFueSA9IG51bGw7XG4gICAgaWYgKFxuICAgICAgIXNob3VsZFNraXBGb3JnZXRDaGVjayAmJlxuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gZmliZXIudXBkYXRlUXVldWUgaXMgbWl4ZWRcbiAgICAgIChmaWJlci51cGRhdGVRdWV1ZT8ubWVtb0NhY2hlICE9IG51bGwgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoZmliZXIubWVtb2l6ZWRTdGF0ZT8ubWVtb2l6ZWRTdGF0ZSkgJiZcbiAgICAgICAgICBmaWJlci5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGVbMF0/LltSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMXSkgfHxcbiAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZT8ubWVtb2l6ZWRTdGF0ZT8uW1JFQUNUX01FTU9fQ0FDSEVfU0VOVElORUxdKVxuICAgICkge1xuICAgICAgY29uc3QgZGlzcGxheU5hbWVXaXRob3V0Rm9yZ2V0V3JhcHBlciA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICB0cnVlLFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNwbGF5TmFtZVdpdGhvdXRGb3JnZXRXcmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgRm9yZ2V0KCR7ZGlzcGxheU5hbWVXaXRob3V0Rm9yZ2V0V3JhcHBlcn0pYDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShyZXNvbHZlZFR5cGUpO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZERpc3BsYXlOYW1lKFxuICAgICAgICAgIGVsZW1lbnRUeXBlLFxuICAgICAgICAgIHJlc29sdmVkVHlwZSxcbiAgICAgICAgICAnRm9yd2FyZFJlZicsXG4gICAgICAgICAgJ0Fub255bW91cycsXG4gICAgICAgICk7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBjb25zdCBmaWJlclJvb3QgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChmaWJlclJvb3QgIT0gbnVsbCAmJiBmaWJlclJvb3QuX2RlYnVnUm9vdFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmliZXJSb290Ll9kZWJ1Z1Jvb3RUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG4gICAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICAgIC8vIFRoaXMgZGlzcGxheSBuYW1lIHdpbGwgbm90IGJlIHVzZXIgdmlzaWJsZS5cbiAgICAgICAgLy8gT25jZSBhIExhenkgY29tcG9uZW50IGxvYWRzIGl0cyBpbm5lciBjb21wb25lbnQsIFJlYWN0IHJlcGxhY2VzIHRoZSB0YWcgYW5kIHR5cGUuXG4gICAgICAgIC8vIFRoaXMgZGlzcGxheSBuYW1lIHdpbGwgb25seSBzaG93IHVwIGluIGNvbnNvbGUgbG9ncyB3aGVuIERldlRvb2xzIERFQlVHIG1vZGUgaXMgb24uXG4gICAgICAgIHJldHVybiAnTGF6eSc7XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIC8vIERpc3BsYXkgbmFtZSBpbiBSZWFjdCBkb2VzIG5vdCB1c2UgYE1lbW9gIGFzIGEgd3JhcHBlciBidXQgZmFsbGJhY2sgbmFtZS5cbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWREaXNwbGF5TmFtZShcbiAgICAgICAgICBlbGVtZW50VHlwZSxcbiAgICAgICAgICByZXNvbHZlZFR5cGUsXG4gICAgICAgICAgJ01lbW8nLFxuICAgICAgICAgICdBbm9ueW1vdXMnLFxuICAgICAgICApO1xuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG4gICAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdMZWdhY3lIaWRkZW4nO1xuICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcbiAgICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnU2NvcGUnO1xuICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuICAgICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ1RyYWNpbmdNYXJrZXInO1xuICAgICAgY2FzZSBWaWV3VHJhbnNpdGlvbkNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdWaWV3VHJhbnNpdGlvbic7XG4gICAgICBjYXNlIFRocm93OlxuICAgICAgICAvLyBUaGlzIHNob3VsZCByZWFsbHkgbmV2ZXIgYmUgdmlzaWJsZS5cbiAgICAgICAgcmV0dXJuICdFcnJvcic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zdCB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgICAgICBjYXNlIENPTkNVUlJFTlRfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICBjYXNlIERFUFJFQ0FURURfQVNZTkNfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgY2FzZSBQUk9WSURFUl9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBQUk9WSURFUl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgLy8gMTYuMy4wIGV4cG9zZWQgdGhlIGNvbnRleHQgb2JqZWN0IGFzIFwiY29udGV4dFwiXG4gICAgICAgICAgICAvLyBQUiAjMTI1MDEgY2hhbmdlZCBpdCB0byBcIl9jb250ZXh0XCIgZm9yIDE2LjMuMStcbiAgICAgICAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggaW5zcGVjdEVsZW1lbnRSYXcoKVxuICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gZmliZXIudHlwZS5fY29udGV4dCB8fCBmaWJlci50eXBlLmNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gYCR7cmVzb2x2ZWRDb250ZXh0LmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0J30uUHJvdmlkZXJgO1xuICAgICAgICAgIGNhc2UgQ09OVEVYVF9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBDT05URVhUX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgY2FzZSBTRVJWRVJfQ09OVEVYVF9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBmaWJlci50eXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgZmliZXIudHlwZS5Qcm92aWRlciA9PT0gZmliZXIudHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIEluIDE5KywgQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCwgc28gdGhpcyBpcyBhIHByb3ZpZGVyLlxuICAgICAgICAgICAgICByZXNvbHZlZENvbnRleHQgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7cmVzb2x2ZWRDb250ZXh0LmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0J30uUHJvdmlkZXJgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxNi4zLTE2LjUgcmVhZCBmcm9tIFwidHlwZVwiIGJlY2F1c2UgdGhlIENvbnN1bWVyIGlzIHRoZSBhY3R1YWwgY29udGV4dCBvYmplY3QuXG4gICAgICAgICAgICAvLyAxNi42KyBzaG91bGQgcmVhZCBmcm9tIFwidHlwZS5fY29udGV4dFwiIGJlY2F1c2UgQ29uc3VtZXIgY2FuIGJlIGRpZmZlcmVudCAoaW4gREVWKS5cbiAgICAgICAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggaW5zcGVjdEVsZW1lbnRSYXcoKVxuICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gZmliZXIudHlwZS5fY29udGV4dCB8fCBmaWJlci50eXBlO1xuXG4gICAgICAgICAgICAvLyBOT1RFOiBUcmFjZVVwZGF0ZXNCYWNrZW5kTWFuYWdlciBkZXBlbmRzIG9uIHRoZSBuYW1lIGVuZGluZyBpbiAnLkNvbnN1bWVyJ1xuICAgICAgICAgICAgLy8gSWYgeW91IGNoYW5nZSB0aGUgbmFtZSwgZmlndXJlIG91dCBhIG1vcmUgcmVzaWxpZW50IHdheSB0byBkZXRlY3QgaXQuXG4gICAgICAgICAgICByZXR1cm4gYCR7cmVzb2x2ZWRDb250ZXh0LmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0J30uQ29uc3VtZXJgO1xuICAgICAgICAgIGNhc2UgQ09OU1VNRVJfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIC8vIDE5K1xuICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gZmliZXIudHlwZS5fY29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBgJHtyZXNvbHZlZENvbnRleHQuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnfS5Db25zdW1lcmA7XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIGBQcm9maWxlcigke2ZpYmVyLm1lbW9pemVkUHJvcHMuaWR9KWA7XG4gICAgICAgICAgY2FzZSBTQ09QRV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBTQ09QRV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuICdTY29wZSc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFVua25vd24gZWxlbWVudCB0eXBlLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbWVhbiBhIG5ldyBlbGVtZW50IHR5cGUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIERldlRvb2xzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXIsXG4gICAgZ2V0VHlwZVN5bWJvbCxcbiAgICBSZWFjdFByaW9yaXR5TGV2ZWxzLFxuICAgIFJlYWN0VHlwZU9mV29yayxcbiAgICBTdHJpY3RNb2RlQml0cyxcbiAgfTtcbn1cblxuLy8gQWxsIGVudmlyb25tZW50IG5hbWVzIHdlJ3ZlIHNlZW4gc28gZmFyLiBUaGlzIGxldHMgdXMgY3JlYXRlIGEgbGlzdCBvZiBmaWx0ZXJzIHRvIGFwcGx5LlxuLy8gVGhpcyBzaG91bGQgaWRlYWxseSBpbmNsdWRlIGVudiBvZiBmaWx0ZXJlZCBDb21wb25lbnRzIHRvbyBzbyB0aGF0IHlvdSBjYW4gYWRkIHRob3NlIGFzXG4vLyBmaWx0ZXJzIGF0IHRoZSBzYW1lIHRpbWUgYXMgcmVtb3Zpbmcgc29tZSBvdGhlciBmaWx0ZXIuXG5jb25zdCBrbm93bkVudmlyb25tZW50TmFtZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4vLyBNYXAgb2YgRmliZXJSb290IHRvIHRoZWlyIHJvb3QgRmliZXJJbnN0YW5jZS5cbmNvbnN0IHJvb3RUb0ZpYmVySW5zdGFuY2VNYXA6IE1hcDxGaWJlclJvb3QsIEZpYmVySW5zdGFuY2U+ID0gbmV3IE1hcCgpO1xuXG4vLyBNYXAgb2YgaWQgdG8gRmliZXJJbnN0YW5jZSBvciBWaXJ0dWFsSW5zdGFuY2UuXG4vLyBUaGlzIE1hcCBpcyB1c2VkIHRvIGUuZy4gZ2V0IHRoZSBkaXNwbGF5IG5hbWUgZm9yIGEgRmliZXIgb3Igc2NoZWR1bGUgYW4gdXBkYXRlLFxuLy8gb3BlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSB0aGUgc2FtZSB3aGV0aGVyIHRoZSBjdXJyZW50IGFuZCB3b3JrLWluLXByb2dyZXNzIEZpYmVyIGlzIHVzZWQuXG5jb25zdCBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcDogTWFwPG51bWJlciwgRmliZXJJbnN0YW5jZSB8IFZpcnR1YWxJbnN0YW5jZT4gPVxuICBuZXcgTWFwKCk7XG5cbi8vIE1hcCBvZiBjYW5vbmljYWwgSG9zdEluc3RhbmNlcyB0byB0aGUgbmVhcmVzdCBwYXJlbnQgRGV2VG9vbHNJbnN0YW5jZS5cbmNvbnN0IHB1YmxpY0luc3RhbmNlVG9EZXZUb29sc0luc3RhbmNlTWFwOiBNYXA8SG9zdEluc3RhbmNlLCBEZXZUb29sc0luc3RhbmNlPiA9XG4gIG5ldyBNYXAoKTtcbi8vIE1hcCBvZiByZXNvdXJjZSBET00gbm9kZXMgdG8gYWxsIHRoZSBuZWFyZXN0IERldlRvb2xzSW5zdGFuY2VzIHRoYXQgZGVwZW5kIG9uIGl0LlxuY29uc3QgaG9zdFJlc291cmNlVG9EZXZUb29sc0luc3RhbmNlTWFwOiBNYXA8XG4gIEhvc3RJbnN0YW5jZSxcbiAgU2V0PERldlRvb2xzSW5zdGFuY2U+LFxuPiA9IG5ldyBNYXAoKTtcblxuLy8gSWRlYWxseSwgdGhpcyBzaG91bGQgYmUgaW5qZWN0ZWQgZnJvbSBSZWNvbmNpbGVyIGNvbmZpZ1xuZnVuY3Rpb24gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2U6IEhvc3RJbnN0YW5jZSk6IEhvc3RJbnN0YW5jZSB7XG4gIC8vIFR5cGljYWxseSB0aGUgUHVibGljSW5zdGFuY2UgYW5kIEhvc3RJbnN0YW5jZSBpcyB0aGUgc2FtZSB0aGluZyBidXQgbm90IGluIEZhYnJpYy5cbiAgLy8gU28gd2UgbmVlZCB0byBkZXRlY3QgdGhpcyBhbmQgdXNlIHRoYXQgYXMgdGhlIHB1YmxpYyBpbnN0YW5jZS5cblxuICAvLyBSZWFjdCBOYXRpdmUuIE1vZGVybi4gRmFicmljLlxuICBpZiAodHlwZW9mIGluc3RhbmNlID09PSAnb2JqZWN0JyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY2Fub25pY2FsID09PSAnb2JqZWN0JyAmJiBpbnN0YW5jZS5jYW5vbmljYWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGluc3RhbmNlLmNhbm9uaWNhbC5wdWJsaWNJbnN0YW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgaW5zdGFuY2UuY2Fub25pY2FsLnB1YmxpY0luc3RhbmNlICE9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmNhbm9uaWNhbC5wdWJsaWNJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWFjdCBOYXRpdmUuIExlZ2FjeS4gUGFwZXIuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5fbmF0aXZlVGFnID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9uYXRpdmVUYWc7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhY3QgV2ViLiBVc3VhbGx5IGEgRE9NIGVsZW1lbnQuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gYXF1aXJlSG9zdEluc3RhbmNlKFxuICBuZWFyZXN0SW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UsXG4gIGhvc3RJbnN0YW5jZTogSG9zdEluc3RhbmNlLFxuKTogdm9pZCB7XG4gIGNvbnN0IHB1YmxpY0luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoaG9zdEluc3RhbmNlKTtcbiAgcHVibGljSW5zdGFuY2VUb0RldlRvb2xzSW5zdGFuY2VNYXAuc2V0KHB1YmxpY0luc3RhbmNlLCBuZWFyZXN0SW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlSG9zdEluc3RhbmNlKFxuICBuZWFyZXN0SW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UsXG4gIGhvc3RJbnN0YW5jZTogSG9zdEluc3RhbmNlLFxuKTogdm9pZCB7XG4gIGNvbnN0IHB1YmxpY0luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoaG9zdEluc3RhbmNlKTtcbiAgaWYgKFxuICAgIHB1YmxpY0luc3RhbmNlVG9EZXZUb29sc0luc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSkgPT09IG5lYXJlc3RJbnN0YW5jZVxuICApIHtcbiAgICBwdWJsaWNJbnN0YW5jZVRvRGV2VG9vbHNJbnN0YW5jZU1hcC5kZWxldGUocHVibGljSW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFxdWlyZUhvc3RSZXNvdXJjZShcbiAgbmVhcmVzdEluc3RhbmNlOiBEZXZUb29sc0luc3RhbmNlLFxuICByZXNvdXJjZTogP3tpbnN0YW5jZT86IEhvc3RJbnN0YW5jZX0sXG4pOiB2b2lkIHtcbiAgY29uc3QgaG9zdEluc3RhbmNlID0gcmVzb3VyY2UgJiYgcmVzb3VyY2UuaW5zdGFuY2U7XG4gIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICBjb25zdCBwdWJsaWNJbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgbGV0IHJlc291cmNlSW5zdGFuY2VzID1cbiAgICAgIGhvc3RSZXNvdXJjZVRvRGV2VG9vbHNJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChyZXNvdXJjZUluc3RhbmNlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNvdXJjZUluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICAgIGhvc3RSZXNvdXJjZVRvRGV2VG9vbHNJbnN0YW5jZU1hcC5zZXQocHVibGljSW5zdGFuY2UsIHJlc291cmNlSW5zdGFuY2VzKTtcbiAgICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgbWFpbiBtYXAgZm9yIHF1aWNrIGFjY2VzcyB3aGVuIHNlbGVjdGluZyBET00gbm9kZS5cbiAgICAgIHB1YmxpY0luc3RhbmNlVG9EZXZUb29sc0luc3RhbmNlTWFwLnNldChwdWJsaWNJbnN0YW5jZSwgbmVhcmVzdEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmVzb3VyY2VJbnN0YW5jZXMuYWRkKG5lYXJlc3RJbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZUhvc3RSZXNvdXJjZShcbiAgbmVhcmVzdEluc3RhbmNlOiBEZXZUb29sc0luc3RhbmNlLFxuICByZXNvdXJjZTogP3tpbnN0YW5jZT86IEhvc3RJbnN0YW5jZX0sXG4pOiB2b2lkIHtcbiAgY29uc3QgaG9zdEluc3RhbmNlID0gcmVzb3VyY2UgJiYgcmVzb3VyY2UuaW5zdGFuY2U7XG4gIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICBjb25zdCBwdWJsaWNJbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgY29uc3QgcmVzb3VyY2VJbnN0YW5jZXMgPVxuICAgICAgaG9zdFJlc291cmNlVG9EZXZUb29sc0luc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKHJlc291cmNlSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc291cmNlSW5zdGFuY2VzLmRlbGV0ZShuZWFyZXN0SW5zdGFuY2UpO1xuICAgICAgaWYgKHJlc291cmNlSW5zdGFuY2VzLnNpemUgPT09IDApIHtcbiAgICAgICAgaG9zdFJlc291cmNlVG9EZXZUb29sc0luc3RhbmNlTWFwLmRlbGV0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgIHB1YmxpY0luc3RhbmNlVG9EZXZUb29sc0luc3RhbmNlTWFwLmRlbGV0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwdWJsaWNJbnN0YW5jZVRvRGV2VG9vbHNJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpID09PVxuICAgICAgICBuZWFyZXN0SW5zdGFuY2VcbiAgICAgICkge1xuICAgICAgICAvLyBUaGlzIHdhcyB0aGUgZmlyc3Qgb25lLiBTdG9yZSB0aGUgbmV4dCBmaXJzdCBvbmUgaW4gdGhlIG1haW4gbWFwIGZvciBlYXN5IGFjY2Vzcy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICAgICAgZm9yIChjb25zdCBmaXJzdEluc3RhbmNlIG9mIHJlc291cmNlSW5zdGFuY2VzKSB7XG4gICAgICAgICAgcHVibGljSW5zdGFuY2VUb0RldlRvb2xzSW5zdGFuY2VNYXAuc2V0KFxuICAgICAgICAgICAgZmlyc3RJbnN0YW5jZSxcbiAgICAgICAgICAgIG5lYXJlc3RJbnN0YW5jZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2goXG4gIGhvb2s6IERldlRvb2xzSG9vayxcbiAgcmVuZGVyZXJJRDogbnVtYmVyLFxuICByZW5kZXJlcjogUmVhY3RSZW5kZXJlcixcbiAgZ2xvYmFsOiBPYmplY3QsXG4gIHNob3VsZFN0YXJ0UHJvZmlsaW5nTm93OiBib29sZWFuLFxuICBwcm9maWxpbmdTZXR0aW5nczogUHJvZmlsaW5nU2V0dGluZ3MsXG4pOiBSZW5kZXJlckludGVyZmFjZSB7XG4gIC8vIE5ld2VyIHZlcnNpb25zIG9mIHRoZSByZWNvbmNpbGVyIHBhY2thZ2UgYWxzbyBzcGVjaWZpYyByZWNvbmNpbGVyIHZlcnNpb24uXG4gIC8vIElmIHRoYXQgdmVyc2lvbiBudW1iZXIgaXMgcHJlc2VudCwgdXNlIGl0LlxuICAvLyBUaGlyZCBwYXJ0eSByZW5kZXJlciB2ZXJzaW9ucyBtYXkgbm90IG1hdGNoIHRoZSByZWNvbmNpbGVyIHZlcnNpb24sXG4gIC8vIGFuZCB0aGUgbGF0dGVyIGlzIHdoYXQncyBpbXBvcnRhbnQgaW4gdGVybXMgb2YgdGFncyBhbmQgc3ltYm9scy5cbiAgY29uc3QgdmVyc2lvbiA9IHJlbmRlcmVyLnJlY29uY2lsZXJWZXJzaW9uIHx8IHJlbmRlcmVyLnZlcnNpb247XG5cbiAgY29uc3Qge1xuICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXIsXG4gICAgZ2V0VHlwZVN5bWJvbCxcbiAgICBSZWFjdFByaW9yaXR5TGV2ZWxzLFxuICAgIFJlYWN0VHlwZU9mV29yayxcbiAgICBTdHJpY3RNb2RlQml0cyxcbiAgfSA9IGdldEludGVybmFsUmVhY3RDb25zdGFudHModmVyc2lvbik7XG4gIGNvbnN0IHtcbiAgICBDYWNoZUNvbXBvbmVudCxcbiAgICBDbGFzc0NvbXBvbmVudCxcbiAgICBDb250ZXh0Q29uc3VtZXIsXG4gICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50LFxuICAgIEZvcndhcmRSZWYsXG4gICAgRnJhZ21lbnQsXG4gICAgRnVuY3Rpb25Db21wb25lbnQsXG4gICAgSG9zdFJvb3QsXG4gICAgSG9zdEhvaXN0YWJsZSxcbiAgICBIb3N0U2luZ2xldG9uLFxuICAgIEhvc3RQb3J0YWwsXG4gICAgSG9zdENvbXBvbmVudCxcbiAgICBIb3N0VGV4dCxcbiAgICBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQsXG4gICAgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50LFxuICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50LFxuICAgIE1lbW9Db21wb25lbnQsXG4gICAgT2Zmc2NyZWVuQ29tcG9uZW50LFxuICAgIFNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgU3VzcGVuc2VDb21wb25lbnQsXG4gICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50LFxuICAgIFRyYWNpbmdNYXJrZXJDb21wb25lbnQsXG4gICAgVGhyb3csXG4gICAgVmlld1RyYW5zaXRpb25Db21wb25lbnQsXG4gIH0gPSBSZWFjdFR5cGVPZldvcms7XG4gIGNvbnN0IHtcbiAgICBJbW1lZGlhdGVQcmlvcml0eSxcbiAgICBVc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICBOb3JtYWxQcmlvcml0eSxcbiAgICBMb3dQcmlvcml0eSxcbiAgICBJZGxlUHJpb3JpdHksXG4gICAgTm9Qcmlvcml0eSxcbiAgfSA9IFJlYWN0UHJpb3JpdHlMZXZlbHM7XG5cbiAgY29uc3Qge1xuICAgIGdldExhbmVMYWJlbE1hcCxcbiAgICBpbmplY3RQcm9maWxpbmdIb29rcyxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZSxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG4gICAgc2NoZWR1bGVSZWZyZXNoLFxuICAgIHNldEVycm9ySGFuZGxlcixcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXIsXG4gICAgc2NoZWR1bGVVcGRhdGUsXG4gICAgZ2V0Q3VycmVudEZpYmVyLFxuICB9ID0gcmVuZGVyZXI7XG4gIGNvbnN0IHN1cHBvcnRzVG9nZ2xpbmdFcnJvciA9XG4gICAgdHlwZW9mIHNldEVycm9ySGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBzY2hlZHVsZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3Qgc3VwcG9ydHNUb2dnbGluZ1N1c3BlbnNlID1cbiAgICB0eXBlb2Ygc2V0U3VzcGVuc2VIYW5kbGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHNjaGVkdWxlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICh0eXBlb2Ygc2NoZWR1bGVSZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gV2hlbiBGYXN0IFJlZnJlc2ggdXBkYXRlcyBhIGNvbXBvbmVudCwgdGhlIGZyb250ZW5kIG1heSBuZWVkIHRvIHB1cmdlIGNhY2hlZCBpbmZvcm1hdGlvbi5cbiAgICAvLyBGb3IgZXhhbXBsZSwgQVNUcyBjYWNoZWQgZm9yIHRoZSBjb21wb25lbnQgKGZvciBuYW1lZCBob29rcykgbWF5IG5vIGxvbmdlciBiZSB2YWxpZC5cbiAgICAvLyBTZW5kIGEgc2lnbmFsIHRvIHRoZSBmcm9udGVuZCB0byBwdXJnZSB0aGlzIGNhY2hlZCBpbmZvcm1hdGlvbi5cbiAgICAvLyBUaGUgXCJmYXN0UmVmcmVzaFNjaGVkdWxlZFwiIGRpc3BhdGNoZWQgaXMgZ2xvYmFsIChub3QgRmliZXIgb3IgZXZlbiBSZW5kZXJlciBzcGVjaWZpYykuXG4gICAgLy8gVGhpcyBpcyBsZXNzIGVmZmVjaWVudCBzaW5jZSBpdCBtZWFucyB0aGUgZnJvbnQtZW5kIHdpbGwgbmVlZCB0byBwdXJnZSB0aGUgZW50aXJlIGNhY2hlLFxuICAgIC8vIGJ1dCB0aGlzIGlzIHByb2JhYmx5IGFuIG9rYXkgdHJhZGUgb2ZmIGluIG9yZGVyIHRvIHJlZHVjZSBjb3VwbGluZyBiZXR3ZWVuIHRoZSBEZXZUb29scyBhbmQgRmFzdCBSZWZyZXNoLlxuICAgIHJlbmRlcmVyLnNjaGVkdWxlUmVmcmVzaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBob29rLmVtaXQoJ2Zhc3RSZWZyZXNoU2NoZWR1bGVkJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVSZWZyZXNoKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBsZXQgZ2V0VGltZWxpbmVEYXRhOiBudWxsIHwgR2V0VGltZWxpbmVEYXRhID0gbnVsbDtcbiAgbGV0IHRvZ2dsZVByb2ZpbGluZ1N0YXR1czogbnVsbCB8IFRvZ2dsZVByb2ZpbGluZ1N0YXR1cyA9IG51bGw7XG4gIGlmICh0eXBlb2YgaW5qZWN0UHJvZmlsaW5nSG9va3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGNyZWF0ZVByb2ZpbGluZ0hvb2tzKHtcbiAgICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXIsXG4gICAgICBnZXRJc1Byb2ZpbGluZzogKCkgPT4gaXNQcm9maWxpbmcsXG4gICAgICBnZXRMYW5lTGFiZWxNYXAsXG4gICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogZ2V0RGlzcGF0Y2hlclJlZihyZW5kZXJlciksXG4gICAgICB3b3JrVGFnTWFwOiBSZWFjdFR5cGVPZldvcmssXG4gICAgICByZWFjdFZlcnNpb246IHZlcnNpb24sXG4gICAgfSk7XG5cbiAgICAvLyBQYXNzIHRoZSBQcm9maWxpbmcgaG9va3MgdG8gdGhlIHJlY29uY2lsZXIgZm9yIGl0IHRvIGNhbGwgZHVyaW5nIHJlbmRlci5cbiAgICBpbmplY3RQcm9maWxpbmdIb29rcyhyZXNwb25zZS5wcm9maWxpbmdIb29rcyk7XG5cbiAgICAvLyBIYW5nIG9udG8gdGhpcyB0b2dnbGUgc28gd2UgY2FuIG5vdGlmeSB0aGUgZXh0ZXJuYWwgbWV0aG9kcyBvZiBwcm9maWxpbmcgc3RhdHVzIGNoYW5nZXMuXG4gICAgZ2V0VGltZWxpbmVEYXRhID0gcmVzcG9uc2UuZ2V0VGltZWxpbmVEYXRhO1xuICAgIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyA9IHJlc3BvbnNlLnRvZ2dsZVByb2ZpbGluZ1N0YXR1cztcbiAgfVxuXG4gIHR5cGUgQ29tcG9uZW50TG9ncyA9IHtcbiAgICBlcnJvcnM6IE1hcDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZXJyb3JzQ291bnQ6IG51bWJlcixcbiAgICB3YXJuaW5nczogTWFwPHN0cmluZywgbnVtYmVyPixcbiAgICB3YXJuaW5nc0NvdW50OiBudW1iZXIsXG4gIH07XG4gIC8vIFRyYWNrcyBFcnJvcnMvV2FybmluZ3MgbG9ncyBhZGRlZCB0byBhIEZpYmVyLiBUaGV5IGFyZSBhZGRlZCBiZWZvcmUgdGhlIGNvbW1pdCBhbmQgZ2V0XG4gIC8vIHBpY2tlZCB1cCBhIEZpYmVySW5zdGFuY2UuIFRoaXMga2VlcHMgaXQgYXJvdW5kIGFzIGxvbmcgYXMgdGhlIEZpYmVyIGlzIGFsaXZlIHdoaWNoXG4gIC8vIGxldHMgdGhlIEZpYmVyIGdldCByZXBhcmVudGVkL3JlbW91bnRlZCBhbmQgc3RpbGwgb2JzZXJ2ZSB0aGUgcHJldmlvdXMgZXJyb3JzL3dhcm5pbmdzLlxuICAvLyBVbmxlc3Mgd2UgZXhwbGljaXRseSBjbGVhciB0aGUgbG9ncyBmcm9tIGEgRmliZXIuXG4gIGNvbnN0IGZpYmVyVG9Db21wb25lbnRMb2dzTWFwOiBXZWFrTWFwPEZpYmVyLCBDb21wb25lbnRMb2dzPiA9IG5ldyBXZWFrTWFwKCk7XG4gIC8vIFRyYWNrcyB3aGV0aGVyIHdlJ3ZlIHBlcmZvcm1lZCBhIGNvbW1pdCBzaW5jZSB0aGUgbGFzdCBsb2cuIFRoaXMgaXMgdXNlZCB0byBrbm93XG4gIC8vIHdoZXRoZXIgd2UgcmVjZWl2ZWQgYW55IG5ldyBsb2dzIGJldHdlZW4gdGhlIGNvbW1pdCBhbmQgcG9zdCBjb21taXQgcGhhc2VzLiBJLmUuXG4gIC8vIGlmIGFueSBwYXNzaXZlIGVmZmVjdHMgY2FsbGVkIGNvbnNvbGUud2FybiAvIGNvbnNvbGUuZXJyb3IuXG4gIGxldCBuZWVkc1RvRmx1c2hDb21wb25lbnRMb2dzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gYnJ1dGVGb3JjZUZsdXNoRXJyb3JzQW5kV2FybmluZ3MoKSB7XG4gICAgLy8gUmVmcmVzaCBlcnJvci93YXJuaW5nIGNvdW50IGZvciBhbGwgbW91bnRlZCB1bmZpbHRlcmVkIEZpYmVycy5cbiAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG4gICAgZm9yIChjb25zdCBkZXZ0b29sc0luc3RhbmNlIG9mIGlkVG9EZXZUb29sc0luc3RhbmNlTWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZS5raW5kID09PSBGSUJFUl9JTlNUQU5DRSkge1xuICAgICAgICBjb25zdCBmaWJlciA9IGRldnRvb2xzSW5zdGFuY2UuZGF0YTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50TG9nc0VudHJ5ID0gZmliZXJUb0NvbXBvbmVudExvZ3NNYXAuZ2V0KGZpYmVyKTtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IHJlY29yZENvbnNvbGVMb2dzKGRldnRvb2xzSW5zdGFuY2UsIGNvbXBvbmVudExvZ3NFbnRyeSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgdXBkYXRlTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudElmTmVjZXNzYXJ5KGRldnRvb2xzSW5zdGFuY2UuaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWaXJ0dWFsIEluc3RhbmNlcyBjYW5ub3QgbG9nIGluIHBhc3NpdmUgZWZmZWN0cyBhbmQgc28gbmV2ZXIgYXBwZWFyIGhlcmUuXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICBmbHVzaFBlbmRpbmdFdmVudHMoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckVycm9yc0FuZFdhcm5pbmdzKCkge1xuICAgIC8vIE5vdGUsIHRoaXMgb25seSBjbGVhcnMgbG9ncyBmb3IgRmliZXJzIHRoYXQgaGF2ZSBpbnN0YW5jZXMuIElmIHRoZXkncmUgZmlsdGVyZWRcbiAgICAvLyBhbmQgdGhlbiBtb3VudCwgdGhlIGxvZ3MgYXJlIHRoZXJlLiBFbnN1cmluZyB3ZSBvbmx5IGNsZWFyIHdoYXQgeW91J3ZlIHNlZW4uXG4gICAgLy8gSWYgd2Ugd2FudGVkIHRvIGNsZWFyIHRoZSB3aG9sZSBzZXQsIHdlJ2QgcmVwbGFjZSBmaWJlclRvQ29tcG9uZW50TG9nc01hcCB3aXRoIGFcbiAgICAvLyBuZXcgV2Vha01hcC4gSXQncyB1bmNsZWFyIHdoZXRoZXIgd2Ugc2hvdWxkIGNsZWFyIGNvbXBvbmVudEluZm9Ub0NvbXBvbmVudExvZ3NNYXBcbiAgICAvLyBzaW5jZSBpdCdzIHNoYXJlZCBieSBvdGhlciByZW5kZXJlcnMgYnV0IHByZXN1bWFibHkgaXQgd291bGQuXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIGZvciAoY29uc3QgZGV2dG9vbHNJbnN0YW5jZSBvZiBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKGRldnRvb2xzSW5zdGFuY2Uua2luZCA9PT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgICAgY29uc3QgZmliZXIgPSBkZXZ0b29sc0luc3RhbmNlLmRhdGE7XG4gICAgICAgIGZpYmVyVG9Db21wb25lbnRMb2dzTWFwLmRlbGV0ZShmaWJlcik7XG4gICAgICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgICAgICBmaWJlclRvQ29tcG9uZW50TG9nc01hcC5kZWxldGUoZmliZXIuYWx0ZXJuYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50SW5mb1RvQ29tcG9uZW50TG9nc01hcC5kZWxldGUoZGV2dG9vbHNJbnN0YW5jZS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZWQgPSByZWNvcmRDb25zb2xlTG9ncyhkZXZ0b29sc0luc3RhbmNlLCB1bmRlZmluZWQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdXBkYXRlTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudElmTmVjZXNzYXJ5KGRldnRvb2xzSW5zdGFuY2UuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaFBlbmRpbmdFdmVudHMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ29uc29sZUxvZ3NIZWxwZXIoaW5zdGFuY2VJRDogbnVtYmVyLCB0eXBlOiAnZXJyb3InIHwgJ3dhcm4nKSB7XG4gICAgY29uc3QgZGV2dG9vbHNJbnN0YW5jZSA9IGlkVG9EZXZUb29sc0luc3RhbmNlTWFwLmdldChpbnN0YW5jZUlEKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgY29tcG9uZW50TG9nc0VudHJ5O1xuICAgICAgaWYgKGRldnRvb2xzSW5zdGFuY2Uua2luZCA9PT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgICAgY29uc3QgZmliZXIgPSBkZXZ0b29sc0luc3RhbmNlLmRhdGE7XG4gICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeSA9IGZpYmVyVG9Db21wb25lbnRMb2dzTWFwLmdldChmaWJlcik7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudExvZ3NFbnRyeSA9PT0gdW5kZWZpbmVkICYmIGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeSA9IGZpYmVyVG9Db21wb25lbnRMb2dzTWFwLmdldChmaWJlci5hbHRlcm5hdGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb21wb25lbnRJbmZvID0gZGV2dG9vbHNJbnN0YW5jZS5kYXRhO1xuICAgICAgICBjb21wb25lbnRMb2dzRW50cnkgPSBjb21wb25lbnRJbmZvVG9Db21wb25lbnRMb2dzTWFwLmdldChjb21wb25lbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wb25lbnRMb2dzRW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeS5lcnJvcnMuY2xlYXIoKTtcbiAgICAgICAgICBjb21wb25lbnRMb2dzRW50cnkuZXJyb3JzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5ncy5jbGVhcigpO1xuICAgICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5nc0NvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VkID0gcmVjb3JkQ29uc29sZUxvZ3MoZGV2dG9vbHNJbnN0YW5jZSwgY29tcG9uZW50TG9nc0VudHJ5KTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMoKTtcbiAgICAgICAgICB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoZGV2dG9vbHNJbnN0YW5jZS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckVycm9yc0ZvckVsZW1lbnRJRChpbnN0YW5jZUlEOiBudW1iZXIpIHtcbiAgICBjbGVhckNvbnNvbGVMb2dzSGVscGVyKGluc3RhbmNlSUQsICdlcnJvcicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJXYXJuaW5nc0ZvckVsZW1lbnRJRChpbnN0YW5jZUlEOiBudW1iZXIpIHtcbiAgICBjbGVhckNvbnNvbGVMb2dzSGVscGVyKGluc3RhbmNlSUQsICd3YXJuJyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoXG4gICAgZmliZXJJRDogbnVtYmVyLFxuICApOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmXG4gICAgICBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LmlkID09PSBmaWJlcklEXG4gICAgKSB7XG4gICAgICBoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50U3RhY2soXG4gICAgdG9wRnJhbWU6IEVycm9yLFxuICApOiBudWxsIHwge2VuYWJsZU93bmVyU3RhY2tzOiBib29sZWFuLCBjb21wb25lbnRTdGFjazogc3RyaW5nfSB7XG4gICAgaWYgKGdldEN1cnJlbnRGaWJlciA9PSBudWxsKSB7XG4gICAgICAvLyBFeHBlY3RlZCB0aGlzIHRvIGJlIHBhcnQgb2YgdGhlIHJlbmRlcmVyLiBJZ25vcmUuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IGdldEN1cnJlbnRGaWJlcigpO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBPdXRzaWRlIG9mIG91ciByZW5kZXIgc2NvcGUuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNDb25zb2xlVGFza3MoY3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBiZSBoYW5kbGVkIG5hdGl2ZWx5IGJ5IGNvbnNvbGUuY3JlYXRlVGFzay4gTm8gbmVlZCBmb3JcbiAgICAgIC8vIERldlRvb2xzIHRvIGFkZCBpdC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoZXJSZWYgPSBnZXREaXNwYXRjaGVyUmVmKHJlbmRlcmVyKTtcbiAgICBpZiAoZGlzcGF0Y2hlclJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBlbmFibGVPd25lclN0YWNrcyA9IHN1cHBvcnRzT3duZXJTdGFja3MoY3VycmVudCk7XG4gICAgbGV0IGNvbXBvbmVudFN0YWNrID0gJyc7XG4gICAgaWYgKGVuYWJsZU93bmVyU3RhY2tzKSB7XG4gICAgICAvLyBQcmVmaXggdGhlIG93bmVyIHN0YWNrIHdpdGggdGhlIGN1cnJlbnQgc3RhY2suIEkuZS4gd2hhdCBjYWxsZWRcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IuIFdoaWxlIHRoaXMgd2lsbCBhbHNvIGJlIHBhcnQgb2YgdGhlIG5hdGl2ZSBzdGFjayxcbiAgICAgIC8vIGl0IGlzIGhpZGRlbiBhbmQgbm90IHByZXNlbnRlZCBhbG9uZ3NpZGUgdGhpcyBhcmd1bWVudCBzbyB3ZSBwcmludFxuICAgICAgLy8gdGhlbSBhbGwgdG9nZXRoZXIuXG4gICAgICBjb25zdCB0b3BTdGFja0ZyYW1lcyA9IGZvcm1hdE93bmVyU3RhY2sodG9wRnJhbWUpO1xuICAgICAgaWYgKHRvcFN0YWNrRnJhbWVzKSB7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrICs9ICdcXG4nICsgdG9wU3RhY2tGcmFtZXM7XG4gICAgICB9XG4gICAgICBjb21wb25lbnRTdGFjayArPSBnZXRPd25lclN0YWNrQnlGaWJlckluRGV2KFxuICAgICAgICBSZWFjdFR5cGVPZldvcmssXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIGRpc3BhdGNoZXJSZWYsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRTdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChcbiAgICAgICAgUmVhY3RUeXBlT2ZXb3JrLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBkaXNwYXRjaGVyUmVmLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtlbmFibGVPd25lclN0YWNrcywgY29tcG9uZW50U3RhY2t9O1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb3Igd2FybmluZyBpcyBsb2dnZWQgZHVyaW5nIHJlbmRlciwgY29tbWl0LCBvciBwYXNzaXZlIChpbmNsdWRpbmcgdW5tb3VudCBmdW5jdGlvbnMpLlxuICBmdW5jdGlvbiBvbkVycm9yT3JXYXJuaW5nKFxuICAgIHR5cGU6ICdlcnJvcicgfCAnd2FybicsXG4gICAgYXJnczogJFJlYWRPbmx5QXJyYXk8YW55PixcbiAgKTogdm9pZCB7XG4gICAgaWYgKGdldEN1cnJlbnRGaWJlciA9PSBudWxsKSB7XG4gICAgICAvLyBFeHBlY3RlZCB0aGlzIHRvIGJlIHBhcnQgb2YgdGhlIHJlbmRlcmVyLiBJZ25vcmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBPdXRzaWRlIG9mIG91ciByZW5kZXIgc2NvcGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAvLyBpZiB0aGlzIGlzIGFuIGVycm9yIHNpbXVsYXRlZCBieSB1cyB0byB0cmlnZ2VyIGVycm9yIGJvdW5kYXJ5LCBpZ25vcmVcbiAgICAgIGlmIChcbiAgICAgICAgZm9yY2VFcnJvckZvckZpYmVycy5nZXQoZmliZXIpID09PSB0cnVlIHx8XG4gICAgICAgIChmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiZcbiAgICAgICAgICBmb3JjZUVycm9yRm9yRmliZXJzLmdldChmaWJlci5hbHRlcm5hdGUpID09PSB0cnVlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCByZWFsbHkgdXNlIHRoaXMgbWVzc2FnZSBhcyBhIHVuaXF1ZSBrZXksIHNpbmNlIHdlIGNhbid0IGRpc3Rpbmd1aXNoXG4gICAgLy8gZGlmZmVyZW50IG9iamVjdHMgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbi4gV2UgaGF2ZSB0byBkZWxlZ2F0ZSBkaXNwbGF5aW5nIG9mIHRoZSBvYmplY3RzXG4gICAgLy8gdG8gdGhlIGVudmlyb25tZW50LCB0aGUgYnJvd3NlciBjb25zb2xlLCBmb3IgZXhhbXBsZSwgc28gdGhpcyBpcyB3aHkgdGhpcyBzaG91bGQgYmUga2VwdFxuICAgIC8vIGFzIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgaW5zdGVhZCBvZiB0aGUgcGxhaW4gc3RyaW5nLlxuICAgIC8vIFtXYXJuaW5nOiAlbywgey4uLn1dIGFuZCBbV2FybmluZzogJW8sIHsuLi59XSB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgdGhlIHNhbWUgbWVzc2FnZSxcbiAgICAvLyBldmVuIGlmIG9iamVjdHMgYXJlIGRpZmZlcmVudFxuICAgIGNvbnN0IG1lc3NhZ2UgPSBmb3JtYXRDb25zb2xlQXJndW1lbnRzVG9TaW5nbGVTdHJpbmcoLi4uYXJncyk7XG5cbiAgICAvLyBUcmFjayB0aGUgd2FybmluZy9lcnJvciBmb3IgbGF0ZXIuXG4gICAgbGV0IGNvbXBvbmVudExvZ3NFbnRyeSA9IGZpYmVyVG9Db21wb25lbnRMb2dzTWFwLmdldChmaWJlcik7XG4gICAgaWYgKGNvbXBvbmVudExvZ3NFbnRyeSA9PT0gdW5kZWZpbmVkICYmIGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50TG9nc0VudHJ5ID0gZmliZXJUb0NvbXBvbmVudExvZ3NNYXAuZ2V0KGZpYmVyLmFsdGVybmF0ZSk7XG4gICAgICBpZiAoY29tcG9uZW50TG9nc0VudHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBzYW1lIHNldCBmb3IgYm90aCBGaWJlcnMuXG4gICAgICAgIGZpYmVyVG9Db21wb25lbnRMb2dzTWFwLnNldChmaWJlciwgY29tcG9uZW50TG9nc0VudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudExvZ3NFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb21wb25lbnRMb2dzRW50cnkgPSB7XG4gICAgICAgIGVycm9yczogbmV3IE1hcCgpLFxuICAgICAgICBlcnJvcnNDb3VudDogMCxcbiAgICAgICAgd2FybmluZ3M6IG5ldyBNYXAoKSxcbiAgICAgICAgd2FybmluZ3NDb3VudDogMCxcbiAgICAgIH07XG4gICAgICBmaWJlclRvQ29tcG9uZW50TG9nc01hcC5zZXQoZmliZXIsIGNvbXBvbmVudExvZ3NFbnRyeSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZU1hcCA9XG4gICAgICB0eXBlID09PSAnZXJyb3InXG4gICAgICAgID8gY29tcG9uZW50TG9nc0VudHJ5LmVycm9yc1xuICAgICAgICA6IGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5ncztcbiAgICBjb25zdCBjb3VudCA9IG1lc3NhZ2VNYXAuZ2V0KG1lc3NhZ2UpIHx8IDA7XG4gICAgbWVzc2FnZU1hcC5zZXQobWVzc2FnZSwgY291bnQgKyAxKTtcbiAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgY29tcG9uZW50TG9nc0VudHJ5LmVycm9yc0NvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5nc0NvdW50Kys7XG4gICAgfVxuXG4gICAgLy8gVGhlIGNoYW5nZXMgd2lsbCBiZSBmbHVzaGVkIGxhdGVyIHdoZW4gd2UgY29tbWl0LlxuXG4gICAgLy8gSWYgdGhlIGxvZyBoYXBwZW5lZCBpbiBhIHBhc3NpdmUgZWZmZWN0LCB0aGVuIHRoaXMgaGFwcGVucyBhZnRlciB3ZSd2ZVxuICAgIC8vIGFscmVhZHkgY29tbWl0dGVkIHRoZSBuZXcgdHJlZSBzbyB0aGUgY2hhbmdlIHdvbid0IHNob3cgdXAgdW50aWwgd2UgcmVyZW5kZXJcbiAgICAvLyB0aGF0IGNvbXBvbmVudCBhZ2Fpbi4gV2UgbmVlZCB0byB2aXNpdCBhIENvbXBvbmVudCB3aXRoIHBhc3NpdmUgZWZmZWN0cyBpblxuICAgIC8vIGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3QgYWdhaW4gdG8gZW5zdXJlIHRoYXQgd2UgZmx1c2ggdGhlIGNoYW5nZXMgYWZ0ZXIgcGFzc2l2ZS5cbiAgICBuZWVkc1RvRmx1c2hDb21wb25lbnRMb2dzID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYnVnKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBpbnN0YW5jZTogRGV2VG9vbHNJbnN0YW5jZSxcbiAgICBwYXJlbnRJbnN0YW5jZTogbnVsbCB8IERldlRvb2xzSW5zdGFuY2UsXG4gICAgZXh0cmFTdHJpbmc6IHN0cmluZyA9ICcnLFxuICApOiB2b2lkIHtcbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBjb25zdCBkaXNwbGF5TmFtZSA9XG4gICAgICAgIGluc3RhbmNlLmtpbmQgPT09IFZJUlRVQUxfSU5TVEFOQ0VcbiAgICAgICAgICA/IGluc3RhbmNlLmRhdGEubmFtZSB8fCAnbnVsbCdcbiAgICAgICAgICA6IGluc3RhbmNlLmRhdGEudGFnICtcbiAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAoZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihpbnN0YW5jZS5kYXRhKSB8fCAnbnVsbCcpO1xuXG4gICAgICBjb25zdCBtYXliZUlEID1cbiAgICAgICAgaW5zdGFuY2Uua2luZCA9PT0gRklMVEVSRURfRklCRVJfSU5TVEFOQ0UgPyAnPG5vIGlkPicgOiBpbnN0YW5jZS5pZDtcblxuICAgICAgY29uc3QgcGFyZW50RGlzcGxheU5hbWUgPVxuICAgICAgICBwYXJlbnRJbnN0YW5jZSA9PT0gbnVsbFxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6IHBhcmVudEluc3RhbmNlLmtpbmQgPT09IFZJUlRVQUxfSU5TVEFOQ0VcbiAgICAgICAgICAgID8gcGFyZW50SW5zdGFuY2UuZGF0YS5uYW1lIHx8ICdudWxsJ1xuICAgICAgICAgICAgOiBwYXJlbnRJbnN0YW5jZS5kYXRhLnRhZyArXG4gICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgIChnZXREaXNwbGF5TmFtZUZvckZpYmVyKHBhcmVudEluc3RhbmNlLmRhdGEpIHx8ICdudWxsJyk7XG5cbiAgICAgIGNvbnN0IG1heWJlUGFyZW50SUQgPVxuICAgICAgICBwYXJlbnRJbnN0YW5jZSA9PT0gbnVsbCB8fFxuICAgICAgICBwYXJlbnRJbnN0YW5jZS5raW5kID09PSBGSUxURVJFRF9GSUJFUl9JTlNUQU5DRVxuICAgICAgICAgID8gJzxubyBpZD4nXG4gICAgICAgICAgOiBwYXJlbnRJbnN0YW5jZS5pZDtcblxuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAgICAgYFtyZW5kZXJlcl0gJWMke25hbWV9ICVjJHtkaXNwbGF5TmFtZX0gKCR7bWF5YmVJRH0pICVjJHtcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZSA/IGAke3BhcmVudERpc3BsYXlOYW1lfSAoJHttYXliZVBhcmVudElEfSlgIDogJydcbiAgICAgICAgfSAlYyR7ZXh0cmFTdHJpbmd9YCxcbiAgICAgICAgJ2NvbG9yOiByZWQ7IGZvbnQtd2VpZ2h0OiBib2xkOycsXG4gICAgICAgICdjb2xvcjogYmx1ZTsnLFxuICAgICAgICAnY29sb3I6IHB1cnBsZTsnLFxuICAgICAgICAnY29sb3I6IGJsYWNrOycsXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2cobmV3IEVycm9yKCkuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpLmpvaW4oJ1xcbicpKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZnVuY3Rpb24gZGVidWdUcmVlKGluc3RhbmNlOiBEZXZUb29sc0luc3RhbmNlLCBpbmRlbnQ6IG51bWJlciA9IDApIHtcbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBjb25zdCBuYW1lID1cbiAgICAgICAgKGluc3RhbmNlLmtpbmQgIT09IFZJUlRVQUxfSU5TVEFOQ0VcbiAgICAgICAgICA/IGdldERpc3BsYXlOYW1lRm9yRmliZXIoaW5zdGFuY2UuZGF0YSlcbiAgICAgICAgICA6IGluc3RhbmNlLmRhdGEubmFtZSkgfHwgJyc7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgJyAgJy5yZXBlYXQoaW5kZW50KSArXG4gICAgICAgICAgJy0gJyArXG4gICAgICAgICAgKGluc3RhbmNlLmtpbmQgPT09IEZJTFRFUkVEX0ZJQkVSX0lOU1RBTkNFID8gMCA6IGluc3RhbmNlLmlkKSArXG4gICAgICAgICAgJyAoJyArXG4gICAgICAgICAgbmFtZSArXG4gICAgICAgICAgJyknLFxuICAgICAgICAncGFyZW50JyxcbiAgICAgICAgaW5zdGFuY2UucGFyZW50ID09PSBudWxsXG4gICAgICAgICAgPyAnICdcbiAgICAgICAgICA6IGluc3RhbmNlLnBhcmVudC5raW5kID09PSBGSUxURVJFRF9GSUJFUl9JTlNUQU5DRVxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IGluc3RhbmNlLnBhcmVudC5pZCxcbiAgICAgICAgJ25leHQnLFxuICAgICAgICBpbnN0YW5jZS5uZXh0U2libGluZyA9PT0gbnVsbCA/ICcgJyA6IGluc3RhbmNlLm5leHRTaWJsaW5nLmlkLFxuICAgICAgKTtcbiAgICAgIGxldCBjaGlsZCA9IGluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZGVidWdUcmVlKGNoaWxkLCBpbmRlbnQgKyAxKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb25maWd1cmFibGUgQ29tcG9uZW50cyB0cmVlIGZpbHRlcnMuXG4gIGNvbnN0IGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXM6IFNldDxSZWdFeHA+ID0gbmV3IFNldCgpO1xuICBjb25zdCBoaWRlRWxlbWVudHNXaXRoUGF0aHM6IFNldDxSZWdFeHA+ID0gbmV3IFNldCgpO1xuICBjb25zdCBoaWRlRWxlbWVudHNXaXRoVHlwZXM6IFNldDxFbGVtZW50VHlwZT4gPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGhpZGVFbGVtZW50c1dpdGhFbnZzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICAvLyBIaWdobGlnaHQgdXBkYXRlc1xuICBsZXQgdHJhY2VVcGRhdGVzRW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBjb25zdCB0cmFjZVVwZGF0ZXNGb3JOb2RlczogU2V0PEhvc3RJbnN0YW5jZT4gPSBuZXcgU2V0KCk7XG5cbiAgZnVuY3Rpb24gYXBwbHlDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4pIHtcbiAgICBoaWRlRWxlbWVudHNXaXRoVHlwZXMuY2xlYXIoKTtcbiAgICBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLmNsZWFyKCk7XG4gICAgaGlkZUVsZW1lbnRzV2l0aFBhdGhzLmNsZWFyKCk7XG4gICAgaGlkZUVsZW1lbnRzV2l0aEVudnMuY2xlYXIoKTtcblxuICAgIGNvbXBvbmVudEZpbHRlcnMuZm9yRWFjaChjb21wb25lbnRGaWx0ZXIgPT4ge1xuICAgICAgaWYgKCFjb21wb25lbnRGaWx0ZXIuaXNFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb21wb25lbnRGaWx0ZXIudHlwZSkge1xuICAgICAgICBjYXNlIENvbXBvbmVudEZpbHRlckRpc3BsYXlOYW1lOlxuICAgICAgICAgIGlmIChjb21wb25lbnRGaWx0ZXIuaXNWYWxpZCAmJiBjb21wb25lbnRGaWx0ZXIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLmFkZChcbiAgICAgICAgICAgICAgbmV3IFJlZ0V4cChjb21wb25lbnRGaWx0ZXIudmFsdWUsICdpJyksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZTpcbiAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoVHlwZXMuYWRkKGNvbXBvbmVudEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29tcG9uZW50RmlsdGVyTG9jYXRpb246XG4gICAgICAgICAgaWYgKGNvbXBvbmVudEZpbHRlci5pc1ZhbGlkICYmIGNvbXBvbmVudEZpbHRlci52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGhpZGVFbGVtZW50c1dpdGhQYXRocy5hZGQobmV3IFJlZ0V4cChjb21wb25lbnRGaWx0ZXIudmFsdWUsICdpJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb21wb25lbnRGaWx0ZXJIT0M6XG4gICAgICAgICAgaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcy5hZGQobmV3IFJlZ0V4cCgnXFxcXCgnKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29tcG9uZW50RmlsdGVyRW52aXJvbm1lbnROYW1lOlxuICAgICAgICAgIGhpZGVFbGVtZW50c1dpdGhFbnZzLmFkZChjb21wb25lbnRGaWx0ZXIudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBJbnZhbGlkIGNvbXBvbmVudCBmaWx0ZXIgdHlwZSBcIiR7Y29tcG9uZW50RmlsdGVyLnR5cGV9XCJgLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBUaGUgcmVuZGVyZXIgaW50ZXJmYWNlIGNhbid0IHJlYWQgc2F2ZWQgY29tcG9uZW50IGZpbHRlcnMgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2UgdGhleSBhcmUgc3RvcmVkIGluIGxvY2FsU3RvcmFnZSB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIGV4dGVuc2lvbi5cbiAgLy8gSW5zdGVhZCBpdCByZWxpZXMgb24gdGhlIGV4dGVuc2lvbiB0byBwYXNzIGZpbHRlcnMgdGhyb3VnaC5cbiAgaWYgKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTVBPTkVOVF9GSUxURVJTX18gIT0gbnVsbCkge1xuICAgIGNvbnN0IGNvbXBvbmVudEZpbHRlcnNXaXRob3V0TG9jYXRpb25CYXNlZE9uZXMgPVxuICAgICAgZmlsdGVyT3V0TG9jYXRpb25Db21wb25lbnRGaWx0ZXJzKFxuICAgICAgICB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19DT01QT05FTlRfRklMVEVSU19fLFxuICAgICAgKTtcbiAgICBhcHBseUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVyc1dpdGhvdXRMb2NhdGlvbkJhc2VkT25lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSB0aGlzIGZlYXR1cmUgaXMgbm90IGV4cGVjdGVkIHRvIHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBmb3Igbm93LlxuICAgIC8vIEl0IHdvdWxkIGJlIGFubm95aW5nIGZvciB1cyB0byBzcGFtIFllbGxvd0JveCB3YXJuaW5ncyB3aXRoIHVuYWN0aW9uYWJsZSBzdHVmZixcbiAgICAvLyBzbyBmb3Igbm93IGp1c3Qgc2tpcCB0aGlzIG1lc3NhZ2UuLi5cbiAgICAvL2NvbnNvbGUud2Fybign4pqbIERldlRvb2xzOiBDb3VsZCBub3QgbG9jYXRlIHNhdmVkIGNvbXBvbmVudCBmaWx0ZXJzJyk7XG5cbiAgICAvLyBGYWxsYmFjayB0byBhc3N1bWluZyB0aGUgZGVmYXVsdCBmaWx0ZXJzIGluIHRoaXMgY2FzZS5cbiAgICBhcHBseUNvbXBvbmVudEZpbHRlcnMoZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMoKSk7XG4gIH1cblxuICAvLyBJZiBuZWNlc3NhcnksIHdlIGNhbiByZXZpc2l0IG9wdGltaXppbmcgdGhpcyBvcGVyYXRpb24uXG4gIC8vIEZvciBleGFtcGxlLCB3ZSBjb3VsZCBhZGQgYSBuZXcgcmVjdXJzaXZlIHVubW91bnQgdHJlZSBvcGVyYXRpb24uXG4gIC8vIFRoZSB1bm1vdW50IG9wZXJhdGlvbnMgYXJlIGFscmVhZHkgc2lnbmlmaWNhbnRseSBzbWFsbGVyIHRoYW4gbW91bnQgb3BlcmF0aW9ucyB0aG91Z2guXG4gIC8vIFRoaXMgaXMgc29tZXRoaW5nIHRvIGtlZXAgaW4gbWluZCBmb3IgbGF0ZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPikge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgLy8gUmUtbW91bnRpbmcgYSB0cmVlIHdoaWxlIHByb2ZpbGluZyBpcyBpbiBwcm9ncmVzcyBtaWdodCBicmVhayBhIGxvdCBvZiBhc3N1bXB0aW9ucy5cbiAgICAgIC8vIElmIG5lY2Vzc2FyeSwgd2UgY291bGQgc3VwcG9ydCB0aGlzLSBidXQgaXQgZG9lc24ndCBzZWVtIGxpa2UgYSBuZWNlc3NhcnkgdXNlIGNhc2UuXG4gICAgICB0aHJvdyBFcnJvcignQ2Fubm90IG1vZGlmeSBmaWx0ZXIgcHJlZmVyZW5jZXMgd2hpbGUgcHJvZmlsaW5nJyk7XG4gICAgfVxuXG4gICAgLy8gUmVjdXJzaXZlbHkgdW5tb3VudCBhbGwgcm9vdHMuXG4gICAgaG9vay5nZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpLmZvckVhY2gocm9vdCA9PiB7XG4gICAgICBjb25zdCByb290SW5zdGFuY2UgPSByb290VG9GaWJlckluc3RhbmNlTWFwLmdldChyb290KTtcbiAgICAgIGlmIChyb290SW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIHRoZSByb290IGluc3RhbmNlIHRvIGFscmVhZHkgZXhpc3Qgd2hlbiBhcHBseWluZyBmaWx0ZXJzJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSb290ID0gcm9vdEluc3RhbmNlO1xuICAgICAgdW5tb3VudEluc3RhbmNlUmVjdXJzaXZlbHkocm9vdEluc3RhbmNlKTtcbiAgICAgIHJvb3RUb0ZpYmVySW5zdGFuY2VNYXAuZGVsZXRlKHJvb3QpO1xuICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3QpO1xuICAgICAgY3VycmVudFJvb3QgPSAobnVsbDogYW55KTtcbiAgICB9KTtcblxuICAgIGFwcGx5Q29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKTtcblxuICAgIC8vIFJlc2V0IHBzZXVkbyBjb3VudGVycyBzbyB0aGF0IG5ldyBwYXRoIHNlbGVjdGlvbnMgd2lsbCBiZSBwZXJzaXN0ZWQuXG4gICAgcm9vdERpc3BsYXlOYW1lQ291bnRlci5jbGVhcigpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgcmUtbW91bnQgYWxsIHJvb3RzIHdpdGggbmV3IGZpbHRlciBjcml0ZXJpYSBhcHBsaWVkLlxuICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKHJvb3QgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgICAgIGNvbnN0IG5ld1Jvb3QgPSBjcmVhdGVGaWJlckluc3RhbmNlKGN1cnJlbnQpO1xuICAgICAgcm9vdFRvRmliZXJJbnN0YW5jZU1hcC5zZXQocm9vdCwgbmV3Um9vdCk7XG4gICAgICBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC5zZXQobmV3Um9vdC5pZCwgbmV3Um9vdCk7XG5cbiAgICAgIC8vIEJlZm9yZSB0aGUgdHJhdmVyc2FscywgcmVtZW1iZXIgdG8gc3RhcnQgdHJhY2tpbmdcbiAgICAgIC8vIG91ciBwYXRoIGluIGNhc2Ugd2UgaGF2ZSBzZWxlY3Rpb24gdG8gcmVzdG9yZS5cbiAgICAgIGlmICh0cmFja2VkUGF0aCAhPT0gbnVsbCkge1xuICAgICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRSb290ID0gbmV3Um9vdDtcbiAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3QuaWQsIHJvb3QuY3VycmVudCk7XG4gICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCBmYWxzZSk7XG4gICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG4gICAgICBjdXJyZW50Um9vdCA9IChudWxsOiBhbnkpO1xuICAgIH0pO1xuXG4gICAgZmx1c2hQZW5kaW5nRXZlbnRzKCk7XG5cbiAgICBuZWVkc1RvRmx1c2hDb21wb25lbnRMb2dzID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudE5hbWVzKCk6IEFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGtub3duRW52aXJvbm1lbnROYW1lcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRGaWx0ZXJWaXJ0dWFsKFxuICAgIGRhdGE6IFJlYWN0Q29tcG9uZW50SW5mbyxcbiAgICBzZWNvbmRhcnlFbnY6IG51bGwgfCBzdHJpbmcsXG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIEZvciBwdXJwb3NlcyBvZiBmaWx0ZXJpbmcgU2VydmVyIENvbXBvbmVudHMgYXJlIGFsd2F5cyBGdW5jdGlvbiBDb21wb25lbnRzLlxuICAgIC8vIEVudmlyb25tZW50IHdpbGwgYmUgdXNlZCB0byBmaWx0ZXIgU2VydmVyIHZzIENsaWVudC5cbiAgICAvLyBUZWNobmljYWxseSB0aGV5IGNhbiBiZSBmb3J3YXJkUmVmIGFuZCBtZW1vIHRvbyBidXQgdGhvc2UgZmlsdGVycyB3aWxsIGdvIGF3YXlcbiAgICAvLyBhcyB0aG9zZSBiZWNvbWUganVzdCBwbGFpbiB1c2VyIHNwYWNlIGZ1bmN0aW9uIGNvbXBvbmVudHMgbGlrZSBhbnkgSG9DLlxuICAgIGlmIChoaWRlRWxlbWVudHNXaXRoVHlwZXMuaGFzKEVsZW1lbnRUeXBlRnVuY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcy5zaXplID4gMCkge1xuICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICBpZiAoZGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgICAgICBmb3IgKGNvbnN0IGRpc3BsYXlOYW1lUmVnRXhwIG9mIGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMpIHtcbiAgICAgICAgICBpZiAoZGlzcGxheU5hbWVSZWdFeHAudGVzdChkaXNwbGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIChkYXRhLmVudiA9PSBudWxsIHx8IGhpZGVFbGVtZW50c1dpdGhFbnZzLmhhcyhkYXRhLmVudikpICYmXG4gICAgICAoc2Vjb25kYXJ5RW52ID09PSBudWxsIHx8IGhpZGVFbGVtZW50c1dpdGhFbnZzLmhhcyhzZWNvbmRhcnlFbnYpKVxuICAgICkge1xuICAgICAgLy8gSWYgYSBDb21wb25lbnQgaGFzIHR3byBlbnZpcm9ubWVudHMsIHlvdSBoYXZlIHRvIGZpbHRlciBib3RoIGZvciBpdCBub3QgdG8gYXBwZWFyLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTk9USUNFIEtlZXAgaW4gc3luYyB3aXRoIGdldCpGb3JGaWJlciBtZXRob2RzXG4gIGZ1bmN0aW9uIHNob3VsZEZpbHRlckZpYmVyKGZpYmVyOiBGaWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHt0YWcsIHR5cGUsIGtleX0gPSBmaWJlcjtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgLy8gVE9ETzogaWRlYWxseSB3ZSB3b3VsZCBzaG93IGRlaHlkcmF0ZWQgU3VzcGVuc2UgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGl0IGhhcyBzb21lIHNwZWNpYWwgYmVoYXZpb3IgKGxpa2UgZGlzY29ubmVjdGluZ1xuICAgICAgICAvLyBhbiBhbHRlcm5hdGUgYW5kIHR1cm5pbmcgaW50byByZWFsIFN1c3BlbnNlKSB3aGljaCBicmVha3MgRGV2VG9vbHMuXG4gICAgICAgIC8vIEZvciBub3csIGlnbm9yZSBpdCwgYW5kIG9ubHkgc2hvdyBpdCBvbmNlIGl0IGdldHMgaHlkcmF0ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9idmF1Z2huL3JlYWN0LWRldnRvb2xzLWV4cGVyaW1lbnRhbC9pc3N1ZXMvMTk3XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICBjYXNlIFRocm93OlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIC8vIEl0IGlzIG5ldmVyIHZhbGlkIHRvIGZpbHRlciB0aGUgcm9vdCBlbGVtZW50LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4ga2V5ID09PSBudWxsO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc3QgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICAgICAgY2FzZSBDT05DVVJSRU5UX01PREVfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgY2FzZSBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICBjYXNlIFNUUklDVF9NT0RFX05VTUJFUjpcbiAgICAgICAgICBjYXNlIFNUUklDVF9NT0RFX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpO1xuICAgIGlmIChoaWRlRWxlbWVudHNXaXRoVHlwZXMuaGFzKGVsZW1lbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcik7XG4gICAgICBpZiAoZGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgICAgICBmb3IgKGNvbnN0IGRpc3BsYXlOYW1lUmVnRXhwIG9mIGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMpIHtcbiAgICAgICAgICBpZiAoZGlzcGxheU5hbWVSZWdFeHAudGVzdChkaXNwbGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoaWRlRWxlbWVudHNXaXRoRW52cy5oYXMoJ0NsaWVudCcpKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBmaWx0ZXJpbmcgb3V0IHRoZSBDbGllbnQgZW52aXJvbm1lbnQgd2Ugc2hvdWxkIGZpbHRlciBvdXQgYWxsXG4gICAgICAvLyBcIkNsaWVudCBDb21wb25lbnRzXCIuIFRlY2huaWNhbGx5IHRoYXQgYWxzbyBpbmNsdWRlcyB0aGUgYnVpbHQtaW5zIGJ1dFxuICAgICAgLy8gc2luY2UgdGhhdCBkb2Vzbid0IGFjdHVhbGx5IGluY2x1ZGUgYW55IGFkZGl0aW9uYWwgY29kZSBsb2FkaW5nIGl0J3NcbiAgICAgIC8vIHVzZWZ1bCB0byBub3QgZmlsdGVyIG91dCB0aGUgYnVpbHQtaW5zLiBUaG9zZSBjYW4gYmUgZmlsdGVyZWQgc2VwYXJhdGVseS5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gb3RoZXIgd2F5IHRvIGZpbHRlciBvdXQganVzdCBGdW5jdGlvbiBjb21wb25lbnRzIG9uIHRoZSBDbGllbnQuXG4gICAgICAvLyBUaGVyZWZvcmUsIHRoaXMgb25seSBmaWx0ZXJzIENsYXNzIGFuZCBGdW5jdGlvbiBjb21wb25lbnRzLlxuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogRElTQUJMRUQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI4NDE3XG4gICAgaWYgKGhpZGVFbGVtZW50c1dpdGhQYXRocy5zaXplID4gMCkge1xuICAgICAgY29uc3Qgc291cmNlID0gZ2V0U291cmNlRm9yRmliZXIoZmliZXIpO1xuXG4gICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qge2ZpbGVOYW1lfSA9IHNvdXJjZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICAgICAgZm9yIChjb25zdCBwYXRoUmVnRXhwIG9mIGhpZGVFbGVtZW50c1dpdGhQYXRocykge1xuICAgICAgICAgIGlmIChwYXRoUmVnRXhwLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE5PVElDRSBLZWVwIGluIHN5bmMgd2l0aCBzaG91bGRGaWx0ZXJGaWJlcigpIGFuZCBvdGhlciBnZXQqRm9yRmliZXIgbWV0aG9kc1xuICBmdW5jdGlvbiBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyOiBGaWJlcik6IEVsZW1lbnRUeXBlIHtcbiAgICBjb25zdCB7dHlwZSwgdGFnfSA9IGZpYmVyO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlQ2xhc3M7XG4gICAgICBjYXNlIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZUZ1bmN0aW9uO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVGb3J3YXJkUmVmO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlUm9vdDtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bjtcbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlTWVtbztcbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZVN1c3BlbnNlO1xuICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZVN1c3BlbnNlTGlzdDtcbiAgICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlVHJhY2luZ01hcmtlcjtcbiAgICAgIGNhc2UgVmlld1RyYW5zaXRpb25Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZVZpZXdUcmFuc2l0aW9uO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc3QgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICAgICAgY2FzZSBDT05DVVJSRU5UX01PREVfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgY2FzZSBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duO1xuICAgICAgICAgIGNhc2UgUFJPVklERVJfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgUFJPVklERVJfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50VHlwZUNvbnRleHQ7XG4gICAgICAgICAgY2FzZSBDT05URVhUX05VTUJFUjpcbiAgICAgICAgICBjYXNlIENPTlRFWFRfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50VHlwZUNvbnRleHQ7XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd247XG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlUHJvZmlsZXI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2hlbiBhIG1vdW50IG9yIHVwZGF0ZSBpcyBpbiBwcm9ncmVzcywgdGhpcyB2YWx1ZSB0cmFja3MgdGhlIHJvb3QgdGhhdCBpcyBiZWluZyBvcGVyYXRlZCBvbi5cbiAgbGV0IGN1cnJlbnRSb290OiBGaWJlckluc3RhbmNlID0gKG51bGw6IGFueSk7XG5cbiAgLy8gUmVtb3ZlcyBhIEZpYmVyIChhbmQgaXRzIGFsdGVybmF0ZSkgZnJvbSB0aGUgTWFwcyB1c2VkIHRvIHRyYWNrIHRoZWlyIGlkLlxuICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCB3aGVuIGEgRmliZXIgaXMgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gdW50cmFja0ZpYmVyKG5lYXJlc3RJbnN0YW5jZTogRGV2VG9vbHNJbnN0YW5jZSwgZmliZXI6IEZpYmVyKSB7XG4gICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGZvcmNlRXJyb3JGb3JGaWJlcnMuZGVsZXRlKGZpYmVyKTtcbiAgICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgICAgZm9yY2VFcnJvckZvckZpYmVycy5kZWxldGUoZmliZXIuYWx0ZXJuYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJzLnNpemUgPT09IDAgJiYgc2V0RXJyb3JIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0RXJyb3JIYW5kbGVyKHNob3VsZEVycm9yRmliZXJBbHdheXNOdWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm9yY2VGYWxsYmFja0ZvckZpYmVycy5zaXplID4gMCkge1xuICAgICAgZm9yY2VGYWxsYmFja0ZvckZpYmVycy5kZWxldGUoZmliZXIpO1xuICAgICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgICBmb3JjZUZhbGxiYWNrRm9yRmliZXJzLmRlbGV0ZShmaWJlci5hbHRlcm5hdGUpO1xuICAgICAgfVxuICAgICAgaWYgKGZvcmNlRmFsbGJhY2tGb3JGaWJlcnMuc2l6ZSA9PT0gMCAmJiBzZXRTdXNwZW5zZUhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRTdXNwZW5zZUhhbmRsZXIoc2hvdWxkU3VzcGVuZEZpYmVyQWx3YXlzRmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVzaW5nIGEgV2Vha01hcCBpbnN0ZWFkLiBUaGUgb25seSB0aGluZyB3aGVyZSB0aGF0IGRvZXNuJ3Qgd29ya1xuICAgIC8vIGlzIFJlYWN0IE5hdGl2ZSBQYXBlciB3aGljaCB0cmFja3MgdGFncyBidXQgdGhhdCBzdXBwb3J0IGlzIGV2ZW50dWFsbHkgZ29pbmcgYXdheVxuICAgIC8vIGFuZCBjYW4gdXNlIHRoZSBvbGQgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2Ugc3RyYXRlZ3kuXG5cbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0SG9pc3RhYmxlKSB7XG4gICAgICByZWxlYXNlSG9zdFJlc291cmNlKG5lYXJlc3RJbnN0YW5jZSwgZmliZXIubWVtb2l6ZWRTdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fFxuICAgICAgZmliZXIudGFnID09PSBIb3N0VGV4dCB8fFxuICAgICAgZmliZXIudGFnID09PSBIb3N0U2luZ2xldG9uXG4gICAgKSB7XG4gICAgICByZWxlYXNlSG9zdEluc3RhbmNlKG5lYXJlc3RJbnN0YW5jZSwgZmliZXIuc3RhdGVOb2RlKTtcbiAgICB9XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjbGVhbiB1cCBhbnkgZmlsdGVyZWQgRmliZXJzIGJlbG93IHRoaXMgb25lIGFzIHdlbGwgc2luY2VcbiAgICAvLyB3ZSB3b24ndCByZWNvcmRVbm1vdW50IG9uIHRob3NlLlxuICAgIGZvciAobGV0IGNoaWxkID0gZmliZXIuY2hpbGQ7IGNoaWxkICE9PSBudWxsOyBjaGlsZCA9IGNoaWxkLnNpYmxpbmcpIHtcbiAgICAgIGlmIChzaG91bGRGaWx0ZXJGaWJlcihjaGlsZCkpIHtcbiAgICAgICAgdW50cmFja0ZpYmVyKG5lYXJlc3RJbnN0YW5jZSwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoYW5nZURlc2NyaXB0aW9uKFxuICAgIHByZXZGaWJlcjogRmliZXIgfCBudWxsLFxuICAgIG5leHRGaWJlcjogRmliZXIsXG4gICk6IENoYW5nZURlc2NyaXB0aW9uIHwgbnVsbCB7XG4gICAgc3dpdGNoIChuZXh0RmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBpZiAocHJldkZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICBkaWRIb29rc0NoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBpc0ZpcnN0TW91bnQ6IHRydWUsXG4gICAgICAgICAgICBwcm9wczogbnVsbCxcbiAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGF0YTogQ2hhbmdlRGVzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBnZXRDb250ZXh0Q2hhbmdlZChwcmV2RmliZXIsIG5leHRGaWJlciksXG4gICAgICAgICAgICBkaWRIb29rc0NoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBpc0ZpcnN0TW91bnQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvcHM6IGdldENoYW5nZWRLZXlzKFxuICAgICAgICAgICAgICBwcmV2RmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgbmV4dEZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgc3RhdGU6IGdldENoYW5nZWRLZXlzKFxuICAgICAgICAgICAgICBwcmV2RmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dEZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgaWYgKHByZXZGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgZGlkSG9va3NDaGFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgaXNGaXJzdE1vdW50OiB0cnVlLFxuICAgICAgICAgICAgcHJvcHM6IG51bGwsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZXRDaGFuZ2VkSG9va3NJbmRpY2VzKFxuICAgICAgICAgICAgcHJldkZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGRhdGE6IENoYW5nZURlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgY29udGV4dDogZ2V0Q29udGV4dENoYW5nZWQocHJldkZpYmVyLCBuZXh0RmliZXIpLFxuICAgICAgICAgICAgZGlkSG9va3NDaGFuZ2U6IGluZGljZXMgIT09IG51bGwgJiYgaW5kaWNlcy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgaXNGaXJzdE1vdW50OiBmYWxzZSxcbiAgICAgICAgICAgIHByb3BzOiBnZXRDaGFuZ2VkS2V5cyhcbiAgICAgICAgICAgICAgcHJldkZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIG5leHRGaWJlci5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgICAgaG9va3M6IGluZGljZXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBPbmx5IHRyYXZlcnNlIHRoZSBob29rcyBsaXN0IG9uY2UsIGRlcGVuZGluZyBvbiB3aGF0IGluZm8gd2UncmUgcmV0dXJuaW5nLlxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0Q2hhbmdlZChwcmV2RmliZXI6IEZpYmVyLCBuZXh0RmliZXI6IEZpYmVyKTogYm9vbGVhbiB7XG4gICAgbGV0IHByZXZDb250ZXh0ID1cbiAgICAgIHByZXZGaWJlci5kZXBlbmRlbmNpZXMgJiYgcHJldkZpYmVyLmRlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG4gICAgbGV0IG5leHRDb250ZXh0ID1cbiAgICAgIG5leHRGaWJlci5kZXBlbmRlbmNpZXMgJiYgbmV4dEZpYmVyLmRlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG5cbiAgICB3aGlsZSAocHJldkNvbnRleHQgJiYgbmV4dENvbnRleHQpIHtcbiAgICAgIC8vIE5vdGUgdGhpcyBvbmx5IHdvcmtzIGZvciB2ZXJzaW9ucyBvZiBSZWFjdCB0aGF0IHN1cHBvcnQgdGhpcyBrZXkgKGUudi4gMTgrKVxuICAgICAgLy8gRm9yIG9sZGVyIHZlcnNpb25zLCB0aGVyZSdzIG5vIGdvb2Qgd2F5IHRvIHJlYWQgdGhlIGN1cnJlbnQgY29udGV4dCB2YWx1ZSBhZnRlciByZW5kZXIgaGFzIGNvbXBsZXRlZC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBSZWFjdCBtYWludGFpbnMgYSBzdGFjayBvZiBjb250ZXh0IHZhbHVlcyBkdXJpbmcgcmVuZGVyLFxuICAgICAgLy8gYnV0IGJ5IHRoZSB0aW1lIERldlRvb2xzIGlzIGNhbGxlZCwgcmVuZGVyIGhhcyBmaW5pc2hlZCBhbmQgdGhlIHN0YWNrIGlzIGVtcHR5LlxuICAgICAgaWYgKHByZXZDb250ZXh0LmNvbnRleHQgIT09IG5leHRDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIG9yZGVyIG9mIGNvbnRleHQgaGFzIGNoYW5nZWQsIHRoZW4gdGhlIGxhdGVyIGNvbnRleHQgdmFsdWVzIG1pZ2h0IGhhdmVcbiAgICAgICAgLy8gY2hhbmdlZCB0b28gYnV0IHRoZSBtYWluIHJlYXNvbiBpdCByZXJlbmRlcmVkIHdhcyBlYXJsaWVyLiBFaXRoZXIgYW4gZWFybGllclxuICAgICAgICAvLyBjb250ZXh0IGNoYW5nZWQgdmFsdWUgYnV0IHRoZW4gd2Ugd291bGQgaGF2ZSBleGl0ZWQgYWxyZWFkeS4gSWYgd2UgZW5kIHVwIGhlcmVcbiAgICAgICAgLy8gaXQncyBiZWNhdXNlIGEgc3RhdGUgb3IgcHJvcHMgY2hhbmdlIGNhdXNlZCB0aGUgb3JkZXIgb2YgY29udGV4dHMgdXNlZCB0byBjaGFuZ2UuXG4gICAgICAgIC8vIFNvIHRoZSBtYWluIGNhdXNlIGlzIG5vdCB0aGUgY29udGV4dHMgdGhlbXNlbHZlcy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFpcyhwcmV2Q29udGV4dC5tZW1vaXplZFZhbHVlLCBuZXh0Q29udGV4dC5tZW1vaXplZFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcHJldkNvbnRleHQgPSBwcmV2Q29udGV4dC5uZXh0O1xuICAgICAgbmV4dENvbnRleHQgPSBuZXh0Q29udGV4dC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvb2tUaGF0Q2FuU2NoZWR1bGVVcGRhdGUoaG9va09iamVjdDogYW55KSB7XG4gICAgY29uc3QgcXVldWUgPSBob29rT2JqZWN0LnF1ZXVlO1xuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBib3VuZEhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHkuYmluZChxdWV1ZSk7XG5cbiAgICAvLyBEZXRlY3QgdGhlIHNoYXBlIG9mIHVzZVN0YXRlKCkgLyB1c2VSZWR1Y2VyKCkgLyB1c2VUcmFuc2l0aW9uKClcbiAgICAvLyB1c2luZyB0aGUgYXR0cmlidXRlcyB0aGF0IGFyZSB1bmlxdWUgdG8gdGhlc2UgaG9va3NcbiAgICAvLyBidXQgYWxzbyBzdGFibGUgKGUuZy4gbm90IHRpZWQgdG8gY3VycmVudCBMYW5lcyBpbXBsZW1lbnRhdGlvbilcbiAgICAvLyBXZSBkb24ndCBjaGVjayBmb3IgZGlzcGF0Y2ggcHJvcGVydHksIGJlY2F1c2UgdXNlVHJhbnNpdGlvbiBkb2Vzbid0IGhhdmUgaXRcbiAgICBpZiAoYm91bmRIYXNPd25Qcm9wZXJ0eSgncGVuZGluZycpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgdXNlU3luY0V4dGVybmFsU3RvcmUoKVxuICAgIHJldHVybiAoXG4gICAgICBib3VuZEhhc093blByb3BlcnR5KCd2YWx1ZScpICYmXG4gICAgICBib3VuZEhhc093blByb3BlcnR5KCdnZXRTbmFwc2hvdCcpICYmXG4gICAgICB0eXBlb2YgcXVldWUuZ2V0U25hcHNob3QgPT09ICdmdW5jdGlvbidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlkU3RhdGVmdWxIb29rQ2hhbmdlKHByZXY6IGFueSwgbmV4dDogYW55KTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJldk1lbW9pemVkU3RhdGUgPSBwcmV2Lm1lbW9pemVkU3RhdGU7XG4gICAgY29uc3QgbmV4dE1lbW9pemVkU3RhdGUgPSBuZXh0Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoaXNIb29rVGhhdENhblNjaGVkdWxlVXBkYXRlKHByZXYpKSB7XG4gICAgICByZXR1cm4gcHJldk1lbW9pemVkU3RhdGUgIT09IG5leHRNZW1vaXplZFN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoYW5nZWRIb29rc0luZGljZXMocHJldjogYW55LCBuZXh0OiBhbnkpOiBudWxsIHwgQXJyYXk8bnVtYmVyPiB7XG4gICAgaWYgKHByZXYgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoZGlkU3RhdGVmdWxIb29rQ2hhbmdlKHByZXYsIG5leHQpKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgICAgcHJldiA9IHByZXYubmV4dDtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDaGFuZ2VkS2V5cyhwcmV2OiBhbnksIG5leHQ6IGFueSk6IG51bGwgfCBBcnJheTxzdHJpbmc+IHtcbiAgICBpZiAocHJldiA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKHByZXYpLCAuLi5PYmplY3Qua2V5cyhuZXh0KV0pO1xuICAgIGNvbnN0IGNoYW5nZWRLZXlzID0gW107XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAocHJldltrZXldICE9PSBuZXh0W2tleV0pIHtcbiAgICAgICAgY2hhbmdlZEtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlcjogRmliZXIsIG5leHRGaWJlcjogRmliZXIpOiBib29sZWFuIHtcbiAgICBzd2l0Y2ggKG5leHRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIC8vIEZvciB0eXBlcyB0aGF0IGV4ZWN1dGUgdXNlciBjb2RlLCB3ZSBjaGVjayBQZXJmb3JtZWRXb3JrIGVmZmVjdC5cbiAgICAgICAgLy8gV2UgZG9uJ3QgcmVmbGVjdCBiYWlsb3V0cyAoZWl0aGVyIHJlZmVyZW50aWFsIG9yIHNDVSkgaW4gRGV2VG9vbHMuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgZmxhZyBpcyBhIGxlYWtlZCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIE9uY2Ugd2Ugc3RhcnRcbiAgICAgICAgLy8gcmVsZWFzaW5nIERldlRvb2xzIGluIGxvY2tzdGVwIHdpdGggUmVhY3QsIHdlIHNob3VsZCBpbXBvcnQgYVxuICAgICAgICAvLyBmdW5jdGlvbiBmcm9tIHRoZSByZWNvbmNpbGVyIGluc3RlYWQuXG4gICAgICAgIGNvbnN0IFBlcmZvcm1lZFdvcmsgPSAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTtcbiAgICAgICAgcmV0dXJuIChnZXRGaWJlckZsYWdzKG5leHRGaWJlcikgJiBQZXJmb3JtZWRXb3JrKSA9PT0gUGVyZm9ybWVkV29yaztcbiAgICAgIC8vIE5vdGU6IENvbnRleHRDb25zdW1lciBvbmx5IGdldHMgUGVyZm9ybWVkV29yayBlZmZlY3QgaW4gMTYuMy4zK1xuICAgICAgLy8gc28gaXQgd29uJ3QgZ2V0IGhpZ2hsaWdodGVkIHdpdGggUmVhY3QgMTYuMy4wIHRvIDE2LjMuMi5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZvciBob3N0IGNvbXBvbmVudHMgYW5kIG90aGVyIHR5cGVzLCB3ZSBjb21wYXJlIGlucHV0c1xuICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBzb21ldGhpbmcgaXMgYW4gdXBkYXRlLlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHByZXZGaWJlci5tZW1vaXplZFByb3BzICE9PSBuZXh0RmliZXIubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgIHByZXZGaWJlci5tZW1vaXplZFN0YXRlICE9PSBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSB8fFxuICAgICAgICAgIHByZXZGaWJlci5yZWYgIT09IG5leHRGaWJlci5yZWZcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB0eXBlIE9wZXJhdGlvbnNBcnJheSA9IEFycmF5PG51bWJlcj47XG5cbiAgdHlwZSBTdHJpbmdUYWJsZUVudHJ5ID0ge1xuICAgIGVuY29kZWRTdHJpbmc6IEFycmF5PG51bWJlcj4sXG4gICAgaWQ6IG51bWJlcixcbiAgfTtcblxuICBjb25zdCBwZW5kaW5nT3BlcmF0aW9uczogT3BlcmF0aW9uc0FycmF5ID0gW107XG4gIGNvbnN0IHBlbmRpbmdSZWFsVW5tb3VudGVkSURzOiBBcnJheTxudW1iZXI+ID0gW107XG4gIGxldCBwZW5kaW5nT3BlcmF0aW9uc1F1ZXVlOiBBcnJheTxPcGVyYXRpb25zQXJyYXk+IHwgbnVsbCA9IFtdO1xuICBjb25zdCBwZW5kaW5nU3RyaW5nVGFibGU6IE1hcDxzdHJpbmcsIFN0cmluZ1RhYmxlRW50cnk+ID0gbmV3IE1hcCgpO1xuICBsZXQgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoOiBudW1iZXIgPSAwO1xuICBsZXQgcGVuZGluZ1VubW91bnRlZFJvb3RJRDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihvcCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAncHVzaE9wZXJhdGlvbigpIHdhcyBjYWxsZWQgYnV0IHRoZSB2YWx1ZSBpcyBub3QgYW4gaW50ZWdlci4nLFxuICAgICAgICAgIG9wLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJhaWxvdXRXaXRoUGVuZGluZ09wZXJhdGlvbnMoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPSBudWxsICYmXG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YS5kdXJhdGlvbnMubGVuZ3RoID4gMFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID09PSAwICYmXG4gICAgICBwZW5kaW5nUmVhbFVubW91bnRlZElEcy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPT09IG51bGxcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hPclF1ZXVlT3BlcmF0aW9ucyhvcGVyYXRpb25zOiBPcGVyYXRpb25zQXJyYXkpOiB2b2lkIHtcbiAgICBpZiAoc2hvdWxkQmFpbG91dFdpdGhQZW5kaW5nT3BlcmF0aW9ucygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdPcGVyYXRpb25zUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHBlbmRpbmdPcGVyYXRpb25zUXVldWUucHVzaChvcGVyYXRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9vay5lbWl0KCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkQ29uc29sZUxvZ3MoXG4gICAgaW5zdGFuY2U6IEZpYmVySW5zdGFuY2UgfCBWaXJ0dWFsSW5zdGFuY2UsXG4gICAgY29tcG9uZW50TG9nc0VudHJ5OiB2b2lkIHwgQ29tcG9uZW50TG9ncyxcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKGNvbXBvbmVudExvZ3NFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5zdGFuY2UubG9nQ291bnQgPT09IDApIHtcbiAgICAgICAgLy8gTm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gUmVzZXQgdG8gemVyby5cbiAgICAgIGluc3RhbmNlLmxvZ0NvdW50ID0gMDtcbiAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGluc3RhbmNlLmlkKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oMCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKDApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRvdGFsQ291bnQgPVxuICAgICAgICBjb21wb25lbnRMb2dzRW50cnkuZXJyb3JzQ291bnQgKyBjb21wb25lbnRMb2dzRW50cnkud2FybmluZ3NDb3VudDtcbiAgICAgIGlmIChpbnN0YW5jZS5sb2dDb3VudCA9PT0gdG90YWxDb3VudCkge1xuICAgICAgICAvLyBOb3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgY291bnRzLlxuICAgICAgaW5zdGFuY2UubG9nQ291bnQgPSB0b3RhbENvdW50O1xuICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaW5zdGFuY2UuaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihjb21wb25lbnRMb2dzRW50cnkuZXJyb3JzQ291bnQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihjb21wb25lbnRMb2dzRW50cnkud2FybmluZ3NDb3VudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdFdmVudHMocm9vdDogT2JqZWN0KTogdm9pZCB7XG4gICAgaWYgKHNob3VsZEJhaWxvdXRXaXRoUGVuZGluZ09wZXJhdGlvbnMoKSkge1xuICAgICAgLy8gSWYgd2UgYXJlbid0IHByb2ZpbGluZywgd2UgY2FuIGp1c3QgYmFpbCBvdXQgaGVyZS5cbiAgICAgIC8vIE5vIHVzZSBzZW5kaW5nIGFuIGVtcHR5IHVwZGF0ZSBvdmVyIHRoZSBicmlkZ2UuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIFByb2ZpbGVyIHN0b3JlcyBtZXRhZGF0YSBmb3IgZWFjaCBjb21taXQgYW5kIHJlY29uc3RydWN0cyB0aGUgYXBwIHRyZWUgcGVyIGNvbW1pdCB1c2luZzpcbiAgICAgIC8vICgxKSBhbiBpbml0aWFsIHRyZWUgc25hcHNob3QgYW5kXG4gICAgICAvLyAoMikgdGhlIG9wZXJhdGlvbnMgYXJyYXkgZm9yIGVhY2ggY29tbWl0XG4gICAgICAvLyBCZWNhdXNlIG9mIHRoaXMsIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhlIG9wZXJhdGlvbnMgYW5kIG1ldGFkYXRhIGFycmF5cyBhbGlnbixcbiAgICAgIC8vIFNvIGl0J3MgaW1wb3J0YW50IG5vdCB0byBvbWl0IGV2ZW4gZW1wdHkgb3BlcmF0aW9ucyB3aGlsZSBwcm9maWxpbmcgaXMgYWN0aXZlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG51bVVubW91bnRJRHMgPVxuICAgICAgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoICtcbiAgICAgIChwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsID8gMCA6IDEpO1xuXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IG5ldyBBcnJheTxudW1iZXI+KFxuICAgICAgLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgICAyICsgLy8gW3JlbmRlcmVySUQsIHJvb3RGaWJlcklEXVxuICAgICAgICAvLyBIb3cgYmlnIGlzIHRoZSBzdHJpbmcgdGFibGU/XG4gICAgICAgIDEgKyAvLyBbc3RyaW5nVGFibGVMZW5ndGhdXG4gICAgICAgIC8vIFRoZW4gZ29lcyB0aGUgYWN0dWFsIHN0cmluZyB0YWJsZS5cbiAgICAgICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoICtcbiAgICAgICAgLy8gQWxsIHVubW91bnRzIGFyZSBiYXRjaGVkIGluIGEgc2luZ2xlIG1lc3NhZ2UuXG4gICAgICAgIC8vIFtUUkVFX09QRVJBVElPTl9SRU1PVkUsIHJlbW92ZWRJRExlbmd0aCwgLi4uaWRzXVxuICAgICAgICAobnVtVW5tb3VudElEcyA+IDAgPyAyICsgbnVtVW5tb3VudElEcyA6IDApICtcbiAgICAgICAgLy8gUmVndWxhciBvcGVyYXRpb25zXG4gICAgICAgIHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCxcbiAgICApO1xuXG4gICAgLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgLy8gVGhpcyBlbmFibGVzIHJvb3RzIHRvIGJlIG1hcHBlZCB0byByZW5kZXJlcnMsXG4gICAgLy8gV2hpY2ggaW4gdHVybiBlbmFibGVzIGZpYmVyIHByb3BzLCBzdGF0ZXMsIGFuZCBob29rcyB0byBiZSBpbnNwZWN0ZWQuXG4gICAgbGV0IGkgPSAwO1xuICAgIG9wZXJhdGlvbnNbaSsrXSA9IHJlbmRlcmVySUQ7XG4gICAgaWYgKGN1cnJlbnRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBhbHdheXMgc2FmZSBzbyB0aGlzIGZpZWxkIGlzIHByb2JhYmx5IG5vdCBuZWVkZWQuXG4gICAgICBvcGVyYXRpb25zW2krK10gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uc1tpKytdID0gY3VycmVudFJvb3QuaWQ7XG4gICAgfVxuXG4gICAgLy8gTm93IGZpbGwgaW4gdGhlIHN0cmluZyB0YWJsZS5cbiAgICAvLyBbc3RyaW5nVGFibGVMZW5ndGgsIHN0cjFMZW5ndGgsIC4uLnN0cjEsIHN0cjJMZW5ndGgsIC4uLnN0cjIsIC4uLl1cbiAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGg7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmZvckVhY2goKGVudHJ5LCBzdHJpbmdLZXkpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBlbnRyeS5lbmNvZGVkU3RyaW5nO1xuXG4gICAgICAvLyBEb24ndCB1c2UgdGhlIHN0cmluZyBsZW5ndGguXG4gICAgICAvLyBJdCB3b24ndCB3b3JrIGZvciBtdWx0aWJ5dGUgY2hhcmFjdGVycyAobGlrZSBlbW9qaSkuXG4gICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGVkU3RyaW5nLmxlbmd0aDtcblxuICAgICAgb3BlcmF0aW9uc1tpKytdID0gbGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICBvcGVyYXRpb25zW2kgKyBqXSA9IGVuY29kZWRTdHJpbmdbal07XG4gICAgICB9XG5cbiAgICAgIGkgKz0gbGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgaWYgKG51bVVubW91bnRJRHMgPiAwKSB7XG4gICAgICAvLyBBbGwgdW5tb3VudHMgZXhjZXB0IHJvb3RzIGFyZSBiYXRjaGVkIGluIGEgc2luZ2xlIG1lc3NhZ2UuXG4gICAgICBvcGVyYXRpb25zW2krK10gPSBUUkVFX09QRVJBVElPTl9SRU1PVkU7XG4gICAgICAvLyBUaGUgZmlyc3QgbnVtYmVyIGlzIGhvdyBtYW55IHVubW91bnRlZCBJRHMgd2UncmUgZ29ubmEgc2VuZC5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IG51bVVubW91bnRJRHM7XG4gICAgICAvLyBGaWxsIGluIHRoZSByZWFsIHVubW91bnRzIGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgICAgLy8gVGhleSB3ZXJlIGluc2VydGVkIHBhcmVudHMtZmlyc3QgYnkgUmVhY3QsIGJ1dCB3ZSB3YW50IGNoaWxkcmVuLWZpcnN0LlxuICAgICAgLy8gU28gd2UgdHJhdmVyc2Ugb3VyIGFycmF5IGJhY2t3YXJkcy5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHNbal07XG4gICAgICB9XG4gICAgICAvLyBUaGUgcm9vdCBJRCBzaG91bGQgYWx3YXlzIGJlIHVubW91bnRlZCBsYXN0LlxuICAgICAgaWYgKHBlbmRpbmdVbm1vdW50ZWRSb290SUQgIT09IG51bGwpIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpXSA9IHBlbmRpbmdVbm1vdW50ZWRSb290SUQ7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgb3BlcmF0aW9ucy5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICBvcGVyYXRpb25zW2kgKyBqXSA9IHBlbmRpbmdPcGVyYXRpb25zW2pdO1xuICAgIH1cbiAgICBpICs9IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDtcblxuICAgIC8vIExldCB0aGUgZnJvbnRlbmQga25vdyBhYm91dCB0cmVlIG9wZXJhdGlvbnMuXG4gICAgZmx1c2hPclF1ZXVlT3BlcmF0aW9ucyhvcGVyYXRpb25zKTtcblxuICAgIC8vIFJlc2V0IGFsbCBvZiB0aGUgcGVuZGluZyBzdGF0ZSBub3cgdGhhdCB3ZSd2ZSB0b2xkIHRoZSBmcm9udGVuZCBhYm91dCBpdC5cbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gICAgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9IG51bGw7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmNsZWFyKCk7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0cmluZ0lEKHN0cmluZzogc3RyaW5nIHwgbnVsbCk6IG51bWJlciB7XG4gICAgaWYgKHN0cmluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSBwZW5kaW5nU3RyaW5nVGFibGUuZ2V0KHN0cmluZyk7XG4gICAgaWYgKGV4aXN0aW5nRW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnkuaWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBwZW5kaW5nU3RyaW5nVGFibGUuc2l6ZSArIDE7XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHV0ZkVuY29kZVN0cmluZyhzdHJpbmcpO1xuXG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLnNldChzdHJpbmcsIHtcbiAgICAgIGVuY29kZWRTdHJpbmcsXG4gICAgICBpZCxcbiAgICB9KTtcblxuICAgIC8vIFRoZSBzdHJpbmcgdGFibGUgdG90YWwgbGVuZ3RoIG5lZWRzIHRvIGFjY291bnQgYm90aCBmb3IgdGhlIHN0cmluZyBsZW5ndGgsXG4gICAgLy8gYW5kIGZvciB0aGUgYXJyYXkgaXRlbSB0aGF0IGNvbnRhaW5zIHRoZSBsZW5ndGggaXRzZWxmLlxuICAgIC8vXG4gICAgLy8gRG9uJ3QgdXNlIHN0cmluZyBsZW5ndGggZm9yIHRoaXMgdGFibGUuXG4gICAgLy8gSXQgd29uJ3Qgd29yayBmb3IgbXVsdGlieXRlIGNoYXJhY3RlcnMgKGxpa2UgZW1vamkpLlxuICAgIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCArPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCArIDE7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRNb3VudChcbiAgICBmaWJlcjogRmliZXIsXG4gICAgcGFyZW50SW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UgfCBudWxsLFxuICApOiBGaWJlckluc3RhbmNlIHtcbiAgICBjb25zdCBpc1Jvb3QgPSBmaWJlci50YWcgPT09IEhvc3RSb290O1xuICAgIGxldCBmaWJlckluc3RhbmNlO1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gcm9vdFRvRmliZXJJbnN0YW5jZU1hcC5nZXQoZmliZXIuc3RhdGVOb2RlKTtcbiAgICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJvb3Qgc2hvdWxkIGhhdmUgYmVlbiByZWdpc3RlcmVkIGF0IHRoaXMgcG9pbnQnKTtcbiAgICAgIH1cbiAgICAgIGZpYmVySW5zdGFuY2UgPSBlbnRyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmliZXJJbnN0YW5jZSA9IGNyZWF0ZUZpYmVySW5zdGFuY2UoZmliZXIpO1xuICAgIH1cbiAgICBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC5zZXQoZmliZXJJbnN0YW5jZS5pZCwgZmliZXJJbnN0YW5jZSk7XG5cbiAgICBjb25zdCBpZCA9IGZpYmVySW5zdGFuY2UuaWQ7XG5cbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBkZWJ1ZygncmVjb3JkTW91bnQoKScsIGZpYmVySW5zdGFuY2UsIHBhcmVudEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1Byb2ZpbGluZ1N1cHBvcnRlZCA9IGZpYmVyLmhhc093blByb3BlcnR5KCd0cmVlQmFzZUR1cmF0aW9uJyk7XG5cbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBjb25zdCBoYXNPd25lck1ldGFkYXRhID0gZmliZXIuaGFzT3duUHJvcGVydHkoJ19kZWJ1Z093bmVyJyk7XG5cbiAgICAgIC8vIEFkZGluZyBhIG5ldyBmaWVsZCBoZXJlIHdvdWxkIHJlcXVpcmUgYSBicmlkZ2UgcHJvdG9jb2wgdmVyc2lvbiBidW1wIChhIGJhY2t3YWRzIGJyZWFraW5nIGNoYW5nZSkuXG4gICAgICAvLyBJbnN0ZWFkIGxldCdzIHJlLXB1cnBvc2UgYSBwcmUtZXhpc3RpbmcgZmllbGQgdG8gY2FycnkgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgIGxldCBwcm9maWxpbmdGbGFncyA9IDA7XG4gICAgICBpZiAoaXNQcm9maWxpbmdTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJvZmlsaW5nRmxhZ3MgPSBQUk9GSUxJTkdfRkxBR19CQVNJQ19TVVBQT1JUO1xuICAgICAgICBpZiAodHlwZW9mIGluamVjdFByb2ZpbGluZ0hvb2tzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcHJvZmlsaW5nRmxhZ3MgfD0gUFJPRklMSU5HX0ZMQUdfVElNRUxJTkVfU1VQUE9SVDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc3VwcG9ydHNTdHJpY3RNb2RlIHRvIGZhbHNlIGZvciBwcm9kdWN0aW9uIHJlbmRlcmVyIGJ1aWxkc1xuICAgICAgY29uc3QgaXNQcm9kdWN0aW9uQnVpbGRPZlJlbmRlcmVyID0gcmVuZGVyZXIuYnVuZGxlVHlwZSA9PT0gMDtcblxuICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9BREQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKEVsZW1lbnRUeXBlUm9vdCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKChmaWJlci5tb2RlICYgU3RyaWN0TW9kZUJpdHMpICE9PSAwID8gMSA6IDApO1xuICAgICAgcHVzaE9wZXJhdGlvbihwcm9maWxpbmdGbGFncyk7XG4gICAgICBwdXNoT3BlcmF0aW9uKFxuICAgICAgICAhaXNQcm9kdWN0aW9uQnVpbGRPZlJlbmRlcmVyICYmIFN0cmljdE1vZGVCaXRzICE9PSAwID8gMSA6IDAsXG4gICAgICApO1xuICAgICAgcHVzaE9wZXJhdGlvbihoYXNPd25lck1ldGFkYXRhID8gMSA6IDApO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgaWYgKGRpc3BsYXlOYW1lc0J5Um9vdElEICE9PSBudWxsKSB7XG4gICAgICAgICAgZGlzcGxheU5hbWVzQnlSb290SUQuc2V0KGlkLCBnZXREaXNwbGF5TmFtZUZvclJvb3QoZmliZXIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7a2V5fSA9IGZpYmVyO1xuICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcik7XG5cbiAgICAgIC8vIEZpbmRpbmcgdGhlIG93bmVyIGluc3RhbmNlIG1pZ2h0IHJlcXVpcmUgdHJhdmVyc2luZyB0aGUgd2hvbGUgcGFyZW50IHBhdGggd2hpY2hcbiAgICAgIC8vIGRvZXNuJ3QgaGF2ZSBncmVhdCBiaWcgTyBub3RhdGlvbi4gSWRlYWxseSB3ZSdkIGxhemlseSBmZXRjaCB0aGUgb3duZXIgd2hlbiB3ZVxuICAgICAgLy8gbmVlZCBpdCBidXQgd2UgaGF2ZSBzb21lIHN5bmNocm9ub3VzIG9wZXJhdGlvbnMgaW4gdGhlIGZyb250IGVuZCBsaWtlIEFsdCtMZWZ0XG4gICAgICAvLyB3aGljaCBzZWxlY3RzIHRoZSBvd25lciBpbW1lZGlhdGVseS4gVHlwaWNhbGx5IG1vc3Qgb3duZXJzIGFyZSBvbmx5IGEgZmV3IHBhcmVudHNcbiAgICAgIC8vIGF3YXkgc28gbWF5YmUgaXQncyBub3Qgc28gYmFkLlxuICAgICAgY29uc3QgZGVidWdPd25lciA9IGdldFVuZmlsdGVyZWRPd25lcihmaWJlcik7XG4gICAgICBjb25zdCBvd25lckluc3RhbmNlID0gZmluZE5lYXJlc3RPd25lckluc3RhbmNlKFxuICAgICAgICBwYXJlbnRJbnN0YW5jZSxcbiAgICAgICAgZGVidWdPd25lcixcbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIG93bmVySW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICAgICAgZGVidWdPd25lciA9PT0gZmliZXIuX2RlYnVnT3duZXIgJiZcbiAgICAgICAgZmliZXIuX2RlYnVnU3RhY2sgIT0gbnVsbCAmJlxuICAgICAgICBvd25lckluc3RhbmNlLnNvdXJjZSA9PT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIC8vIFRoZSBuZXcgRmliZXIgaXMgZGlyZWN0bHkgb3duZWQgYnkgdGhlIG93bmVySW5zdGFuY2UuIFRoZXJlZm9yZSBzb21ld2hlcmUgb25cbiAgICAgICAgLy8gdGhlIGRlYnVnU3RhY2sgd2lsbCBiZSBhIHN0YWNrIGZyYW1lIGluc2lkZSB0aGUgb3duZXJJbnN0YW5jZSdzIHNvdXJjZS5cbiAgICAgICAgb3duZXJJbnN0YW5jZS5zb3VyY2UgPSBmaWJlci5fZGVidWdTdGFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG93bmVySUQgPSBvd25lckluc3RhbmNlID09PSBudWxsID8gMCA6IG93bmVySW5zdGFuY2UuaWQ7XG4gICAgICBjb25zdCBwYXJlbnRJRCA9IHBhcmVudEluc3RhbmNlXG4gICAgICAgID8gcGFyZW50SW5zdGFuY2Uua2luZCA9PT0gRklMVEVSRURfRklCRVJfSU5TVEFOQ0VcbiAgICAgICAgICA/IC8vIEEgRmlsdGVyZWQgRmliZXIgSW5zdGFuY2Ugd2lsbCBhbHdheXMgaGF2ZSBhIFZpcnR1YWwgSW5zdGFuY2UgYXMgYSBwYXJlbnQuXG4gICAgICAgICAgICAoKHBhcmVudEluc3RhbmNlLnBhcmVudDogYW55KTogVmlydHVhbEluc3RhbmNlKS5pZFxuICAgICAgICAgIDogcGFyZW50SW5zdGFuY2UuaWRcbiAgICAgICAgOiAwO1xuXG4gICAgICBjb25zdCBkaXNwbGF5TmFtZVN0cmluZ0lEID0gZ2V0U3RyaW5nSUQoZGlzcGxheU5hbWUpO1xuXG4gICAgICAvLyBUaGlzIGNoZWNrIGlzIGEgZ3VhcmQgdG8gaGFuZGxlIGEgUmVhY3QgZWxlbWVudCB0aGF0IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICAvLyBpbiBzdWNoIGEgd2F5IGFzIHRvIGJ5cGFzcyB0aGUgZGVmYXVsdCBzdHJpbmdpZmljYXRpb24gb2YgdGhlIFwia2V5XCIgcHJvcGVydHkuXG4gICAgICBjb25zdCBrZXlTdHJpbmcgPSBrZXkgPT09IG51bGwgPyBudWxsIDogU3RyaW5nKGtleSk7XG4gICAgICBjb25zdCBrZXlTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGtleVN0cmluZyk7XG5cbiAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fQUREKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihlbGVtZW50VHlwZSk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHBhcmVudElEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24ob3duZXJJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGRpc3BsYXlOYW1lU3RyaW5nSUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihrZXlTdHJpbmdJRCk7XG5cbiAgICAgIC8vIElmIHRoaXMgc3VidHJlZSBoYXMgYSBuZXcgbW9kZSwgbGV0IHRoZSBmcm9udGVuZCBrbm93LlxuICAgICAgaWYgKChmaWJlci5tb2RlICYgU3RyaWN0TW9kZUJpdHMpICE9PSAwKSB7XG4gICAgICAgIGxldCBwYXJlbnRGaWJlciA9IG51bGw7XG4gICAgICAgIGxldCBwYXJlbnRGaWJlckluc3RhbmNlID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICAgIHdoaWxlIChwYXJlbnRGaWJlckluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHBhcmVudEZpYmVySW5zdGFuY2Uua2luZCA9PT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXJJbnN0YW5jZS5kYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudEZpYmVySW5zdGFuY2UgPSBwYXJlbnRGaWJlckluc3RhbmNlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50RmliZXIgPT09IG51bGwgfHwgKHBhcmVudEZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlQml0cykgPT09IDApIHtcbiAgICAgICAgICBwdXNoT3BlcmF0aW9uKFRSRUVfT1BFUkFUSU9OX1NFVF9TVUJUUkVFX01PREUpO1xuICAgICAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgICAgIHB1c2hPcGVyYXRpb24oU3RyaWN0TW9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY29tcG9uZW50TG9nc0VudHJ5ID0gZmliZXJUb0NvbXBvbmVudExvZ3NNYXAuZ2V0KGZpYmVyKTtcbiAgICBpZiAoY29tcG9uZW50TG9nc0VudHJ5ID09PSB1bmRlZmluZWQgJiYgZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRMb2dzRW50cnkgPSBmaWJlclRvQ29tcG9uZW50TG9nc01hcC5nZXQoZmliZXIuYWx0ZXJuYXRlKTtcbiAgICB9XG4gICAgcmVjb3JkQ29uc29sZUxvZ3MoZmliZXJJbnN0YW5jZSwgY29tcG9uZW50TG9nc0VudHJ5KTtcblxuICAgIGlmIChpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgcmVjb3JkUHJvZmlsaW5nRHVyYXRpb25zKGZpYmVySW5zdGFuY2UsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gZmliZXJJbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFZpcnR1YWxNb3VudChcbiAgICBpbnN0YW5jZTogVmlydHVhbEluc3RhbmNlLFxuICAgIHBhcmVudEluc3RhbmNlOiBEZXZUb29sc0luc3RhbmNlIHwgbnVsbCxcbiAgICBzZWNvbmRhcnlFbnY6IG51bGwgfCBzdHJpbmcsXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGlkID0gaW5zdGFuY2UuaWQ7XG5cbiAgICBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC5zZXQoaWQsIGluc3RhbmNlKTtcblxuICAgIGNvbnN0IGNvbXBvbmVudEluZm8gPSBpbnN0YW5jZS5kYXRhO1xuXG4gICAgY29uc3Qga2V5ID1cbiAgICAgIHR5cGVvZiBjb21wb25lbnRJbmZvLmtleSA9PT0gJ3N0cmluZycgPyBjb21wb25lbnRJbmZvLmtleSA6IG51bGw7XG4gICAgY29uc3QgZW52ID0gY29tcG9uZW50SW5mby5lbnY7XG4gICAgbGV0IGRpc3BsYXlOYW1lID0gY29tcG9uZW50SW5mby5uYW1lIHx8ICcnO1xuICAgIGlmICh0eXBlb2YgZW52ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgbW9kZWwgZW52aXJvbm1lbnQgYXMgYW4gSG9DIG5hbWUgZm9yIG5vdy5cbiAgICAgIGlmIChzZWNvbmRhcnlFbnYgIT09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheU5hbWUgPSBzZWNvbmRhcnlFbnYgKyAnKCcgKyBkaXNwbGF5TmFtZSArICcpJztcbiAgICAgIH1cbiAgICAgIGRpc3BsYXlOYW1lID0gZW52ICsgJygnICsgZGlzcGxheU5hbWUgKyAnKSc7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gRWxlbWVudFR5cGVWaXJ0dWFsO1xuXG4gICAgLy8gRmluZGluZyB0aGUgb3duZXIgaW5zdGFuY2UgbWlnaHQgcmVxdWlyZSB0cmF2ZXJzaW5nIHRoZSB3aG9sZSBwYXJlbnQgcGF0aCB3aGljaFxuICAgIC8vIGRvZXNuJ3QgaGF2ZSBncmVhdCBiaWcgTyBub3RhdGlvbi4gSWRlYWxseSB3ZSdkIGxhemlseSBmZXRjaCB0aGUgb3duZXIgd2hlbiB3ZVxuICAgIC8vIG5lZWQgaXQgYnV0IHdlIGhhdmUgc29tZSBzeW5jaHJvbm91cyBvcGVyYXRpb25zIGluIHRoZSBmcm9udCBlbmQgbGlrZSBBbHQrTGVmdFxuICAgIC8vIHdoaWNoIHNlbGVjdHMgdGhlIG93bmVyIGltbWVkaWF0ZWx5LiBUeXBpY2FsbHkgbW9zdCBvd25lcnMgYXJlIG9ubHkgYSBmZXcgcGFyZW50c1xuICAgIC8vIGF3YXkgc28gbWF5YmUgaXQncyBub3Qgc28gYmFkLlxuICAgIGNvbnN0IGRlYnVnT3duZXIgPSBnZXRVbmZpbHRlcmVkT3duZXIoY29tcG9uZW50SW5mbyk7XG4gICAgY29uc3Qgb3duZXJJbnN0YW5jZSA9IGZpbmROZWFyZXN0T3duZXJJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSwgZGVidWdPd25lcik7XG4gICAgaWYgKFxuICAgICAgb3duZXJJbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICAgZGVidWdPd25lciA9PT0gY29tcG9uZW50SW5mby5vd25lciAmJlxuICAgICAgY29tcG9uZW50SW5mby5kZWJ1Z1N0YWNrICE9IG51bGwgJiZcbiAgICAgIG93bmVySW5zdGFuY2Uuc291cmNlID09PSBudWxsXG4gICAgKSB7XG4gICAgICAvLyBUaGUgbmV3IEZpYmVyIGlzIGRpcmVjdGx5IG93bmVkIGJ5IHRoZSBvd25lckluc3RhbmNlLiBUaGVyZWZvcmUgc29tZXdoZXJlIG9uXG4gICAgICAvLyB0aGUgZGVidWdTdGFjayB3aWxsIGJlIGEgc3RhY2sgZnJhbWUgaW5zaWRlIHRoZSBvd25lckluc3RhbmNlJ3Mgc291cmNlLlxuICAgICAgb3duZXJJbnN0YW5jZS5zb3VyY2UgPSBjb21wb25lbnRJbmZvLmRlYnVnU3RhY2s7XG4gICAgfVxuICAgIGNvbnN0IG93bmVySUQgPSBvd25lckluc3RhbmNlID09PSBudWxsID8gMCA6IG93bmVySW5zdGFuY2UuaWQ7XG4gICAgY29uc3QgcGFyZW50SUQgPSBwYXJlbnRJbnN0YW5jZVxuICAgICAgPyBwYXJlbnRJbnN0YW5jZS5raW5kID09PSBGSUxURVJFRF9GSUJFUl9JTlNUQU5DRVxuICAgICAgICA/IC8vIEEgRmlsdGVyZWQgRmliZXIgSW5zdGFuY2Ugd2lsbCBhbHdheXMgaGF2ZSBhIFZpcnR1YWwgSW5zdGFuY2UgYXMgYSBwYXJlbnQuXG4gICAgICAgICAgKChwYXJlbnRJbnN0YW5jZS5wYXJlbnQ6IGFueSk6IFZpcnR1YWxJbnN0YW5jZSkuaWRcbiAgICAgICAgOiBwYXJlbnRJbnN0YW5jZS5pZFxuICAgICAgOiAwO1xuXG4gICAgY29uc3QgZGlzcGxheU5hbWVTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGRpc3BsYXlOYW1lKTtcblxuICAgIC8vIFRoaXMgY2hlY2sgaXMgYSBndWFyZCB0byBoYW5kbGUgYSBSZWFjdCBlbGVtZW50IHRoYXQgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAvLyBpbiBzdWNoIGEgd2F5IGFzIHRvIGJ5cGFzcyB0aGUgZGVmYXVsdCBzdHJpbmdpZmljYXRpb24gb2YgdGhlIFwia2V5XCIgcHJvcGVydHkuXG4gICAgY29uc3Qga2V5U3RyaW5nID0ga2V5ID09PSBudWxsID8gbnVsbCA6IFN0cmluZyhrZXkpO1xuICAgIGNvbnN0IGtleVN0cmluZ0lEID0gZ2V0U3RyaW5nSUQoa2V5U3RyaW5nKTtcblxuICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fQUREKTtcbiAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICBwdXNoT3BlcmF0aW9uKGVsZW1lbnRUeXBlKTtcbiAgICBwdXNoT3BlcmF0aW9uKHBhcmVudElEKTtcbiAgICBwdXNoT3BlcmF0aW9uKG93bmVySUQpO1xuICAgIHB1c2hPcGVyYXRpb24oZGlzcGxheU5hbWVTdHJpbmdJRCk7XG4gICAgcHVzaE9wZXJhdGlvbihrZXlTdHJpbmdJRCk7XG5cbiAgICBjb25zdCBjb21wb25lbnRMb2dzRW50cnkgPVxuICAgICAgY29tcG9uZW50SW5mb1RvQ29tcG9uZW50TG9nc01hcC5nZXQoY29tcG9uZW50SW5mbyk7XG4gICAgcmVjb3JkQ29uc29sZUxvZ3MoaW5zdGFuY2UsIGNvbXBvbmVudExvZ3NFbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRVbm1vdW50KGZpYmVySW5zdGFuY2U6IEZpYmVySW5zdGFuY2UpOiB2b2lkIHtcbiAgICBjb25zdCBmaWJlciA9IGZpYmVySW5zdGFuY2UuZGF0YTtcbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBkZWJ1ZygncmVjb3JkVW5tb3VudCgpJywgZmliZXJJbnN0YW5jZSwgcmVjb25jaWxpbmdQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoSW5zdGFuY2UgPT09IGZpYmVySW5zdGFuY2UpIHtcbiAgICAgIC8vIFdlJ3JlIGluIHRoZSBwcm9jZXNzIG9mIHRyeWluZyB0byByZXN0b3JlIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgIC8vIElmIHRoaXMgZmliZXIgbWF0Y2hlZCBidXQgaXMgYmVpbmcgdW5tb3VudGVkLCB0aGVyZSdzIG5vIHVzZSB0cnlpbmcuXG4gICAgICAvLyBSZXNldCB0aGUgc3RhdGUgc28gd2UgZG9uJ3Qga2VlcCBob2xkaW5nIG9udG8gaXQuXG4gICAgICBzZXRUcmFja2VkUGF0aChudWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGZpYmVySW5zdGFuY2UuaWQ7XG4gICAgY29uc3QgaXNSb290ID0gZmliZXIudGFnID09PSBIb3N0Um9vdDtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICAvLyBSb290cyBtdXN0IGJlIHJlbW92ZWQgb25seSBhZnRlciBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAgICAvLyBTbyB3ZSB0cmFjayBpdCBzZXBhcmF0ZWx5LlxuICAgICAgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9IGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUbyBtYWludGFpbiBjaGlsZC1maXJzdCBvcmRlcmluZyxcbiAgICAgIC8vIHdlJ2xsIHB1c2ggaXQgaW50byBvbmUgb2YgdGhlc2UgcXVldWVzLFxuICAgICAgLy8gYW5kIGxhdGVyIGFycmFuZ2UgdGhlbSBpbiB0aGUgY29ycmVjdCBvcmRlci5cbiAgICAgIHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLnB1c2goaWQpO1xuICAgIH1cblxuICAgIGlkVG9EZXZUb29sc0luc3RhbmNlTWFwLmRlbGV0ZShmaWJlckluc3RhbmNlLmlkKTtcblxuICAgIHVudHJhY2tGaWJlcihmaWJlckluc3RhbmNlLCBmaWJlcik7XG4gIH1cblxuICAvLyBSdW5uaW5nIHN0YXRlIG9mIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gZnJvbSB0aGUgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIHBhcmVudCB0aGF0XG4gIC8vIHdlIGhhdmVuJ3QgeWV0IGFkZGVkIGJhY2suIFRoaXMgc2hvdWxkIGJlIHJlc2V0IGFueXRpbWUgd2UgY2hhbmdlIHBhcmVudC5cbiAgLy8gQW55IHJlbWFpbmluZyBvbmVzIGF0IHRoZSBlbmQgd2lsbCBiZSBkZWxldGVkLlxuICBsZXQgcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbjogbnVsbCB8IERldlRvb2xzSW5zdGFuY2UgPSBudWxsO1xuICAvLyBUaGUgcHJldmlvdXNseSBwbGFjZWQgY2hpbGQuXG4gIGxldCBwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmc6IG51bGwgfCBEZXZUb29sc0luc3RhbmNlID0gbnVsbDtcbiAgLy8gVG8gc2F2ZSBvbiBzdGFjayBhbGxvY2F0aW9uIGFuZCBlbnN1cmUgdGhhdCB0aGV5IGFyZSB1cGRhdGVkIGFzIGEgcGFpciwgd2UgYWxzbyBzdG9yZVxuICAvLyB0aGUgY3VycmVudCBwYXJlbnQgaGVyZSBhcyB3ZWxsLlxuICBsZXQgcmVjb25jaWxpbmdQYXJlbnQ6IG51bGwgfCBEZXZUb29sc0luc3RhbmNlID0gbnVsbDtcblxuICBmdW5jdGlvbiBpbnNlcnRDaGlsZChpbnN0YW5jZTogRGV2VG9vbHNJbnN0YW5jZSk6IHZvaWQge1xuICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gcmVjb25jaWxpbmdQYXJlbnQ7XG4gICAgaWYgKHBhcmVudEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGluc3RhbmNlIGlzIGF0IHRoZSByb290LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBQbGFjZSBpdCBpbiB0aGUgcGFyZW50LlxuICAgIGluc3RhbmNlLnBhcmVudCA9IHBhcmVudEluc3RhbmNlO1xuICAgIGlmIChwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHByZXZpb3VzbHlSZWNvbmNpbGVkU2libGluZyA9IGluc3RhbmNlO1xuICAgICAgcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZCA9IGluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmcubmV4dFNpYmxpbmcgPSBpbnN0YW5jZTtcbiAgICAgIHByZXZpb3VzbHlSZWNvbmNpbGVkU2libGluZyA9IGluc3RhbmNlO1xuICAgIH1cbiAgICBpbnN0YW5jZS5uZXh0U2libGluZyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2hpbGQoXG4gICAgaW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UsXG4gICAgcHJldmlvdXNTaWJsaW5nOiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgKTogdm9pZCB7XG4gICAgcmVtb3ZlQ2hpbGQoaW5zdGFuY2UsIHByZXZpb3VzU2libGluZyk7XG4gICAgaW5zZXJ0Q2hpbGQoaW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoXG4gICAgaW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UsXG4gICAgcHJldmlvdXNTaWJsaW5nOiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgKTogdm9pZCB7XG4gICAgaWYgKGluc3RhbmNlLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW4gPT09IGluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnUmVtYWluaW5nIGNoaWxkcmVuIHNob3VsZCBub3QgaGF2ZSBpdGVtcyB3aXRoIG5vIHBhcmVudCcsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBkZWxldGVkIGluc3RhbmNlIHNob3VsZCBub3QgaGF2ZSBuZXh0IHNpYmxpbmdzJyk7XG4gICAgICB9XG4gICAgICAvLyBBbHJlYWR5IGRlbGV0ZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gcmVjb25jaWxpbmdQYXJlbnQ7XG4gICAgaWYgKHBhcmVudEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgaGF2ZSBhIHBhcmVudCBpZiB3ZSBhcmUgYXQgdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnBhcmVudCAhPT0gcGFyZW50SW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCByZW1vdmUgYSBub2RlIGZyb20gYSBkaWZmZXJlbnQgcGFyZW50IHRoYW4gaXMgYmVpbmcgcmVjb25jaWxlZC4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFuIGV4aXN0aW5nIGNoaWxkIGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24sIHdoaWNoIHdlIGFzc3VtZSBpcyBpbiB0aGVcbiAgICAvLyByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuIHNldC5cbiAgICBpZiAocHJldmlvdXNTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBmaXJzdCBpbiB0aGUgcmVtYWluaW5nIHNldC4gUmVtb3ZlIHVzLlxuICAgICAgaWYgKHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW4gIT09IGluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXhwZWN0ZWQgYSBwbGFjZWQgY2hpbGQgdG8gYmUgbW92ZWQgZnJvbSB0aGUgcmVtYWluaW5nIHNldC4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbiA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c1NpYmxpbmcubmV4dFNpYmxpbmcgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgaW5zdGFuY2UubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIGluc3RhbmNlLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50UmVtYWluaW5nQ2hpbGRyZW4oKSB7XG4gICAgbGV0IGNoaWxkID0gcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbjtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHVubW91bnRJbnN0YW5jZVJlY3Vyc2l2ZWx5KGNoaWxkKTtcbiAgICAgIGNoaWxkID0gcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudFZpcnR1YWxJbnN0YW5jZVJlY3Vyc2l2ZWx5KFxuICAgIHZpcnR1YWxJbnN0YW5jZTogVmlydHVhbEluc3RhbmNlLFxuICAgIGZpcnN0Q2hpbGQ6IEZpYmVyLFxuICAgIGxhc3RDaGlsZDogbnVsbCB8IEZpYmVyLCAvLyBub24taW5jbHVzaXZlXG4gICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZTogYm9vbGVhbixcbiAgICB2aXJ0dWFsTGV2ZWw6IG51bWJlciwgLy8gdGhlIG50aCBsZXZlbCBvZiB2aXJ0dWFsIGluc3RhbmNlc1xuICApOiB2b2lkIHtcbiAgICAvLyBJZiB3ZSBoYXZlIHRoZSB0cmVlIHNlbGVjdGlvbiBmcm9tIHByZXZpb3VzIHJlbG9hZCwgdHJ5IHRvIG1hdGNoIHRoaXMgSW5zdGFuY2UuXG4gICAgLy8gQWxzbyByZW1lbWJlciB3aGV0aGVyIHRvIGRvIHRoZSBzYW1lIGZvciBzaWJsaW5ncy5cbiAgICBjb25zdCBtaWdodFNpYmxpbmdzQmVPblRyYWNrZWRQYXRoID1cbiAgICAgIHVwZGF0ZVZpcnR1YWxUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoXG4gICAgICAgIHZpcnR1YWxJbnN0YW5jZSxcbiAgICAgICAgcmVjb25jaWxpbmdQYXJlbnQsXG4gICAgICApO1xuXG4gICAgY29uc3Qgc3Rhc2hlZFBhcmVudCA9IHJlY29uY2lsaW5nUGFyZW50O1xuICAgIGNvbnN0IHN0YXNoZWRQcmV2aW91cyA9IHByZXZpb3VzbHlSZWNvbmNpbGVkU2libGluZztcbiAgICBjb25zdCBzdGFzaGVkUmVtYWluaW5nID0gcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbjtcbiAgICAvLyBQdXNoIGEgbmV3IERldlRvb2xzIGluc3RhbmNlIHBhcmVudCB3aGlsZSByZWNvbmNpbGluZyB0aGlzIHN1YnRyZWUuXG4gICAgcmVjb25jaWxpbmdQYXJlbnQgPSB2aXJ0dWFsSW5zdGFuY2U7XG4gICAgcHJldmlvdXNseVJlY29uY2lsZWRTaWJsaW5nID0gbnVsbDtcbiAgICByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgbW91bnRWaXJ0dWFsQ2hpbGRyZW5SZWN1cnNpdmVseShcbiAgICAgICAgZmlyc3RDaGlsZCxcbiAgICAgICAgbGFzdENoaWxkLFxuICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICB2aXJ0dWFsTGV2ZWwgKyAxLFxuICAgICAgKTtcbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGFmdGVyIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gYXBwZW5kZWQuXG4gICAgICByZWNvcmRWaXJ0dWFsUHJvZmlsaW5nRHVyYXRpb25zKHZpcnR1YWxJbnN0YW5jZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29uY2lsaW5nUGFyZW50ID0gc3Rhc2hlZFBhcmVudDtcbiAgICAgIHByZXZpb3VzbHlSZWNvbmNpbGVkU2libGluZyA9IHN0YXNoZWRQcmV2aW91cztcbiAgICAgIHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW4gPSBzdGFzaGVkUmVtYWluaW5nO1xuICAgICAgdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUFmdGVyTW91bnQobWlnaHRTaWJsaW5nc0JlT25UcmFja2VkUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkVmlydHVhbFVubW91bnQoaW5zdGFuY2U6IFZpcnR1YWxJbnN0YW5jZSkge1xuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoSW5zdGFuY2UgPT09IGluc3RhbmNlKSB7XG4gICAgICAvLyBXZSdyZSBpbiB0aGUgcHJvY2VzcyBvZiB0cnlpbmcgdG8gcmVzdG9yZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gICAgICAvLyBJZiB0aGlzIGZpYmVyIG1hdGNoZWQgYnV0IGlzIGJlaW5nIHVubW91bnRlZCwgdGhlcmUncyBubyB1c2UgdHJ5aW5nLlxuICAgICAgLy8gUmVzZXQgdGhlIHN0YXRlIHNvIHdlIGRvbid0IGtlZXAgaG9sZGluZyBvbnRvIGl0LlxuICAgICAgc2V0VHJhY2tlZFBhdGgobnVsbCk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBpbnN0YW5jZS5pZDtcbiAgICBwZW5kaW5nUmVhbFVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlY29uZGFyeUVudmlyb25tZW50TmFtZShcbiAgICBkZWJ1Z0luZm86ID9SZWFjdERlYnVnSW5mbyxcbiAgICBpbmRleDogbnVtYmVyLFxuICApOiBudWxsIHwgc3RyaW5nIHtcbiAgICBpZiAoZGVidWdJbmZvICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudEluZm86IFJlYWN0Q29tcG9uZW50SW5mbyA9IChkZWJ1Z0luZm9baW5kZXhdOiBhbnkpO1xuICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWJ1Z0VudHJ5ID0gZGVidWdJbmZvW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGRlYnVnRW50cnkuZW52ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGVudmlyb25tZW50IGlzIGRpZmZlcmVudCB0aGVuIHRoaXMgY29tcG9uZW50IHdhcyB0aGUgYm91bmRhcnlcbiAgICAgICAgICAvLyBhbmQgaXQgY2hhbmdlZCBiZWZvcmUgZW50ZXJpbmcgdGhlIG5leHQgY29tcG9uZW50LiBTbyB3ZSBhc3NpZ24gdGhpc1xuICAgICAgICAgIC8vIGNvbXBvbmVudCBhIHNlY29uZGFyeSBlbnZpcm9ubWVudC5cbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50SW5mby5lbnYgIT09IGRlYnVnRW50cnkuZW52ID8gZGVidWdFbnRyeS5lbnYgOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRWaXJ0dWFsQ2hpbGRyZW5SZWN1cnNpdmVseShcbiAgICBmaXJzdENoaWxkOiBGaWJlcixcbiAgICBsYXN0Q2hpbGQ6IG51bGwgfCBGaWJlciwgLy8gbm9uLWluY2x1c2l2ZVxuICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGU6IGJvb2xlYW4sXG4gICAgdmlydHVhbExldmVsOiBudW1iZXIsIC8vIHRoZSBudGggbGV2ZWwgb2YgdmlydHVhbCBpbnN0YW5jZXNcbiAgKTogdm9pZCB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIHNpYmxpbmdzIHJhdGhlciB0aGFuIHJlY3Vyc2luZy5cbiAgICAvLyBUaGlzIHJlZHVjZXMgdGhlIGNoYW5jZSBvZiBzdGFjayBvdmVyZmxvdyBmb3Igd2lkZSB0cmVlcyAoZS5nLiBsaXN0cyB3aXRoIG1hbnkgaXRlbXMpLlxuICAgIGxldCBmaWJlcjogRmliZXIgfCBudWxsID0gZmlyc3RDaGlsZDtcbiAgICBsZXQgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2U6IG51bGwgfCBWaXJ0dWFsSW5zdGFuY2UgPSBudWxsO1xuICAgIGxldCBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZUZpcnN0RmliZXI6IEZpYmVyID0gZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZmliZXIgIT09IG51bGwgJiYgZmliZXIgIT09IGxhc3RDaGlsZCkge1xuICAgICAgbGV0IGxldmVsID0gMDtcbiAgICAgIGlmIChmaWJlci5fZGVidWdJbmZvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmliZXIuX2RlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGRlYnVnRW50cnkgPSBmaWJlci5fZGVidWdJbmZvW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGVidWdFbnRyeS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gTm90IGEgQ29tcG9uZW50LiBTb21lIG90aGVyIERlYnVnIEluZm8uXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2NhbiB1cCB1bnRpbCB0aGUgbmV4dCBDb21wb25lbnQgdG8gc2VlIGlmIHRoaXMgY29tcG9uZW50IGNoYW5nZWQgZW52aXJvbm1lbnQuXG4gICAgICAgICAgY29uc3QgY29tcG9uZW50SW5mbzogUmVhY3RDb21wb25lbnRJbmZvID0gKGRlYnVnRW50cnk6IGFueSk7XG4gICAgICAgICAgY29uc3Qgc2Vjb25kYXJ5RW52ID0gZ2V0U2Vjb25kYXJ5RW52aXJvbm1lbnROYW1lKGZpYmVyLl9kZWJ1Z0luZm8sIGkpO1xuICAgICAgICAgIGlmIChjb21wb25lbnRJbmZvLmVudiAhPSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bkVudmlyb25tZW50TmFtZXMuYWRkKGNvbXBvbmVudEluZm8uZW52KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlY29uZGFyeUVudiAhPT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25FbnZpcm9ubWVudE5hbWVzLmFkZChzZWNvbmRhcnlFbnYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkRmlsdGVyVmlydHVhbChjb21wb25lbnRJbmZvLCBzZWNvbmRhcnlFbnYpKSB7XG4gICAgICAgICAgICAvLyBTa2lwLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZXZlbCA9PT0gdmlydHVhbExldmVsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgIC8vIENvbnNlY3V0aXZlIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUgZGVidWcgZW50cnkgYXMgYSBwYXJlbnQgZ2V0c1xuICAgICAgICAgICAgICAvLyB0cmVhdGVkIGFzIGlmIHRoZXkgc2hhcmUgdGhlIHNhbWUgdmlydHVhbCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UuZGF0YSAhPT0gZGVidWdFbnRyeVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIE1vdW50IGFueSBwcmV2aW91cyBjaGlsZHJlbiB0aGF0IHNob3VsZCBnbyBpbnRvIHRoZSBwcmV2aW91cyBwYXJlbnQuXG4gICAgICAgICAgICAgICAgbW91bnRWaXJ0dWFsSW5zdGFuY2VSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VGaXJzdEZpYmVyLFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICAgICAgICAgdmlydHVhbExldmVsLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UgPSBjcmVhdGVWaXJ0dWFsSW5zdGFuY2UoY29tcG9uZW50SW5mbyk7XG4gICAgICAgICAgICAgIHJlY29yZFZpcnR1YWxNb3VudChcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICByZWNvbmNpbGluZ1BhcmVudCxcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlFbnYsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKHByZXZpb3VzVmlydHVhbEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VGaXJzdEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IHZpcnR1YWxMZXZlbCkge1xuICAgICAgICBpZiAocHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHdvcmtpbmcgb24gYSB2aXJ0dWFsIGluc3RhbmNlIGFuZCB0aGlzIGlzIG5vdCBhIHZpcnR1YWxcbiAgICAgICAgICAvLyBpbnN0YW5jZSwgdGhlbiB3ZSBlbmQgdGhlIHNlcXVlbmNlIGFuZCBtb3VudCBhbnkgcHJldmlvdXMgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHNob3VsZCBnbyBpbnRvIHRoZSBwcmV2aW91cyB2aXJ0dWFsIGluc3RhbmNlLlxuICAgICAgICAgIG1vdW50VmlydHVhbEluc3RhbmNlUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSxcbiAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlRmlyc3RGaWJlcixcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgIHZpcnR1YWxMZXZlbCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHZpcnR1YWwgbGV2ZWxzLCBidXQgbm90IGJleW9uZCxcbiAgICAgICAgLy8gYW5kIG5vdyBjb250aW51ZSB3aXRoIHRoZSByZWd1bGFyIGZpYmVyLlxuICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkoZmliZXIsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpO1xuICAgICAgfVxuICAgICAgZmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIC8vIE1vdW50IGFueSBwcmV2aW91cyBjaGlsZHJlbiB0aGF0IHNob3VsZCBnbyBpbnRvIHRoZSBwcmV2aW91cyBwYXJlbnQuXG4gICAgICBtb3VudFZpcnR1YWxJbnN0YW5jZVJlY3Vyc2l2ZWx5KFxuICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSxcbiAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VGaXJzdEZpYmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICB2aXJ0dWFsTGV2ZWwsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50Q2hpbGRyZW5SZWN1cnNpdmVseShcbiAgICBmaXJzdENoaWxkOiBGaWJlcixcbiAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlOiBib29sZWFuLFxuICApOiB2b2lkIHtcbiAgICBtb3VudFZpcnR1YWxDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgICAgZmlyc3RDaGlsZCxcbiAgICAgIG51bGwsXG4gICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgMCwgLy8gZmlyc3QgbGV2ZWxcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRGaWJlclJlY3Vyc2l2ZWx5KFxuICAgIGZpYmVyOiBGaWJlcixcbiAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlOiBib29sZWFuLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBzaG91bGRJbmNsdWRlSW5UcmVlID0gIXNob3VsZEZpbHRlckZpYmVyKGZpYmVyKTtcbiAgICBsZXQgbmV3SW5zdGFuY2UgPSBudWxsO1xuICAgIGlmIChzaG91bGRJbmNsdWRlSW5UcmVlKSB7XG4gICAgICBuZXdJbnN0YW5jZSA9IHJlY29yZE1vdW50KGZpYmVyLCByZWNvbmNpbGluZ1BhcmVudCk7XG4gICAgICBpbnNlcnRDaGlsZChuZXdJbnN0YW5jZSk7XG4gICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgIGRlYnVnKCdtb3VudEZpYmVyUmVjdXJzaXZlbHkoKScsIG5ld0luc3RhbmNlLCByZWNvbmNpbGluZ1BhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHJlY29uY2lsaW5nUGFyZW50ICE9PSBudWxsICYmXG4gICAgICByZWNvbmNpbGluZ1BhcmVudC5raW5kID09PSBWSVJUVUFMX0lOU1RBTkNFXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGlzIGEgVmlydHVhbCBJbnN0YW5jZSBhbmQgd2UgZmlsdGVyZWQgdGhpcyBGaWJlciB3ZSBpbmNsdWRlIGFcbiAgICAgIC8vIGhpZGRlbiBub2RlLlxuXG4gICAgICBpZiAoXG4gICAgICAgIHJlY29uY2lsaW5nUGFyZW50LmRhdGEgPT09IGZpYmVyLl9kZWJ1Z093bmVyICYmXG4gICAgICAgIGZpYmVyLl9kZWJ1Z1N0YWNrICE9IG51bGwgJiZcbiAgICAgICAgcmVjb25jaWxpbmdQYXJlbnQuc291cmNlID09PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhlIG5ldyBGaWJlciBpcyBkaXJlY3RseSBvd25lZCBieSB0aGUgcGFyZW50LiBUaGVyZWZvcmUgc29tZXdoZXJlIG9uIHRoZVxuICAgICAgICAvLyBkZWJ1Z1N0YWNrIHdpbGwgYmUgYSBzdGFjayBmcmFtZSBpbnNpZGUgcGFyZW50IHRoYXQgd2UgY2FuIHVzZSBhcyBpdHMgc29ydWNlLlxuICAgICAgICByZWNvbmNpbGluZ1BhcmVudC5zb3VyY2UgPSBmaWJlci5fZGVidWdTdGFjaztcbiAgICAgIH1cblxuICAgICAgbmV3SW5zdGFuY2UgPSBjcmVhdGVGaWx0ZXJlZEZpYmVySW5zdGFuY2UoZmliZXIpO1xuICAgICAgaW5zZXJ0Q2hpbGQobmV3SW5zdGFuY2UpO1xuICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICBkZWJ1ZygnbW91bnRGaWJlclJlY3Vyc2l2ZWx5KCknLCBuZXdJbnN0YW5jZSwgcmVjb25jaWxpbmdQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdGhlIHRyZWUgc2VsZWN0aW9uIGZyb20gcHJldmlvdXMgcmVsb2FkLCB0cnkgdG8gbWF0Y2ggdGhpcyBGaWJlci5cbiAgICAvLyBBbHNvIHJlbWVtYmVyIHdoZXRoZXIgdG8gZG8gdGhlIHNhbWUgZm9yIHNpYmxpbmdzLlxuICAgIGNvbnN0IG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGggPSB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoXG4gICAgICBmaWJlcixcbiAgICAgIG5ld0luc3RhbmNlLFxuICAgICk7XG5cbiAgICBjb25zdCBzdGFzaGVkUGFyZW50ID0gcmVjb25jaWxpbmdQYXJlbnQ7XG4gICAgY29uc3Qgc3Rhc2hlZFByZXZpb3VzID0gcHJldmlvdXNseVJlY29uY2lsZWRTaWJsaW5nO1xuICAgIGNvbnN0IHN0YXNoZWRSZW1haW5pbmcgPSByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuO1xuICAgIGlmIChuZXdJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgLy8gUHVzaCBhIG5ldyBEZXZUb29scyBpbnN0YW5jZSBwYXJlbnQgd2hpbGUgcmVjb25jaWxpbmcgdGhpcyBzdWJ0cmVlLlxuICAgICAgcmVjb25jaWxpbmdQYXJlbnQgPSBuZXdJbnN0YW5jZTtcbiAgICAgIHByZXZpb3VzbHlSZWNvbmNpbGVkU2libGluZyA9IG51bGw7XG4gICAgICByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0cmFjZVVwZGF0ZXNFbmFibGVkKSB7XG4gICAgICAgIGlmICh0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKTtcbiAgICAgICAgICAvLyBJZiBhbiBhbmNlc3RvciB1cGRhdGVkLCB3ZSBzaG91bGQgbWFyayB0aGUgbmVhcmVzdCBob3N0IG5vZGVzIGZvciBoaWdobGlnaHRpbmcuXG4gICAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRyYWNlVXBkYXRlc0Zvck5vZGVzLmFkZChmaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG8gbm90IHJlLWVuYWJsZSB0aGUgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSBmbGFnIGluIHRoaXMgYnJhbmNoLFxuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gaGlnaGxpZ2h0IGV2ZXJ5IGhvc3Qgbm9kZSBpbnNpZGUgb2YgYSBuZXdseSBtb3VudGVkIHN1YnRyZWUuXG4gICAgICB9XG5cbiAgICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RIb2lzdGFibGUpIHtcbiAgICAgICAgY29uc3QgbmVhcmVzdEluc3RhbmNlID0gcmVjb25jaWxpbmdQYXJlbnQ7XG4gICAgICAgIGlmIChuZWFyZXN0SW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZXhwZWN0IGEgaG9zdCBob2lzdGFibGUgdG8gYmUgdGhlIHJvb3QnKTtcbiAgICAgICAgfVxuICAgICAgICBhcXVpcmVIb3N0UmVzb3VyY2UobmVhcmVzdEluc3RhbmNlLCBmaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fFxuICAgICAgICBmaWJlci50YWcgPT09IEhvc3RUZXh0IHx8XG4gICAgICAgIGZpYmVyLnRhZyA9PT0gSG9zdFNpbmdsZXRvblxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG5lYXJlc3RJbnN0YW5jZSA9IHJlY29uY2lsaW5nUGFyZW50O1xuICAgICAgICBpZiAobmVhcmVzdEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGV4cGVjdCBhIGhvc3QgaG9pc3RhYmxlIHRvIGJlIHRoZSByb290Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXF1aXJlSG9zdEluc3RhbmNlKG5lYXJlc3RJbnN0YW5jZSwgZmliZXIuc3RhdGVOb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgaXNUaW1lZE91dCA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgIGlmIChpc1RpbWVkT3V0KSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBTdXNwZW5zZSBtb3VudHMgaW4gYSB0aW1lZC1vdXQgc3RhdGUsXG4gICAgICAgICAgLy8gZ2V0IHRoZSBmYWxsYmFjayBjaGlsZCBmcm9tIHRoZSBpbm5lciBmcmFnbWVudCBhbmQgbW91bnRcbiAgICAgICAgICAvLyBpdCBhcyBpZiBpdCB3YXMgb3VyIG93biBjaGlsZC4gVXBkYXRlcyBoYW5kbGUgdGhpcyB0b28uXG4gICAgICAgICAgY29uc3QgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICBjb25zdCBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudFxuICAgICAgICAgICAgPyBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaWYgKGZhbGxiYWNrQ2hpbGRGcmFnbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tDaGlsZCA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5jaGlsZDtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja0NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZVRyYWNrZWRQYXRoU3RhdGVCZWZvcmVNb3VudChmYWxsYmFja0NoaWxkRnJhZ21lbnQsIG51bGwpO1xuICAgICAgICAgICAgICBtb3VudENoaWxkcmVuUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICAgICAgZmFsbGJhY2tDaGlsZCxcbiAgICAgICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgcHJpbWFyeUNoaWxkOiBGaWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgIGNvbnN0IGFyZVN1c3BlbnNlQ2hpbGRyZW5Db25kaXRpb25hbGx5V3JhcHBlZCA9XG4gICAgICAgICAgICBPZmZzY3JlZW5Db21wb25lbnQgPT09IC0xO1xuICAgICAgICAgIGlmIChhcmVTdXNwZW5zZUNoaWxkcmVuQ29uZGl0aW9uYWxseVdyYXBwZWQpIHtcbiAgICAgICAgICAgIHByaW1hcnlDaGlsZCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmliZXIuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByaW1hcnlDaGlsZCA9IGZpYmVyLmNoaWxkLmNoaWxkO1xuICAgICAgICAgICAgdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KGZpYmVyLmNoaWxkLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByaW1hcnlDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbW91bnRDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICBwcmltYXJ5Q2hpbGQsXG4gICAgICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpYmVyLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgZmliZXIuY2hpbGQsXG4gICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKG5ld0luc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgIHJlY29uY2lsaW5nUGFyZW50ID0gc3Rhc2hlZFBhcmVudDtcbiAgICAgICAgcHJldmlvdXNseVJlY29uY2lsZWRTaWJsaW5nID0gc3Rhc2hlZFByZXZpb3VzO1xuICAgICAgICByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuID0gc3Rhc2hlZFJlbWFpbmluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSdyZSBleGl0aW5nIHRoaXMgRmliZXIgbm93LCBhbmQgZW50ZXJpbmcgaXRzIHNpYmxpbmdzLlxuICAgIC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIHRvIHJlc3RvcmUsIHdlIG1pZ2h0IG5lZWQgdG8gcmUtYWN0aXZhdGUgdHJhY2tpbmcuXG4gICAgdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUFmdGVyTW91bnQobWlnaHRTaWJsaW5nc0JlT25UcmFja2VkUGF0aCk7XG4gIH1cblxuICAvLyBXZSB1c2UgdGhpcyB0byBzaW11bGF0ZSB1bm1vdW50aW5nIGZvciBTdXNwZW5zZSB0cmVlc1xuICAvLyB3aGVuIHdlIHN3aXRjaCBmcm9tIHByaW1hcnkgdG8gZmFsbGJhY2ssIG9yIGRlbGV0aW5nIGEgc3VidHJlZS5cbiAgZnVuY3Rpb24gdW5tb3VudEluc3RhbmNlUmVjdXJzaXZlbHkoaW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UpIHtcbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBkZWJ1ZygndW5tb3VudEluc3RhbmNlUmVjdXJzaXZlbHkoKScsIGluc3RhbmNlLCByZWNvbmNpbGluZ1BhcmVudCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3Rhc2hlZFBhcmVudCA9IHJlY29uY2lsaW5nUGFyZW50O1xuICAgIGNvbnN0IHN0YXNoZWRQcmV2aW91cyA9IHByZXZpb3VzbHlSZWNvbmNpbGVkU2libGluZztcbiAgICBjb25zdCBzdGFzaGVkUmVtYWluaW5nID0gcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbjtcbiAgICAvLyBQdXNoIGEgbmV3IERldlRvb2xzIGluc3RhbmNlIHBhcmVudCB3aGlsZSByZWNvbmNpbGluZyB0aGlzIHN1YnRyZWUuXG4gICAgcmVjb25jaWxpbmdQYXJlbnQgPSBpbnN0YW5jZTtcbiAgICBwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmcgPSBudWxsO1xuICAgIC8vIE1vdmUgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIGluc3RhbmNlIHRvIHRoZSByZW1haW5pbmcgc2V0LlxuICAgIHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW4gPSBpbnN0YW5jZS5maXJzdENoaWxkO1xuICAgIGluc3RhbmNlLmZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAvLyBVbm1vdW50IHRoZSByZW1haW5pbmcgc2V0LlxuICAgICAgdW5tb3VudFJlbWFpbmluZ0NoaWxkcmVuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29uY2lsaW5nUGFyZW50ID0gc3Rhc2hlZFBhcmVudDtcbiAgICAgIHByZXZpb3VzbHlSZWNvbmNpbGVkU2libGluZyA9IHN0YXNoZWRQcmV2aW91cztcbiAgICAgIHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW4gPSBzdGFzaGVkUmVtYWluaW5nO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uua2luZCA9PT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgIHJlY29yZFVubW91bnQoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2Uua2luZCA9PT0gVklSVFVBTF9JTlNUQU5DRSkge1xuICAgICAgcmVjb3JkVmlydHVhbFVubW91bnQoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnRyYWNrRmliZXIoaW5zdGFuY2UsIGluc3RhbmNlLmRhdGEpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZChpbnN0YW5jZSwgbnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMoXG4gICAgZmliZXJJbnN0YW5jZTogRmliZXJJbnN0YW5jZSxcbiAgICBwcmV2RmliZXI6IG51bGwgfCBGaWJlcixcbiAgKSB7XG4gICAgY29uc3QgaWQgPSBmaWJlckluc3RhbmNlLmlkO1xuICAgIGNvbnN0IGZpYmVyID0gZmliZXJJbnN0YW5jZS5kYXRhO1xuICAgIGNvbnN0IHthY3R1YWxEdXJhdGlvbiwgdHJlZUJhc2VEdXJhdGlvbn0gPSBmaWJlcjtcblxuICAgIGZpYmVySW5zdGFuY2UudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb24gfHwgMDtcblxuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXBkYXRlIHRyZWVCYXNlRHVyYXRpb24gZXZlbiBpZiB0aGUgY3VycmVudCBGaWJlciBkaWQgbm90IHJlbmRlcixcbiAgICAgIC8vIGJlY2F1c2UgaXQncyBwb3NzaWJsZSB0aGF0IG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgZGlkLlxuICAgICAgaWYgKFxuICAgICAgICBwcmV2RmliZXIgPT0gbnVsbCB8fFxuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uICE9PSBwcmV2RmliZXIudHJlZUJhc2VEdXJhdGlvblxuICAgICAgKSB7XG4gICAgICAgIC8vIFRyZWUgYmFzZSBkdXJhdGlvbiB1cGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3BlcmF0aW9ucyB0eXBlZCBhcnJheS5cbiAgICAgICAgLy8gU28gd2UgaGF2ZSB0byBjb252ZXJ0IHRoZW0gZnJvbSBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzIHNvIHdlIGNhbiBzZW5kIHRoZW0gYXMgaW50cy5cbiAgICAgICAgY29uc3QgY29udmVydGVkVHJlZUJhc2VEdXJhdGlvbiA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgKHRyZWVCYXNlRHVyYXRpb24gfHwgMCkgKiAxMDAwLFxuICAgICAgICApO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT04pO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihjb252ZXJ0ZWRUcmVlQmFzZUR1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZGaWJlciA9PSBudWxsIHx8IGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgZmliZXIpKSB7XG4gICAgICAgIGlmIChhY3R1YWxEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhlIGFjdHVhbCBkdXJhdGlvbiByZXBvcnRlZCBieSBSZWFjdCBpbmNsdWRlcyB0aW1lIHNwZW50IHdvcmtpbmcgb24gY2hpbGRyZW4uXG4gICAgICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgaW5mb3JtYXRpb24sIGJ1dCBpdCdzIGFsc28gdXNlZnVsIHRvIGJlIGFibGUgdG8gZXhjbHVkZSBjaGlsZCBkdXJhdGlvbnMuXG4gICAgICAgICAgLy8gVGhlIGZyb250ZW5kIGNhbid0IGNvbXB1dGUgdGhpcywgc2luY2UgdGhlIGltbWVkaWF0ZSBjaGlsZHJlbiBtYXkgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dC5cbiAgICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIGRvIHRoaXMgb24gdGhlIGJhY2tlbmQuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgY2FsY3VsYXRlZCBzZWxmIGR1cmF0aW9uIGlzIG5vdCB0aGUgc2FtZSB0aGluZyBhcyB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBUaGUgdHdvIGFyZSBjYWxjdWxhdGVkIGRpZmZlcmVudGx5ICh0cmVlIGR1cmF0aW9uIGRvZXMgbm90IGFjY3VtdWxhdGUpLlxuICAgICAgICAgIGxldCBzZWxmRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBsZXQgY2hpbGQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGZEdXJhdGlvbiAtPSBjaGlsZC5hY3R1YWxEdXJhdGlvbiB8fCAwO1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHByb2ZpbGluZyBpcyBhY3RpdmUsIHN0b3JlIGR1cmF0aW9ucyBmb3IgZWxlbWVudHMgdGhhdCB3ZXJlIHJlbmRlcmVkIGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBzaG91bGQgZG8gdGhpcyBmb3IgYW55IGZpYmVyIHdlIHBlcmZvcm1lZCB3b3JrIG9uLCByZWdhcmRsZXNzIG9mIGl0cyBhY3R1YWxEdXJhdGlvbiB2YWx1ZS5cbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzIGFjdHVhbER1cmF0aW9uIG1pZ2h0IGJlIDAgZm9yIGZpYmVycyB3ZSB3b3JrZWQgb24gKHBhcnRpY3VsYXJseSBpZiB3ZSdyZSB1c2luZyBEYXRlLm5vdylcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcyAoZS5nLiBNZW1vKSBhY3R1YWxEdXJhdGlvbiBtaWdodCBiZSBncmVhdGVyIHRoYW4gMCBldmVuIGlmIHdlIFwiYmFpbGVkIG91dFwiLlxuICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID1cbiAgICAgICAgICAgICgoY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhOiBhbnkpOiBDb21taXRQcm9maWxpbmdEYXRhKTtcbiAgICAgICAgICBtZXRhZGF0YS5kdXJhdGlvbnMucHVzaChpZCwgYWN0dWFsRHVyYXRpb24sIHNlbGZEdXJhdGlvbik7XG4gICAgICAgICAgbWV0YWRhdGEubWF4QWN0dWFsRHVyYXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgICAgIG1ldGFkYXRhLm1heEFjdHVhbER1cmF0aW9uLFxuICAgICAgICAgICAgYWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZURlc2NyaXB0aW9uID0gZ2V0Q2hhbmdlRGVzY3JpcHRpb24ocHJldkZpYmVyLCBmaWJlcik7XG4gICAgICAgICAgICBpZiAoY2hhbmdlRGVzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucy5zZXQoaWQsIGNoYW5nZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIEZpYmVyIHdhcyBpbiB0aGUgc2V0IG9mIG1lbW9pemVkVXBkYXRlcnMgd2UgbmVlZCB0byByZWNvcmRcbiAgICAgIC8vIGl0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY29tbWl0LlxuICAgICAgY29uc3QgZmliZXJSb290OiBGaWJlclJvb3QgPSBjdXJyZW50Um9vdC5kYXRhLnN0YXRlTm9kZTtcbiAgICAgIGNvbnN0IHVwZGF0ZXJzID0gZmliZXJSb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICBpZiAoXG4gICAgICAgIHVwZGF0ZXJzICE9IG51bGwgJiZcbiAgICAgICAgKHVwZGF0ZXJzLmhhcyhmaWJlcikgfHxcbiAgICAgICAgICAvLyBXZSBjaGVjayB0aGUgYWx0ZXJuYXRlIGhlcmUgYmVjYXVzZSB3ZSdyZSBtYXRjaGluZyBpZGVudGl0eSBhbmRcbiAgICAgICAgICAvLyBwcmV2RmliZXIgbWlnaHQgYmUgc2FtZSBhcyBmaWJlci5cbiAgICAgICAgICAoZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIHVwZGF0ZXJzLmhhcyhmaWJlci5hbHRlcm5hdGUpKSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9XG4gICAgICAgICAgKChjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGE6IGFueSk6IENvbW1pdFByb2ZpbGluZ0RhdGEpO1xuICAgICAgICBpZiAobWV0YWRhdGEudXBkYXRlcnMgPT09IG51bGwpIHtcbiAgICAgICAgICBtZXRhZGF0YS51cGRhdGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnVwZGF0ZXJzLnB1c2goaW5zdGFuY2VUb1NlcmlhbGl6ZWRFbGVtZW50KGZpYmVySW5zdGFuY2UpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRWaXJ0dWFsUHJvZmlsaW5nRHVyYXRpb25zKHZpcnR1YWxJbnN0YW5jZTogVmlydHVhbEluc3RhbmNlKSB7XG4gICAgY29uc3QgaWQgPSB2aXJ0dWFsSW5zdGFuY2UuaWQ7XG5cbiAgICBsZXQgdHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgLy8gQWRkIHVwIHRoZSBiYXNlIGR1cmF0aW9uIG9mIHRoZSBjaGlsZCBpbnN0YW5jZXMuIFRoZSB2aXJ0dWFsIGJhc2UgZHVyYXRpb25cbiAgICAvLyB3aWxsIGJlIHRoZSBzYW1lIGFzIGNoaWxkcmVuJ3MgZHVyYXRpb24gc2luY2Ugd2UgZG9uJ3QgdGFrZSB1cCBhbnkgcmVuZGVyXG4gICAgLy8gdGltZSBpbiB0aGUgdmlydHVhbCBpbnN0YW5jZS5cbiAgICBmb3IgKFxuICAgICAgbGV0IGNoaWxkID0gdmlydHVhbEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICBjaGlsZCAhPT0gbnVsbDtcbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmdcbiAgICApIHtcbiAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVHJlZUJhc2VEdXJhdGlvbiA9IHZpcnR1YWxJbnN0YW5jZS50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgaWYgKHRyZWVCYXNlRHVyYXRpb24gIT09IHByZXZpb3VzVHJlZUJhc2VEdXJhdGlvbikge1xuICAgICAgICAvLyBUcmVlIGJhc2UgZHVyYXRpb24gdXBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhlIG9wZXJhdGlvbnMgdHlwZWQgYXJyYXkuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gY29udmVydCB0aGVtIGZyb20gbWlsbGlzZWNvbmRzIHRvIG1pY3Jvc2Vjb25kcyBzbyB3ZSBjYW4gc2VuZCB0aGVtIGFzIGludHMuXG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFRyZWVCYXNlRHVyYXRpb24gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICh0cmVlQmFzZUR1cmF0aW9uIHx8IDApICogMTAwMCxcbiAgICAgICAgKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OKTtcbiAgICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oY29udmVydGVkVHJlZUJhc2VEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlydHVhbEluc3RhbmNlLnRyZWVCYXNlRHVyYXRpb24gPSB0cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUmVzZXRDaGlsZHJlbihcbiAgICBwYXJlbnRJbnN0YW5jZTogRmliZXJJbnN0YW5jZSB8IFZpcnR1YWxJbnN0YW5jZSxcbiAgKSB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgaWYgKHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ3JlY29yZFJlc2V0Q2hpbGRyZW4oKScsXG4gICAgICAgICAgcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZCxcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlIGZyb250ZW5kIG9ubHkgcmVhbGx5IGNhcmVzIGFib3V0IHRoZSBkaXNwbGF5TmFtZSwga2V5LCBhbmQgY2hpbGRyZW4uXG4gICAgLy8gVGhlIGZpcnN0IHR3byBkb24ndCByZWFsbHkgY2hhbmdlLCBzbyB3ZSBhcmUgb25seSBjb25jZXJuZWQgd2l0aCB0aGUgb3JkZXIgb2YgY2hpbGRyZW4gaGVyZS5cbiAgICAvLyBUaGlzIGlzIHRyaWNraWVyIHRoYW4gYSBzaW1wbGUgY29tcGFyaXNvbiB0aG91Z2gsIHNpbmNlIGNlcnRhaW4gdHlwZXMgb2YgZmliZXJzIGFyZSBmaWx0ZXJlZC5cbiAgICBjb25zdCBuZXh0Q2hpbGRyZW46IEFycmF5PG51bWJlcj4gPSBbXTtcblxuICAgIGxldCBjaGlsZDogbnVsbCB8IERldlRvb2xzSW5zdGFuY2UgPSBwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLmtpbmQgPT09IEZJTFRFUkVEX0ZJQkVSX0lOU1RBTkNFKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgbGV0IGlubmVyQ2hpbGQ6IG51bGwgfCBEZXZUb29sc0luc3RhbmNlID0gcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZDtcbiAgICAgICAgICBpbm5lckNoaWxkICE9PSBudWxsO1xuICAgICAgICAgIGlubmVyQ2hpbGQgPSBpbm5lckNoaWxkLm5leHRTaWJsaW5nXG4gICAgICAgICkge1xuICAgICAgICAgIG5leHRDaGlsZHJlbi5wdXNoKChpbm5lckNoaWxkOiBhbnkpLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dENoaWxkcmVuLnB1c2goY2hpbGQuaWQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICB9XG5cbiAgICBjb25zdCBudW1DaGlsZHJlbiA9IG5leHRDaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKG51bUNoaWxkcmVuIDwgMikge1xuICAgICAgLy8gTm8gbmVlZCB0byByZW9yZGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdXNoT3BlcmF0aW9uKFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4pO1xuICAgIHB1c2hPcGVyYXRpb24ocGFyZW50SW5zdGFuY2UuaWQpO1xuICAgIHB1c2hPcGVyYXRpb24obnVtQ2hpbGRyZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwdXNoT3BlcmF0aW9uKG5leHRDaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVmlydHVhbEluc3RhbmNlUmVjdXJzaXZlbHkoXG4gICAgdmlydHVhbEluc3RhbmNlOiBWaXJ0dWFsSW5zdGFuY2UsXG4gICAgbmV4dEZpcnN0Q2hpbGQ6IEZpYmVyLFxuICAgIG5leHRMYXN0Q2hpbGQ6IG51bGwgfCBGaWJlciwgLy8gbm9uLWluY2x1c2l2ZVxuICAgIHByZXZGaXJzdENoaWxkOiBudWxsIHwgRmliZXIsXG4gICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZTogYm9vbGVhbixcbiAgICB2aXJ0dWFsTGV2ZWw6IG51bWJlciwgLy8gdGhlIG50aCBsZXZlbCBvZiB2aXJ0dWFsIGluc3RhbmNlc1xuICApOiB2b2lkIHtcbiAgICBjb25zdCBzdGFzaGVkUGFyZW50ID0gcmVjb25jaWxpbmdQYXJlbnQ7XG4gICAgY29uc3Qgc3Rhc2hlZFByZXZpb3VzID0gcHJldmlvdXNseVJlY29uY2lsZWRTaWJsaW5nO1xuICAgIGNvbnN0IHN0YXNoZWRSZW1haW5pbmcgPSByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuO1xuICAgIC8vIFB1c2ggYSBuZXcgRGV2VG9vbHMgaW5zdGFuY2UgcGFyZW50IHdoaWxlIHJlY29uY2lsaW5nIHRoaXMgc3VidHJlZS5cbiAgICByZWNvbmNpbGluZ1BhcmVudCA9IHZpcnR1YWxJbnN0YW5jZTtcbiAgICBwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmcgPSBudWxsO1xuICAgIC8vIE1vdmUgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIGluc3RhbmNlIHRvIHRoZSByZW1haW5pbmcgc2V0LlxuICAgIC8vIFdlJ2xsIG1vdmUgdGhlbSBiYWNrIG9uZSBieSBvbmUsIGFuZCBhbnl0aGluZyB0aGF0IHJlbWFpbnMgaXMgZGVsZXRlZC5cbiAgICByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuID0gdmlydHVhbEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgdmlydHVhbEluc3RhbmNlLmZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBpZiAoXG4gICAgICAgIHVwZGF0ZVZpcnR1YWxDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgICAgICAgIG5leHRGaXJzdENoaWxkLFxuICAgICAgICAgIG5leHRMYXN0Q2hpbGQsXG4gICAgICAgICAgcHJldkZpcnN0Q2hpbGQsXG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICB2aXJ0dWFsTGV2ZWwgKyAxLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmVjb3JkUmVzZXRDaGlsZHJlbih2aXJ0dWFsSW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIHRoZSBlcnJvcnMvd2FybmluZ3MgY291bnQuIElmIHRoaXMgSW5zdGFuY2UgaGFzIHN3aXRjaGVkIHRvIGEgZGlmZmVyZW50XG4gICAgICAvLyBSZWFjdENvbXBvbmVudEluZm8gaW5zdGFuY2UsIHN1Y2ggYXMgd2hlbiByZWZyZXNoaW5nIFNlcnZlciBDb21wb25lbnRzLCB0aGVuXG4gICAgICAvLyB3ZSByZXBsYWNlIGFsbCB0aGUgcHJldmlvdXMgbG9ncyB3aXRoIHRoZSBvbmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbmV3IG9uZXMgcmF0aGVyXG4gICAgICAvLyB0aGFuIG1lcmdpbmcuIEJlY2F1c2UgZGVkdXBpbmcgaXMgZXhwZWN0ZWQgdG8gaGFwcGVuIGF0IHRoZSByZXF1ZXN0IGxldmVsLlxuICAgICAgY29uc3QgY29tcG9uZW50TG9nc0VudHJ5ID0gY29tcG9uZW50SW5mb1RvQ29tcG9uZW50TG9nc01hcC5nZXQoXG4gICAgICAgIHZpcnR1YWxJbnN0YW5jZS5kYXRhLFxuICAgICAgKTtcbiAgICAgIHJlY29yZENvbnNvbGVMb2dzKHZpcnR1YWxJbnN0YW5jZSwgY29tcG9uZW50TG9nc0VudHJ5KTtcbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGFmdGVyIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gYXBwZW5kZWQuXG4gICAgICByZWNvcmRWaXJ0dWFsUHJvZmlsaW5nRHVyYXRpb25zKHZpcnR1YWxJbnN0YW5jZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubW91bnRSZW1haW5pbmdDaGlsZHJlbigpO1xuICAgICAgcmVjb25jaWxpbmdQYXJlbnQgPSBzdGFzaGVkUGFyZW50O1xuICAgICAgcHJldmlvdXNseVJlY29uY2lsZWRTaWJsaW5nID0gc3Rhc2hlZFByZXZpb3VzO1xuICAgICAgcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbiA9IHN0YXNoZWRSZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVmlydHVhbENoaWxkcmVuUmVjdXJzaXZlbHkoXG4gICAgbmV4dEZpcnN0Q2hpbGQ6IEZpYmVyLFxuICAgIG5leHRMYXN0Q2hpbGQ6IG51bGwgfCBGaWJlciwgLy8gbm9uLWluY2x1c2l2ZVxuICAgIHByZXZGaXJzdENoaWxkOiBudWxsIHwgRmliZXIsXG4gICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZTogYm9vbGVhbixcbiAgICB2aXJ0dWFsTGV2ZWw6IG51bWJlciwgLy8gdGhlIG50aCBsZXZlbCBvZiB2aXJ0dWFsIGluc3RhbmNlc1xuICApOiBib29sZWFuIHtcbiAgICBsZXQgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IGZhbHNlO1xuICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBpcyBkaWZmZXJlbnQsIHdlIG5lZWQgdG8gdHJhdmVyc2UgdGhlbS5cbiAgICAvLyBFYWNoIG5leHQgY2hpbGQgd2lsbCBiZSBlaXRoZXIgYSBuZXcgY2hpbGQgKG1vdW50KSBvciBhbiBhbHRlcm5hdGUgKHVwZGF0ZSkuXG4gICAgbGV0IG5leHRDaGlsZDogbnVsbCB8IEZpYmVyID0gbmV4dEZpcnN0Q2hpbGQ7XG4gICAgbGV0IHByZXZDaGlsZEF0U2FtZUluZGV4ID0gcHJldkZpcnN0Q2hpbGQ7XG4gICAgbGV0IHByZXZpb3VzVmlydHVhbEluc3RhbmNlOiBudWxsIHwgVmlydHVhbEluc3RhbmNlID0gbnVsbDtcbiAgICBsZXQgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VXYXNNb3VudDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGxldCBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZU5leHRGaXJzdEZpYmVyOiBGaWJlciA9IG5leHRGaXJzdENoaWxkO1xuICAgIGxldCBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZVByZXZGaXJzdEZpYmVyOiBudWxsIHwgRmliZXIgPSBwcmV2Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobmV4dENoaWxkICE9PSBudWxsICYmIG5leHRDaGlsZCAhPT0gbmV4dExhc3RDaGlsZCkge1xuICAgICAgbGV0IGxldmVsID0gMDtcbiAgICAgIGlmIChuZXh0Q2hpbGQuX2RlYnVnSW5mbykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRDaGlsZC5fZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZGVidWdFbnRyeSA9IG5leHRDaGlsZC5fZGVidWdJbmZvW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGVidWdFbnRyeS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gTm90IGEgQ29tcG9uZW50LiBTb21lIG90aGVyIERlYnVnIEluZm8uXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50SW5mbzogUmVhY3RDb21wb25lbnRJbmZvID0gKGRlYnVnRW50cnk6IGFueSk7XG4gICAgICAgICAgY29uc3Qgc2Vjb25kYXJ5RW52ID0gZ2V0U2Vjb25kYXJ5RW52aXJvbm1lbnROYW1lKFxuICAgICAgICAgICAgbmV4dENoaWxkLl9kZWJ1Z0luZm8sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudEluZm8uZW52ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duRW52aXJvbm1lbnROYW1lcy5hZGQoY29tcG9uZW50SW5mby5lbnYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5RW52ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bkVudmlyb25tZW50TmFtZXMuYWRkKHNlY29uZGFyeUVudik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRGaWx0ZXJWaXJ0dWFsKGNvbXBvbmVudEluZm8sIHNlY29uZGFyeUVudikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGV2ZWwgPT09IHZpcnR1YWxMZXZlbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAvLyBDb25zZWN1dGl2ZSBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGRlYnVnIGVudHJ5IGFzIGEgcGFyZW50IGdldHNcbiAgICAgICAgICAgICAgLy8gdHJlYXRlZCBhcyBpZiB0aGV5IHNoYXJlIHRoZSBzYW1lIHZpcnR1YWwgaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlLmRhdGEgIT09IGNvbXBvbmVudEluZm9cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAocHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3VudCBhbnkgcHJldmlvdXMgY2hpbGRyZW4gdGhhdCBzaG91bGQgZ28gaW50byB0aGUgcHJldmlvdXMgcGFyZW50LlxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZVdhc01vdW50KSB7XG4gICAgICAgICAgICAgICAgICBtb3VudFZpcnR1YWxJbnN0YW5jZVJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VOZXh0Rmlyc3RGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsTGV2ZWwsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVWaXJ0dWFsSW5zdGFuY2VSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlTmV4dEZpcnN0RmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VQcmV2Rmlyc3RGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmlydHVhbExldmVsLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHByZXZpb3VzU2libGluZ09mQmVzdE1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW47XG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnRJbmZvLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBrZXkgdHJ5IHRvIGZpbmQgYSBtYXRjaGluZyBrZXkgaW4gdGhlIHNldC5cbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHdoaWxlIChiZXN0TWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmtpbmQgPT09IFZJUlRVQUxfSU5TVEFOQ0UgJiZcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmRhdGEua2V5ID09PSBjb21wb25lbnRJbmZvLmtleVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nT2ZCZXN0TWF0Y2ggPSBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBiZXN0TWF0Y2gubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2gua2luZCA9PT0gVklSVFVBTF9JTlNUQU5DRSAmJlxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5kYXRhLm5hbWUgPT09IGNvbXBvbmVudEluZm8ubmFtZSAmJlxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5kYXRhLmVudiA9PT0gY29tcG9uZW50SW5mby5lbnYgJiZcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZGF0YS5rZXkgPT09IGNvbXBvbmVudEluZm8ua2V5XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGlsZHJlbiBoYWQgYSB2aXJ0dWFsIGluc3RhbmNlIGluIHRoZSBzYW1lIHNsb3RcbiAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZW4gd2UgY2xhaW0gaXQgYW5kIHJldXNlIGl0IGZvciB0aGlzIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaXQgd2l0aCB0aGUgbGF0ZXN0IGVudHJ5LlxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5kYXRhID0gY29tcG9uZW50SW5mbztcbiAgICAgICAgICAgICAgICBtb3ZlQ2hpbGQoYmVzdE1hdGNoLCBwcmV2aW91c1NpYmxpbmdPZkJlc3RNYXRjaCk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UgPSBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VXYXNNb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmlydHVhbEluc3RhbmNlID0gY3JlYXRlVmlydHVhbEluc3RhbmNlKGNvbXBvbmVudEluZm8pO1xuICAgICAgICAgICAgICAgIHJlY29yZFZpcnR1YWxNb3VudChcbiAgICAgICAgICAgICAgICAgIG5ld1ZpcnR1YWxJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIHJlY29uY2lsaW5nUGFyZW50LFxuICAgICAgICAgICAgICAgICAgc2Vjb25kYXJ5RW52LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobmV3VmlydHVhbEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSA9IG5ld1ZpcnR1YWxJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZVdhc01vdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBFeGlzdGluZyBjaGlsZHJlbiBtaWdodCBiZSByZXBhcmVudGVkIGludG8gdGhpcyBuZXcgdmlydHVhbCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyB3aWxsIGNhdXNlIHRoZSBmcm9udCBlbmQgdG8gZXJyb3Igd2hpY2ggbmVlZHMgdG8gYmUgZml4ZWQuXG4gICAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlTmV4dEZpcnN0RmliZXIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlUHJldkZpcnN0RmliZXIgPSBwcmV2Q2hpbGRBdFNhbWVJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA9PT0gdmlydHVhbExldmVsKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIHdlcmUgd29ya2luZyBvbiBhIHZpcnR1YWwgaW5zdGFuY2UgYW5kIHRoaXMgaXMgbm90IGEgdmlydHVhbFxuICAgICAgICAgIC8vIGluc3RhbmNlLCB0aGVuIHdlIGVuZCB0aGUgc2VxdWVuY2UgYW5kIHVwZGF0ZSBhbnkgcHJldmlvdXMgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHNob3VsZCBnbyBpbnRvIHRoZSBwcmV2aW91cyB2aXJ0dWFsIGluc3RhbmNlLlxuICAgICAgICAgIGlmIChwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZVdhc01vdW50KSB7XG4gICAgICAgICAgICBtb3VudFZpcnR1YWxJbnN0YW5jZVJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgICBwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZSxcbiAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VOZXh0Rmlyc3RGaWJlcixcbiAgICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICAgICB2aXJ0dWFsTGV2ZWwsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVWaXJ0dWFsSW5zdGFuY2VSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UsXG4gICAgICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlTmV4dEZpcnN0RmliZXIsXG4gICAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VQcmV2Rmlyc3RGaWJlcixcbiAgICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICAgICAgdmlydHVhbExldmVsLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSB2aXJ0dWFsIGxldmVscywgYnV0IG5vdCBiZXlvbmQsXG4gICAgICAgIC8vIGFuZCBub3cgY29udGludWUgd2l0aCB0aGUgcmVndWxhciBmaWJlci5cblxuICAgICAgICAvLyBEbyBhIGZhc3QgcGFzcyBvdmVyIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gZmluZCB0aGUgcHJldmlvdXMgaW5zdGFuY2UuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgZG9lc24ndCBoYXZlIHRoZSBiZXN0IE8obikgZm9yIGEgbGFyZ2Ugc2V0IG9mIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAgIC8vIHJlb3JkZXJlZC4gQ29uc2lkZXIgdXNpbmcgYSB0ZW1wb3JhcnkgbWFwIGlmIGl0J3Mgbm90IHRoZSB2ZXJ5IG5leHQgb25lLlxuICAgICAgICBsZXQgcHJldkNoaWxkO1xuICAgICAgICBpZiAocHJldkNoaWxkQXRTYW1lSW5kZXggPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIC8vIFRoaXMgc2V0IGlzIHVuY2hhbmdlZC4gV2UncmUganVzdCBnb2luZyB0aHJvdWdoIGl0IHRvIHBsYWNlIGFsbCB0aGVcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhZ2Fpbi5cbiAgICAgICAgICBwcmV2Q2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0byByZWx5IG9uIHRoZSBhbHRlcm5hdGUgaGVyZS4gV2UgY291bGQgYWxzb1xuICAgICAgICAgIC8vIHJlY29uY2lsZSBhZ2FpbnN0IHN0YXRlTm9kZSwga2V5IG9yIHdoYXRldmVyLiBEb2Vzbid0IGhhdmUgdG8gYmUgc2FtZVxuICAgICAgICAgIC8vIEZpYmVyIHBhaXIuXG4gICAgICAgICAgcHJldkNoaWxkID0gbmV4dENoaWxkLmFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldmlvdXNTaWJsaW5nT2ZFeGlzdGluZ0luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgbGV0IGV4aXN0aW5nSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAocHJldkNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgZXhpc3RpbmdJbnN0YW5jZSA9IHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW47XG4gICAgICAgICAgd2hpbGUgKGV4aXN0aW5nSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlLmRhdGEgPT09IHByZXZDaGlsZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzU2libGluZ09mRXhpc3RpbmdJbnN0YW5jZSA9IGV4aXN0aW5nSW5zdGFuY2U7XG4gICAgICAgICAgICBleGlzdGluZ0luc3RhbmNlID0gZXhpc3RpbmdJbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0aW5nSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBDb21tb24gY2FzZS4gTWF0Y2ggaW4gdGhlIHNhbWUgcGFyZW50LlxuICAgICAgICAgIGNvbnN0IGZpYmVySW5zdGFuY2U6IEZpYmVySW5zdGFuY2UgPSAoZXhpc3RpbmdJbnN0YW5jZTogYW55KTsgLy8gT25seSBtYXRjaGVzIGlmIGl0J3MgYSBGaWJlci5cblxuICAgICAgICAgIC8vIFdlIGtlZXAgdHJhY2sgaWYgdGhlIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBtYXRjaGVzIHRoZSBwcmV2aW91cyBvcmRlci5cbiAgICAgICAgICAvLyBUaGV5IGFyZSBhbHdheXMgZGlmZmVyZW50IHJlZmVyZW50aWFsbHksIGJ1dCBpZiB0aGUgaW5zdGFuY2VzIGxpbmUgdXBcbiAgICAgICAgICAvLyBjb25jZXB0dWFsbHkgd2UnbGwgd2FudCB0byBrbm93IHRoYXQuXG4gICAgICAgICAgaWYgKHByZXZDaGlsZCAhPT0gcHJldkNoaWxkQXRTYW1lSW5kZXgpIHtcbiAgICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vdmVDaGlsZChmaWJlckluc3RhbmNlLCBwcmV2aW91c1NpYmxpbmdPZkV4aXN0aW5nSW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdXBkYXRlRmliZXJSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgZmliZXJJbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgICAocHJldkNoaWxkOiBhbnkpLFxuICAgICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgYSBuZXN0ZWQgdHJlZSBjaGlsZCBvcmRlciBjaGFuZ2VkIGJ1dCBpdCBjYW4ndCBoYW5kbGUgaXRzIG93blxuICAgICAgICAgICAgLy8gY2hpbGQgb3JkZXIgaW52YWxpZGF0aW9uIChlLmcuIGJlY2F1c2UgaXQncyBmaWx0ZXJlZCBvdXQgbGlrZSBob3N0IG5vZGVzKSxcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSB0aGUgbmVlZCB0byByZXNldCBjaGlsZCBvcmRlciB1cHdhcmRzIHRvIHRoaXMgRmliZXIuXG4gICAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJldkNoaWxkICE9PSBudWxsICYmIHNob3VsZEZpbHRlckZpYmVyKG5leHRDaGlsZCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIEZpYmVyIHNob3VsZCBiZSBmaWx0ZXJlZCwgd2UgbmVlZCB0byBzdGlsbCB1cGRhdGUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgIC8vIFRoaXMgcmVsaWVzIG9uIGFuIGFsdGVybmF0ZSBzaW5jZSB3ZSBkb24ndCBoYXZlIGFuIEluc3RhbmNlIHdpdGggdGhlIHByZXZpb3VzXG4gICAgICAgICAgLy8gY2hpbGQgb24gaXQuIElkZWFsbHksIHRoZSByZWNvbmNpbGlhdGlvbiB3b3VsZG4ndCBuZWVkIHByZXZpb3VzIEZpYmVycyB0aGF0XG4gICAgICAgICAgLy8gYXJlIGZpbHRlcmVkIGZyb20gdGhlIHRyZWUuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdXBkYXRlRmliZXJSZWN1cnNpdmVseShcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgYSBGaWJlckluc3RhbmNlIHRvIGJlIHJlcGFyZW50ZWQgd2hlbiB2aXJ0dWFsIHBhcmVudHNcbiAgICAgICAgICAvLyBnZXQgdGhlaXIgc2VxdWVuY2Ugc3BsaXQgb3IgY2hhbmdlIHN0cnVjdHVyZSB3aXRoIHRoZSBzYW1lIHJlbmRlciByZXN1bHQuXG4gICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIHVubW91bnQgdGhlIGFuZCByZW1vdW50IHRoZSBGaWJlckluc3RhbmNlcy5cbiAgICAgICAgICAvLyBUaGlzIG1pZ2h0IGNhdXNlIHVzIHRvIGxvc2UgdGhlIHNlbGVjdGlvbiBidXQgaXQncyBhbiBlZGdlIGNhc2UuXG5cbiAgICAgICAgICAvLyBXZSBsZXQgdGhlIHByZXZpb3VzIGluc3RhbmNlIHJlbWFpbiBpbiB0aGUgXCJyZW1haW5pbmcgcXVldWVcIiBpdCBpc1xuICAgICAgICAgIC8vIGluIHRvIGJlIGRlbGV0ZWQgYXQgdGhlIGVuZCBzaW5jZSBpdCdsbCBoYXZlIG5vIG1hdGNoLlxuXG4gICAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KG5leHRDaGlsZCwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICAgICAgLy8gTmVlZCB0byBtYXJrIHRoZSBwYXJlbnQgc2V0IHRvIHJlbW91bnQgdGhlIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVHJ5IHRoZSBuZXh0IGNoaWxkLlxuICAgICAgbmV4dENoaWxkID0gbmV4dENoaWxkLnNpYmxpbmc7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBwb2ludGVyIGluIHRoZSBwcmV2aW91cyBsaXN0IHNvIHRoYXQgd2UgY2FuXG4gICAgICAvLyBrZWVwIGNvbXBhcmluZyBpZiB0aGV5IGxpbmUgdXAuXG4gICAgICBpZiAoIXNob3VsZFJlc2V0Q2hpbGRyZW4gJiYgcHJldkNoaWxkQXRTYW1lSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgcHJldkNoaWxkQXRTYW1lSW5kZXggPSBwcmV2Q2hpbGRBdFNhbWVJbmRleC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmV2aW91c1ZpcnR1YWxJbnN0YW5jZVdhc01vdW50KSB7XG4gICAgICAgIG1vdW50VmlydHVhbEluc3RhbmNlUmVjdXJzaXZlbHkoXG4gICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UsXG4gICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VOZXh0Rmlyc3RGaWJlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgdmlydHVhbExldmVsLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlVmlydHVhbEluc3RhbmNlUmVjdXJzaXZlbHkoXG4gICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2UsXG4gICAgICAgICAgcHJldmlvdXNWaXJ0dWFsSW5zdGFuY2VOZXh0Rmlyc3RGaWJlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHByZXZpb3VzVmlydHVhbEluc3RhbmNlUHJldkZpcnN0RmliZXIsXG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICB2aXJ0dWFsTGV2ZWwsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgbm8gbW9yZSBjaGlsZHJlbiwgYnV0IHVzZWQgdG8sIHRoZXkgZG9uJ3QgbGluZSB1cC5cbiAgICBpZiAocHJldkNoaWxkQXRTYW1lSW5kZXggIT09IG51bGwpIHtcbiAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkUmVzZXRDaGlsZHJlbjtcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciBjbG9zZXN0IHVuZmlsdGVyZWQgZmliZXIgcGFyZW50IG5lZWRzIHRvIHJlc2V0IGl0cyBjaGlsZCBsaXN0LlxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgIG5leHRGaXJzdENoaWxkOiBudWxsIHwgRmliZXIsXG4gICAgcHJldkZpcnN0Q2hpbGQ6IG51bGwgfCBGaWJlcixcbiAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlOiBib29sZWFuLFxuICApOiBib29sZWFuIHtcbiAgICBpZiAobmV4dEZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBwcmV2Rmlyc3RDaGlsZCAhPT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZVZpcnR1YWxDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgICAgbmV4dEZpcnN0Q2hpbGQsXG4gICAgICBudWxsLFxuICAgICAgcHJldkZpcnN0Q2hpbGQsXG4gICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgMCxcbiAgICApO1xuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGNsb3Nlc3QgdW5maWx0ZXJlZCBmaWJlciBwYXJlbnQgbmVlZHMgdG8gcmVzZXQgaXRzIGNoaWxkIGxpc3QuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkoXG4gICAgZmliZXJJbnN0YW5jZTogbnVsbCB8IEZpYmVySW5zdGFuY2UsIC8vIG51bGwgaWYgdGhpcyBzaG91bGQgYmUgZmlsdGVyZWRcbiAgICBuZXh0RmliZXI6IEZpYmVyLFxuICAgIHByZXZGaWJlcjogRmliZXIsXG4gICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZTogYm9vbGVhbixcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgaWYgKGZpYmVySW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZGVidWcoJ3VwZGF0ZUZpYmVyUmVjdXJzaXZlbHkoKScsIGZpYmVySW5zdGFuY2UsIHJlY29uY2lsaW5nUGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKG5leHRGaWJlcik7XG4gICAgICBpZiAodHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAvLyBJZiBhbiBhbmNlc3RvciB1cGRhdGVkLCB3ZSBzaG91bGQgbWFyayB0aGUgbmVhcmVzdCBob3N0IG5vZGVzIGZvciBoaWdobGlnaHRpbmcuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgICAgdHJhY2VVcGRhdGVzRm9yTm9kZXMuYWRkKG5leHRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVsZW1lbnRUeXBlID09PSBFbGVtZW50VHlwZUZ1bmN0aW9uIHx8XG4gICAgICAgICAgZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlQ2xhc3MgfHxcbiAgICAgICAgICBlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVDb250ZXh0IHx8XG4gICAgICAgICAgZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlTWVtbyB8fFxuICAgICAgICAgIGVsZW1lbnRUeXBlID09PSBFbGVtZW50VHlwZUZvcndhcmRSZWZcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHRoaXMgaXMgYSB0cmFjZWQgYW5jZXN0b3IsIGZsYWcgZm9yIHRoZSBuZWFyZXN0IGhvc3QgZGVzY2VuZGFudChzKS5cbiAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlID0gZGlkRmliZXJSZW5kZXIoXG4gICAgICAgICAgICBwcmV2RmliZXIsXG4gICAgICAgICAgICBuZXh0RmliZXIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXNoZWRQYXJlbnQgPSByZWNvbmNpbGluZ1BhcmVudDtcbiAgICBjb25zdCBzdGFzaGVkUHJldmlvdXMgPSBwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmc7XG4gICAgY29uc3Qgc3Rhc2hlZFJlbWFpbmluZyA9IHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW47XG4gICAgaWYgKGZpYmVySW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgRmliZXIgc28gd2UgdGhhdCB3ZSBhbHdheXMga2VlcCB0aGUgY3VycmVudCBGaWJlciBvbiB0aGUgZGF0YS5cbiAgICAgIGZpYmVySW5zdGFuY2UuZGF0YSA9IG5leHRGaWJlcjtcbiAgICAgIGlmIChcbiAgICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCAmJlxuICAgICAgICBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LmlkID09PSBmaWJlckluc3RhbmNlLmlkICYmXG4gICAgICAgIGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgbmV4dEZpYmVyKVxuICAgICAgKSB7XG4gICAgICAgIC8vIElmIHRoaXMgRmliZXIgaGFzIHVwZGF0ZWQsIGNsZWFyIGNhY2hlZCBpbnNwZWN0ZWQgZGF0YS5cbiAgICAgICAgLy8gSWYgaXQgaXMgaW5zcGVjdGVkIGFnYWluLCBpdCBtYXkgbmVlZCB0byBiZSByZS1ydW4gdG8gb2J0YWluIHVwZGF0ZWQgaG9va3MgdmFsdWVzLlxuICAgICAgICBoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBQdXNoIGEgbmV3IERldlRvb2xzIGluc3RhbmNlIHBhcmVudCB3aGlsZSByZWNvbmNpbGluZyB0aGlzIHN1YnRyZWUuXG4gICAgICByZWNvbmNpbGluZ1BhcmVudCA9IGZpYmVySW5zdGFuY2U7XG4gICAgICBwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmcgPSBudWxsO1xuICAgICAgLy8gTW92ZSBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoaXMgaW5zdGFuY2UgdG8gdGhlIHJlbWFpbmluZyBzZXQuXG4gICAgICAvLyBXZSdsbCBtb3ZlIHRoZW0gYmFjayBvbmUgYnkgb25lLCBhbmQgYW55dGhpbmcgdGhhdCByZW1haW5zIGlzIGRlbGV0ZWQuXG4gICAgICByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuID0gZmliZXJJbnN0YW5jZS5maXJzdENoaWxkO1xuICAgICAgZmliZXJJbnN0YW5jZS5maXJzdENoaWxkID0gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuZXh0RmliZXIudGFnID09PSBIb3N0SG9pc3RhYmxlKSB7XG4gICAgICAgIGNvbnN0IG5lYXJlc3RJbnN0YW5jZSA9IHJlY29uY2lsaW5nUGFyZW50O1xuICAgICAgICBpZiAobmVhcmVzdEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGV4cGVjdCBhIGhvc3QgaG9pc3RhYmxlIHRvIGJlIHRoZSByb290Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZUhvc3RSZXNvdXJjZShuZWFyZXN0SW5zdGFuY2UsIHByZXZGaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgYXF1aXJlSG9zdFJlc291cmNlKG5lYXJlc3RJbnN0YW5jZSwgbmV4dEZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc1N1c3BlbnNlID0gbmV4dEZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQ7XG4gICAgICBsZXQgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgLy8gVGhlIGJlaGF2aW9yIG9mIHRpbWVkLW91dCBTdXNwZW5zZSB0cmVlcyBpcyB1bmlxdWUuXG4gICAgICAvLyBSYXRoZXIgdGhhbiB1bm1vdW50IHRoZSB0aW1lZCBvdXQgY29udGVudCAoYW5kIHBvc3NpYmx5IGxvc2UgaW1wb3J0YW50IHN0YXRlKSxcbiAgICAgIC8vIFJlYWN0IHJlLXBhcmVudHMgdGhpcyBjb250ZW50IHdpdGhpbiBhIGhpZGRlbiBGcmFnbWVudCB3aGlsZSB0aGUgZmFsbGJhY2sgaXMgc2hvd2luZy5cbiAgICAgIC8vIFRoaXMgYmVoYXZpb3IgZG9lc24ndCBuZWVkIHRvIGJlIG9ic2VydmFibGUgaW4gdGhlIERldlRvb2xzIHRob3VnaC5cbiAgICAgIC8vIEl0IG1pZ2h0IGV2ZW4gcmVzdWx0IGluIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSBmb3IgZS5nLiBub2RlIHNlbGVjdGlvbiBpbiB0aGUgRWxlbWVudHMgcGFuZWwuXG4gICAgICAvLyBUaGUgZWFzaWVzdCBmaXggaXMgdG8gc3RyaXAgb3V0IHRoZSBpbnRlcm1lZGlhdGUgRnJhZ21lbnQgZmliZXJzLFxuICAgICAgLy8gc28gdGhlIEVsZW1lbnRzIHBhbmVsIGFuZCBQcm9maWxlciBkb24ndCBuZWVkIHRvIHNwZWNpYWwgY2FzZSB0aGVtLlxuICAgICAgLy8gU3VzcGVuc2UgY29tcG9uZW50cyBvbmx5IGhhdmUgYSBub24tbnVsbCBtZW1vaXplZFN0YXRlIGlmIHRoZXkncmUgdGltZWQtb3V0LlxuICAgICAgY29uc3QgcHJldkRpZFRpbWVvdXQgPSBpc1N1c3BlbnNlICYmIHByZXZGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgY29uc3QgbmV4dERpZFRpbWVPdXQgPSBpc1N1c3BlbnNlICYmIG5leHRGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgLy8gVGhlIGxvZ2ljIGJlbG93IGlzIGluc3BpcmVkIGJ5IHRoZSBjb2RlIHBhdGhzIGluIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KClcbiAgICAgIC8vIGluc2lkZSBSZWFjdEZpYmVyQmVnaW5Xb3JrIGluIHRoZSBSZWFjdCBzb3VyY2UgY29kZS5cbiAgICAgIGlmIChwcmV2RGlkVGltZW91dCAmJiBuZXh0RGlkVGltZU91dCkge1xuICAgICAgICAvLyBGYWxsYmFjayAtPiBGYWxsYmFjazpcbiAgICAgICAgLy8gMS4gUmVjb25jaWxlIGZhbGxiYWNrIHNldC5cbiAgICAgICAgY29uc3QgbmV4dEZpYmVyQ2hpbGQgPSBuZXh0RmliZXIuY2hpbGQ7XG4gICAgICAgIGNvbnN0IG5leHRGYWxsYmFja0NoaWxkU2V0ID0gbmV4dEZpYmVyQ2hpbGRcbiAgICAgICAgICA/IG5leHRGaWJlckNoaWxkLnNpYmxpbmdcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIC8vIE5vdGU6IFdlIGNhbid0IHVzZSBuZXh0RmliZXIuY2hpbGQuc2libGluZy5hbHRlcm5hdGVcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgc2V0IGlzIHNwZWNpYWwgYW5kIGFsdGVybmF0ZSBtYXkgbm90IGV4aXN0LlxuICAgICAgICBjb25zdCBwcmV2RmliZXJDaGlsZCA9IHByZXZGaWJlci5jaGlsZDtcbiAgICAgICAgY29uc3QgcHJldkZhbGxiYWNrQ2hpbGRTZXQgPSBwcmV2RmliZXJDaGlsZFxuICAgICAgICAgID8gcHJldkZpYmVyQ2hpbGQuc2libGluZ1xuICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBpZiAocHJldkZhbGxiYWNrQ2hpbGRTZXQgPT0gbnVsbCAmJiBuZXh0RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsKSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgbmV4dEZhbGxiYWNrQ2hpbGRTZXQsXG4gICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXh0RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsICYmXG4gICAgICAgICAgcHJldkZhbGxiYWNrQ2hpbGRTZXQgIT0gbnVsbCAmJlxuICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICBuZXh0RmFsbGJhY2tDaGlsZFNldCxcbiAgICAgICAgICAgIHByZXZGYWxsYmFja0NoaWxkU2V0LFxuICAgICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZEaWRUaW1lb3V0ICYmICFuZXh0RGlkVGltZU91dCkge1xuICAgICAgICAvLyBGYWxsYmFjayAtPiBQcmltYXJ5OlxuICAgICAgICAvLyAxLiBVbm1vdW50IGZhbGxiYWNrIHNldFxuICAgICAgICAvLyBOb3RlOiBkb24ndCBlbXVsYXRlIGZhbGxiYWNrIHVubW91bnQgYmVjYXVzZSBSZWFjdCBhY3R1YWxseSBkaWQgaXQuXG4gICAgICAgIC8vIDIuIE1vdW50IHByaW1hcnkgc2V0XG4gICAgICAgIGNvbnN0IG5leHRQcmltYXJ5Q2hpbGRTZXQgPSBuZXh0RmliZXIuY2hpbGQ7XG4gICAgICAgIGlmIChuZXh0UHJpbWFyeUNoaWxkU2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlblJlY3Vyc2l2ZWx5KFxuICAgICAgICAgICAgbmV4dFByaW1hcnlDaGlsZFNldCxcbiAgICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXByZXZEaWRUaW1lb3V0ICYmIG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAgIC8vIFByaW1hcnkgLT4gRmFsbGJhY2s6XG4gICAgICAgIC8vIDEuIEhpZGUgcHJpbWFyeSBzZXRcbiAgICAgICAgLy8gV2Ugc2ltcGx5IGRvbid0IHJlLWFkZCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4gYW5kIGxldFxuICAgICAgICAvLyB1bm1vdW50UmVtYWluaW5nQ2hpbGRyZW4oKSBoYW5kbGUgaXQuXG4gICAgICAgIC8vIDIuIE1vdW50IGZhbGxiYWNrIHNldFxuICAgICAgICBjb25zdCBuZXh0RmliZXJDaGlsZCA9IG5leHRGaWJlci5jaGlsZDtcbiAgICAgICAgY29uc3QgbmV4dEZhbGxiYWNrQ2hpbGRTZXQgPSBuZXh0RmliZXJDaGlsZFxuICAgICAgICAgID8gbmV4dEZpYmVyQ2hpbGQuc2libGluZ1xuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKG5leHRGYWxsYmFja0NoaWxkU2V0ICE9IG51bGwpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICBuZXh0RmFsbGJhY2tDaGlsZFNldCxcbiAgICAgICAgICAgIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29tbW9uIGNhc2U6IFByaW1hcnkgLT4gUHJpbWFyeS5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBjb2RlIHBhdGggYXMgZm9yIG5vbi1TdXNwZW5zZSBmaWJlcnMuXG4gICAgICAgIGlmIChuZXh0RmliZXIuY2hpbGQgIT09IHByZXZGaWJlci5jaGlsZCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICAgIG5leHRGaWJlci5jaGlsZCxcbiAgICAgICAgICAgICAgcHJldkZpYmVyLmNoaWxkLFxuICAgICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENoaWxkcmVuIGFyZSB1bmNoYW5nZWQuXG4gICAgICAgICAgaWYgKGZpYmVySW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEFsbCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHdpbGwgYmUgY2hpbGRyZW4gb2YgdGhpcyBzYW1lIGZpYmVyIHNvIHdlIGNhbiBqdXN0IHJldXNlIHRoZW0uXG4gICAgICAgICAgICAvLyBJLmUuIHdlIGp1c3QgcmVzdG9yZSB0aGVtIGJ5IHVuZG9pbmcgd2hhdCB3ZSBkaWQgYWJvdmUuXG4gICAgICAgICAgICBmaWJlckluc3RhbmNlLmZpcnN0Q2hpbGQgPSByZW1haW5pbmdSZWNvbmNpbGluZ0NoaWxkcmVuO1xuICAgICAgICAgICAgcmVtYWluaW5nUmVjb25jaWxpbmdDaGlsZHJlbiA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0cmFjZVVwZGF0ZXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHRyYWNpbmcgdXBkYXRlcyBhbmQgd2UndmUgYmFpbGVkIG91dCBiZWZvcmUgcmVhY2hpbmcgYSBob3N0IG5vZGUsXG4gICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBmYWxsIGJhY2sgdG8gcmVjdXJzaXZlbHkgbWFya2luZyB0aGUgbmVhcmVzdCBob3N0IGRlc2NlbmRhbnRzIGZvciBoaWdobGlnaHQuXG4gICAgICAgICAgICAgIGlmICh0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdEluc3RhbmNlcyA9XG4gICAgICAgICAgICAgICAgICBmaW5kQWxsQ3VycmVudEhvc3RJbnN0YW5jZXMoZmliZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgaG9zdEluc3RhbmNlcy5mb3JFYWNoKGhvc3RJbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5hZGQoaG9zdEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGlzIGZpbHRlcmVkIHRoZXJlIG1pZ2h0IGJlIGNoYW5nZXMgdG8gdGhpcyBzZXQgZWxzZXdoZXJlIHNvIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIHRvIHZpc2l0IGVhY2ggY2hpbGQgdG8gcGxhY2UgaXQgYmFjayBpbiB0aGUgc2V0LiBXZSBsZXQgdGhlIGNoaWxkIGJhaWwgb3V0IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuUmVjdXJzaXZlbHkobmV4dEZpYmVyLmNoaWxkLCBwcmV2RmliZXIuY2hpbGQsIGZhbHNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnVGhlIGNoaWxkcmVuIHNob3VsZCBub3QgaGF2ZSBjaGFuZ2VkIGlmIHdlIHBhc3MgaW4gdGhlIHNhbWUgc2V0LicsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWJlckluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBjb21wb25lbnRMb2dzRW50cnkgPSBmaWJlclRvQ29tcG9uZW50TG9nc01hcC5nZXQoXG4gICAgICAgICAgZmliZXJJbnN0YW5jZS5kYXRhLFxuICAgICAgICApO1xuICAgICAgICBpZiAoY29tcG9uZW50TG9nc0VudHJ5ID09PSB1bmRlZmluZWQgJiYgZmliZXJJbnN0YW5jZS5kYXRhLmFsdGVybmF0ZSkge1xuICAgICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeSA9IGZpYmVyVG9Db21wb25lbnRMb2dzTWFwLmdldChcbiAgICAgICAgICAgIGZpYmVySW5zdGFuY2UuZGF0YS5hbHRlcm5hdGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRDb25zb2xlTG9ncyhmaWJlckluc3RhbmNlLCBjb21wb25lbnRMb2dzRW50cnkpO1xuXG4gICAgICAgIGNvbnN0IGlzUHJvZmlsaW5nU3VwcG9ydGVkID1cbiAgICAgICAgICBuZXh0RmliZXIuaGFzT3duUHJvcGVydHkoJ3RyZWVCYXNlRHVyYXRpb24nKTtcbiAgICAgICAgaWYgKGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgICAgcmVjb3JkUHJvZmlsaW5nRHVyYXRpb25zKGZpYmVySW5zdGFuY2UsIHByZXZGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZXNldENoaWxkcmVuKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY3Jhd2wgdGhlIHN1YnRyZWUgZm9yIGNsb3Nlc3Qgbm9uLWZpbHRlcmVkIEZpYmVyc1xuICAgICAgICAvLyBzbyB0aGF0IHdlIGNhbiBkaXNwbGF5IHRoZW0gaW4gYSBmbGF0IGNoaWxkcmVuIHNldC5cbiAgICAgICAgaWYgKGZpYmVySW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICByZWNvcmRSZXNldENoaWxkcmVuKGZpYmVySW5zdGFuY2UpO1xuICAgICAgICAgIC8vIFdlJ3ZlIGhhbmRsZWQgdGhlIGNoaWxkIG9yZGVyIGNoYW5nZSBmb3IgdGhpcyBGaWJlci5cbiAgICAgICAgICAvLyBTaW5jZSBpdCdzIGluY2x1ZGVkLCB0aGVyZSdzIG5vIG5lZWQgdG8gaW52YWxpZGF0ZSBwYXJlbnQgY2hpbGQgb3JkZXIuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExldCB0aGUgY2xvc2VzdCB1bmZpbHRlcmVkIHBhcmVudCBGaWJlciByZXNldCBpdHMgY2hpbGQgb3JkZXIgaW5zdGVhZC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZmliZXJJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICB1bm1vdW50UmVtYWluaW5nQ2hpbGRyZW4oKTtcbiAgICAgICAgcmVjb25jaWxpbmdQYXJlbnQgPSBzdGFzaGVkUGFyZW50O1xuICAgICAgICBwcmV2aW91c2x5UmVjb25jaWxlZFNpYmxpbmcgPSBzdGFzaGVkUHJldmlvdXM7XG4gICAgICAgIHJlbWFpbmluZ1JlY29uY2lsaW5nQ2hpbGRyZW4gPSBzdGFzaGVkUmVtYWluaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290OiBhbnkpIHtcbiAgICBpZiAocm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAvLyB2MTYgYnVpbGRzIGluY2x1ZGUgdGhpcyBmaWVsZCBmb3IgdGhlIHNjaGVkdWxlci90cmFjaW5nIEFQSS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICByb290LmN1cnJlbnQgIT0gbnVsbCAmJlxuICAgICAgcm9vdC5jdXJyZW50Lmhhc093blByb3BlcnR5KCd0cmVlQmFzZUR1cmF0aW9uJylcbiAgICApIHtcbiAgICAgIC8vIFRoZSBzY2hlZHVsZXIvdHJhY2luZyBBUEkgd2FzIHJlbW92ZWQgaW4gdjE3IHRob3VnaFxuICAgICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayBhIG5vbi1yb290IEZpYmVyLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaEluaXRpYWxPcGVyYXRpb25zKCkge1xuICAgIGNvbnN0IGxvY2FsUGVuZGluZ09wZXJhdGlvbnNRdWV1ZSA9IHBlbmRpbmdPcGVyYXRpb25zUXVldWU7XG5cbiAgICBwZW5kaW5nT3BlcmF0aW9uc1F1ZXVlID0gbnVsbDtcblxuICAgIGlmIChcbiAgICAgIGxvY2FsUGVuZGluZ09wZXJhdGlvbnNRdWV1ZSAhPT0gbnVsbCAmJlxuICAgICAgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIC8vIFdlIG1heSBoYXZlIGFscmVhZHkgcXVldWVkIHVwIHNvbWUgb3BlcmF0aW9ucyBiZWZvcmUgdGhlIGZyb250ZW5kIGNvbm5lY3RlZFxuICAgICAgLy8gSWYgc28sIGxldCB0aGUgZnJvbnRlbmQga25vdyBhYm91dCB0aGVtLlxuICAgICAgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlLmZvckVhY2gob3BlcmF0aW9ucyA9PiB7XG4gICAgICAgIGhvb2suZW1pdCgnb3BlcmF0aW9ucycsIG9wZXJhdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJlZm9yZSB0aGUgdHJhdmVyc2FscywgcmVtZW1iZXIgdG8gc3RhcnQgdHJhY2tpbmdcbiAgICAgIC8vIG91ciBwYXRoIGluIGNhc2Ugd2UgaGF2ZSBzZWxlY3Rpb24gdG8gcmVzdG9yZS5cbiAgICAgIGlmICh0cmFja2VkUGF0aCAhPT0gbnVsbCkge1xuICAgICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIG5vdCBiZWVuIHByb2ZpbGluZywgdGhlbiB3ZSBjYW4ganVzdCB3YWxrIHRoZSB0cmVlIGFuZCBidWlsZCB1cCBpdHMgY3VycmVudCBzdGF0ZSBhcy1pcy5cbiAgICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKHJvb3QgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICAgICAgICBjb25zdCBuZXdSb290ID0gY3JlYXRlRmliZXJJbnN0YW5jZShjdXJyZW50KTtcbiAgICAgICAgcm9vdFRvRmliZXJJbnN0YW5jZU1hcC5zZXQocm9vdCwgbmV3Um9vdCk7XG4gICAgICAgIGlkVG9EZXZUb29sc0luc3RhbmNlTWFwLnNldChuZXdSb290LmlkLCBuZXdSb290KTtcbiAgICAgICAgY3VycmVudFJvb3QgPSBuZXdSb290O1xuICAgICAgICBzZXRSb290UHNldWRvS2V5KGN1cnJlbnRSb290LmlkLCByb290LmN1cnJlbnQpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBtdWx0aS1yZW5kZXJlciBlZGdlLWNhc2Ugd2hlcmUgb25seSBzb21lIHYxNiByZW5kZXJlcnMgc3VwcG9ydCBwcm9maWxpbmcuXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZyAmJiByb290U3VwcG9ydHNQcm9maWxpbmcocm9vdCkpIHtcbiAgICAgICAgICAvLyBJZiBwcm9maWxpbmcgaXMgYWN0aXZlLCBzdG9yZSBjb21taXQgdGltZSBhbmQgZHVyYXRpb24uXG4gICAgICAgICAgLy8gVGhlIGZyb250ZW5kIG1heSByZXF1ZXN0IHRoaXMgaW5mb3JtYXRpb24gYWZ0ZXIgcHJvZmlsaW5nIGhhcyBzdG9wcGVkLlxuICAgICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGNoYW5nZURlc2NyaXB0aW9uczogcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID8gbmV3IE1hcCgpIDogbnVsbCxcbiAgICAgICAgICAgIGR1cmF0aW9uczogW10sXG4gICAgICAgICAgICBjb21taXRUaW1lOiBnZXRDdXJyZW50VGltZSgpIC0gcHJvZmlsaW5nU3RhcnRUaW1lLFxuICAgICAgICAgICAgbWF4QWN0dWFsRHVyYXRpb246IDAsXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsOiBudWxsLFxuICAgICAgICAgICAgdXBkYXRlcnM6IG51bGwsXG4gICAgICAgICAgICBlZmZlY3REdXJhdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogbnVsbCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgZmFsc2UpO1xuXG4gICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcblxuICAgICAgICBuZWVkc1RvRmx1c2hDb21wb25lbnRMb2dzID0gZmFsc2U7XG4gICAgICAgIGN1cnJlbnRSb290ID0gKG51bGw6IGFueSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb21taXRGaWJlclVubW91bnQoZmliZXI6IGFueSkge1xuICAgIC8vIFRoaXMgSG9vayBpcyBubyBsb25nZXIgdXNlZC4gQWZ0ZXIgaGF2aW5nIHNoaXBwZWQgRGV2VG9vbHMgZXZlcnl3aGVyZSBpdCBpc1xuICAgIC8vIHNhZmUgdG8gc3RvcCBjYWxsaW5nIGl0IGZyb20gRmliZXIuXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290KHJvb3Q6IGFueSkge1xuICAgIGlmIChpc1Byb2ZpbGluZyAmJiByb290U3VwcG9ydHNQcm9maWxpbmcocm9vdCkpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qge2VmZmVjdER1cmF0aW9uLCBwYXNzaXZlRWZmZWN0RHVyYXRpb259ID1cbiAgICAgICAgICBnZXRFZmZlY3REdXJhdGlvbnMocm9vdCk7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEuZWZmZWN0RHVyYXRpb24gPSBlZmZlY3REdXJhdGlvbjtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPVxuICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZHNUb0ZsdXNoQ29tcG9uZW50TG9ncykge1xuICAgICAgLy8gV2UgcmVjZWl2ZWQgbmV3IGxvZ3MgYWZ0ZXIgY29tbWl0LiBJLmUuIGluIGEgcGFzc2l2ZSBlZmZlY3QuIFdlIG5lZWQgdG9cbiAgICAgIC8vIHRyYXZlcnNlIHRoZSB0cmVlIHRvIGZpbmQgdGhlIGFmZmVjdGVkIG9uZXMuIElmIHdlIGp1c3QgbW92ZWQgdGhlIHdob2xlXG4gICAgICAvLyB0cmVlIHRyYXZlcnNhbCBmcm9tIGhhbmRsZUNvbW1pdEZpYmVyUm9vdCB0byBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290XG4gICAgICAvLyB0aGlzIHdvdWxkbid0IGJlIG5lZWRlZC4gRm9yIG5vdyB3ZSBqdXN0IGJydXRlIGZvcmNlIGNoZWNrIGFsbCBpbnN0YW5jZXMuXG4gICAgICAvLyBUaGlzIGlzIG5vdCB0aGF0IGNvbW1vbiBvZiBhIGNhc2UuXG4gICAgICBicnV0ZUZvcmNlRmx1c2hFcnJvcnNBbmRXYXJuaW5ncygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbW1pdEZpYmVyUm9vdChcbiAgICByb290OiBGaWJlclJvb3QsXG4gICAgcHJpb3JpdHlMZXZlbDogdm9pZCB8IG51bWJlcixcbiAgKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHJvb3QuY3VycmVudDtcblxuICAgIGxldCBwcmV2RmliZXI6IG51bGwgfCBGaWJlciA9IG51bGw7XG4gICAgbGV0IHJvb3RJbnN0YW5jZSA9IHJvb3RUb0ZpYmVySW5zdGFuY2VNYXAuZ2V0KHJvb3QpO1xuICAgIGlmICghcm9vdEluc3RhbmNlKSB7XG4gICAgICByb290SW5zdGFuY2UgPSBjcmVhdGVGaWJlckluc3RhbmNlKGN1cnJlbnQpO1xuICAgICAgcm9vdFRvRmliZXJJbnN0YW5jZU1hcC5zZXQocm9vdCwgcm9vdEluc3RhbmNlKTtcbiAgICAgIGlkVG9EZXZUb29sc0luc3RhbmNlTWFwLnNldChyb290SW5zdGFuY2UuaWQsIHJvb3RJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZGaWJlciA9IHJvb3RJbnN0YW5jZS5kYXRhO1xuICAgIH1cbiAgICBjdXJyZW50Um9vdCA9IHJvb3RJbnN0YW5jZTtcblxuICAgIC8vIEJlZm9yZSB0aGUgdHJhdmVyc2FscywgcmVtZW1iZXIgdG8gc3RhcnQgdHJhY2tpbmdcbiAgICAvLyBvdXIgcGF0aCBpbiBjYXNlIHdlIGhhdmUgc2VsZWN0aW9uIHRvIHJlc3RvcmUuXG4gICAgaWYgKHRyYWNrZWRQYXRoICE9PSBudWxsKSB7XG4gICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgIHRyYWNlVXBkYXRlc0Zvck5vZGVzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG11bHRpLXJlbmRlcmVyIGVkZ2UtY2FzZSB3aGVyZSBvbmx5IHNvbWUgdjE2IHJlbmRlcmVycyBzdXBwb3J0IHByb2ZpbGluZy5cbiAgICBjb25zdCBpc1Byb2ZpbGluZ1N1cHBvcnRlZCA9IHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KTtcblxuICAgIGlmIChpc1Byb2ZpbGluZyAmJiBpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgLy8gSWYgcHJvZmlsaW5nIGlzIGFjdGl2ZSwgc3RvcmUgY29tbWl0IHRpbWUgYW5kIGR1cmF0aW9uLlxuICAgICAgLy8gVGhlIGZyb250ZW5kIG1heSByZXF1ZXN0IHRoaXMgaW5mb3JtYXRpb24gYWZ0ZXIgcHJvZmlsaW5nIGhhcyBzdG9wcGVkLlxuICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/IG5ldyBNYXAoKSA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uczogW10sXG4gICAgICAgIGNvbW1pdFRpbWU6IGdldEN1cnJlbnRUaW1lKCkgLSBwcm9maWxpbmdTdGFydFRpbWUsXG4gICAgICAgIG1heEFjdHVhbER1cmF0aW9uOiAwLFxuICAgICAgICBwcmlvcml0eUxldmVsOlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPT0gbnVsbCA/IG51bGwgOiBmb3JtYXRQcmlvcml0eUxldmVsKHByaW9yaXR5TGV2ZWwpLFxuICAgICAgICB1cGRhdGVyczogbnVsbCxcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byBudWxsOyBpZiBuZXcgZW5vdWdoIFJlYWN0IHZlcnNpb24gaXMgcnVubmluZyxcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHdpbGwgYmUgcmVhZCBkdXJpbmcgc2VwYXJhdGUgaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCgpIGNhbGwuXG4gICAgICAgIGVmZmVjdER1cmF0aW9uOiBudWxsLFxuICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChwcmV2RmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IHJlbHlpbmcgb24gdGhpcyBzZWVtcyBhIGJpdCBmaXNoeS5cbiAgICAgIGNvbnN0IHdhc01vdW50ZWQgPVxuICAgICAgICBwcmV2RmliZXIubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmXG4gICAgICAgIHByZXZGaWJlci5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbCAmJlxuICAgICAgICAvLyBBIGRlaHlkcmF0ZWQgcm9vdCBpcyBub3QgY29uc2lkZXJlZCBtb3VudGVkXG4gICAgICAgIHByZXZGaWJlci5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAhPT0gdHJ1ZTtcbiAgICAgIGNvbnN0IGlzTW91bnRlZCA9XG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmXG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGwgJiZcbiAgICAgICAgLy8gQSBkZWh5ZHJhdGVkIHJvb3QgaXMgbm90IGNvbnNpZGVyZWQgbW91bnRlZFxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkICE9PSB0cnVlO1xuICAgICAgaWYgKCF3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xuICAgICAgICAvLyBNb3VudCBhIG5ldyByb290LlxuICAgICAgICBzZXRSb290UHNldWRvS2V5KGN1cnJlbnRSb290LmlkLCBjdXJyZW50KTtcbiAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGN1cnJlbnQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAod2FzTW91bnRlZCAmJiBpc01vdW50ZWQpIHtcbiAgICAgICAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIHJvb3QuXG4gICAgICAgIHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkocm9vdEluc3RhbmNlLCBjdXJyZW50LCBwcmV2RmliZXIsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAod2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIFVubW91bnQgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgdW5tb3VudEluc3RhbmNlUmVjdXJzaXZlbHkocm9vdEluc3RhbmNlKTtcbiAgICAgICAgcmVtb3ZlUm9vdFBzZXVkb0tleShjdXJyZW50Um9vdC5pZCk7XG4gICAgICAgIHJvb3RUb0ZpYmVySW5zdGFuY2VNYXAuZGVsZXRlKHJvb3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3VudCBhIG5ldyByb290LlxuICAgICAgc2V0Um9vdFBzZXVkb0tleShjdXJyZW50Um9vdC5pZCwgY3VycmVudCk7XG4gICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkoY3VycmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChpc1Byb2ZpbGluZyAmJiBpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgaWYgKCFzaG91bGRCYWlsb3V0V2l0aFBlbmRpbmdPcGVyYXRpb25zKCkpIHtcbiAgICAgICAgY29uc3QgY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgPVxuICAgICAgICAgICgocm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXA6IGFueSk6IENvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwKS5nZXQoXG4gICAgICAgICAgICBjdXJyZW50Um9vdC5pZCxcbiAgICAgICAgICApO1xuXG4gICAgICAgIGlmIChjb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEucHVzaChcbiAgICAgICAgICAgICgoY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhOiBhbnkpOiBDb21taXRQcm9maWxpbmdEYXRhKSxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgocm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXA6IGFueSk6IENvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwKS5zZXQoXG4gICAgICAgICAgICBjdXJyZW50Um9vdC5pZCxcbiAgICAgICAgICAgIFsoKGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YTogYW55KTogQ29tbWl0UHJvZmlsaW5nRGF0YSldLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSdyZSBkb25lIGhlcmUuXG4gICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3QpO1xuXG4gICAgbmVlZHNUb0ZsdXNoQ29tcG9uZW50TG9ncyA9IGZhbHNlO1xuXG4gICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgIGhvb2suZW1pdCgndHJhY2VVcGRhdGVzJywgdHJhY2VVcGRhdGVzRm9yTm9kZXMpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSb290ID0gKG51bGw6IGFueSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXNvdXJjZUluc3RhbmNlKGZpYmVyOiBGaWJlcik6IEhvc3RJbnN0YW5jZSB8IG51bGwge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RIb2lzdGFibGUpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIC8vIEZlYXR1cmUgRGV0ZWN0IGEgRE9NIFNwZWNpZmljIEluc3RhbmNlIG9mIGEgUmVzb3VyY2VcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHJlc291cmNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICByZXNvdXJjZSAhPT0gbnVsbCAmJlxuICAgICAgICByZXNvdXJjZS5pbnN0YW5jZSAhPSBudWxsXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlLmluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEhvc3RJbnN0YW5jZXNCeURldlRvb2xzSW5zdGFuY2UoXG4gICAgZGV2dG9vbHNJbnN0YW5jZTogRGV2VG9vbHNJbnN0YW5jZSxcbiAgICBob3N0SW5zdGFuY2VzOiBBcnJheTxIb3N0SW5zdGFuY2U+LFxuICApIHtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZS5raW5kICE9PSBWSVJUVUFMX0lOU1RBTkNFKSB7XG4gICAgICBjb25zdCBmaWJlciA9IGRldnRvb2xzSW5zdGFuY2UuZGF0YTtcbiAgICAgIGFwcGVuZEhvc3RJbnN0YW5jZXNCeUZpYmVyKGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2VhcmNoIHRoZSB0cmVlIGZvciB0aGUgbmVhcmVzdCBjaGlsZCBGaWJlciBhbmQgYWRkIGFsbCBpdHMgaG9zdCBpbnN0YW5jZXMuXG4gICAgLy8gVE9ETzogSWYgdGhlIHRydWUgbmVhcmVzdCBGaWJlciBpcyBmaWx0ZXJlZCwgd2UgbWlnaHQgc2tpcCBpdCBhbmQgaW5zdGVhZCBpbmNsdWRlIGFsbFxuICAgIC8vIHRoZSBjaGlsZHJlbiBiZWxvdyBpdC4gSW4gdGhlIGV4dHJlbWUgY2FzZSwgc2VhcmNoaW5nIHRoZSB3aG9sZSB0cmVlLlxuICAgIGZvciAoXG4gICAgICBsZXQgY2hpbGQgPSBkZXZ0b29sc0luc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICBjaGlsZCAhPT0gbnVsbDtcbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmdcbiAgICApIHtcbiAgICAgIGFwcGVuZEhvc3RJbnN0YW5jZXNCeURldlRvb2xzSW5zdGFuY2UoY2hpbGQsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEhvc3RJbnN0YW5jZXNCeUZpYmVyKFxuICAgIGZpYmVyOiBGaWJlcixcbiAgICBob3N0SW5zdGFuY2VzOiBBcnJheTxIb3N0SW5zdGFuY2U+LFxuICApOiB2b2lkIHtcbiAgICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCBhbGwgSG9zdENvbXBvbmVudC9UZXh0LlxuICAgIGxldCBub2RlOiBGaWJlciA9IGZpYmVyO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8XG4gICAgICAgIG5vZGUudGFnID09PSBIb3N0VGV4dCB8fFxuICAgICAgICBub2RlLnRhZyA9PT0gSG9zdFNpbmdsZXRvbiB8fFxuICAgICAgICBub2RlLnRhZyA9PT0gSG9zdEhvaXN0YWJsZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGhvc3RJbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlIHx8IGdldFJlc291cmNlSW5zdGFuY2Uobm9kZSk7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLnB1c2goaG9zdEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZpYmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZEFsbEN1cnJlbnRIb3N0SW5zdGFuY2VzKFxuICAgIGRldnRvb2xzSW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UsXG4gICk6ICRSZWFkT25seUFycmF5PEhvc3RJbnN0YW5jZT4ge1xuICAgIGNvbnN0IGhvc3RJbnN0YW5jZXM6IEFycmF5PEhvc3RJbnN0YW5jZT4gPSBbXTtcbiAgICBhcHBlbmRIb3N0SW5zdGFuY2VzQnlEZXZUb29sc0luc3RhbmNlKGRldnRvb2xzSW5zdGFuY2UsIGhvc3RJbnN0YW5jZXMpO1xuICAgIHJldHVybiBob3N0SW5zdGFuY2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JFbGVtZW50SUQoaWQ6IG51bWJlcikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICAgIGlmIChkZXZ0b29sc0luc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBEZXZUb29sc0luc3RhbmNlIHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRBbGxDdXJyZW50SG9zdEluc3RhbmNlcyhkZXZ0b29sc0luc3RhbmNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRoZSBmaWJlciBtaWdodCBoYXZlIHVubW91bnRlZCBieSBub3cuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZUZvckVsZW1lbnRJRChpZDogbnVtYmVyKTogbnVsbCB8IHN0cmluZyB7XG4gICAgY29uc3QgZGV2dG9vbHNJbnN0YW5jZSA9IGlkVG9EZXZUb29sc0luc3RhbmNlTWFwLmdldChpZCk7XG4gICAgaWYgKGRldnRvb2xzSW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkZXZ0b29sc0luc3RhbmNlLmtpbmQgPT09IEZJQkVSX0lOU1RBTkNFKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihkZXZ0b29sc0luc3RhbmNlLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGV2dG9vbHNJbnN0YW5jZS5kYXRhLm5hbWUgfHwgJyc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRET01Ob2RlKHB1YmxpY0luc3RhbmNlOiBFbGVtZW50KTogbnVsbCB8IEVsZW1lbnQge1xuICAgIGxldCBkb21Ob2RlOiBudWxsIHwgRWxlbWVudCA9IHB1YmxpY0luc3RhbmNlO1xuICAgIHdoaWxlIChkb21Ob2RlICYmICFwdWJsaWNJbnN0YW5jZVRvRGV2VG9vbHNJbnN0YW5jZU1hcC5oYXMoZG9tTm9kZSkpIHtcbiAgICAgIC8vICRGbG93Rml4TWU6IEluIHByYWN0aWNlIHRoaXMgaXMgZWl0aGVyIG51bGwgb3IgRWxlbWVudC5cbiAgICAgIGRvbU5vZGUgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBkb21Ob2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudElERm9ySG9zdEluc3RhbmNlKFxuICAgIHB1YmxpY0luc3RhbmNlOiBIb3N0SW5zdGFuY2UsXG4gICk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IGluc3RhbmNlID0gcHVibGljSW5zdGFuY2VUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluc3RhbmNlLmtpbmQgPT09IEZJTFRFUkVEX0ZJQkVSX0lOU1RBTkNFKSB7XG4gICAgICAgIC8vIEEgRmlsdGVyZWQgRmliZXIgSW5zdGFuY2Ugd2lsbCBhbHdheXMgaGF2ZSBhIFZpcnR1YWwgSW5zdGFuY2UgYXMgYSBwYXJlbnQuXG4gICAgICAgIHJldHVybiAoKGluc3RhbmNlLnBhcmVudDogYW55KTogVmlydHVhbEluc3RhbmNlKS5pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW5jZS5pZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVtZW50QXR0cmlidXRlQnlQYXRoKFxuICAgIGlkOiBudW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgKTogbWl4ZWQge1xuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpKSB7XG4gICAgICByZXR1cm4gZ2V0SW5PYmplY3QoXG4gICAgICAgICgobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudDogYW55KTogSW5zcGVjdGVkRWxlbWVudCksXG4gICAgICAgIHBhdGgsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudFNvdXJjZUZ1bmN0aW9uQnlJZChpZDogbnVtYmVyKTogbnVsbCB8IEZ1bmN0aW9uIHtcbiAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIERldlRvb2xzSW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZS5raW5kICE9PSBGSUJFUl9JTlNUQU5DRSkge1xuICAgICAgLy8gVE9ETzogSGFuZGxlIFZpcnR1YWxJbnN0YW5jZS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmaWJlciA9IGRldnRvb2xzSW5zdGFuY2UuZGF0YTtcblxuICAgIGNvbnN0IHtlbGVtZW50VHlwZSwgdGFnLCB0eXBlfSA9IGZpYmVyO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHJldHVybiB0eXBlLnJlbmRlcjtcbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlICE9IG51bGwgJiYgZWxlbWVudFR5cGUudHlwZSAhPSBudWxsXG4gICAgICAgICAgPyBlbGVtZW50VHlwZS50eXBlXG4gICAgICAgICAgOiB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFuY2VUb1NlcmlhbGl6ZWRFbGVtZW50KFxuICAgIGluc3RhbmNlOiBGaWJlckluc3RhbmNlIHwgVmlydHVhbEluc3RhbmNlLFxuICApOiBTZXJpYWxpemVkRWxlbWVudCB7XG4gICAgaWYgKGluc3RhbmNlLmtpbmQgPT09IEZJQkVSX0lOU1RBTkNFKSB7XG4gICAgICBjb25zdCBmaWJlciA9IGluc3RhbmNlLmRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ0Fub255bW91cycsXG4gICAgICAgIGlkOiBpbnN0YW5jZS5pZCxcbiAgICAgICAga2V5OiBmaWJlci5rZXksXG4gICAgICAgIHR5cGU6IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcG9uZW50SW5mbyA9IGluc3RhbmNlLmRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5TmFtZTogY29tcG9uZW50SW5mby5uYW1lIHx8ICdBbm9ueW1vdXMnLFxuICAgICAgICBpZDogaW5zdGFuY2UuaWQsXG4gICAgICAgIGtleTogY29tcG9uZW50SW5mby5rZXkgPT0gbnVsbCA/IG51bGwgOiBjb21wb25lbnRJbmZvLmtleSxcbiAgICAgICAgdHlwZTogRWxlbWVudFR5cGVWaXJ0dWFsLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPd25lcnNMaXN0KGlkOiBudW1iZXIpOiBBcnJheTxTZXJpYWxpemVkRWxlbWVudD4gfCBudWxsIHtcbiAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIERldlRvb2xzSW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZWxmID0gaW5zdGFuY2VUb1NlcmlhbGl6ZWRFbGVtZW50KGRldnRvb2xzSW5zdGFuY2UpO1xuICAgIGNvbnN0IG93bmVycyA9IGdldE93bmVyc0xpc3RGcm9tSW5zdGFuY2UoZGV2dG9vbHNJbnN0YW5jZSk7XG4gICAgLy8gVGhpcyBpcyBwYXJ0aWN1bGFyIEFQSSBpcyBwcmVmaXhlZCB3aXRoIHRoZSBjdXJyZW50IGluc3RhbmNlIHRvbyBmb3Igc29tZSByZWFzb24uXG4gICAgaWYgKG93bmVycyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICB9XG4gICAgb3duZXJzLnVuc2hpZnQoc2VsZik7XG4gICAgb3duZXJzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gb3duZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3duZXJzTGlzdEZyb21JbnN0YW5jZShcbiAgICBpbnN0YW5jZTogRGV2VG9vbHNJbnN0YW5jZSxcbiAgKTogQXJyYXk8U2VyaWFsaXplZEVsZW1lbnQ+IHwgbnVsbCB7XG4gICAgbGV0IG93bmVyID0gZ2V0VW5maWx0ZXJlZE93bmVyKGluc3RhbmNlLmRhdGEpO1xuICAgIGlmIChvd25lciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG93bmVyczogQXJyYXk8U2VyaWFsaXplZEVsZW1lbnQ+ID0gW107XG4gICAgbGV0IHBhcmVudEluc3RhbmNlOiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50SW5zdGFuY2UgIT09IG51bGwgJiYgb3duZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG93bmVySW5zdGFuY2UgPSBmaW5kTmVhcmVzdE93bmVySW5zdGFuY2UocGFyZW50SW5zdGFuY2UsIG93bmVyKTtcbiAgICAgIGlmIChvd25lckluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgIG93bmVycy5wdXNoKGluc3RhbmNlVG9TZXJpYWxpemVkRWxlbWVudChvd25lckluc3RhbmNlKSk7XG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBvd25lciBhbmQga2VlcCBzZWFyY2hpbmcgZnJvbSB0aGUgcHJldmlvdXMgbWF0Y2guXG4gICAgICAgIG93bmVyID0gZ2V0VW5maWx0ZXJlZE93bmVyKG93bmVyKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UgPSBvd25lckluc3RhbmNlLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3duZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VW5maWx0ZXJlZE93bmVyKFxuICAgIG93bmVyOiBSZWFjdENvbXBvbmVudEluZm8gfCBGaWJlciB8IG51bGwgfCB2b2lkLFxuICApOiBSZWFjdENvbXBvbmVudEluZm8gfCBGaWJlciB8IG51bGwge1xuICAgIGlmIChvd25lciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvd25lci50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCBvd25lckZpYmVyOiBGaWJlciA9IChvd25lcjogYW55KTsgLy8gUmVmaW5lZFxuICAgICAgb3duZXIgPSBvd25lckZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvd25lckluZm86IFJlYWN0Q29tcG9uZW50SW5mbyA9IChvd25lcjogYW55KTsgLy8gUmVmaW5lZFxuICAgICAgb3duZXIgPSBvd25lckluZm8ub3duZXI7XG4gICAgfVxuICAgIHdoaWxlIChvd25lcikge1xuICAgICAgaWYgKHR5cGVvZiBvd25lci50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IG93bmVyRmliZXI6IEZpYmVyID0gKG93bmVyOiBhbnkpOyAvLyBSZWZpbmVkXG4gICAgICAgIGlmICghc2hvdWxkRmlsdGVyRmliZXIob3duZXJGaWJlcikpIHtcbiAgICAgICAgICByZXR1cm4gb3duZXJGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBvd25lciA9IG93bmVyRmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvd25lckluZm86IFJlYWN0Q29tcG9uZW50SW5mbyA9IChvd25lcjogYW55KTsgLy8gUmVmaW5lZFxuICAgICAgICBpZiAoIXNob3VsZEZpbHRlclZpcnR1YWwob3duZXJJbmZvLCBudWxsKSkge1xuICAgICAgICAgIHJldHVybiBvd25lckluZm87XG4gICAgICAgIH1cbiAgICAgICAgb3duZXIgPSBvd25lckluZm8ub3duZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZE5lYXJlc3RPd25lckluc3RhbmNlKFxuICAgIHBhcmVudEluc3RhbmNlOiBudWxsIHwgRGV2VG9vbHNJbnN0YW5jZSxcbiAgICBvd25lcjogdm9pZCB8IG51bGwgfCBSZWFjdENvbXBvbmVudEluZm8gfCBGaWJlcixcbiAgKTogbnVsbCB8IEZpYmVySW5zdGFuY2UgfCBWaXJ0dWFsSW5zdGFuY2Uge1xuICAgIGlmIChvd25lciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2VhcmNoIHRoZSBwYXJlbnQgcGF0aCBmb3IgYW55IGluc3RhbmNlIHRoYXQgbWF0Y2hlcyB0aGlzIGtpbmQgb2Ygb3duZXIuXG4gICAgd2hpbGUgKHBhcmVudEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHBhcmVudEluc3RhbmNlLmRhdGEgPT09IG93bmVyIHx8XG4gICAgICAgIC8vIFR5cGljYWxseSBib3RoIG93bmVyIGFuZCBpbnN0YW5jZS5kYXRhIHdvdWxkIHJlZmVyIHRvIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgYSBGaWJlclxuICAgICAgICAvLyBidXQgaXQgaXMgcG9zc2libGUgZm9yIG1lbW9pemF0aW9uIHRvIGlnbm9yZSB0aGUgb3duZXIgb24gdGhlIEpTWC4gVGhlbiB0aGUgbmV3IEZpYmVyXG4gICAgICAgIC8vIGlzbid0IHByb3BhZ2F0ZWQgZG93biBhcyB0aGUgbmV3IG93bmVyLiBJbiB0aGF0IGNhc2Ugd2UgbWlnaHQgbWF0Y2ggdGhlIGFsdGVybmF0ZVxuICAgICAgICAvLyBpbnN0ZWFkLiBUaGlzIGlzIGEgYml0IGhhY2t5IGJ1dCB0aGUgZmFzdGVzdCBjaGVjayBzaW5jZSB0eXBlIGNhc3Rpbmcgb3duZXIgdG8gYSBGaWJlclxuICAgICAgICAvLyBuZWVkcyBhIGR1Y2sgdHlwZSBjaGVjayBhbnl3YXkuXG4gICAgICAgIHBhcmVudEluc3RhbmNlLmRhdGEgPT09IChvd25lcjogYW55KS5hbHRlcm5hdGVcbiAgICAgICkge1xuICAgICAgICBpZiAocGFyZW50SW5zdGFuY2Uua2luZCA9PT0gRklMVEVSRURfRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50SW5zdGFuY2U7XG4gICAgICB9XG4gICAgICBwYXJlbnRJbnN0YW5jZSA9IHBhcmVudEluc3RhbmNlLnBhcmVudDtcbiAgICB9XG4gICAgLy8gSXQgaXMgdGVjaG5pY2FsbHkgcG9zc2libGUgdG8gY3JlYXRlIGFuIGVsZW1lbnQgYW5kIHJlbmRlciBpdCBpbiBhIGRpZmZlcmVudCBwYXJlbnRcbiAgICAvLyBidXQgdGhpcyBpcyBhIHdlaXJkIGVkZ2UgY2FzZSBhbmQgaXQgaXMgd29ydGggbm90IGhhdmluZyB0byBzY2FuIHRoZSB0cmVlIG9yIGtlZXBcbiAgICAvLyBhIHJlZ2lzdGVyIGZvciBldmVyeSBmaWJlci9jb21wb25lbnQgaW5mby5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEZhc3QgcGF0aCBwcm9wcyBsb29rdXAgZm9yIFJlYWN0IE5hdGl2ZSBzdHlsZSBlZGl0b3IuXG4gIC8vIENvdWxkIHVzZSBpbnNwZWN0RWxlbWVudFJhdygpIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgc2hhbGxvdyByZW5kZXJpbmcgaG9va3MgY29tcG9uZW50cyxcbiAgLy8gYW5kIGNvdWxkIGFsc28gbWVzcyB3aXRoIG1lbW9pemF0aW9uLlxuICBmdW5jdGlvbiBnZXRJbnN0YW5jZUFuZFN0eWxlKGlkOiBudW1iZXIpOiBJbnN0YW5jZUFuZFN0eWxlIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBudWxsO1xuICAgIGxldCBzdHlsZSA9IG51bGw7XG5cbiAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIERldlRvb2xzSW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybiB7aW5zdGFuY2UsIHN0eWxlfTtcbiAgICB9XG4gICAgaWYgKGRldnRvb2xzSW5zdGFuY2Uua2luZCAhPT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBWaXJ0dWFsSW5zdGFuY2UuXG4gICAgICByZXR1cm4ge2luc3RhbmNlLCBzdHlsZX07XG4gICAgfVxuXG4gICAgY29uc3QgZmliZXIgPSBkZXZ0b29sc0luc3RhbmNlLmRhdGE7XG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKGZpYmVyLm1lbW9pemVkUHJvcHMgIT09IG51bGwpIHtcbiAgICAgICAgc3R5bGUgPSBmaWJlci5tZW1vaXplZFByb3BzLnN0eWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7aW5zdGFuY2UsIHN0eWxlfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXJyb3JCb3VuZGFyeShmaWJlcjogRmliZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCB7dGFnLCB0eXBlfSA9IGZpYmVyO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdHlwZW9mIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgKGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpXG4gICAgICAgICk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdEVsZW1lbnRSYXcoaWQ6IG51bWJlcik6IEluc3BlY3RlZEVsZW1lbnQgfCBudWxsIHtcbiAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIERldlRvb2xzSW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZS5raW5kID09PSBWSVJUVUFMX0lOU1RBTkNFKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdFZpcnR1YWxJbnN0YW5jZVJhdyhkZXZ0b29sc0luc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKGRldnRvb2xzSW5zdGFuY2Uua2luZCA9PT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0RmliZXJJbnN0YW5jZVJhdyhkZXZ0b29sc0luc3RhbmNlKTtcbiAgICB9XG4gICAgKGRldnRvb2xzSW5zdGFuY2U6IEZpbHRlcmVkRmliZXJJbnN0YW5jZSk7IC8vIGFzc2VydCBleGhhdXN0aXZlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBpbnN0YW5jZSBraW5kJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0RmliZXJJbnN0YW5jZVJhdyhcbiAgICBmaWJlckluc3RhbmNlOiBGaWJlckluc3RhbmNlLFxuICApOiBJbnNwZWN0ZWRFbGVtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgZmliZXIgPSBmaWJlckluc3RhbmNlLmRhdGE7XG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlTm9kZSxcbiAgICAgIGtleSxcbiAgICAgIG1lbW9pemVkUHJvcHMsXG4gICAgICBtZW1vaXplZFN0YXRlLFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgdGFnLFxuICAgICAgdHlwZSxcbiAgICB9ID0gZmliZXI7XG5cbiAgICBjb25zdCBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpO1xuXG4gICAgY29uc3QgdXNlc0hvb2tzID1cbiAgICAgICh0YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50IHx8XG4gICAgICAgIHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCB8fFxuICAgICAgICB0YWcgPT09IEZvcndhcmRSZWYpICYmXG4gICAgICAoISFtZW1vaXplZFN0YXRlIHx8ICEhZGVwZW5kZW5jaWVzKTtcblxuICAgIC8vIFRPRE8gU2hvdyBjdXN0b20gVUkgZm9yIENhY2hlIGxpa2Ugd2UgZG8gZm9yIFN1c3BlbnNlXG4gICAgLy8gRm9yIG5vdywganVzdCBoaWRlIHN0YXRlIGRhdGEgZW50aXJlbHkgc2luY2UgaXQncyBub3QgbWVhbnQgdG8gYmUgaW5zcGVjdGVkLlxuICAgIGNvbnN0IHNob3dTdGF0ZSA9ICF1c2VzSG9va3MgJiYgdGFnICE9PSBDYWNoZUNvbXBvbmVudDtcblxuICAgIGNvbnN0IHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuXG4gICAgbGV0IGNhblZpZXdTb3VyY2UgPSBmYWxzZTtcbiAgICBsZXQgY29udGV4dCA9IG51bGw7XG4gICAgaWYgKFxuICAgICAgdGFnID09PSBDbGFzc0NvbXBvbmVudCB8fFxuICAgICAgdGFnID09PSBGdW5jdGlvbkNvbXBvbmVudCB8fFxuICAgICAgdGFnID09PSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgfHxcbiAgICAgIHRhZyA9PT0gSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50IHx8XG4gICAgICB0YWcgPT09IEluZGV0ZXJtaW5hdGVDb21wb25lbnQgfHxcbiAgICAgIHRhZyA9PT0gTWVtb0NvbXBvbmVudCB8fFxuICAgICAgdGFnID09PSBGb3J3YXJkUmVmIHx8XG4gICAgICB0YWcgPT09IFNpbXBsZU1lbW9Db21wb25lbnRcbiAgICApIHtcbiAgICAgIGNhblZpZXdTb3VyY2UgPSB0cnVlO1xuICAgICAgaWYgKHN0YXRlTm9kZSAmJiBzdGF0ZU5vZGUuY29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIC8vIERvbid0IHNob3cgYW4gZW1wdHkgY29udGV4dCBvYmplY3QgZm9yIGNsYXNzIGNvbXBvbmVudHMgdGhhdCBkb24ndCB1c2UgdGhlIGNvbnRleHQgQVBJLlxuICAgICAgICBjb25zdCBzaG91bGRIaWRlQ29udGV4dCA9XG4gICAgICAgICAgZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlQ2xhc3MgJiZcbiAgICAgICAgICAhKHR5cGUuY29udGV4dFR5cGVzIHx8IHR5cGUuY29udGV4dFR5cGUpO1xuXG4gICAgICAgIGlmICghc2hvdWxkSGlkZUNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0ID0gc3RhdGVOb2RlLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gRGV0ZWN0IHByZS0xOSBDb250ZXh0IENvbnN1bWVyc1xuICAgICAgKHR5cGVTeW1ib2wgPT09IENPTlRFWFRfTlVNQkVSIHx8IHR5cGVTeW1ib2wgPT09IENPTlRFWFRfU1lNQk9MX1NUUklORykgJiZcbiAgICAgICEoXG4gICAgICAgIC8vIEluIDE5KywgQ09OVEVYVF9TWU1CT0xfU1RSSU5HIG1lYW5zIGEgUHJvdmlkZXIgaW5zdGVhZC5cbiAgICAgICAgLy8gSXQgd2lsbCBiZSBoYW5kbGVkIGluIGEgZGlmZmVyZW50IGJyYW5jaCBiZWxvdy5cbiAgICAgICAgLy8gRXZlbnR1YWxseSwgdGhpcyBlbnRpcmUgYnJhbmNoIGNhbiBiZSByZW1vdmVkLlxuICAgICAgICAodHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkICYmIHR5cGUuUHJvdmlkZXIgPT09IHR5cGUpXG4gICAgICApXG4gICAgKSB7XG4gICAgICAvLyAxNi4zLTE2LjUgcmVhZCBmcm9tIFwidHlwZVwiIGJlY2F1c2UgdGhlIENvbnN1bWVyIGlzIHRoZSBhY3R1YWwgY29udGV4dCBvYmplY3QuXG4gICAgICAvLyAxNi42KyBzaG91bGQgcmVhZCBmcm9tIFwidHlwZS5fY29udGV4dFwiIGJlY2F1c2UgQ29uc3VtZXIgY2FuIGJlIGRpZmZlcmVudCAoaW4gREVWKS5cbiAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggZ2V0RGlzcGxheU5hbWVGb3JGaWJlcigpXG4gICAgICBjb25zdCBjb25zdW1lclJlc29sdmVkQ29udGV4dCA9IHR5cGUuX2NvbnRleHQgfHwgdHlwZTtcblxuICAgICAgLy8gR2xvYmFsIGNvbnRleHQgdmFsdWUuXG4gICAgICBjb250ZXh0ID0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQuX2N1cnJlbnRWYWx1ZSB8fCBudWxsO1xuXG4gICAgICAvLyBMb29rIGZvciBvdmVycmlkZGVuIHZhbHVlLlxuICAgICAgbGV0IGN1cnJlbnQgPSAoKGZpYmVyOiBhbnkpOiBGaWJlcikucmV0dXJuO1xuICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUeXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbChjdXJyZW50VHlwZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50VHlwZVN5bWJvbCA9PT0gUFJPVklERVJfTlVNQkVSIHx8XG4gICAgICAgICAgY3VycmVudFR5cGVTeW1ib2wgPT09IFBST1ZJREVSX1NZTUJPTF9TVFJJTkdcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gMTYuMy4wIGV4cG9zZWQgdGhlIGNvbnRleHQgb2JqZWN0IGFzIFwiY29udGV4dFwiXG4gICAgICAgICAgLy8gUFIgIzEyNTAxIGNoYW5nZWQgaXQgdG8gXCJfY29udGV4dFwiIGZvciAxNi4zLjErXG4gICAgICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBnZXREaXNwbGF5TmFtZUZvckZpYmVyKClcbiAgICAgICAgICBjb25zdCBwcm92aWRlclJlc29sdmVkQ29udGV4dCA9XG4gICAgICAgICAgICBjdXJyZW50VHlwZS5fY29udGV4dCB8fCBjdXJyZW50VHlwZS5jb250ZXh0O1xuICAgICAgICAgIGlmIChwcm92aWRlclJlc29sdmVkQ29udGV4dCA9PT0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMudmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIERldGVjdCAxOSsgQ29udGV4dCBDb25zdW1lcnNcbiAgICAgIHR5cGVTeW1ib2wgPT09IENPTlNVTUVSX1NZTUJPTF9TVFJJTkdcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgYnJhbmNoIGlzIDE5KyBvbmx5LCB3aGVyZSBDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0LlxuICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBnZXREaXNwbGF5TmFtZUZvckZpYmVyKClcbiAgICAgIGNvbnN0IGNvbnN1bWVyUmVzb2x2ZWRDb250ZXh0ID0gdHlwZS5fY29udGV4dDtcblxuICAgICAgLy8gR2xvYmFsIGNvbnRleHQgdmFsdWUuXG4gICAgICBjb250ZXh0ID0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQuX2N1cnJlbnRWYWx1ZSB8fCBudWxsO1xuXG4gICAgICAvLyBMb29rIGZvciBvdmVycmlkZGVuIHZhbHVlLlxuICAgICAgbGV0IGN1cnJlbnQgPSAoKGZpYmVyOiBhbnkpOiBGaWJlcikucmV0dXJuO1xuICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUeXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbChjdXJyZW50VHlwZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBJbiAxOSssIHRoZXNlIGFyZSBDb250ZXh0IFByb3ZpZGVyc1xuICAgICAgICAgIGN1cnJlbnRUeXBlU3ltYm9sID09PSBDT05URVhUX1NZTUJPTF9TVFJJTkdcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXJSZXNvbHZlZENvbnRleHQgPSBjdXJyZW50VHlwZTtcbiAgICAgICAgICBpZiAocHJvdmlkZXJSZXNvbHZlZENvbnRleHQgPT09IGNvbnN1bWVyUmVzb2x2ZWRDb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBoYXNMZWdhY3lDb250ZXh0ID0gZmFsc2U7XG4gICAgaWYgKGNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGhhc0xlZ2FjeUNvbnRleHQgPSAhIXR5cGUuY29udGV4dFR5cGVzO1xuXG4gICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgbG9naWMgZm9yIGNvbnRleHQsIHdyYXAgaW4gYSB2YWx1ZSBvYmplY3QuXG4gICAgICAvLyBPdGhlcndpc2Ugc2ltcGxlIHZhbHVlcyAoZS5nLiBzdHJpbmdzLCBib29sZWFucykgYmVjb21lIGhhcmRlciB0byBoYW5kbGUuXG4gICAgICBjb250ZXh0ID0ge3ZhbHVlOiBjb250ZXh0fTtcbiAgICB9XG5cbiAgICBjb25zdCBvd25lcnM6IG51bGwgfCBBcnJheTxTZXJpYWxpemVkRWxlbWVudD4gPVxuICAgICAgZ2V0T3duZXJzTGlzdEZyb21JbnN0YW5jZShmaWJlckluc3RhbmNlKTtcblxuICAgIGxldCBob29rcyA9IG51bGw7XG4gICAgaWYgKHVzZXNIb29rcykge1xuICAgICAgY29uc3Qgb3JpZ2luYWxDb25zb2xlTWV0aG9kczoge1tzdHJpbmddOiAkRmxvd0ZpeE1lfSA9IHt9O1xuXG4gICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIGFsbCBjb25zb2xlIGxvZ2dpbmcgYmVmb3JlIHJlLXJ1bm5pbmcgdGhlIGhvb2suXG4gICAgICBmb3IgKGNvbnN0IG1ldGhvZCBpbiBjb25zb2xlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbXB1dGVkLXByb3BdXG4gICAgICAgICAgb3JpZ2luYWxDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gY29uc29sZVttZXRob2RdO1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9ICgpID0+IHt9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaG9va3MgPSBpbnNwZWN0SG9va3NPZkZpYmVyKGZpYmVyLCBnZXREaXNwYXRjaGVyUmVmKHJlbmRlcmVyKSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbnNvbGUgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgZm9yIChjb25zdCBtZXRob2QgaW4gb3JpZ2luYWxDb25zb2xlTWV0aG9kcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByb290VHlwZSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnQgPSBmaWJlcjtcbiAgICBsZXQgaGFzRXJyb3JCb3VuZGFyeSA9IGZhbHNlO1xuICAgIGxldCBoYXNTdXNwZW5zZUJvdW5kYXJ5ID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnQucmV0dXJuICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0ZW1wID0gY3VycmVudDtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICAgIGlmICh0ZW1wLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgaGFzU3VzcGVuc2VCb3VuZGFyeSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGlzRXJyb3JCb3VuZGFyeSh0ZW1wKSkge1xuICAgICAgICBoYXNFcnJvckJvdW5kYXJ5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmliZXJSb290ID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgaWYgKGZpYmVyUm9vdCAhPSBudWxsICYmIGZpYmVyUm9vdC5fZGVidWdSb290VHlwZSAhPT0gbnVsbCkge1xuICAgICAgcm9vdFR5cGUgPSBmaWJlclJvb3QuX2RlYnVnUm9vdFR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgaXNUaW1lZE91dFN1c3BlbnNlID1cbiAgICAgIHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgbWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgIGxldCBpc0Vycm9yZWQgPSBmYWxzZTtcbiAgICBpZiAoaXNFcnJvckJvdW5kYXJ5KGZpYmVyKSkge1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgaW5zcGVjdGVkIGVsZW1lbnQgaXMgYW4gZXJyb3IgYm91bmRhcnksXG4gICAgICAvLyBlaXRoZXIgdGhhdCB3ZSB3YW50IHRvIHVzZSBpdCB0byB0b2dnbGUgb2ZmIGVycm9yIHN0YXRlXG4gICAgICAvLyBvciB0aGF0IHdlIGFsbG93IHRvIGZvcmNlIGVycm9yIHN0YXRlIG9uIGl0IGlmIGl0J3Mgd2l0aGluIGFub3RoZXJcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5XG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogVGhpcyBmbGFnIGlzIGEgbGVha2VkIGltcGxlbWVudGF0aW9uIGRldGFpbC4gT25jZSB3ZSBzdGFydFxuICAgICAgLy8gcmVsZWFzaW5nIERldlRvb2xzIGluIGxvY2tzdGVwIHdpdGggUmVhY3QsIHdlIHNob3VsZCBpbXBvcnQgYSBmdW5jdGlvblxuICAgICAgLy8gZnJvbSB0aGUgcmVjb25jaWxlciBpbnN0ZWFkLlxuICAgICAgY29uc3QgRGlkQ2FwdHVyZSA9IDBiMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwO1xuICAgICAgaXNFcnJvcmVkID1cbiAgICAgICAgKGZpYmVyLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IDAgfHxcbiAgICAgICAgZm9yY2VFcnJvckZvckZpYmVycy5nZXQoZmliZXIpID09PSB0cnVlIHx8XG4gICAgICAgIChmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiZcbiAgICAgICAgICBmb3JjZUVycm9yRm9yRmliZXJzLmdldChmaWJlci5hbHRlcm5hdGUpID09PSB0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwbHVnaW5zOiBQbHVnaW5zID0ge1xuICAgICAgc3R5bGV4OiBudWxsLFxuICAgIH07XG5cbiAgICBpZiAoZW5hYmxlU3R5bGVYRmVhdHVyZXMpIHtcbiAgICAgIGlmIChtZW1vaXplZFByb3BzICE9IG51bGwgJiYgbWVtb2l6ZWRQcm9wcy5oYXNPd25Qcm9wZXJ0eSgneHN0eWxlJykpIHtcbiAgICAgICAgcGx1Z2lucy5zdHlsZXggPSBnZXRTdHlsZVhEYXRhKG1lbW9pemVkUHJvcHMueHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc291cmNlID0gbnVsbDtcbiAgICBpZiAoY2FuVmlld1NvdXJjZSkge1xuICAgICAgc291cmNlID0gZ2V0U291cmNlRm9yRmliZXJJbnN0YW5jZShmaWJlckluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBsZXQgY29tcG9uZW50TG9nc0VudHJ5ID0gZmliZXJUb0NvbXBvbmVudExvZ3NNYXAuZ2V0KGZpYmVyKTtcbiAgICBpZiAoY29tcG9uZW50TG9nc0VudHJ5ID09PSB1bmRlZmluZWQgJiYgZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRMb2dzRW50cnkgPSBmaWJlclRvQ29tcG9uZW50TG9nc01hcC5nZXQoZmliZXIuYWx0ZXJuYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGZpYmVySW5zdGFuY2UuaWQsXG5cbiAgICAgIC8vIERvZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydCBlZGl0YWJsZSBob29rcyBhbmQgZnVuY3Rpb24gcHJvcHM/XG4gICAgICBjYW5FZGl0SG9va3M6IHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzOiB0eXBlb2Ygb3ZlcnJpZGVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyxcblxuICAgICAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGFkdmFuY2VkIGVkaXRpbmcgaW50ZXJmYWNlP1xuICAgICAgY2FuRWRpdEhvb2tzQW5kRGVsZXRlUGF0aHM6XG4gICAgICAgIHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPT09ICdmdW5jdGlvbicsXG4gICAgICBjYW5FZGl0SG9va3NBbmRSZW5hbWVQYXRoczpcbiAgICAgICAgdHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzRGVsZXRlUGF0aHM6XG4gICAgICAgIHR5cGVvZiBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzUmVuYW1lUGF0aHM6XG4gICAgICAgIHR5cGVvZiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcblxuICAgICAgY2FuVG9nZ2xlRXJyb3I6IHN1cHBvcnRzVG9nZ2xpbmdFcnJvciAmJiBoYXNFcnJvckJvdW5kYXJ5LFxuICAgICAgLy8gSXMgdGhpcyBlcnJvciBib3VuZGFyeSBpbiBlcnJvciBzdGF0ZS5cbiAgICAgIGlzRXJyb3JlZCxcblxuICAgICAgY2FuVG9nZ2xlU3VzcGVuc2U6XG4gICAgICAgIHN1cHBvcnRzVG9nZ2xpbmdTdXNwZW5zZSAmJlxuICAgICAgICBoYXNTdXNwZW5zZUJvdW5kYXJ5ICYmXG4gICAgICAgIC8vIElmIGl0J3Mgc2hvd2luZyB0aGUgcmVhbCBjb250ZW50LCB3ZSBjYW4gYWx3YXlzIGZsaXAgZmFsbGJhY2suXG4gICAgICAgICghaXNUaW1lZE91dFN1c3BlbnNlIHx8XG4gICAgICAgICAgLy8gSWYgaXQncyBzaG93aW5nIGZhbGxiYWNrIGJlY2F1c2Ugd2UgcHJldmlvdXNseSBmb3JjZWQgaXQgdG8sXG4gICAgICAgICAgLy8gYWxsb3cgdG9nZ2xpbmcgaXQgYmFjayB0byByZW1vdmUgdGhlIGZhbGxiYWNrIG92ZXJyaWRlLlxuICAgICAgICAgIGZvcmNlRmFsbGJhY2tGb3JGaWJlcnMuaGFzKGZpYmVyKSB8fFxuICAgICAgICAgIChmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGZvcmNlRmFsbGJhY2tGb3JGaWJlcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpKSxcblxuICAgICAgLy8gQ2FuIHZpZXcgY29tcG9uZW50IHNvdXJjZSBsb2NhdGlvbi5cbiAgICAgIGNhblZpZXdTb3VyY2UsXG4gICAgICBzb3VyY2UsXG5cbiAgICAgIC8vIERvZXMgdGhlIGNvbXBvbmVudCBoYXZlIGxlZ2FjeSBjb250ZXh0IGF0dGFjaGVkIHRvIGl0LlxuICAgICAgaGFzTGVnYWN5Q29udGV4dCxcblxuICAgICAga2V5OiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGwsXG5cbiAgICAgIHR5cGU6IGVsZW1lbnRUeXBlLFxuXG4gICAgICAvLyBJbnNwZWN0YWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgLy8gVE9ETyBSZXZpZXcgc2FuaXRpemF0aW9uIGFwcHJvYWNoIGZvciB0aGUgYmVsb3cgaW5zcGVjdGFibGUgdmFsdWVzLlxuICAgICAgY29udGV4dCxcbiAgICAgIGhvb2tzLFxuICAgICAgcHJvcHM6IG1lbW9pemVkUHJvcHMsXG4gICAgICBzdGF0ZTogc2hvd1N0YXRlID8gbWVtb2l6ZWRTdGF0ZSA6IG51bGwsXG4gICAgICBlcnJvcnM6XG4gICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogQXJyYXkuZnJvbShjb21wb25lbnRMb2dzRW50cnkuZXJyb3JzLmVudHJpZXMoKSksXG4gICAgICB3YXJuaW5nczpcbiAgICAgICAgY29tcG9uZW50TG9nc0VudHJ5ID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiBBcnJheS5mcm9tKGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5ncy5lbnRyaWVzKCkpLFxuXG4gICAgICAvLyBMaXN0IG9mIG93bmVyc1xuICAgICAgb3duZXJzLFxuXG4gICAgICByb290VHlwZSxcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IHJlbmRlcmVyLnJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgICByZW5kZXJlclZlcnNpb246IHJlbmRlcmVyLnZlcnNpb24sXG5cbiAgICAgIHBsdWdpbnMsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RWaXJ0dWFsSW5zdGFuY2VSYXcoXG4gICAgdmlydHVhbEluc3RhbmNlOiBWaXJ0dWFsSW5zdGFuY2UsXG4gICk6IEluc3BlY3RlZEVsZW1lbnQgfCBudWxsIHtcbiAgICBjb25zdCBjYW5WaWV3U291cmNlID0gdHJ1ZTtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRTb3VyY2VGb3JJbnN0YW5jZSh2aXJ0dWFsSW5zdGFuY2UpO1xuXG4gICAgY29uc3QgY29tcG9uZW50SW5mbyA9IHZpcnR1YWxJbnN0YW5jZS5kYXRhO1xuICAgIGNvbnN0IGtleSA9XG4gICAgICB0eXBlb2YgY29tcG9uZW50SW5mby5rZXkgPT09ICdzdHJpbmcnID8gY29tcG9uZW50SW5mby5rZXkgOiBudWxsO1xuICAgIGNvbnN0IHByb3BzID0gY29tcG9uZW50SW5mby5wcm9wcyA9PSBudWxsID8gbnVsbCA6IGNvbXBvbmVudEluZm8ucHJvcHM7XG4gICAgY29uc3Qgb3duZXJzOiBudWxsIHwgQXJyYXk8U2VyaWFsaXplZEVsZW1lbnQ+ID1cbiAgICAgIGdldE93bmVyc0xpc3RGcm9tSW5zdGFuY2UodmlydHVhbEluc3RhbmNlKTtcblxuICAgIGxldCByb290VHlwZSA9IG51bGw7XG4gICAgbGV0IGhhc0Vycm9yQm91bmRhcnkgPSBmYWxzZTtcbiAgICBsZXQgaGFzU3VzcGVuc2VCb3VuZGFyeSA9IGZhbHNlO1xuICAgIGNvbnN0IG5lYXJlc3RGaWJlciA9IGdldE5lYXJlc3RGaWJlcih2aXJ0dWFsSW5zdGFuY2UpO1xuICAgIGlmIChuZWFyZXN0RmliZXIgIT09IG51bGwpIHtcbiAgICAgIGxldCBjdXJyZW50ID0gbmVhcmVzdEZpYmVyO1xuICAgICAgd2hpbGUgKGN1cnJlbnQucmV0dXJuICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBjdXJyZW50O1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIGlmICh0ZW1wLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgICBoYXNTdXNwZW5zZUJvdW5kYXJ5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Vycm9yQm91bmRhcnkodGVtcCkpIHtcbiAgICAgICAgICBoYXNFcnJvckJvdW5kYXJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZmliZXJSb290ID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICBpZiAoZmliZXJSb290ICE9IG51bGwgJiYgZmliZXJSb290Ll9kZWJ1Z1Jvb3RUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIHJvb3RUeXBlID0gZmliZXJSb290Ll9kZWJ1Z1Jvb3RUeXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBsdWdpbnM6IFBsdWdpbnMgPSB7XG4gICAgICBzdHlsZXg6IG51bGwsXG4gICAgfTtcblxuICAgIGNvbnN0IGNvbXBvbmVudExvZ3NFbnRyeSA9XG4gICAgICBjb21wb25lbnRJbmZvVG9Db21wb25lbnRMb2dzTWFwLmdldChjb21wb25lbnRJbmZvKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogdmlydHVhbEluc3RhbmNlLmlkLFxuXG4gICAgICBjYW5FZGl0SG9va3M6IGZhbHNlLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHM6IGZhbHNlLFxuXG4gICAgICBjYW5FZGl0SG9va3NBbmREZWxldGVQYXRoczogZmFsc2UsXG4gICAgICBjYW5FZGl0SG9va3NBbmRSZW5hbWVQYXRoczogZmFsc2UsXG4gICAgICBjYW5FZGl0RnVuY3Rpb25Qcm9wc0RlbGV0ZVBhdGhzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzUmVuYW1lUGF0aHM6IGZhbHNlLFxuXG4gICAgICBjYW5Ub2dnbGVFcnJvcjogc3VwcG9ydHNUb2dnbGluZ0Vycm9yICYmIGhhc0Vycm9yQm91bmRhcnksXG4gICAgICBpc0Vycm9yZWQ6IGZhbHNlLFxuXG4gICAgICBjYW5Ub2dnbGVTdXNwZW5zZTogc3VwcG9ydHNUb2dnbGluZ1N1c3BlbnNlICYmIGhhc1N1c3BlbnNlQm91bmRhcnksXG5cbiAgICAgIC8vIENhbiB2aWV3IGNvbXBvbmVudCBzb3VyY2UgbG9jYXRpb24uXG4gICAgICBjYW5WaWV3U291cmNlLFxuICAgICAgc291cmNlLFxuXG4gICAgICAvLyBEb2VzIHRoZSBjb21wb25lbnQgaGF2ZSBsZWdhY3kgY29udGV4dCBhdHRhY2hlZCB0byBpdC5cbiAgICAgIGhhc0xlZ2FjeUNvbnRleHQ6IGZhbHNlLFxuXG4gICAgICBrZXk6IGtleSxcblxuICAgICAgdHlwZTogRWxlbWVudFR5cGVWaXJ0dWFsLFxuXG4gICAgICAvLyBJbnNwZWN0YWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgLy8gVE9ETyBSZXZpZXcgc2FuaXRpemF0aW9uIGFwcHJvYWNoIGZvciB0aGUgYmVsb3cgaW5zcGVjdGFibGUgdmFsdWVzLlxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIGhvb2tzOiBudWxsLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgc3RhdGU6IG51bGwsXG4gICAgICBlcnJvcnM6XG4gICAgICAgIGNvbXBvbmVudExvZ3NFbnRyeSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogQXJyYXkuZnJvbShjb21wb25lbnRMb2dzRW50cnkuZXJyb3JzLmVudHJpZXMoKSksXG4gICAgICB3YXJuaW5nczpcbiAgICAgICAgY29tcG9uZW50TG9nc0VudHJ5ID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiBBcnJheS5mcm9tKGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5ncy5lbnRyaWVzKCkpLFxuICAgICAgLy8gTGlzdCBvZiBvd25lcnNcbiAgICAgIG93bmVycyxcblxuICAgICAgcm9vdFR5cGUsXG4gICAgICByZW5kZXJlclBhY2thZ2VOYW1lOiByZW5kZXJlci5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgICAgcmVuZGVyZXJWZXJzaW9uOiByZW5kZXJlci52ZXJzaW9uLFxuXG4gICAgICBwbHVnaW5zLFxuICAgIH07XG4gIH1cblxuICBsZXQgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudDogSW5zcGVjdGVkRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBsZXQgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgbGV0IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzOiBPYmplY3QgPSB7fTtcblxuICBmdW5jdGlvbiBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmXG4gICAgICBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LmlkID09PSBpZFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRDdXJyZW50KGlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSAmJiAhaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWRcbiAgICApO1xuICB9XG5cbiAgLy8gVHJhY2sgdGhlIGludGVyc2VjdGlvbiBvZiBjdXJyZW50bHkgaW5zcGVjdGVkIHBhdGhzLFxuICAvLyBzbyB0aGF0IHdlIGNhbiBzZW5kIHRoZWlyIGRhdGEgYWxvbmcgaWYgdGhlIGVsZW1lbnQgaXMgcmUtcmVuZGVyZWQuXG4gIGZ1bmN0aW9uIG1lcmdlSW5zcGVjdGVkUGF0aHMocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikge1xuICAgIGxldCBjdXJyZW50ID0gY3VycmVudGx5SW5zcGVjdGVkUGF0aHM7XG4gICAgcGF0aC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRba2V5XSkge1xuICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJc1BhdGhBbGxvd2VkKFxuICAgIGtleTogc3RyaW5nIHwgbnVsbCxcbiAgICBzZWNvbmRhcnlDYXRlZ29yeTogJ2hvb2tzJyB8IG51bGwsXG4gICkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGVscHMgcHJldmVudCBwcmV2aW91c2x5LWluc3BlY3RlZCBwYXRocyBmcm9tIGJlaW5nIGRlaHlkcmF0ZWQgaW4gdXBkYXRlcy5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCB0byBhdm9pZCBhIGJhZCB1c2VyIGV4cGVyaWVuY2Ugd2hlcmUgZXhwYW5kZWQgdG9nZ2xlcyBjb2xsYXBzZSBvbiB1cGRhdGUuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzUGF0aEFsbG93ZWQocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgc3dpdGNoIChzZWNvbmRhcnlDYXRlZ29yeSkge1xuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBOZXZlciBkZWh5ZHJhdGUgdGhlIFwiaG9va3NcIiBvYmplY3QgYXQgdGhlIHRvcCBsZXZlbHMuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMl0gPT09ICdob29rU291cmNlJyAmJlxuICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnZmlsZU5hbWUnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBwcmVzZXJ2ZSB0aGUgZnVsbCBmaWxlIG5hbWUgKFVSTCkgZm9yIGhvb2sgc291cmNlc1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdXNlciBoYXMgZW5hYmxlZCB0aGUgbmFtZWQgaG9va3MgZmVhdHVyZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgZnJvbnRlbmQgbWF5IGVuZCB1cCB3aXRoIGEgcGFydGlhbCBVUkwgd2hpY2ggaXQgY2FuJ3QgbG9hZC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ3N1Ykhvb2tzJyB8fFxuICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDJdID09PSAnc3ViSG9va3MnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBEZWh5ZHJhdGluZyB0aGUgJ3N1Ykhvb2tzJyBwcm9wZXJ0eSBtYWtlcyB0aGUgSG9va3NUcmVlIFVJIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQsXG4gICAgICAgICAgICAvLyBzbyBpdCdzIGVhc2llc3QgZm9yIG5vdyBpZiB3ZSBqdXN0IGRvbid0IGJyZWFrIG9uIHRoaXMgYm91bmRhcnkuXG4gICAgICAgICAgICAvLyBXZSBjYW4gYWx3YXlzIGRlaHlkcmF0ZSBhIGxldmVsIGRlZXBlciAoaW4gdGhlIHZhbHVlIG9iamVjdCkuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxldCBjdXJyZW50ID1cbiAgICAgICAga2V5ID09PSBudWxsID8gY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgOiBjdXJyZW50bHlJbnNwZWN0ZWRQYXRoc1trZXldO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoW2ldXTtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0ZWRFbGVtZW50KGluc3BlY3RlZEVsZW1lbnQ6IEluc3BlY3RlZEVsZW1lbnQpOiB2b2lkIHtcbiAgICBjb25zdCB7aG9va3MsIGlkLCBwcm9wc30gPSBpbnNwZWN0ZWRFbGVtZW50O1xuXG4gICAgY29uc3QgZGV2dG9vbHNJbnN0YW5jZSA9IGlkVG9EZXZUb29sc0luc3RhbmNlTWFwLmdldChpZCk7XG4gICAgaWYgKGRldnRvb2xzSW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBEZXZUb29sc0luc3RhbmNlIHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZXZ0b29sc0luc3RhbmNlLmtpbmQgIT09IEZJQkVSX0lOU1RBTkNFKSB7XG4gICAgICAvLyBUT0RPOiBIYW5kbGUgVmlydHVhbEluc3RhbmNlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpYmVyID0gZGV2dG9vbHNJbnN0YW5jZS5kYXRhO1xuICAgIGNvbnN0IHtlbGVtZW50VHlwZSwgc3RhdGVOb2RlLCB0YWcsIHR5cGV9ID0gZmliZXI7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHIgPSBzdGF0ZU5vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgaG9va3MsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGdsb2JhbC4kciA9IHtcbiAgICAgICAgICBob29rcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICB0eXBlOiB0eXBlLnJlbmRlcixcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIGdsb2JhbC4kciA9IHtcbiAgICAgICAgICBob29rcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICB0eXBlOlxuICAgICAgICAgICAgZWxlbWVudFR5cGUgIT0gbnVsbCAmJiBlbGVtZW50VHlwZS50eXBlICE9IG51bGxcbiAgICAgICAgICAgICAgPyBlbGVtZW50VHlwZS50eXBlXG4gICAgICAgICAgICAgIDogdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBnbG9iYWwuJHIgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9yZUFzR2xvYmFsKFxuICAgIGlkOiBudW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgICBjb3VudDogbnVtYmVyLFxuICApOiB2b2lkIHtcbiAgICBpZiAoaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXRJbk9iamVjdChcbiAgICAgICAgKChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50OiBhbnkpOiBJbnNwZWN0ZWRFbGVtZW50KSxcbiAgICAgICAgcGF0aCxcbiAgICAgICk7XG4gICAgICBjb25zdCBrZXkgPSBgJHJlYWN0VGVtcCR7Y291bnR9YDtcblxuICAgICAgd2luZG93W2tleV0gPSB2YWx1ZTtcblxuICAgICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoKFxuICAgIGlkOiBudW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgKTogP3N0cmluZyB7XG4gICAgaWYgKGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudChpZCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlVG9Db3B5ID0gZ2V0SW5PYmplY3QoXG4gICAgICAgICgobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudDogYW55KTogSW5zcGVjdGVkRWxlbWVudCksXG4gICAgICAgIHBhdGgsXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gc2VyaWFsaXplVG9TdHJpbmcodmFsdWVUb0NvcHkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50KFxuICAgIHJlcXVlc3RJRDogbnVtYmVyLFxuICAgIGlkOiBudW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiB8IG51bGwsXG4gICAgZm9yY2VGdWxsRGF0YTogYm9vbGVhbixcbiAgKTogSW5zcGVjdGVkRWxlbWVudFBheWxvYWQge1xuICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICBtZXJnZUluc3BlY3RlZFBhdGhzKHBhdGgpO1xuICAgIH1cblxuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpICYmICFmb3JjZUZ1bGxEYXRhKSB7XG4gICAgICBpZiAoIWhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkKSB7XG4gICAgICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgbGV0IHNlY29uZGFyeUNhdGVnb3J5ID0gbnVsbDtcbiAgICAgICAgICBpZiAocGF0aFswXSA9PT0gJ2hvb2tzJykge1xuICAgICAgICAgICAgc2Vjb25kYXJ5Q2F0ZWdvcnkgPSAnaG9va3MnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgbm90IGJlZW4gdXBkYXRlZCBzaW5jZSBpdCB3YXMgbGFzdCBpbnNwZWN0ZWQsXG4gICAgICAgICAgLy8gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBzdWJzZXQgb2YgZGF0YSBpbiB0aGUgbmV3bHktaW5zcGVjdGVkIHBhdGguXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICAgICAgdHlwZTogJ2h5ZHJhdGVkLXBhdGgnLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiBjbGVhbkZvckJyaWRnZShcbiAgICAgICAgICAgICAgZ2V0SW5PYmplY3QoXG4gICAgICAgICAgICAgICAgKChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50OiBhbnkpOiBJbnNwZWN0ZWRFbGVtZW50KSxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjcmVhdGVJc1BhdGhBbGxvd2VkKG51bGwsIHNlY29uZGFyeUNhdGVnb3J5KSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIG5vdCBiZWVuIHVwZGF0ZWQgc2luY2UgaXQgd2FzIGxhc3QgaW5zcGVjdGVkLCB3ZSBkb24ndCBuZWVkIHRvIHJldHVybiBpdC5cbiAgICAgICAgICAvLyBJbnN0ZWFkIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgSUQgdG8gaW5kaWNhdGUgdGhhdCBpdCBoYXMgbm90IGNoYW5nZWQuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICAgICAgdHlwZTogJ25vLWNoYW5nZScsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9O1xuICAgIH1cblxuICAgIGhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gdGhlIGVycm9yIG5hbWUgaXMgc3luY2VkIHdpdGggUmVhY3REZWJ1Z0hvb2tzXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1JlYWN0RGVidWdUb29sc1JlbmRlckVycm9yJykge1xuICAgICAgICBsZXQgbWVzc2FnZSA9ICdFcnJvciByZW5kZXJpbmcgaW5zcGVjdGVkIGVsZW1lbnQuJztcbiAgICAgICAgbGV0IHN0YWNrO1xuICAgICAgICAvLyBMb2cgZXJyb3IgJiBjYXVzZSBmb3IgdXNlciB0byBkZWJ1Z1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UgKyAnXFxuXFxuJywgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IuY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckVsZW1lbnRJRChpZCk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gaW5zcGVjdCBob29rcy4gJyArXG4gICAgICAgICAgICAgICdUaGlzIGlzIG1vc3QgbGlrZWx5IGNhdXNlZCBieSBhbiBlcnJvciBpbiBjdXJyZW50IGluc3BlY3RlZCBjb21wb25lbnQnICtcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgIT0gbnVsbCA/IGA6IFwiJHtjb21wb25lbnROYW1lfVwiLmAgOiAnLicpICtcbiAgICAgICAgICAgICAgJ1xcblRoZSBlcnJvciB0aHJvd24gaW4gdGhlIGNvbXBvbmVudCBpczogXFxuXFxuJyxcbiAgICAgICAgICAgIGVycm9yLmNhdXNlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVycm9yLmNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZS5tZXNzYWdlIHx8IG1lc3NhZ2U7XG4gICAgICAgICAgICBzdGFjayA9IGVycm9yLmNhdXNlLnN0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvclR5cGU6ICd1c2VyJyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIGVycm9yIG5hbWUgaXMgc3luY2VkIHdpdGggUmVhY3REZWJ1Z0hvb2tzXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1JlYWN0RGVidWdUb29sc1Vuc3VwcG9ydGVkSG9va0Vycm9yJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgZXJyb3JUeXBlOiAndW5rbm93bi1ob29rJyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICdVbnN1cHBvcnRlZCBob29rIGluIHRoZSByZWFjdC1kZWJ1Zy10b29scyBwYWNrYWdlOiAnICtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIExvZyBVbmNhdWdodCBFcnJvclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5zcGVjdGluZyBlbGVtZW50LlxcblxcbicsIGVycm9yKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3JUeXBlOiAndW5jYXVnaHQnLFxuICAgICAgICBpZCxcbiAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2ssXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICB0eXBlOiAnbm90LWZvdW5kJyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQW55IHRpbWUgYW4gaW5zcGVjdGVkIGVsZW1lbnQgaGFzIGFuIHVwZGF0ZSxcbiAgICAvLyB3ZSBzaG91bGQgdXBkYXRlIHRoZSBzZWxlY3RlZCAkciB2YWx1ZSBhcyB3ZWwuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgZGVoeWRyYXRpb24gKGNsZWFuRm9yQnJpZGdlKS5cbiAgICB1cGRhdGVTZWxlY3RlZEVsZW1lbnQobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCk7XG5cbiAgICAvLyBDbG9uZSBiZWZvcmUgY2xlYW5pbmcgc28gdGhhdCB3ZSBwcmVzZXJ2ZSB0aGUgZnVsbCBkYXRhLlxuICAgIC8vIFRoaXMgd2lsbCBlbmFibGUgdXMgdG8gc2VuZCBwYXRjaGVzIHdpdGhvdXQgcmUtaW5zcGVjdGluZyBpZiBoeWRyYXRlZCBwYXRocyBhcmUgcmVxdWVzdGVkLlxuICAgIC8vIChSZWR1Y2luZyBob3cgb2Z0ZW4gd2Ugc2hhbGxvdy1yZW5kZXIgaXMgYSBiZXR0ZXIgRFggZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMgdGhhdCB1c2UgaG9va3MuKVxuICAgIGNvbnN0IGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50ID0gey4uLm1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnR9O1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuY29udGV4dCA9IGNsZWFuRm9yQnJpZGdlKFxuICAgICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuY29udGV4dCxcbiAgICAgIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ2NvbnRleHQnLCBudWxsKSxcbiAgICApO1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuaG9va3MgPSBjbGVhbkZvckJyaWRnZShcbiAgICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50Lmhvb2tzLFxuICAgICAgY3JlYXRlSXNQYXRoQWxsb3dlZCgnaG9va3MnLCAnaG9va3MnKSxcbiAgICApO1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQucHJvcHMgPSBjbGVhbkZvckJyaWRnZShcbiAgICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnByb3BzLFxuICAgICAgY3JlYXRlSXNQYXRoQWxsb3dlZCgncHJvcHMnLCBudWxsKSxcbiAgICApO1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuc3RhdGUgPSBjbGVhbkZvckJyaWRnZShcbiAgICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnN0YXRlLFxuICAgICAgY3JlYXRlSXNQYXRoQWxsb3dlZCgnc3RhdGUnLCBudWxsKSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgdHlwZTogJ2Z1bGwtZGF0YScsXG4gICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgdmFsdWU6IGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFbGVtZW50VG9Db25zb2xlKGlkOiBudW1iZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnRDdXJyZW50KGlkKVxuICAgICAgPyBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50XG4gICAgICA6IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIERldlRvb2xzSW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRWxlbWVudElEKGlkKTtcblxuICAgIGNvbnN0IHN1cHBvcnRzR3JvdXAgPSB0eXBlb2YgY29uc29sZS5ncm91cENvbGxhcHNlZCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAgICAgYFtDbGljayB0byBleHBhbmRdICVjPCR7ZGlzcGxheU5hbWUgfHwgJ0NvbXBvbmVudCd9IC8+YCxcbiAgICAgICAgLy8gLS1kb20tdGFnLW5hbWUtY29sb3IgaXMgdGhlIENTUyB2YXJpYWJsZSBDaHJvbWUgc3R5bGVzIEhUTUwgZWxlbWVudHMgd2l0aCBpbiB0aGUgY29uc29sZS5cbiAgICAgICAgJ2NvbG9yOiB2YXIoLS1kb20tdGFnLW5hbWUtY29sb3IpOyBmb250LXdlaWdodDogbm9ybWFsOycsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnByb3BzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnUHJvcHM6JywgcmVzdWx0LnByb3BzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5zdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ1N0YXRlOicsIHJlc3VsdC5zdGF0ZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaG9va3MgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdIb29rczonLCByZXN1bHQuaG9va3MpO1xuICAgIH1cbiAgICBjb25zdCBob3N0SW5zdGFuY2VzID0gZmluZEhvc3RJbnN0YW5jZXNGb3JFbGVtZW50SUQoaWQpO1xuICAgIGlmIChob3N0SW5zdGFuY2VzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnTm9kZXM6JywgaG9zdEluc3RhbmNlcyk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuY2hyb21lIHx8IC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICdSaWdodC1jbGljayBhbnkgdmFsdWUgdG8gc2F2ZSBpdCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBmb3IgZnVydGhlciBpbnNwZWN0aW9uLicsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVBhdGgoXG4gICAgdHlwZTogJ2NvbnRleHQnIHwgJ2hvb2tzJyB8ICdwcm9wcycgfCAnc3RhdGUnLFxuICAgIGlkOiBudW1iZXIsXG4gICAgaG9va0lEOiA/bnVtYmVyLFxuICAgIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGRldnRvb2xzSW5zdGFuY2UgPSBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgIGlmIChkZXZ0b29sc0luc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgRGV2VG9vbHNJbnN0YW5jZSB3aXRoIGlkIFwiJHtpZH1cImApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZS5raW5kICE9PSBGSUJFUl9JTlNUQU5DRSkge1xuICAgICAgLy8gVE9ETzogSGFuZGxlIFZpcnR1YWxJbnN0YW5jZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmliZXIgPSBkZXZ0b29sc0luc3RhbmNlLmRhdGE7XG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgIC8vIFRvIHNpbXBsaWZ5IGh5ZHJhdGlvbiBhbmQgZGlzcGxheSBvZiBwcmltaXRpdmUgY29udGV4dCB2YWx1ZXMgKGUuZy4gbnVtYmVyLCBzdHJpbmcpXG4gICAgICAgICAgLy8gdGhlIGluc3BlY3RFbGVtZW50KCkgbWV0aG9kIHdyYXBzIGNvbnRleHQgaW4gYSB7dmFsdWU6IC4uLn0gb2JqZWN0LlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBwYXRoICh0aGUgXCJ2YWx1ZVwiKSBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgY29udGV4dCB2YWx1ZSAobm9vcClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGVQYXRoSW5PYmplY3QoaW5zdGFuY2UuY29udGV4dCwgcGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjb21wb25lbnRzIHVzaW5nIGxlZ2FjeSBjb250ZXh0IGFyZSBub3QgZWRpdGFibGVcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGluc3RhbmNlIG9uIHdoaWNoIHRvIGNyZWF0ZSBhIGNsb25lZCwgbXV0YXRlZCBjb250ZXh0LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoKGZpYmVyLCAoKGhvb2tJRDogYW55KTogbnVtYmVyKSwgcGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoKGZpYmVyLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhEZWxldGUoaW5zdGFuY2UucHJvcHMsIHBhdGgpO1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICBkZWxldGVQYXRoSW5PYmplY3QoaW5zdGFuY2Uuc3RhdGUsIHBhdGgpO1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuYW1lUGF0aChcbiAgICB0eXBlOiAnY29udGV4dCcgfCAnaG9va3MnIHwgJ3Byb3BzJyB8ICdzdGF0ZScsXG4gICAgaWQ6IG51bWJlcixcbiAgICBob29rSUQ6ID9udW1iZXIsXG4gICAgb2xkUGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgICBuZXdQYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIERldlRvb2xzSW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRldnRvb2xzSW5zdGFuY2Uua2luZCAhPT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBWaXJ0dWFsSW5zdGFuY2UuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpYmVyID0gZGV2dG9vbHNJbnN0YW5jZS5kYXRhO1xuICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgb2YgcHJpbWl0aXZlIGNvbnRleHQgdmFsdWVzIChlLmcuIG51bWJlciwgc3RyaW5nKVxuICAgICAgICAgIC8vIHRoZSBpbnNwZWN0RWxlbWVudCgpIG1ldGhvZCB3cmFwcyBjb250ZXh0IGluIGEge3ZhbHVlOiAuLi59IG9iamVjdC5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGF0aCAodGhlIFwidmFsdWVcIikgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgb2xkUGF0aCA9IG9sZFBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgbmV3UGF0aCA9IG5ld1BhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaWYgKG9sZFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIGNvbnRleHQgdmFsdWUgKG5vb3ApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lUGF0aEluT2JqZWN0KGluc3RhbmNlLmNvbnRleHQsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY29tcG9uZW50cyB1c2luZyBsZWdhY3kgY29udGV4dCBhcmUgbm90IGVkaXRhYmxlXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBpbnN0YW5jZSBvbiB3aGljaCB0byBjcmVhdGUgYSBjbG9uZWQsIG11dGF0ZWQgY29udGV4dC5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aChcbiAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICgoaG9va0lEOiBhbnkpOiBudW1iZXIpLFxuICAgICAgICAgICAgICBvbGRQYXRoLFxuICAgICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShcbiAgICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMsXG4gICAgICAgICAgICAgIG9sZFBhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICByZW5hbWVQYXRoSW5PYmplY3QoaW5zdGFuY2Uuc3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGVWYWx1ZUF0UGF0aChcbiAgICB0eXBlOiAnY29udGV4dCcgfCAnaG9va3MnIHwgJ3Byb3BzJyB8ICdzdGF0ZScsXG4gICAgaWQ6IG51bWJlcixcbiAgICBob29rSUQ6ID9udW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgICB2YWx1ZTogYW55LFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIERldlRvb2xzSW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRldnRvb2xzSW5zdGFuY2Uua2luZCAhPT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBWaXJ0dWFsSW5zdGFuY2UuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpYmVyID0gZGV2dG9vbHNJbnN0YW5jZS5kYXRhO1xuICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgb2YgcHJpbWl0aXZlIGNvbnRleHQgdmFsdWVzIChlLmcuIG51bWJlciwgc3RyaW5nKVxuICAgICAgICAgIC8vIHRoZSBpbnNwZWN0RWxlbWVudCgpIG1ldGhvZCB3cmFwcyBjb250ZXh0IGluIGEge3ZhbHVlOiAuLi59IG9iamVjdC5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGF0aCAodGhlIFwidmFsdWVcIikgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIGNvbnRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW5PYmplY3QoaW5zdGFuY2UuY29udGV4dCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY29tcG9uZW50cyB1c2luZyBsZWdhY3kgY29udGV4dCBhcmUgbm90IGVkaXRhYmxlXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBpbnN0YW5jZSBvbiB3aGljaCB0byBjcmVhdGUgYSBjbG9uZWQsIG11dGF0ZWQgY29udGV4dC5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIb29rU3RhdGUoZmliZXIsICgoaG9va0lEOiBhbnkpOiBudW1iZXIpLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoU2V0KGluc3RhbmNlLnByb3BzLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wcyhmaWJlciwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBzZXRJbk9iamVjdChpbnN0YW5jZS5zdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHlwZSBDb21taXRQcm9maWxpbmdEYXRhID0ge1xuICAgIGNoYW5nZURlc2NyaXB0aW9uczogTWFwPG51bWJlciwgQ2hhbmdlRGVzY3JpcHRpb24+IHwgbnVsbCxcbiAgICBjb21taXRUaW1lOiBudW1iZXIsXG4gICAgZHVyYXRpb25zOiBBcnJheTxudW1iZXI+LFxuICAgIGVmZmVjdER1cmF0aW9uOiBudW1iZXIgfCBudWxsLFxuICAgIG1heEFjdHVhbER1cmF0aW9uOiBudW1iZXIsXG4gICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiBudW1iZXIgfCBudWxsLFxuICAgIHByaW9yaXR5TGV2ZWw6IHN0cmluZyB8IG51bGwsXG4gICAgdXBkYXRlcnM6IEFycmF5PFNlcmlhbGl6ZWRFbGVtZW50PiB8IG51bGwsXG4gIH07XG5cbiAgdHlwZSBDb21taXRQcm9maWxpbmdNZXRhZGF0YU1hcCA9IE1hcDxudW1iZXIsIEFycmF5PENvbW1pdFByb2ZpbGluZ0RhdGE+PjtcbiAgdHlwZSBEaXNwbGF5TmFtZXNCeVJvb3RJRCA9IE1hcDxudW1iZXIsIHN0cmluZz47XG5cbiAgbGV0IGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YTogQ29tbWl0UHJvZmlsaW5nRGF0YSB8IG51bGwgPSBudWxsO1xuICBsZXQgZGlzcGxheU5hbWVzQnlSb290SUQ6IERpc3BsYXlOYW1lc0J5Um9vdElEIHwgbnVsbCA9IG51bGw7XG4gIGxldCBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXA6IE1hcDxudW1iZXIsIEFycmF5PFtudW1iZXIsIG51bWJlcl0+PiB8IG51bGwgPVxuICAgIG51bGw7XG4gIGxldCBpc1Byb2ZpbGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBsZXQgcHJvZmlsaW5nU3RhcnRUaW1lOiBudW1iZXIgPSAwO1xuICBsZXQgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOiBib29sZWFuID0gZmFsc2U7XG4gIGxldCByZWNvcmRUaW1lbGluZTogYm9vbGVhbiA9IGZhbHNlO1xuICBsZXQgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXA6IENvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwIHwgbnVsbCA9XG4gICAgbnVsbDtcblxuICBmdW5jdGlvbiBnZXRQcm9maWxpbmdEYXRhKCk6IFByb2ZpbGluZ0RhdGFCYWNrZW5kIHtcbiAgICBjb25zdCBkYXRhRm9yUm9vdHM6IEFycmF5PFByb2ZpbGluZ0RhdGFGb3JSb290QmFja2VuZD4gPSBbXTtcblxuICAgIGlmIChyb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICdnZXRQcm9maWxpbmdEYXRhKCkgY2FsbGVkIGJlZm9yZSBhbnkgcHJvZmlsaW5nIGRhdGEgd2FzIHJlY29yZGVkJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAuZm9yRWFjaChcbiAgICAgIChjb21taXRQcm9maWxpbmdNZXRhZGF0YSwgcm9vdElEKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbW1pdERhdGE6IEFycmF5PENvbW1pdERhdGFCYWNrZW5kPiA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID1cbiAgICAgICAgICAoZGlzcGxheU5hbWVzQnlSb290SUQgIT09IG51bGwgJiYgZGlzcGxheU5hbWVzQnlSb290SUQuZ2V0KHJvb3RJRCkpIHx8XG4gICAgICAgICAgJ1Vua25vd24nO1xuXG4gICAgICAgIGNvbnN0IGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPVxuICAgICAgICAgIChpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXAgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcC5nZXQocm9vdElEKSkgfHxcbiAgICAgICAgICBbXTtcblxuICAgICAgICBjb21taXRQcm9maWxpbmdNZXRhZGF0YS5mb3JFYWNoKChjb21taXRQcm9maWxpbmdEYXRhLCBjb21taXRJbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNoYW5nZURlc2NyaXB0aW9ucyxcbiAgICAgICAgICAgIGR1cmF0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgbWF4QWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgICAgICAgY29tbWl0VGltZSxcbiAgICAgICAgICAgIHVwZGF0ZXJzLFxuICAgICAgICAgIH0gPSBjb21taXRQcm9maWxpbmdEYXRhO1xuXG4gICAgICAgICAgY29uc3QgZmliZXJBY3R1YWxEdXJhdGlvbnM6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+ID0gW107XG4gICAgICAgICAgY29uc3QgZmliZXJTZWxmRHVyYXRpb25zOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPiA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHVyYXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWJlcklEID0gZHVyYXRpb25zW2ldO1xuICAgICAgICAgICAgZmliZXJBY3R1YWxEdXJhdGlvbnMucHVzaChbXG4gICAgICAgICAgICAgIGZpYmVySUQsXG4gICAgICAgICAgICAgIGZvcm1hdER1cmF0aW9uVG9NaWNyb3NlY29uZHNHcmFudWxhcml0eShkdXJhdGlvbnNbaSArIDFdKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZmliZXJTZWxmRHVyYXRpb25zLnB1c2goW1xuICAgICAgICAgICAgICBmaWJlcklELFxuICAgICAgICAgICAgICBmb3JtYXREdXJhdGlvblRvTWljcm9zZWNvbmRzR3JhbnVsYXJpdHkoZHVyYXRpb25zW2kgKyAyXSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21taXREYXRhLnB1c2goe1xuICAgICAgICAgICAgY2hhbmdlRGVzY3JpcHRpb25zOlxuICAgICAgICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnMgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IEFycmF5LmZyb20oY2hhbmdlRGVzY3JpcHRpb25zLmVudHJpZXMoKSlcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICBkdXJhdGlvbjpcbiAgICAgICAgICAgICAgZm9ybWF0RHVyYXRpb25Ub01pY3Jvc2Vjb25kc0dyYW51bGFyaXR5KG1heEFjdHVhbER1cmF0aW9uKSxcbiAgICAgICAgICAgIGVmZmVjdER1cmF0aW9uOlxuICAgICAgICAgICAgICBlZmZlY3REdXJhdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZm9ybWF0RHVyYXRpb25Ub01pY3Jvc2Vjb25kc0dyYW51bGFyaXR5KGVmZmVjdER1cmF0aW9uKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIGZpYmVyQWN0dWFsRHVyYXRpb25zLFxuICAgICAgICAgICAgZmliZXJTZWxmRHVyYXRpb25zLFxuICAgICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOlxuICAgICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGZvcm1hdER1cmF0aW9uVG9NaWNyb3NlY29uZHNHcmFudWxhcml0eShwYXNzaXZlRWZmZWN0RHVyYXRpb24pXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogY29tbWl0VGltZSxcbiAgICAgICAgICAgIHVwZGF0ZXJzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkYXRhRm9yUm9vdHMucHVzaCh7XG4gICAgICAgICAgY29tbWl0RGF0YSxcbiAgICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMsXG4gICAgICAgICAgcm9vdElELFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGxldCB0aW1lbGluZURhdGEgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgZ2V0VGltZWxpbmVEYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZWxpbmVEYXRhID0gZ2V0VGltZWxpbmVEYXRhKCk7XG4gICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwLFxuICAgICAgICAgIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMsXG4gICAgICAgICAgbGFuZVRvTGFiZWxNYXAsXG4gICAgICAgICAgbGFuZVRvUmVhY3RNZWFzdXJlTWFwLFxuICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgfSA9IGN1cnJlbnRUaW1lbGluZURhdGE7XG5cbiAgICAgICAgdGltZWxpbmVEYXRhID0ge1xuICAgICAgICAgIC4uLnJlc3QsXG5cbiAgICAgICAgICAvLyBNb3N0IG9mIHRoZSBkYXRhIGlzIHNhZmUgdG8gcGFyc2UgYXMtaXMsXG4gICAgICAgICAgLy8gYnV0IHdlIG5lZWQgdG8gY29udmVydCB0aGUgbmVzdGVkIEFycmF5cyBiYWNrIHRvIE1hcHMuXG4gICAgICAgICAgLy8gTW9zdCBvZiB0aGUgZGF0YSBpcyBzYWZlIHRvIHNlcmlhbGl6ZSBhcy1pcyxcbiAgICAgICAgICAvLyBidXQgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBNYXBzIHRvIG5lc3RlZCBBcnJheXMuXG4gICAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzS2V5VmFsdWVBcnJheTogQXJyYXkuZnJvbShcbiAgICAgICAgICAgIGJhdGNoVUlEVG9NZWFzdXJlc01hcC5lbnRyaWVzKCksXG4gICAgICAgICAgKSxcbiAgICAgICAgICBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzOiBBcnJheS5mcm9tKFxuICAgICAgICAgICAgaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1Jhbmdlcy5lbnRyaWVzKCksXG4gICAgICAgICAgKSxcbiAgICAgICAgICBsYW5lVG9MYWJlbEtleVZhbHVlQXJyYXk6IEFycmF5LmZyb20obGFuZVRvTGFiZWxNYXAuZW50cmllcygpKSxcbiAgICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVLZXlWYWx1ZUFycmF5OiBBcnJheS5mcm9tKFxuICAgICAgICAgICAgbGFuZVRvUmVhY3RNZWFzdXJlTWFwLmVudHJpZXMoKSxcbiAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhRm9yUm9vdHMsXG4gICAgICByZW5kZXJlcklELFxuICAgICAgdGltZWxpbmVEYXRhLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzbmFwc2hvdFRyZWVCYXNlRHVyYXRpb25zKFxuICAgIGluc3RhbmNlOiBEZXZUb29sc0luc3RhbmNlLFxuICAgIHRhcmdldDogQXJyYXk8W251bWJlciwgbnVtYmVyXT4sXG4gICkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29udmVydCBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzIGluIHRoaXMgY2FzZSxcbiAgICAvLyBiZWNhdXNlIHRoZSBwcm9maWxpbmcgc3VtbWFyeSBpcyBKU09OIHNlcmlhbGl6ZWQuXG4gICAgaWYgKGluc3RhbmNlLmtpbmQgIT09IEZJTFRFUkVEX0ZJQkVSX0lOU1RBTkNFKSB7XG4gICAgICB0YXJnZXQucHVzaChbaW5zdGFuY2UuaWQsIGluc3RhbmNlLnRyZWVCYXNlRHVyYXRpb25dKTtcbiAgICB9XG4gICAgZm9yIChcbiAgICAgIGxldCBjaGlsZCA9IGluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICBjaGlsZCAhPT0gbnVsbDtcbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmdcbiAgICApIHtcbiAgICAgIHNuYXBzaG90VHJlZUJhc2VEdXJhdGlvbnMoY2hpbGQsIHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRQcm9maWxpbmcoXG4gICAgc2hvdWxkUmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOiBib29sZWFuLFxuICAgIHNob3VsZFJlY29yZFRpbWVsaW5lOiBib29sZWFuLFxuICApIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPSBzaG91bGRSZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM7XG4gICAgcmVjb3JkVGltZWxpbmUgPSBzaG91bGRSZWNvcmRUaW1lbGluZTtcblxuICAgIC8vIENhcHR1cmUgaW5pdGlhbCB2YWx1ZXMgYXMgb2YgdGhlIHRpbWUgcHJvZmlsaW5nIHN0YXJ0cy5cbiAgICAvLyBJdCdzIGltcG9ydGFudCB3ZSBzbmFwc2hvdCBib3RoIHRoZSBkdXJhdGlvbnMgYW5kIHRoZSBpZC10by1yb290IG1hcCxcbiAgICAvLyBzaW5jZSBlaXRoZXIgb2YgdGhlc2UgbWF5IGNoYW5nZSBkdXJpbmcgdGhlIHByb2ZpbGluZyBzZXNzaW9uXG4gICAgLy8gKGUuZy4gd2hlbiBhIGZpYmVyIGlzIHJlLXJlbmRlcmVkIG9yIHdoZW4gYSBmaWJlciBnZXRzIHJlbW92ZWQpLlxuICAgIGRpc3BsYXlOYW1lc0J5Um9vdElEID0gbmV3IE1hcCgpO1xuICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcCA9IG5ldyBNYXAoKTtcblxuICAgIGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKS5mb3JFYWNoKHJvb3QgPT4ge1xuICAgICAgY29uc3Qgcm9vdEluc3RhbmNlID0gcm9vdFRvRmliZXJJbnN0YW5jZU1hcC5nZXQocm9vdCk7XG4gICAgICBpZiAocm9vdEluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCB0aGUgcm9vdCBpbnN0YW5jZSB0byBhbHJlYWR5IGV4aXN0IHdoZW4gc3RhcnRpbmcgcHJvZmlsaW5nJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvb3RJRCA9IHJvb3RJbnN0YW5jZS5pZDtcbiAgICAgICgoZGlzcGxheU5hbWVzQnlSb290SUQ6IGFueSk6IERpc3BsYXlOYW1lc0J5Um9vdElEKS5zZXQoXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgZ2V0RGlzcGxheU5hbWVGb3JSb290KHJvb3QuY3VycmVudCksXG4gICAgICApO1xuICAgICAgY29uc3QgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPiA9IFtdO1xuICAgICAgc25hcHNob3RUcmVlQmFzZUR1cmF0aW9ucyhyb290SW5zdGFuY2UsIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucyk7XG4gICAgICAoaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zTWFwOiBhbnkpLnNldChyb290SUQsIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBpc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgcHJvZmlsaW5nU3RhcnRUaW1lID0gZ2V0Q3VycmVudFRpbWUoKTtcbiAgICByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGlmICh0b2dnbGVQcm9maWxpbmdTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyh0cnVlLCByZWNvcmRUaW1lbGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFByb2ZpbGluZygpIHtcbiAgICBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICAgIHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA9IGZhbHNlO1xuXG4gICAgaWYgKHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgdG9nZ2xlUHJvZmlsaW5nU3RhdHVzKGZhbHNlLCByZWNvcmRUaW1lbGluZSk7XG4gICAgfVxuXG4gICAgcmVjb3JkVGltZWxpbmUgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEF1dG9tYXRpY2FsbHkgc3RhcnQgcHJvZmlsaW5nIHNvIHRoYXQgd2UgZG9uJ3QgbWlzcyB0aW1pbmcgaW5mbyBmcm9tIGluaXRpYWwgXCJtb3VudFwiLlxuICBpZiAoc2hvdWxkU3RhcnRQcm9maWxpbmdOb3cpIHtcbiAgICBzdGFydFByb2ZpbGluZyhcbiAgICAgIHByb2ZpbGluZ1NldHRpbmdzLnJlY29yZENoYW5nZURlc2NyaXB0aW9ucyxcbiAgICAgIHByb2ZpbGluZ1NldHRpbmdzLnJlY29yZFRpbWVsaW5lLFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZWFyZXN0RmliZXIoZGV2dG9vbHNJbnN0YW5jZTogRGV2VG9vbHNJbnN0YW5jZSk6IG51bGwgfCBGaWJlciB7XG4gICAgaWYgKGRldnRvb2xzSW5zdGFuY2Uua2luZCA9PT0gVklSVFVBTF9JTlNUQU5DRSkge1xuICAgICAgbGV0IGluc3Q6IERldlRvb2xzSW5zdGFuY2UgPSBkZXZ0b29sc0luc3RhbmNlO1xuICAgICAgd2hpbGUgKGluc3Qua2luZCA9PT0gVklSVFVBTF9JTlNUQU5DRSkge1xuICAgICAgICAvLyBGb3IgdmlydHVhbCBpbnN0YW5jZXMsIHdlIHNlYXJjaCBkZWVwZXIgdW50aWwgd2UgZmluZCBhIEZpYmVyIGluc3RhbmNlLlxuICAgICAgICAvLyBUaGVuIHdlIHNlYXJjaCB1cHdhcmRzIGZyb20gdGhhdCBGaWJlci4gVGhhdCdzIGJlY2F1c2UgVmlydHVhbCBJbnN0YW5jZXNcbiAgICAgICAgLy8gd2lsbCBhbHdheXMgaGF2ZSBhbiBGaWJlciBjaGlsZCBmaWx0ZXJlZCBvciBub3QuIElmIHdlIHNlYXJjaGVkIGl0cyBwYXJlbnRzXG4gICAgICAgIC8vIHdlIG1pZ2h0IHNraXAgdGhyb3VnaCBhIGZpbHRlcmVkIEVycm9yIEJvdW5kYXJ5IGJlZm9yZSB3ZSBoaXQgYSBGaWJlckluc3RhbmNlLlxuICAgICAgICBpZiAoaW5zdC5maXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdCA9IGluc3QuZmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0LmRhdGEucmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGV2dG9vbHNJbnN0YW5jZS5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IHdpbGwgc3dpdGNoIGJldHdlZW4gdGhlc2UgaW1wbGVtZW50YXRpb25zIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gIC8vIHdlIGhhdmUgYW55IG1hbnVhbGx5IHN1c3BlbmRlZC9lcnJvcmVkLW91dCBGaWJlcnMgb3Igbm90LlxuICBmdW5jdGlvbiBzaG91bGRFcnJvckZpYmVyQWx3YXlzTnVsbCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE1hcCBvZiBGaWJlciBhbmQgaXRzIGZvcmNlIGVycm9yIHN0YXR1czogdHJ1ZSAoZXJyb3IpLCBmYWxzZSAodG9nZ2xlZCBvZmYpXG4gIGNvbnN0IGZvcmNlRXJyb3JGb3JGaWJlcnMgPSBuZXcgTWFwPEZpYmVyLCBib29sZWFuPigpO1xuXG4gIGZ1bmN0aW9uIHNob3VsZEVycm9yRmliZXJBY2NvcmRpbmdUb01hcChmaWJlcjogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiBzZXRFcnJvckhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIG92ZXJyaWRlRXJyb3IoKSB0byBub3QgZ2V0IGNhbGxlZCBmb3IgZWFybGllciBSZWFjdCB2ZXJzaW9ucy4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHVzID0gZm9yY2VFcnJvckZvckZpYmVycy5nZXQoZmliZXIpO1xuICAgIGlmIChzdGF0dXMgPT09IGZhbHNlKSB7XG4gICAgICAvLyBUUklDS1kgb3ZlcnJpZGVFcnJvciBhZGRzIGVudHJpZXMgdG8gdGhpcyBNYXAsXG4gICAgICAvLyBzbyBpZGVhbGx5IGl0IHdvdWxkIGJlIHRoZSBtZXRob2QgdGhhdCBjbGVhcnMgdGhlbSB0b28sXG4gICAgICAvLyBidXQgdGhhdCB3b3VsZCBicmVhayB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGUgZmVhdHVyZSxcbiAgICAgIC8vIHNpbmNlIERldlRvb2xzIG5lZWRzIHRvIHRlbGwgUmVhY3QgdG8gYWN0IGRpZmZlcmVudGx5IHRoYW4gaXQgbm9ybWFsbHkgd291bGRcbiAgICAgIC8vIChkb24ndCBqdXN0IHJlLXJlbmRlciB0aGUgZmFpbGVkIGJvdW5kYXJ5LCBidXQgcmVzZXQgaXRzIGVycm9yZWQgc3RhdGUgdG9vKS5cbiAgICAgIC8vIFNvIHdlIGNhbiBvbmx5IGNsZWFyIGl0IGFmdGVyIHRlbGxpbmcgUmVhY3QgdG8gcmVzZXQgdGhlIHN0YXRlLlxuICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBpcyBwcmVtYXR1cmUgYW5kIHdlIHNob3VsZCBzY2hlZHVsZSBpdCBmb3IgbGF0ZXIsXG4gICAgICAvLyBzaW5jZSB0aGUgcmVuZGVyIGNvdWxkIGFsd2F5cyBmYWlsIHdpdGhvdXQgY29tbWl0dGluZyB0aGUgdXBkYXRlZCBlcnJvciBib3VuZGFyeSxcbiAgICAgIC8vIGJ1dCBzaW5jZSB0aGlzIGlzIGEgREVWLW9ubHkgZmVhdHVyZSwgdGhlIHNpbXBsaWNpdHkgaXMgd29ydGggdGhlIHRyYWRlIG9mZi5cbiAgICAgIGZvcmNlRXJyb3JGb3JGaWJlcnMuZGVsZXRlKGZpYmVyKTtcbiAgICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgLy8gTGFzdCBvdmVycmlkZSBpcyBnb25lLiBTd2l0Y2ggUmVhY3QgYmFjayB0byBmYXN0IHBhdGguXG4gICAgICAgIHNldEVycm9ySGFuZGxlcihzaG91bGRFcnJvckZpYmVyQWx3YXlzTnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IHVuZGVmaW5lZCAmJiBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIHN0YXR1cyA9IGZvcmNlRXJyb3JGb3JGaWJlcnMuZ2V0KGZpYmVyLmFsdGVybmF0ZSk7XG4gICAgICBpZiAoc3RhdHVzID09PSBmYWxzZSkge1xuICAgICAgICBmb3JjZUVycm9yRm9yRmliZXJzLmRlbGV0ZShmaWJlci5hbHRlcm5hdGUpO1xuICAgICAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgLy8gTGFzdCBvdmVycmlkZSBpcyBnb25lLiBTd2l0Y2ggUmVhY3QgYmFjayB0byBmYXN0IHBhdGguXG4gICAgICAgICAgc2V0RXJyb3JIYW5kbGVyKHNob3VsZEVycm9yRmliZXJBbHdheXNOdWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlRXJyb3IoaWQ6IG51bWJlciwgZm9yY2VFcnJvcjogYm9vbGVhbikge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzZXRFcnJvckhhbmRsZXIgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBzY2hlZHVsZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgb3ZlcnJpZGVFcnJvcigpIHRvIG5vdCBnZXQgY2FsbGVkIGZvciBlYXJsaWVyIFJlYWN0IHZlcnNpb25zLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRldnRvb2xzSW5zdGFuY2UgPSBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgIGlmIChkZXZ0b29sc0luc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVhcmVzdEZpYmVyID0gZ2V0TmVhcmVzdEZpYmVyKGRldnRvb2xzSW5zdGFuY2UpO1xuICAgIGlmIChuZWFyZXN0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZpYmVyID0gbmVhcmVzdEZpYmVyO1xuICAgIHdoaWxlICghaXNFcnJvckJvdW5kYXJ5KGZpYmVyKSkge1xuICAgICAgaWYgKGZpYmVyLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICB9XG4gICAgZm9yY2VFcnJvckZvckZpYmVycy5zZXQoZmliZXIsIGZvcmNlRXJyb3IpO1xuICAgIGlmIChmaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlIG9ubHkgbmVlZCBvbmUgb2YgdGhlIEZpYmVycyBpbiB0aGUgc2V0LlxuICAgICAgZm9yY2VFcnJvckZvckZpYmVycy5kZWxldGUoZmliZXIuYWx0ZXJuYXRlKTtcbiAgICB9XG4gICAgaWYgKGZvcmNlRXJyb3JGb3JGaWJlcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgLy8gRmlyc3Qgb3ZlcnJpZGUgaXMgYWRkZWQuIFN3aXRjaCBSZWFjdCB0byBzbG93ZXIgcGF0aC5cbiAgICAgIHNldEVycm9ySGFuZGxlcihzaG91bGRFcnJvckZpYmVyQWNjb3JkaW5nVG9NYXApO1xuICAgIH1cbiAgICBzY2hlZHVsZVVwZGF0ZShmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kRmliZXJBbHdheXNGYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmb3JjZUZhbGxiYWNrRm9yRmliZXJzID0gbmV3IFNldDxGaWJlcj4oKTtcblxuICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kRmliZXJBY2NvcmRpbmdUb1NldChmaWJlcjogRmliZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgZm9yY2VGYWxsYmFja0ZvckZpYmVycy5oYXMoZmliZXIpIHx8XG4gICAgICAoZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIGZvcmNlRmFsbGJhY2tGb3JGaWJlcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlU3VzcGVuc2UoaWQ6IG51bWJlciwgZm9yY2VGYWxsYmFjazogYm9vbGVhbikge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzZXRTdXNwZW5zZUhhbmRsZXIgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBzY2hlZHVsZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgb3ZlcnJpZGVTdXNwZW5zZSgpIHRvIG5vdCBnZXQgY2FsbGVkIGZvciBlYXJsaWVyIFJlYWN0IHZlcnNpb25zLicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkZXZ0b29sc0luc3RhbmNlID0gaWRUb0RldlRvb2xzSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoZGV2dG9vbHNJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lYXJlc3RGaWJlciA9IGdldE5lYXJlc3RGaWJlcihkZXZ0b29sc0luc3RhbmNlKTtcbiAgICBpZiAobmVhcmVzdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmaWJlciA9IG5lYXJlc3RGaWJlcjtcbiAgICB3aGlsZSAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgaWYgKGZpYmVyLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSBvbmx5IG5lZWQgb25lIG9mIHRoZSBGaWJlcnMgaW4gdGhlIHNldC5cbiAgICAgIGZvcmNlRmFsbGJhY2tGb3JGaWJlcnMuZGVsZXRlKGZpYmVyLmFsdGVybmF0ZSk7XG4gICAgfVxuICAgIGlmIChmb3JjZUZhbGxiYWNrKSB7XG4gICAgICBmb3JjZUZhbGxiYWNrRm9yRmliZXJzLmFkZChmaWJlcik7XG4gICAgICBpZiAoZm9yY2VGYWxsYmFja0ZvckZpYmVycy5zaXplID09PSAxKSB7XG4gICAgICAgIC8vIEZpcnN0IG92ZXJyaWRlIGlzIGFkZGVkLiBTd2l0Y2ggUmVhY3QgdG8gc2xvd2VyIHBhdGguXG4gICAgICAgIHNldFN1c3BlbnNlSGFuZGxlcihzaG91bGRTdXNwZW5kRmliZXJBY2NvcmRpbmdUb1NldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcmNlRmFsbGJhY2tGb3JGaWJlcnMuZGVsZXRlKGZpYmVyKTtcbiAgICAgIGlmIChmb3JjZUZhbGxiYWNrRm9yRmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgLy8gTGFzdCBvdmVycmlkZSBpcyBnb25lLiBTd2l0Y2ggUmVhY3QgYmFjayB0byBmYXN0IHBhdGguXG4gICAgICAgIHNldFN1c3BlbnNlSGFuZGxlcihzaG91bGRTdXNwZW5kRmliZXJBbHdheXNGYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNjaGVkdWxlVXBkYXRlKGZpYmVyKTtcbiAgfVxuXG4gIC8vIFJlbWVtYmVyIGlmIHdlJ3JlIHRyeWluZyB0byByZXN0b3JlIHRoZSBzZWxlY3Rpb24gYWZ0ZXIgcmVsb2FkLlxuICAvLyBJbiB0aGF0IGNhc2UsIHdlJ2xsIGRvIHNvbWUgZXh0cmEgY2hlY2tzIGZvciBtYXRjaGluZyBtb3VudHMuXG4gIGxldCB0cmFja2VkUGF0aDogQXJyYXk8UGF0aEZyYW1lPiB8IG51bGwgPSBudWxsO1xuICBsZXQgdHJhY2tlZFBhdGhNYXRjaEZpYmVyOiBGaWJlciB8IG51bGwgPSBudWxsOyAvLyBUaGlzIGlzIHRoZSBkZWVwZXN0IHVuZmlsdGVyZWQgbWF0Y2ggb2YgYSBGaWJlci5cbiAgbGV0IHRyYWNrZWRQYXRoTWF0Y2hJbnN0YW5jZTogRmliZXJJbnN0YW5jZSB8IFZpcnR1YWxJbnN0YW5jZSB8IG51bGwgPSBudWxsOyAvLyBUaGlzIGlzIHRoZSBkZWVwZXN0IG1hdGNoZWQgZmlsdGVyZWQgSW5zdGFuY2UuXG4gIGxldCB0cmFja2VkUGF0aE1hdGNoRGVwdGggPSAtMTtcbiAgbGV0IG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2V0VHJhY2tlZFBhdGgocGF0aDogQXJyYXk8UGF0aEZyYW1lPiB8IG51bGwpIHtcbiAgICBpZiAocGF0aCA9PT0gbnVsbCkge1xuICAgICAgdHJhY2tlZFBhdGhNYXRjaEZpYmVyID0gbnVsbDtcbiAgICAgIHRyYWNrZWRQYXRoTWF0Y2hJbnN0YW5jZSA9IG51bGw7XG4gICAgICB0cmFja2VkUGF0aE1hdGNoRGVwdGggPSAtMTtcbiAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIHRyYWNrZWRQYXRoID0gcGF0aDtcbiAgfVxuXG4gIC8vIFdlIGNhbGwgdGhpcyBiZWZvcmUgdHJhdmVyc2luZyBhIG5ldyBtb3VudC5cbiAgLy8gSXQgcmVtZW1iZXJzIHdoZXRoZXIgdGhpcyBGaWJlciBpcyB0aGUgbmV4dCBiZXN0IG1hdGNoIGZvciB0cmFja2VkIHBhdGguXG4gIC8vIFRoZSByZXR1cm4gdmFsdWUgc2lnbmFscyB3aGV0aGVyIHdlIHNob3VsZCBrZWVwIG1hdGNoaW5nIHNpYmxpbmdzIG9yIG5vdC5cbiAgZnVuY3Rpb24gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KFxuICAgIGZpYmVyOiBGaWJlcixcbiAgICBmaWJlckluc3RhbmNlOiBudWxsIHwgRmliZXJJbnN0YW5jZSB8IEZpbHRlcmVkRmliZXJJbnN0YW5jZSxcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKHRyYWNrZWRQYXRoID09PSBudWxsIHx8ICFtaWdodEJlT25UcmFja2VkUGF0aCkge1xuICAgICAgLy8gRmFzdCBwYXRoOiB0aGVyZSdzIG5vdGhpbmcgdG8gdHJhY2sgc28gZG8gbm90aGluZyBhbmQgaWdub3JlIHNpYmxpbmdzLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXR1cm5GaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICBjb25zdCByZXR1cm5BbHRlcm5hdGUgPSByZXR1cm5GaWJlciAhPT0gbnVsbCA/IHJldHVybkZpYmVyLmFsdGVybmF0ZSA6IG51bGw7XG4gICAgLy8gQnkgbm93IHdlIGtub3cgdGhlcmUncyBzb21lIHNlbGVjdGlvbiB0byByZXN0b3JlLCBhbmQgdGhpcyBpcyBhIG5ldyBGaWJlci5cbiAgICAvLyBJcyB0aGlzIG5ld2x5IG1vdW50ZWQgRmliZXIgYSBkaXJlY3QgY2hpbGQgb2YgdGhlIGN1cnJlbnQgYmVzdCBtYXRjaD9cbiAgICAvLyAoVGhpcyB3aWxsIGFsc28gYmUgdHJ1ZSBmb3IgbmV3IHJvb3RzIGlmIHdlIGhhdmVuJ3QgbWF0Y2hlZCBhbnl0aGluZyB5ZXQuKVxuICAgIGlmIChcbiAgICAgIHRyYWNrZWRQYXRoTWF0Y2hGaWJlciA9PT0gcmV0dXJuRmliZXIgfHxcbiAgICAgICh0cmFja2VkUGF0aE1hdGNoRmliZXIgPT09IHJldHVybkFsdGVybmF0ZSAmJiByZXR1cm5BbHRlcm5hdGUgIT09IG51bGwpXG4gICAgKSB7XG4gICAgICAvLyBJcyB0aGlzIHRoZSBuZXh0IEZpYmVyIHdlIHNob3VsZCBzZWxlY3Q/IExldCdzIGNvbXBhcmUgdGhlIGZyYW1lcy5cbiAgICAgIGNvbnN0IGFjdHVhbEZyYW1lID0gZ2V0UGF0aEZyYW1lKGZpYmVyKTtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgY29uc3QgZXhwZWN0ZWRGcmFtZSA9IHRyYWNrZWRQYXRoW3RyYWNrZWRQYXRoTWF0Y2hEZXB0aCArIDFdO1xuICAgICAgaWYgKGV4cGVjdGVkRnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHNlZSBhIGZyYW1lIGF0IHRoZSBuZXh0IGRlcHRoLicpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBhY3R1YWxGcmFtZS5pbmRleCA9PT0gZXhwZWN0ZWRGcmFtZS5pbmRleCAmJlxuICAgICAgICBhY3R1YWxGcmFtZS5rZXkgPT09IGV4cGVjdGVkRnJhbWUua2V5ICYmXG4gICAgICAgIGFjdHVhbEZyYW1lLmRpc3BsYXlOYW1lID09PSBleHBlY3RlZEZyYW1lLmRpc3BsYXlOYW1lXG4gICAgICApIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBvdXIgbmV4dCBtYXRjaC5cbiAgICAgICAgdHJhY2tlZFBhdGhNYXRjaEZpYmVyID0gZmliZXI7XG4gICAgICAgIGlmIChmaWJlckluc3RhbmNlICE9PSBudWxsICYmIGZpYmVySW5zdGFuY2Uua2luZCA9PT0gRklCRVJfSU5TVEFOQ0UpIHtcbiAgICAgICAgICB0cmFja2VkUGF0aE1hdGNoSW5zdGFuY2UgPSBmaWJlckluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCsrO1xuICAgICAgICAvLyBBcmUgd2Ugb3V0IG9mIGZyYW1lcyB0byBtYXRjaD9cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGlmICh0cmFja2VkUGF0aE1hdGNoRGVwdGggPT09IHRyYWNrZWRQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBUaGVyZSdzIG5vdGhpbmcgdGhhdCBjYW4gcG9zc2libHkgbWF0Y2ggYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAvLyBEb24ndCBjaGVjayB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDaGVjayB0aGUgY2hpbGRyZW4sIGFzIHRoZXkgbWlnaHQgcmV2ZWFsIHRoZSBuZXh0IG1hdGNoLlxuICAgICAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBlaXRoZXIgY2FzZSwgc2luY2Ugd2UgaGF2ZSBhIG1hdGNoLCB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBzaWJsaW5ncy4gVGhleSdsbCBuZXZlciBtYXRjaC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhY2tlZFBhdGhNYXRjaEZpYmVyID09PSBudWxsICYmIGZpYmVySW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIG5vdyBsb29raW5nIGZvciBhIFZpcnR1YWwgSW5zdGFuY2UuIEl0IG1pZ2h0IGJlIGluc2lkZSBmaWx0ZXJlZCBGaWJlcnNcbiAgICAgIC8vIHNvIHdlIGtlZXAgbG9va2luZyBiZWxvdy5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBUaGlzIEZpYmVyJ3MgcGFyZW50IGlzIG9uIHRoZSBwYXRoLCBidXQgdGhpcyBGaWJlciBpdHNlbGYgaXNuJ3QuXG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGl0cyBjaGlsZHJlbi0tdGhleSB3b24ndCBiZSBvbiB0aGUgcGF0aCBlaXRoZXIuXG4gICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSBmYWxzZTtcbiAgICAvLyBIb3dldmVyLCBvbmUgb2YgaXRzIHNpYmxpbmdzIG1heSBiZSBvbiB0aGUgcGF0aCBzbyBrZWVwIHNlYXJjaGluZy5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZpcnR1YWxUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoXG4gICAgdmlydHVhbEluc3RhbmNlOiBWaXJ0dWFsSW5zdGFuY2UsXG4gICAgcGFyZW50SW5zdGFuY2U6IG51bGwgfCBEZXZUb29sc0luc3RhbmNlLFxuICApOiBib29sZWFuIHtcbiAgICBpZiAodHJhY2tlZFBhdGggPT09IG51bGwgfHwgIW1pZ2h0QmVPblRyYWNrZWRQYXRoKSB7XG4gICAgICAvLyBGYXN0IHBhdGg6IHRoZXJlJ3Mgbm90aGluZyB0byB0cmFjayBzbyBkbyBub3RoaW5nIGFuZCBpZ25vcmUgc2libGluZ3MuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHdlJ3ZlIG1hdGNoZWQgb3VyIG5lYXJlc3QgdW5maWx0ZXJlZCBwYXJlbnQgc28gZmFyLlxuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoSW5zdGFuY2UgPT09IHBhcmVudEluc3RhbmNlKSB7XG4gICAgICBjb25zdCBhY3R1YWxGcmFtZSA9IGdldFZpcnR1YWxQYXRoRnJhbWUodmlydHVhbEluc3RhbmNlKTtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgY29uc3QgZXhwZWN0ZWRGcmFtZSA9IHRyYWNrZWRQYXRoW3RyYWNrZWRQYXRoTWF0Y2hEZXB0aCArIDFdO1xuICAgICAgaWYgKGV4cGVjdGVkRnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHNlZSBhIGZyYW1lIGF0IHRoZSBuZXh0IGRlcHRoLicpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBhY3R1YWxGcmFtZS5pbmRleCA9PT0gZXhwZWN0ZWRGcmFtZS5pbmRleCAmJlxuICAgICAgICBhY3R1YWxGcmFtZS5rZXkgPT09IGV4cGVjdGVkRnJhbWUua2V5ICYmXG4gICAgICAgIGFjdHVhbEZyYW1lLmRpc3BsYXlOYW1lID09PSBleHBlY3RlZEZyYW1lLmRpc3BsYXlOYW1lXG4gICAgICApIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBvdXIgbmV4dCBtYXRjaC5cbiAgICAgICAgdHJhY2tlZFBhdGhNYXRjaEZpYmVyID0gbnVsbDsgLy8gRG9uJ3QgYm90aGVyIGxvb2tpbmcgaW4gRmliZXJzIGFueW1vcmUuIFdlJ3JlIGRlZXBlciBub3cuXG4gICAgICAgIHRyYWNrZWRQYXRoTWF0Y2hJbnN0YW5jZSA9IHZpcnR1YWxJbnN0YW5jZTtcbiAgICAgICAgdHJhY2tlZFBhdGhNYXRjaERlcHRoKys7XG4gICAgICAgIC8vIEFyZSB3ZSBvdXQgb2YgZnJhbWVzIHRvIG1hdGNoP1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgaWYgKHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCA9PT0gdHJhY2tlZFBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm90aGluZyB0aGF0IGNhbiBwb3NzaWJseSBtYXRjaCBhZnRlcndhcmRzLlxuICAgICAgICAgIC8vIERvbid0IGNoZWNrIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENoZWNrIHRoZSBjaGlsZHJlbiwgYXMgdGhleSBtaWdodCByZXZlYWwgdGhlIG5leHQgbWF0Y2guXG4gICAgICAgICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGVpdGhlciBjYXNlLCBzaW5jZSB3ZSBoYXZlIGEgbWF0Y2gsIHdlIGRvbid0IG5lZWRcbiAgICAgICAgLy8gdG8gY2hlY2sgdGhlIHNpYmxpbmdzLiBUaGV5J2xsIG5ldmVyIG1hdGNoLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGxvb2tpbmcgZm9yIGEgRmliZXIgd2hpY2ggbWlnaHQgYmUgdW5kZXJuZWF0aCB0aGlzIGluc3RhbmNlLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoaXMgSW5zdGFuY2UncyBwYXJlbnQgaXMgb24gdGhlIHBhdGgsIGJ1dCB0aGlzIEluc3RhbmNlIGl0c2VsZiBpc24ndC5cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgaXRzIGNoaWxkcmVuLS10aGV5IHdvbid0IGJlIG9uIHRoZSBwYXRoIGVpdGhlci5cbiAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlO1xuICAgIC8vIEhvd2V2ZXIsIG9uZSBvZiBpdHMgc2libGluZ3MgbWF5IGJlIG9uIHRoZSBwYXRoIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUFmdGVyTW91bnQoXG4gICAgbWlnaHRTaWJsaW5nc0JlT25UcmFja2VkUGF0aDogYm9vbGVhbixcbiAgKSB7XG4gICAgLy8gdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUJlZm9yZU1vdW50KCkgdG9sZCB1cyB3aGV0aGVyIHRvIG1hdGNoIHNpYmxpbmdzLlxuICAgIC8vIE5vdyB0aGF0IHdlJ3JlIGVudGVyaW5nIHNpYmxpbmdzLCBsZXQncyB1c2UgdGhhdCBpbmZvcm1hdGlvbi5cbiAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGg7XG4gIH1cblxuICAvLyBSb290cyBkb24ndCBoYXZlIGEgcmVhbCBwZXJzaXN0ZW50IGlkZW50aXR5LlxuICAvLyBBIHJvb3QncyBcInBzZXVkbyBrZXlcIiBpcyBcImNoaWxkRGlzcGxheU5hbWU6aW5kZXhXaXRoVGhhdE5hbWVcIi5cbiAgLy8gRm9yIGV4YW1wbGUsIFwiQXBwOjBcIiBvciwgaW4gY2FzZSBvZiBzaW1pbGFyIHJvb3RzLCBcIlN0b3J5OjBcIiwgXCJTdG9yeToxXCIsIGV0Yy5cbiAgLy8gV2Ugd2lsbCB1c2UgdGhpcyB0byB0cnkgdG8gZGlzYW1iaWd1YXRlIHJvb3RzIHdoZW4gcmVzdG9yaW5nIHNlbGVjdGlvbiBiZXR3ZWVuIHJlbG9hZHMuXG4gIGNvbnN0IHJvb3RQc2V1ZG9LZXlzOiBNYXA8bnVtYmVyLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuICBjb25zdCByb290RGlzcGxheU5hbWVDb3VudGVyOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIHNldFJvb3RQc2V1ZG9LZXkoaWQ6IG51bWJlciwgZmliZXI6IEZpYmVyKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldERpc3BsYXlOYW1lRm9yUm9vdChmaWJlcik7XG4gICAgY29uc3QgY291bnRlciA9IHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZ2V0KG5hbWUpIHx8IDA7XG4gICAgcm9vdERpc3BsYXlOYW1lQ291bnRlci5zZXQobmFtZSwgY291bnRlciArIDEpO1xuICAgIGNvbnN0IHBzZXVkb0tleSA9IGAke25hbWV9OiR7Y291bnRlcn1gO1xuICAgIHJvb3RQc2V1ZG9LZXlzLnNldChpZCwgcHNldWRvS2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVJvb3RQc2V1ZG9LZXkoaWQ6IG51bWJlcikge1xuICAgIGNvbnN0IHBzZXVkb0tleSA9IHJvb3RQc2V1ZG9LZXlzLmdldChpZCk7XG4gICAgaWYgKHBzZXVkb0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJvb3QgcHNldWRvIGtleSB0byBiZSBrbm93bi4nKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHBzZXVkb0tleS5zbGljZSgwLCBwc2V1ZG9LZXkubGFzdEluZGV4T2YoJzonKSk7XG4gICAgY29uc3QgY291bnRlciA9IHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZ2V0KG5hbWUpO1xuICAgIGlmIChjb3VudGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY291bnRlciB0byBiZSBrbm93bi4nKTtcbiAgICB9XG4gICAgaWYgKGNvdW50ZXIgPiAxKSB7XG4gICAgICByb290RGlzcGxheU5hbWVDb3VudGVyLnNldChuYW1lLCBjb3VudGVyIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICByb290UHNldWRvS2V5cy5kZWxldGUoaWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JSb290KGZpYmVyOiBGaWJlcik6IHN0cmluZyB7XG4gICAgbGV0IHByZWZlcnJlZERpc3BsYXlOYW1lID0gbnVsbDtcbiAgICBsZXQgZmFsbGJhY2tEaXNwbGF5TmFtZSA9IG51bGw7XG4gICAgbGV0IGNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgLy8gR28gYXQgbW9zdCB0aHJlZSBsZXZlbHMgZGVlcCBpbnRvIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIHdoaWxlIHNlYXJjaGluZyBmb3IgYSBjaGlsZCB0aGF0IGhhcyBhIGRpc3BsYXlOYW1lLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoY2hpbGQpO1xuICAgICAgaWYgKGRpc3BsYXlOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFByZWZlciBkaXNwbGF5IG5hbWVzIHRoYXQgd2UgZ2V0IGZyb20gdXNlci1kZWZpbmVkIGNvbXBvbmVudHMuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gYXZvaWQgdXNpbmcgZS5nLiAnU3VzcGVuc2UnIHVubGVzcyB3ZSBmaW5kIG5vdGhpbmcgZWxzZS5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBhIGZldyB1c2VyLWRlZmluZWQgdGFncywgYnV0IHdlJ2xsIHByZWZlciB0aGUgb25lc1xuICAgICAgICAgIC8vIHRoYXQgYXJlIHVzdWFsbHkgZXhwbGljaXRseSBuYW1lZCAoZnVuY3Rpb24gb3IgY2xhc3MgY29tcG9uZW50cykuXG4gICAgICAgICAgcHJlZmVycmVkRGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFja0Rpc3BsYXlOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgZmFsbGJhY2tEaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJlZmVycmVkRGlzcGxheU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZmVycmVkRGlzcGxheU5hbWUgfHwgZmFsbGJhY2tEaXNwbGF5TmFtZSB8fCAnQW5vbnltb3VzJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhdGhGcmFtZShmaWJlcjogRmliZXIpOiBQYXRoRnJhbWUge1xuICAgIGNvbnN0IHtrZXl9ID0gZmliZXI7XG4gICAgbGV0IGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcik7XG4gICAgY29uc3QgaW5kZXggPSBmaWJlci5pbmRleDtcbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgLy8gUm9vdHMgZG9uJ3QgaGF2ZSBhIHJlYWwgZGlzcGxheU5hbWUsIGluZGV4LCBvciBrZXkuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlJ2xsIHVzZSB0aGUgcHNldWRvIGtleSAoY2hpbGREaXNwbGF5TmFtZTppbmRleFdpdGhUaGF0TmFtZSkuXG4gICAgICAgIGNvbnN0IHJvb3RJbnN0YW5jZSA9IHJvb3RUb0ZpYmVySW5zdGFuY2VNYXAuZ2V0KGZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgIGlmIChyb290SW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHBlY3RlZCB0aGUgcm9vdCBpbnN0YW5jZSB0byBleGlzdCB3aGVuIGNvbXB1dGluZyBhIHBhdGgnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHNldWRvS2V5ID0gcm9vdFBzZXVkb0tleXMuZ2V0KHJvb3RJbnN0YW5jZS5pZCk7XG4gICAgICAgIGlmIChwc2V1ZG9LZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbW91bnRlZCByb290IHRvIGhhdmUga25vd24gcHNldWRvIGtleS4nKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwbGF5TmFtZSA9IHBzZXVkb0tleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGRpc3BsYXlOYW1lID0gZmliZXIudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAga2V5LFxuICAgICAgaW5kZXgsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZpcnR1YWxQYXRoRnJhbWUodmlydHVhbEluc3RhbmNlOiBWaXJ0dWFsSW5zdGFuY2UpOiBQYXRoRnJhbWUge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5TmFtZTogdmlydHVhbEluc3RhbmNlLmRhdGEubmFtZSB8fCAnJyxcbiAgICAgIGtleTogdmlydHVhbEluc3RhbmNlLmRhdGEua2V5ID09IG51bGwgPyBudWxsIDogdmlydHVhbEluc3RhbmNlLmRhdGEua2V5LFxuICAgICAgaW5kZXg6IC0xLCAvLyBXZSB1c2UgLTEgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIGlzIGEgdmlydHVhbCBwYXRoIGZyYW1lLlxuICAgIH07XG4gIH1cblxuICAvLyBQcm9kdWNlcyBhIHNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiB0aGF0IGRvZXMgYSBiZXN0IGVmZm9ydFxuICAvLyBvZiBpZGVudGlmeWluZyBhIHBhcnRpY3VsYXIgRmliZXIgYmV0d2VlbiBwYWdlIHJlbG9hZHMuXG4gIC8vIFRoZSByZXR1cm4gcGF0aCB3aWxsIGNvbnRhaW4gRmliZXJzIHRoYXQgYXJlIFwiaW52aXNpYmxlXCIgdG8gdGhlIHN0b3JlXG4gIC8vIGJlY2F1c2UgdGhlaXIga2V5cyBhbmQgaW5kZXhlcyBhcmUgaW1wb3J0YW50IHRvIHJlc3RvcmluZyB0aGUgc2VsZWN0aW9uLlxuICBmdW5jdGlvbiBnZXRQYXRoRm9yRWxlbWVudChpZDogbnVtYmVyKTogQXJyYXk8UGF0aEZyYW1lPiB8IG51bGwge1xuICAgIGNvbnN0IGRldnRvb2xzSW5zdGFuY2UgPSBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgIGlmIChkZXZ0b29sc0luc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGtleVBhdGggPSBbXTtcblxuICAgIGxldCBpbnN0OiBEZXZUb29sc0luc3RhbmNlID0gZGV2dG9vbHNJbnN0YW5jZTtcbiAgICB3aGlsZSAoaW5zdC5raW5kID09PSBWSVJUVUFMX0lOU1RBTkNFKSB7XG4gICAgICBrZXlQYXRoLnB1c2goZ2V0VmlydHVhbFBhdGhGcmFtZShpbnN0KSk7XG4gICAgICBpZiAoaW5zdC5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGJ1ZyBidXQgbm9uLWVzc2VudGlhbC4gV2Ugc2hvdWxkJ3ZlIGZvdW5kIGEgcm9vdCBpbnN0YW5jZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbnN0ID0gaW5zdC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgbGV0IGZpYmVyOiBudWxsIHwgRmliZXIgPSBpbnN0LmRhdGE7XG4gICAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBrZXlQYXRoLnB1c2goZ2V0UGF0aEZyYW1lKGZpYmVyKSk7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIH1cbiAgICBrZXlQYXRoLnJldmVyc2UoKTtcbiAgICByZXR1cm4ga2V5UGF0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJlc3RNYXRjaEZvclRyYWNrZWRQYXRoKCk6IFBhdGhNYXRjaCB8IG51bGwge1xuICAgIGlmICh0cmFja2VkUGF0aCA9PT0gbnVsbCkge1xuICAgICAgLy8gTm90aGluZyB0byBtYXRjaC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHJhY2tlZFBhdGhNYXRjaEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAvLyBXZSBkaWRuJ3QgZmluZCBhbnl0aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRyYWNrZWRQYXRoTWF0Y2hJbnN0YW5jZS5pZCxcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgaXNGdWxsTWF0Y2g6IHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCA9PT0gdHJhY2tlZFBhdGgubGVuZ3RoIC0gMSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZm9ybWF0UHJpb3JpdHlMZXZlbCA9IChwcmlvcml0eUxldmVsOiA/bnVtYmVyKSA9PiB7XG4gICAgaWYgKHByaW9yaXR5TGV2ZWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnSW1tZWRpYXRlJztcbiAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnVXNlci1CbG9ja2luZyc7XG4gICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ05vcm1hbCc7XG4gICAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ0xvdyc7XG4gICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdJZGxlJztcbiAgICAgIGNhc2UgTm9Qcmlvcml0eTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQoaXNFbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdHJhY2VVcGRhdGVzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0VsZW1lbnRXaXRoSWQoaWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpZFRvRGV2VG9vbHNJbnN0YW5jZU1hcC5oYXMoaWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U291cmNlRm9yRmliZXJJbnN0YW5jZShcbiAgICBmaWJlckluc3RhbmNlOiBGaWJlckluc3RhbmNlLFxuICApOiBTb3VyY2UgfCBudWxsIHtcbiAgICBjb25zdCB1bnJlc29sdmVkU291cmNlID0gZmliZXJJbnN0YW5jZS5zb3VyY2U7XG4gICAgaWYgKFxuICAgICAgdW5yZXNvbHZlZFNvdXJjZSAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHVucmVzb2x2ZWRTb3VyY2UgPT09ICdvYmplY3QnICYmXG4gICAgICAhaXNFcnJvcih1bnJlc29sdmVkU291cmNlKVxuICAgICkge1xuICAgICAgLy8gJEZsb3dGaXhNZTogaXNFcnJvciBzaG91bGQgaGF2ZSByZWZpbmVkIGl0LlxuICAgICAgcmV0dXJuIHVucmVzb2x2ZWRTb3VyY2U7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BhdGNoZXJSZWYgPSBnZXREaXNwYXRjaGVyUmVmKHJlbmRlcmVyKTtcbiAgICBjb25zdCBzdGFja0ZyYW1lID1cbiAgICAgIGRpc3BhdGNoZXJSZWYgPT0gbnVsbFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBnZXRTb3VyY2VMb2NhdGlvbkJ5RmliZXIoXG4gICAgICAgICAgICBSZWFjdFR5cGVPZldvcmssXG4gICAgICAgICAgICBmaWJlckluc3RhbmNlLmRhdGEsXG4gICAgICAgICAgICBkaXNwYXRjaGVyUmVmLFxuICAgICAgICAgICk7XG4gICAgaWYgKHN0YWNrRnJhbWUgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgYSBzb3VyY2UgbG9jYXRpb24gYnkgdGhyb3dpbmcsIHRyeSB0byBnZXQgb25lXG4gICAgICAvLyBmcm9tIGFuIG93bmVkIGNoaWxkIGlmIHBvc3NpYmxlLiBUaGlzIGlzIHRoZSBzYW1lIGJyYW5jaCBhc1xuICAgICAgLy8gZm9yIHZpcnR1YWwgaW5zdGFuY2VzLlxuICAgICAgcmV0dXJuIGdldFNvdXJjZUZvckluc3RhbmNlKGZpYmVySW5zdGFuY2UpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBwYXJzZVNvdXJjZUZyb21Db21wb25lbnRTdGFjayhzdGFja0ZyYW1lKTtcbiAgICBmaWJlckluc3RhbmNlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U291cmNlRm9ySW5zdGFuY2UoaW5zdGFuY2U6IERldlRvb2xzSW5zdGFuY2UpOiBTb3VyY2UgfCBudWxsIHtcbiAgICBsZXQgdW5yZXNvbHZlZFNvdXJjZSA9IGluc3RhbmNlLnNvdXJjZTtcbiAgICBpZiAodW5yZXNvbHZlZFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnkgc291cmNlIHlldC4gV2UgY2FuIHRyeSBhZ2FpbiBsYXRlciBpbiBjYXNlIGFuIG93bmVkIGNoaWxkIG1vdW50cyBsYXRlci5cbiAgICAgIC8vIFRPRE86IFdlIHdvbid0IGhhdmUgYW55IGluZm9ybWF0aW9uIGhlcmUgaWYgdGhlIGNoaWxkIGlzIGZpbHRlcmVkLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB0aGUgZGVidWcgc3RhY2sgKHRoZSBjcmVhdGlvbiBzdGFjayBvZiB0aGUgSlNYKSBmb3IgYW55IG93bmVkIGNoaWxkIG9mIHRoaXNcbiAgICAvLyBjb21wb25lbnQsIHRoZW4gYXQgdGhlIGJvdHRvbSBvZiB0aGF0IHN0YWNrIHdpbGwgYmUgYSBzdGFjayBmcmFtZSB0aGF0IGlzIHNvbWV3aGVyZSB3aXRoaW5cbiAgICAvLyB0aGUgY29tcG9uZW50J3MgZnVuY3Rpb24gYm9keS4gVHlwaWNhbGx5IGl0IHdvdWxkIGJlIHRoZSBjYWxsc2l0ZSBvZiB0aGUgSlNYIHVubGVzcyB0aGVyZSdzXG4gICAgLy8gYW55IGludGVybWVkaWF0ZSB1dGlsaXR5IGZ1bmN0aW9ucy4gVGhpcyB3b24ndCBwb2ludCB0byB0aGUgdG9wIG9mIHRoZSBjb21wb25lbnQgZnVuY3Rpb25cbiAgICAvLyBidXQgaXQncyBhdCBsZWFzdCBzb21ld2hlcmUgd2l0aGluIGl0LlxuICAgIGlmIChpc0Vycm9yKHVucmVzb2x2ZWRTb3VyY2UpKSB7XG4gICAgICB1bnJlc29sdmVkU291cmNlID0gZm9ybWF0T3duZXJTdGFjaygodW5yZXNvbHZlZFNvdXJjZTogYW55KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdW5yZXNvbHZlZFNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGlkeCA9IHVucmVzb2x2ZWRTb3VyY2UubGFzdEluZGV4T2YoJ1xcbicpO1xuICAgICAgY29uc3QgbGFzdExpbmUgPVxuICAgICAgICBpZHggPT09IC0xID8gdW5yZXNvbHZlZFNvdXJjZSA6IHVucmVzb2x2ZWRTb3VyY2Uuc2xpY2UoaWR4ICsgMSk7XG4gICAgICByZXR1cm4gKGluc3RhbmNlLnNvdXJjZSA9IHBhcnNlU291cmNlRnJvbUNvbXBvbmVudFN0YWNrKGxhc3RMaW5lKSk7XG4gICAgfVxuXG4gICAgLy8gJEZsb3dGaXhNZTogcmVmaW5lZC5cbiAgICByZXR1cm4gdW5yZXNvbHZlZFNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYW51cCxcbiAgICBjbGVhckVycm9yc0FuZFdhcm5pbmdzLFxuICAgIGNsZWFyRXJyb3JzRm9yRWxlbWVudElELFxuICAgIGNsZWFyV2FybmluZ3NGb3JFbGVtZW50SUQsXG4gICAgZ2V0U2VyaWFsaXplZEVsZW1lbnRWYWx1ZUJ5UGF0aCxcbiAgICBkZWxldGVQYXRoLFxuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yRWxlbWVudElELFxuICAgIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMsXG4gICAgZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgsXG4gICAgZ2V0RGlzcGxheU5hbWVGb3JFbGVtZW50SUQsXG4gICAgZ2V0TmVhcmVzdE1vdW50ZWRET01Ob2RlLFxuICAgIGdldEVsZW1lbnRJREZvckhvc3RJbnN0YW5jZSxcbiAgICBnZXRJbnN0YW5jZUFuZFN0eWxlLFxuICAgIGdldE93bmVyc0xpc3QsXG4gICAgZ2V0UGF0aEZvckVsZW1lbnQsXG4gICAgZ2V0UHJvZmlsaW5nRGF0YSxcbiAgICBoYW5kbGVDb21taXRGaWJlclJvb3QsXG4gICAgaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50LFxuICAgIGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3QsXG4gICAgaGFzRWxlbWVudFdpdGhJZCxcbiAgICBpbnNwZWN0RWxlbWVudCxcbiAgICBsb2dFbGVtZW50VG9Db25zb2xlLFxuICAgIGdldENvbXBvbmVudFN0YWNrLFxuICAgIGdldEVsZW1lbnRBdHRyaWJ1dGVCeVBhdGgsXG4gICAgZ2V0RWxlbWVudFNvdXJjZUZ1bmN0aW9uQnlJZCxcbiAgICBvbkVycm9yT3JXYXJuaW5nLFxuICAgIG92ZXJyaWRlRXJyb3IsXG4gICAgb3ZlcnJpZGVTdXNwZW5zZSxcbiAgICBvdmVycmlkZVZhbHVlQXRQYXRoLFxuICAgIHJlbmFtZVBhdGgsXG4gICAgcmVuZGVyZXIsXG4gICAgc2V0VHJhY2VVcGRhdGVzRW5hYmxlZCxcbiAgICBzZXRUcmFja2VkUGF0aCxcbiAgICBzdGFydFByb2ZpbGluZyxcbiAgICBzdG9wUHJvZmlsaW5nLFxuICAgIHN0b3JlQXNHbG9iYWwsXG4gICAgdXBkYXRlQ29tcG9uZW50RmlsdGVycyxcbiAgICBnZXRFbnZpcm9ubWVudE5hbWVzLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/fiber/renderer.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/flight/DevToolsComponentInfoStack.js":
/*!*********************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/flight/DevToolsComponentInfoStack.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOwnerStackByComponentInfoInDev\": () => (/* binding */ getOwnerStackByComponentInfoInDev)\n/* harmony export */ });\n/* harmony import */ var _shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/DevToolsComponentStackFrame */ \"../react-devtools-shared/src/backend/shared/DevToolsComponentStackFrame.js\");\n/* harmony import */ var _shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/DevToolsOwnerStack */ \"../react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactComponentInfoStack.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n\n\nfunction getOwnerStackByComponentInfoInDev(componentInfo) {\n  try {\n    var info = ''; // The owner stack of the current component will be where it was created, i.e. inside its owner.\n    // There's no actual name of the currently executing component. Instead, that is available\n    // on the regular stack that's currently executing. However, if there is no owner at all, then\n    // there's no stack frame so we add the name of the root component to the stack to know which\n    // component is currently executing.\n\n    if (!componentInfo.owner && typeof componentInfo.name === 'string') {\n      return (0,_shared_DevToolsComponentStackFrame__WEBPACK_IMPORTED_MODULE_0__.describeBuiltInComponentFrame)(componentInfo.name);\n    }\n\n    var owner = componentInfo;\n\n    while (owner) {\n      var ownerStack = owner.debugStack;\n\n      if (ownerStack != null) {\n        // Server Component\n        owner = owner.owner;\n\n        if (owner) {\n          // TODO: Should we stash this somewhere for caching purposes?\n          info += '\\n' + (0,_shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_1__.formatOwnerStack)(ownerStack);\n        }\n      } else {\n        break;\n      }\n    }\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZsaWdodC9EZXZUb29sc0NvbXBvbmVudEluZm9TdGFjay5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZsaWdodC9EZXZUb29sc0NvbXBvbmVudEluZm9TdGFjay5qcz9kNmM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIFJlYWN0Q29tcG9uZW50SW5mb1N0YWNrLlxuLy8gVGhpcyBmb3JrIGVuYWJsZXMgRGV2VG9vbHMgdG8gdXNlIHRoZSBzYW1lIFwibmF0aXZlXCIgY29tcG9uZW50IHN0YWNrIGZvcm1hdCxcbi8vIHdoaWxlIHN0aWxsIG1haW50YWluaW5nIHN1cHBvcnQgZm9yIG11bHRpcGxlIHJlbmRlcmVyIHZlcnNpb25zXG4vLyAod2hpY2ggdXNlIGRpZmZlcmVudCB2YWx1ZXMgZm9yIFJlYWN0VHlwZU9mV29yaykuXG5cbmltcG9ydCB0eXBlIHtSZWFjdENvbXBvbmVudEluZm99IGZyb20gJ3NoYXJlZC9SZWFjdFR5cGVzJztcblxuaW1wb3J0IHtkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZX0gZnJvbSAnLi4vc2hhcmVkL0RldlRvb2xzQ29tcG9uZW50U3RhY2tGcmFtZSc7XG5cbmltcG9ydCB7Zm9ybWF0T3duZXJTdGFja30gZnJvbSAnLi4vc2hhcmVkL0RldlRvb2xzT3duZXJTdGFjayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lclN0YWNrQnlDb21wb25lbnRJbmZvSW5EZXYoXG4gIGNvbXBvbmVudEluZm86IFJlYWN0Q29tcG9uZW50SW5mbyxcbik6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgbGV0IGluZm8gPSAnJztcblxuICAgIC8vIFRoZSBvd25lciBzdGFjayBvZiB0aGUgY3VycmVudCBjb21wb25lbnQgd2lsbCBiZSB3aGVyZSBpdCB3YXMgY3JlYXRlZCwgaS5lLiBpbnNpZGUgaXRzIG93bmVyLlxuICAgIC8vIFRoZXJlJ3Mgbm8gYWN0dWFsIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgY29tcG9uZW50LiBJbnN0ZWFkLCB0aGF0IGlzIGF2YWlsYWJsZVxuICAgIC8vIG9uIHRoZSByZWd1bGFyIHN0YWNrIHRoYXQncyBjdXJyZW50bHkgZXhlY3V0aW5nLiBIb3dldmVyLCBpZiB0aGVyZSBpcyBubyBvd25lciBhdCBhbGwsIHRoZW5cbiAgICAvLyB0aGVyZSdzIG5vIHN0YWNrIGZyYW1lIHNvIHdlIGFkZCB0aGUgbmFtZSBvZiB0aGUgcm9vdCBjb21wb25lbnQgdG8gdGhlIHN0YWNrIHRvIGtub3cgd2hpY2hcbiAgICAvLyBjb21wb25lbnQgaXMgY3VycmVudGx5IGV4ZWN1dGluZy5cbiAgICBpZiAoIWNvbXBvbmVudEluZm8ub3duZXIgJiYgdHlwZW9mIGNvbXBvbmVudEluZm8ubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShjb21wb25lbnRJbmZvLm5hbWUpO1xuICAgIH1cblxuICAgIGxldCBvd25lcjogdm9pZCB8IG51bGwgfCBSZWFjdENvbXBvbmVudEluZm8gPSBjb21wb25lbnRJbmZvO1xuXG4gICAgd2hpbGUgKG93bmVyKSB7XG4gICAgICBjb25zdCBvd25lclN0YWNrOiA/RXJyb3IgPSBvd25lci5kZWJ1Z1N0YWNrO1xuICAgICAgaWYgKG93bmVyU3RhY2sgIT0gbnVsbCkge1xuICAgICAgICAvLyBTZXJ2ZXIgQ29tcG9uZW50XG4gICAgICAgIG93bmVyID0gb3duZXIub3duZXI7XG4gICAgICAgIGlmIChvd25lcikge1xuICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBzdGFzaCB0aGlzIHNvbWV3aGVyZSBmb3IgY2FjaGluZyBwdXJwb3Nlcz9cbiAgICAgICAgICBpbmZvICs9ICdcXG4nICsgZm9ybWF0T3duZXJTdGFjayhvd25lclN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/flight/DevToolsComponentInfoStack.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/flight/renderer.js":
/*!***************************************************************!*\
  !*** ../react-devtools-shared/src/backend/flight/renderer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"attach\": () => (/* binding */ attach)\n/* harmony export */ });\n/* harmony import */ var _DevToolsComponentInfoStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DevToolsComponentInfoStack */ \"../react-devtools-shared/src/backend/flight/DevToolsComponentInfoStack.js\");\n/* harmony import */ var _shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/DevToolsOwnerStack */ \"../react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js\");\n/* harmony import */ var _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/DevToolsServerComponentLogs */ \"../react-devtools-shared/src/backend/shared/DevToolsServerComponentLogs.js\");\n/* harmony import */ var react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/backend/utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\nfunction supportsConsoleTasks(componentInfo) {\n  // If this ReactComponentInfo supports native console.createTask then we are already running\n  // inside a native async stack trace if it's active - meaning the DevTools is open.\n  // Ideally we'd detect if this task was created while the DevTools was open or not.\n  return !!componentInfo.debugTask;\n}\n\nfunction attach(hook, rendererID, renderer, global) {\n  var getCurrentComponentInfo = renderer.getCurrentComponentInfo;\n\n  function getComponentStack(topFrame) {\n    if (getCurrentComponentInfo === undefined) {\n      // Expected this to be part of the renderer. Ignore.\n      return null;\n    }\n\n    var current = getCurrentComponentInfo();\n\n    if (current === null) {\n      // Outside of our render scope.\n      return null;\n    }\n\n    if (supportsConsoleTasks(current)) {\n      // This will be handled natively by console.createTask. No need for\n      // DevTools to add it.\n      return null;\n    }\n\n    var enableOwnerStacks = current.debugStack != null;\n    var componentStack = '';\n\n    if (enableOwnerStacks) {\n      // Prefix the owner stack with the current stack. I.e. what called\n      // console.error. While this will also be part of the native stack,\n      // it is hidden and not presented alongside this argument so we print\n      // them all together.\n      var topStackFrames = (0,_shared_DevToolsOwnerStack__WEBPACK_IMPORTED_MODULE_1__.formatOwnerStack)(topFrame);\n\n      if (topStackFrames) {\n        componentStack += '\\n' + topStackFrames;\n      }\n\n      componentStack += (0,_DevToolsComponentInfoStack__WEBPACK_IMPORTED_MODULE_0__.getOwnerStackByComponentInfoInDev)(current);\n    }\n\n    return {\n      enableOwnerStacks: enableOwnerStacks,\n      componentStack: componentStack\n    };\n  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).\n\n\n  function onErrorOrWarning(type, args) {\n    if (getCurrentComponentInfo === undefined) {\n      // Expected this to be part of the renderer. Ignore.\n      return;\n    }\n\n    var componentInfo = getCurrentComponentInfo();\n\n    if (componentInfo === null) {\n      // Outside of our render scope.\n      return;\n    }\n\n    if (args.length > 3 && typeof args[0] === 'string' && args[0].startsWith('%c%s%c ') && typeof args[1] === 'string' && typeof args[2] === 'string' && typeof args[3] === 'string') {\n      // This looks like the badge we prefixed to the log. Our UI doesn't support formatted logs.\n      // We remove the formatting. If the environment of the log is the same as the environment of\n      // the component (the common case) we remove the badge completely otherwise leave it plain\n      var format = args[0].slice(7);\n      var env = args[2].trim();\n      args = args.slice(4);\n\n      if (env !== componentInfo.env) {\n        args.unshift('[' + env + '] ' + format);\n      } else {\n        args.unshift(format);\n      }\n    } // We can't really use this message as a unique key, since we can't distinguish\n    // different objects in this implementation. We have to delegate displaying of the objects\n    // to the environment, the browser console, for example, so this is why this should be kept\n    // as an array of arguments, instead of the plain string.\n    // [Warning: %o, {...}] and [Warning: %o, {...}] will be considered as the same message,\n    // even if objects are different\n\n\n    var message = react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_3__.formatConsoleArgumentsToSingleString.apply(void 0, _toConsumableArray(args)); // Track the warning/error for later.\n\n    var componentLogsEntry = _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_2__.componentInfoToComponentLogsMap.get(componentInfo);\n\n    if (componentLogsEntry === undefined) {\n      componentLogsEntry = {\n        errors: new Map(),\n        errorsCount: 0,\n        warnings: new Map(),\n        warningsCount: 0\n      };\n      _shared_DevToolsServerComponentLogs__WEBPACK_IMPORTED_MODULE_2__.componentInfoToComponentLogsMap.set(componentInfo, componentLogsEntry);\n    }\n\n    var messageMap = type === 'error' ? componentLogsEntry.errors : componentLogsEntry.warnings;\n    var count = messageMap.get(message) || 0;\n    messageMap.set(message, count + 1);\n\n    if (type === 'error') {\n      componentLogsEntry.errorsCount++;\n    } else {\n      componentLogsEntry.warningsCount++;\n    } // The changes will be flushed later when we commit this tree to Fiber.\n\n  }\n\n  return {\n    cleanup: function cleanup() {},\n    clearErrorsAndWarnings: function clearErrorsAndWarnings() {},\n    clearErrorsForElementID: function clearErrorsForElementID() {},\n    clearWarningsForElementID: function clearWarningsForElementID() {},\n    getSerializedElementValueByPath: function getSerializedElementValueByPath() {},\n    deletePath: function deletePath() {},\n    findHostInstancesForElementID: function findHostInstancesForElementID() {\n      return null;\n    },\n    flushInitialOperations: function flushInitialOperations() {},\n    getBestMatchForTrackedPath: function getBestMatchForTrackedPath() {\n      return null;\n    },\n    getComponentStack: getComponentStack,\n    getDisplayNameForElementID: function getDisplayNameForElementID() {\n      return null;\n    },\n    getNearestMountedDOMNode: function getNearestMountedDOMNode() {\n      return null;\n    },\n    getElementIDForHostInstance: function getElementIDForHostInstance() {\n      return null;\n    },\n    getInstanceAndStyle: function getInstanceAndStyle() {\n      return {\n        instance: null,\n        style: null\n      };\n    },\n    getOwnersList: function getOwnersList() {\n      return null;\n    },\n    getPathForElement: function getPathForElement() {\n      return null;\n    },\n    getProfilingData: function getProfilingData() {\n      throw new Error('getProfilingData not supported by this renderer');\n    },\n    handleCommitFiberRoot: function handleCommitFiberRoot() {},\n    handleCommitFiberUnmount: function handleCommitFiberUnmount() {},\n    handlePostCommitFiberRoot: function handlePostCommitFiberRoot() {},\n    hasElementWithId: function hasElementWithId() {\n      return false;\n    },\n    inspectElement: function inspectElement(requestID, id, path) {\n      return {\n        id: id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    },\n    logElementToConsole: function logElementToConsole() {},\n    getElementAttributeByPath: function getElementAttributeByPath() {},\n    getElementSourceFunctionById: function getElementSourceFunctionById() {},\n    onErrorOrWarning: onErrorOrWarning,\n    overrideError: function overrideError() {},\n    overrideSuspense: function overrideSuspense() {},\n    overrideValueAtPath: function overrideValueAtPath() {},\n    renamePath: function renamePath() {},\n    renderer: renderer,\n    setTraceUpdatesEnabled: function setTraceUpdatesEnabled() {},\n    setTrackedPath: function setTrackedPath() {},\n    startProfiling: function startProfiling() {},\n    stopProfiling: function stopProfiling() {},\n    storeAsGlobal: function storeAsGlobal() {},\n    updateComponentFilters: function updateComponentFilters() {},\n    getEnvironmentNames: function getEnvironmentNames() {\n      return [];\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2ZsaWdodC9yZW5kZXJlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQWFBO0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtBOztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpFQTtBQTJFQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9mbGlnaHQvcmVuZGVyZXIuanM/NTY2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7UmVhY3RDb21wb25lbnRJbmZvfSBmcm9tICdzaGFyZWQvUmVhY3RUeXBlcyc7XG5cbmltcG9ydCB0eXBlIHtEZXZUb29sc0hvb2ssIFJlYWN0UmVuZGVyZXIsIFJlbmRlcmVySW50ZXJmYWNlfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Z2V0T3duZXJTdGFja0J5Q29tcG9uZW50SW5mb0luRGV2fSBmcm9tICcuL0RldlRvb2xzQ29tcG9uZW50SW5mb1N0YWNrJztcblxuaW1wb3J0IHtmb3JtYXRPd25lclN0YWNrfSBmcm9tICcuLi9zaGFyZWQvRGV2VG9vbHNPd25lclN0YWNrJztcblxuaW1wb3J0IHtjb21wb25lbnRJbmZvVG9Db21wb25lbnRMb2dzTWFwfSBmcm9tICcuLi9zaGFyZWQvRGV2VG9vbHNTZXJ2ZXJDb21wb25lbnRMb2dzJztcblxuaW1wb3J0IHtmb3JtYXRDb25zb2xlQXJndW1lbnRzVG9TaW5nbGVTdHJpbmd9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC91dGlscyc7XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29uc29sZVRhc2tzKGNvbXBvbmVudEluZm86IFJlYWN0Q29tcG9uZW50SW5mbyk6IGJvb2xlYW4ge1xuICAvLyBJZiB0aGlzIFJlYWN0Q29tcG9uZW50SW5mbyBzdXBwb3J0cyBuYXRpdmUgY29uc29sZS5jcmVhdGVUYXNrIHRoZW4gd2UgYXJlIGFscmVhZHkgcnVubmluZ1xuICAvLyBpbnNpZGUgYSBuYXRpdmUgYXN5bmMgc3RhY2sgdHJhY2UgaWYgaXQncyBhY3RpdmUgLSBtZWFuaW5nIHRoZSBEZXZUb29scyBpcyBvcGVuLlxuICAvLyBJZGVhbGx5IHdlJ2QgZGV0ZWN0IGlmIHRoaXMgdGFzayB3YXMgY3JlYXRlZCB3aGlsZSB0aGUgRGV2VG9vbHMgd2FzIG9wZW4gb3Igbm90LlxuICByZXR1cm4gISFjb21wb25lbnRJbmZvLmRlYnVnVGFzaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChcbiAgaG9vazogRGV2VG9vbHNIb29rLFxuICByZW5kZXJlcklEOiBudW1iZXIsXG4gIHJlbmRlcmVyOiBSZWFjdFJlbmRlcmVyLFxuICBnbG9iYWw6IE9iamVjdCxcbik6IFJlbmRlcmVySW50ZXJmYWNlIHtcbiAgY29uc3Qge2dldEN1cnJlbnRDb21wb25lbnRJbmZvfSA9IHJlbmRlcmVyO1xuXG4gIGZ1bmN0aW9uIGdldENvbXBvbmVudFN0YWNrKFxuICAgIHRvcEZyYW1lOiBFcnJvcixcbiAgKTogbnVsbCB8IHtlbmFibGVPd25lclN0YWNrczogYm9vbGVhbiwgY29tcG9uZW50U3RhY2s6IHN0cmluZ30ge1xuICAgIGlmIChnZXRDdXJyZW50Q29tcG9uZW50SW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHBlY3RlZCB0aGlzIHRvIGJlIHBhcnQgb2YgdGhlIHJlbmRlcmVyLiBJZ25vcmUuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IGdldEN1cnJlbnRDb21wb25lbnRJbmZvKCk7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIE91dHNpZGUgb2Ygb3VyIHJlbmRlciBzY29wZS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c0NvbnNvbGVUYXNrcyhjdXJyZW50KSkge1xuICAgICAgLy8gVGhpcyB3aWxsIGJlIGhhbmRsZWQgbmF0aXZlbHkgYnkgY29uc29sZS5jcmVhdGVUYXNrLiBObyBuZWVkIGZvclxuICAgICAgLy8gRGV2VG9vbHMgdG8gYWRkIGl0LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZW5hYmxlT3duZXJTdGFja3MgPSBjdXJyZW50LmRlYnVnU3RhY2sgIT0gbnVsbDtcbiAgICBsZXQgY29tcG9uZW50U3RhY2sgPSAnJztcbiAgICBpZiAoZW5hYmxlT3duZXJTdGFja3MpIHtcbiAgICAgIC8vIFByZWZpeCB0aGUgb3duZXIgc3RhY2sgd2l0aCB0aGUgY3VycmVudCBzdGFjay4gSS5lLiB3aGF0IGNhbGxlZFxuICAgICAgLy8gY29uc29sZS5lcnJvci4gV2hpbGUgdGhpcyB3aWxsIGFsc28gYmUgcGFydCBvZiB0aGUgbmF0aXZlIHN0YWNrLFxuICAgICAgLy8gaXQgaXMgaGlkZGVuIGFuZCBub3QgcHJlc2VudGVkIGFsb25nc2lkZSB0aGlzIGFyZ3VtZW50IHNvIHdlIHByaW50XG4gICAgICAvLyB0aGVtIGFsbCB0b2dldGhlci5cbiAgICAgIGNvbnN0IHRvcFN0YWNrRnJhbWVzID0gZm9ybWF0T3duZXJTdGFjayh0b3BGcmFtZSk7XG4gICAgICBpZiAodG9wU3RhY2tGcmFtZXMpIHtcbiAgICAgICAgY29tcG9uZW50U3RhY2sgKz0gJ1xcbicgKyB0b3BTdGFja0ZyYW1lcztcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudFN0YWNrICs9IGdldE93bmVyU3RhY2tCeUNvbXBvbmVudEluZm9JbkRldihjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHtlbmFibGVPd25lclN0YWNrcywgY29tcG9uZW50U3RhY2t9O1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb3Igd2FybmluZyBpcyBsb2dnZWQgZHVyaW5nIHJlbmRlciwgY29tbWl0LCBvciBwYXNzaXZlIChpbmNsdWRpbmcgdW5tb3VudCBmdW5jdGlvbnMpLlxuICBmdW5jdGlvbiBvbkVycm9yT3JXYXJuaW5nKFxuICAgIHR5cGU6ICdlcnJvcicgfCAnd2FybicsXG4gICAgYXJnczogJFJlYWRPbmx5QXJyYXk8YW55PixcbiAgKTogdm9pZCB7XG4gICAgaWYgKGdldEN1cnJlbnRDb21wb25lbnRJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4cGVjdGVkIHRoaXMgdG8gYmUgcGFydCBvZiB0aGUgcmVuZGVyZXIuIElnbm9yZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50SW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRJbmZvKCk7XG4gICAgaWYgKGNvbXBvbmVudEluZm8gPT09IG51bGwpIHtcbiAgICAgIC8vIE91dHNpZGUgb2Ygb3VyIHJlbmRlciBzY29wZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhcmdzLmxlbmd0aCA+IDMgJiZcbiAgICAgIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJlxuICAgICAgYXJnc1swXS5zdGFydHNXaXRoKCclYyVzJWMgJykgJiZcbiAgICAgIHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJyAmJlxuICAgICAgdHlwZW9mIGFyZ3NbMl0gPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgYXJnc1szXSA9PT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSB0aGUgYmFkZ2Ugd2UgcHJlZml4ZWQgdG8gdGhlIGxvZy4gT3VyIFVJIGRvZXNuJ3Qgc3VwcG9ydCBmb3JtYXR0ZWQgbG9ncy5cbiAgICAgIC8vIFdlIHJlbW92ZSB0aGUgZm9ybWF0dGluZy4gSWYgdGhlIGVudmlyb25tZW50IG9mIHRoZSBsb2cgaXMgdGhlIHNhbWUgYXMgdGhlIGVudmlyb25tZW50IG9mXG4gICAgICAvLyB0aGUgY29tcG9uZW50ICh0aGUgY29tbW9uIGNhc2UpIHdlIHJlbW92ZSB0aGUgYmFkZ2UgY29tcGxldGVseSBvdGhlcndpc2UgbGVhdmUgaXQgcGxhaW5cbiAgICAgIGNvbnN0IGZvcm1hdCA9IGFyZ3NbMF0uc2xpY2UoNyk7XG4gICAgICBjb25zdCBlbnYgPSBhcmdzWzJdLnRyaW0oKTtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDQpO1xuICAgICAgaWYgKGVudiAhPT0gY29tcG9uZW50SW5mby5lbnYpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KCdbJyArIGVudiArICddICcgKyBmb3JtYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVhbGx5IHVzZSB0aGlzIG1lc3NhZ2UgYXMgYSB1bmlxdWUga2V5LCBzaW5jZSB3ZSBjYW4ndCBkaXN0aW5ndWlzaFxuICAgIC8vIGRpZmZlcmVudCBvYmplY3RzIGluIHRoaXMgaW1wbGVtZW50YXRpb24uIFdlIGhhdmUgdG8gZGVsZWdhdGUgZGlzcGxheWluZyBvZiB0aGUgb2JqZWN0c1xuICAgIC8vIHRvIHRoZSBlbnZpcm9ubWVudCwgdGhlIGJyb3dzZXIgY29uc29sZSwgZm9yIGV4YW1wbGUsIHNvIHRoaXMgaXMgd2h5IHRoaXMgc2hvdWxkIGJlIGtlcHRcbiAgICAvLyBhcyBhbiBhcnJheSBvZiBhcmd1bWVudHMsIGluc3RlYWQgb2YgdGhlIHBsYWluIHN0cmluZy5cbiAgICAvLyBbV2FybmluZzogJW8sIHsuLi59XSBhbmQgW1dhcm5pbmc6ICVvLCB7Li4ufV0gd2lsbCBiZSBjb25zaWRlcmVkIGFzIHRoZSBzYW1lIG1lc3NhZ2UsXG4gICAgLy8gZXZlbiBpZiBvYmplY3RzIGFyZSBkaWZmZXJlbnRcbiAgICBjb25zdCBtZXNzYWdlID0gZm9ybWF0Q29uc29sZUFyZ3VtZW50c1RvU2luZ2xlU3RyaW5nKC4uLmFyZ3MpO1xuXG4gICAgLy8gVHJhY2sgdGhlIHdhcm5pbmcvZXJyb3IgZm9yIGxhdGVyLlxuICAgIGxldCBjb21wb25lbnRMb2dzRW50cnkgPSBjb21wb25lbnRJbmZvVG9Db21wb25lbnRMb2dzTWFwLmdldChjb21wb25lbnRJbmZvKTtcbiAgICBpZiAoY29tcG9uZW50TG9nc0VudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbXBvbmVudExvZ3NFbnRyeSA9IHtcbiAgICAgICAgZXJyb3JzOiBuZXcgTWFwKCksXG4gICAgICAgIGVycm9yc0NvdW50OiAwLFxuICAgICAgICB3YXJuaW5nczogbmV3IE1hcCgpLFxuICAgICAgICB3YXJuaW5nc0NvdW50OiAwLFxuICAgICAgfTtcbiAgICAgIGNvbXBvbmVudEluZm9Ub0NvbXBvbmVudExvZ3NNYXAuc2V0KGNvbXBvbmVudEluZm8sIGNvbXBvbmVudExvZ3NFbnRyeSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZU1hcCA9XG4gICAgICB0eXBlID09PSAnZXJyb3InXG4gICAgICAgID8gY29tcG9uZW50TG9nc0VudHJ5LmVycm9yc1xuICAgICAgICA6IGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5ncztcbiAgICBjb25zdCBjb3VudCA9IG1lc3NhZ2VNYXAuZ2V0KG1lc3NhZ2UpIHx8IDA7XG4gICAgbWVzc2FnZU1hcC5zZXQobWVzc2FnZSwgY291bnQgKyAxKTtcbiAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgY29tcG9uZW50TG9nc0VudHJ5LmVycm9yc0NvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudExvZ3NFbnRyeS53YXJuaW5nc0NvdW50Kys7XG4gICAgfVxuXG4gICAgLy8gVGhlIGNoYW5nZXMgd2lsbCBiZSBmbHVzaGVkIGxhdGVyIHdoZW4gd2UgY29tbWl0IHRoaXMgdHJlZSB0byBGaWJlci5cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYW51cCgpIHt9LFxuICAgIGNsZWFyRXJyb3JzQW5kV2FybmluZ3MoKSB7fSxcbiAgICBjbGVhckVycm9yc0ZvckVsZW1lbnRJRCgpIHt9LFxuICAgIGNsZWFyV2FybmluZ3NGb3JFbGVtZW50SUQoKSB7fSxcbiAgICBnZXRTZXJpYWxpemVkRWxlbWVudFZhbHVlQnlQYXRoKCkge30sXG4gICAgZGVsZXRlUGF0aCgpIHt9LFxuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yRWxlbWVudElEKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmbHVzaEluaXRpYWxPcGVyYXRpb25zKCkge30sXG4gICAgZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldENvbXBvbmVudFN0YWNrLFxuICAgIGdldERpc3BsYXlOYW1lRm9yRWxlbWVudElEKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXROZWFyZXN0TW91bnRlZERPTU5vZGUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldEVsZW1lbnRJREZvckhvc3RJbnN0YW5jZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0SW5zdGFuY2VBbmRTdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICBzdHlsZTogbnVsbCxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRPd25lcnNMaXN0KCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBnZXRQYXRoRm9yRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0UHJvZmlsaW5nRGF0YSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0UHJvZmlsaW5nRGF0YSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgICB9LFxuICAgIGhhbmRsZUNvbW1pdEZpYmVyUm9vdCgpIHt9LFxuICAgIGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudCgpIHt9LFxuICAgIGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3QoKSB7fSxcbiAgICBoYXNFbGVtZW50V2l0aElkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaW5zcGVjdEVsZW1lbnQoXG4gICAgICByZXF1ZXN0SUQ6IG51bWJlcixcbiAgICAgIGlkOiBudW1iZXIsXG4gICAgICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+IHwgbnVsbCxcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgIHR5cGU6ICdub3QtZm91bmQnLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGxvZ0VsZW1lbnRUb0NvbnNvbGUoKSB7fSxcbiAgICBnZXRFbGVtZW50QXR0cmlidXRlQnlQYXRoKCkge30sXG4gICAgZ2V0RWxlbWVudFNvdXJjZUZ1bmN0aW9uQnlJZCgpIHt9LFxuICAgIG9uRXJyb3JPcldhcm5pbmcsXG4gICAgb3ZlcnJpZGVFcnJvcigpIHt9LFxuICAgIG92ZXJyaWRlU3VzcGVuc2UoKSB7fSxcbiAgICBvdmVycmlkZVZhbHVlQXRQYXRoKCkge30sXG4gICAgcmVuYW1lUGF0aCgpIHt9LFxuICAgIHJlbmRlcmVyLFxuICAgIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQoKSB7fSxcbiAgICBzZXRUcmFja2VkUGF0aCgpIHt9LFxuICAgIHN0YXJ0UHJvZmlsaW5nKCkge30sXG4gICAgc3RvcFByb2ZpbGluZygpIHt9LFxuICAgIHN0b3JlQXNHbG9iYWwoKSB7fSxcbiAgICB1cGRhdGVDb21wb25lbnRGaWx0ZXJzKCkge30sXG4gICAgZ2V0RW52aXJvbm1lbnROYW1lcygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/flight/renderer.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/index.js":
/*!*****************************************************!*\
  !*** ../react-devtools-shared/src/backend/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initBackend\": () => (/* binding */ initBackend)\n/* harmony export */ });\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./agent */ \"../react-devtools-shared/src/backend/agent.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction initBackend(hook, agent, global, isReloadAndProfileSupported) {\n  if (hook == null) {\n    // DevTools didn't get injected into this page (maybe b'c of the contentType).\n    return function () {};\n  }\n\n  function registerRendererInterface(id, rendererInterface) {\n    agent.registerRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,\n    // it's time to flush the pending operation codes to the frontend.\n\n    rendererInterface.flushInitialOperations();\n  }\n\n  var subs = [hook.sub('renderer-attached', function (_ref) {\n    var id = _ref.id,\n        rendererInterface = _ref.rendererInterface;\n    registerRendererInterface(id, rendererInterface);\n  }), hook.sub('unsupported-renderer-version', function () {\n    agent.onUnsupportedRenderer();\n  }), hook.sub('fastRefreshScheduled', agent.onFastRefreshScheduled), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates), hook.sub('settingsInitialized', agent.onHookSettings) // TODO Add additional subscriptions required for profiling mode\n  ];\n  agent.addListener('getIfHasUnsupportedRendererVersion', function () {\n    if (hook.hasUnsupportedRendererAttached) {\n      agent.onUnsupportedRenderer();\n    }\n  });\n  hook.rendererInterfaces.forEach(function (rendererInterface, id) {\n    registerRendererInterface(id, rendererInterface);\n  });\n  hook.emit('react-devtools', agent);\n  hook.reactDevtoolsAgent = agent;\n\n  var onAgentShutdown = function onAgentShutdown() {\n    subs.forEach(function (fn) {\n      return fn();\n    });\n    hook.rendererInterfaces.forEach(function (rendererInterface) {\n      rendererInterface.cleanup();\n    });\n    hook.reactDevtoolsAgent = null;\n  }; // Agent's event listeners are cleaned up by Agent in `shutdown` implementation.\n\n\n  agent.addListener('shutdown', onAgentShutdown);\n  agent.addListener('updateHookSettings', function (settings) {\n    hook.settings = settings;\n  });\n  agent.addListener('getHookSettings', function () {\n    if (hook.settings != null) {\n      agent.onHookSettings(hook.settings);\n    }\n  });\n\n  if (isReloadAndProfileSupported) {\n    agent.onReloadAndProfileSupportedByHost();\n  }\n\n  return function () {\n    subs.forEach(function (fn) {\n      return fn();\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFHQTs7QUFDQTtBQUNBOztBQUVBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBZkE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9pbmRleC5qcz8yYTY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBBZ2VudCBmcm9tICcuL2FnZW50JztcblxuaW1wb3J0IHR5cGUge0RldlRvb2xzSG9vaywgUmVuZGVyZXJJRCwgUmVuZGVyZXJJbnRlcmZhY2V9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBJbml0QmFja2VuZCA9IHR5cGVvZiBpbml0QmFja2VuZDtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRCYWNrZW5kKFxuICBob29rOiBEZXZUb29sc0hvb2ssXG4gIGFnZW50OiBBZ2VudCxcbiAgZ2xvYmFsOiBPYmplY3QsXG4gIGlzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZDogYm9vbGVhbixcbik6ICgpID0+IHZvaWQge1xuICBpZiAoaG9vayA9PSBudWxsKSB7XG4gICAgLy8gRGV2VG9vbHMgZGlkbid0IGdldCBpbmplY3RlZCBpbnRvIHRoaXMgcGFnZSAobWF5YmUgYidjIG9mIHRoZSBjb250ZW50VHlwZSkuXG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJlckludGVyZmFjZShcbiAgICBpZDogUmVuZGVyZXJJRCxcbiAgICByZW5kZXJlckludGVyZmFjZTogUmVuZGVyZXJJbnRlcmZhY2UsXG4gICkge1xuICAgIGFnZW50LnJlZ2lzdGVyUmVuZGVyZXJJbnRlcmZhY2UoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTtcblxuICAgIC8vIE5vdyB0aGF0IHRoZSBTdG9yZSBhbmQgdGhlIHJlbmRlcmVyIGludGVyZmFjZSBhcmUgY29ubmVjdGVkLFxuICAgIC8vIGl0J3MgdGltZSB0byBmbHVzaCB0aGUgcGVuZGluZyBvcGVyYXRpb24gY29kZXMgdG8gdGhlIGZyb250ZW5kLlxuICAgIHJlbmRlcmVySW50ZXJmYWNlLmZsdXNoSW5pdGlhbE9wZXJhdGlvbnMoKTtcbiAgfVxuXG4gIGNvbnN0IHN1YnMgPSBbXG4gICAgaG9vay5zdWIoXG4gICAgICAncmVuZGVyZXItYXR0YWNoZWQnLFxuICAgICAgKHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJmYWNlLFxuICAgICAgfToge1xuICAgICAgICBpZDogbnVtYmVyLFxuICAgICAgICByZW5kZXJlckludGVyZmFjZTogUmVuZGVyZXJJbnRlcmZhY2UsXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJlZ2lzdGVyUmVuZGVyZXJJbnRlcmZhY2UoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTtcbiAgICAgIH0sXG4gICAgKSxcbiAgICBob29rLnN1YigndW5zdXBwb3J0ZWQtcmVuZGVyZXItdmVyc2lvbicsICgpID0+IHtcbiAgICAgIGFnZW50Lm9uVW5zdXBwb3J0ZWRSZW5kZXJlcigpO1xuICAgIH0pLFxuXG4gICAgaG9vay5zdWIoJ2Zhc3RSZWZyZXNoU2NoZWR1bGVkJywgYWdlbnQub25GYXN0UmVmcmVzaFNjaGVkdWxlZCksXG4gICAgaG9vay5zdWIoJ29wZXJhdGlvbnMnLCBhZ2VudC5vbkhvb2tPcGVyYXRpb25zKSxcbiAgICBob29rLnN1YigndHJhY2VVcGRhdGVzJywgYWdlbnQub25UcmFjZVVwZGF0ZXMpLFxuICAgIGhvb2suc3ViKCdzZXR0aW5nc0luaXRpYWxpemVkJywgYWdlbnQub25Ib29rU2V0dGluZ3MpLFxuXG4gICAgLy8gVE9ETyBBZGQgYWRkaXRpb25hbCBzdWJzY3JpcHRpb25zIHJlcXVpcmVkIGZvciBwcm9maWxpbmcgbW9kZVxuICBdO1xuXG4gIGFnZW50LmFkZExpc3RlbmVyKCdnZXRJZkhhc1Vuc3VwcG9ydGVkUmVuZGVyZXJWZXJzaW9uJywgKCkgPT4ge1xuICAgIGlmIChob29rLmhhc1Vuc3VwcG9ydGVkUmVuZGVyZXJBdHRhY2hlZCkge1xuICAgICAgYWdlbnQub25VbnN1cHBvcnRlZFJlbmRlcmVyKCk7XG4gICAgfVxuICB9KTtcblxuICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5mb3JFYWNoKChyZW5kZXJlckludGVyZmFjZSwgaWQpID0+IHtcbiAgICByZWdpc3RlclJlbmRlcmVySW50ZXJmYWNlKGlkLCByZW5kZXJlckludGVyZmFjZSk7XG4gIH0pO1xuXG4gIGhvb2suZW1pdCgncmVhY3QtZGV2dG9vbHMnLCBhZ2VudCk7XG4gIGhvb2sucmVhY3REZXZ0b29sc0FnZW50ID0gYWdlbnQ7XG5cbiAgY29uc3Qgb25BZ2VudFNodXRkb3duID0gKCkgPT4ge1xuICAgIHN1YnMuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5mb3JFYWNoKHJlbmRlcmVySW50ZXJmYWNlID0+IHtcbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlLmNsZWFudXAoKTtcbiAgICB9KTtcbiAgICBob29rLnJlYWN0RGV2dG9vbHNBZ2VudCA9IG51bGw7XG4gIH07XG5cbiAgLy8gQWdlbnQncyBldmVudCBsaXN0ZW5lcnMgYXJlIGNsZWFuZWQgdXAgYnkgQWdlbnQgaW4gYHNodXRkb3duYCBpbXBsZW1lbnRhdGlvbi5cbiAgYWdlbnQuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgb25BZ2VudFNodXRkb3duKTtcbiAgYWdlbnQuYWRkTGlzdGVuZXIoJ3VwZGF0ZUhvb2tTZXR0aW5ncycsIHNldHRpbmdzID0+IHtcbiAgICBob29rLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gIH0pO1xuICBhZ2VudC5hZGRMaXN0ZW5lcignZ2V0SG9va1NldHRpbmdzJywgKCkgPT4ge1xuICAgIGlmIChob29rLnNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgIGFnZW50Lm9uSG9va1NldHRpbmdzKGhvb2suc2V0dGluZ3MpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGlzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZCkge1xuICAgIGFnZW50Lm9uUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZEJ5SG9zdCgpO1xuICB9XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBzdWJzLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/index.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/legacy/renderer.js":
/*!***************************************************************!*\
  !*** ../react-devtools-shared/src/backend/legacy/renderer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"attach\": () => (/* binding */ attach)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/frontend/types */ \"../react-devtools-shared/src/frontend/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/backend/legacy/utils.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\nfunction getData(internalInstance) {\n  var displayName = null;\n  var key = null; // != used deliberately here to catch undefined and null\n\n  if (internalInstance._currentElement != null) {\n    if (internalInstance._currentElement.key) {\n      key = String(internalInstance._currentElement.key);\n    }\n\n    var elementType = internalInstance._currentElement.type;\n\n    if (typeof elementType === 'string') {\n      displayName = elementType;\n    } else if (typeof elementType === 'function') {\n      displayName = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getDisplayName)(elementType);\n    }\n  }\n\n  return {\n    displayName: displayName,\n    key: key\n  };\n}\n\nfunction getElementType(internalInstance) {\n  // != used deliberately here to catch undefined and null\n  if (internalInstance._currentElement != null) {\n    var elementType = internalInstance._currentElement.type;\n\n    if (typeof elementType === 'function') {\n      var publicInstance = internalInstance.getPublicInstance();\n\n      if (publicInstance !== null) {\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeClass;\n      } else {\n        return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeFunction;\n      }\n    } else if (typeof elementType === 'string') {\n      return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeHostComponent;\n    }\n  }\n\n  return react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown;\n}\n\nfunction getChildren(internalInstance) {\n  var children = []; // If the parent is a native node without rendered children, but with\n  // multiple string children, then the `element` that gets passed in here is\n  // a plain value -- a string or number.\n\n  if (_typeof(internalInstance) !== 'object') {// No children\n  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children\n  } else if (internalInstance._renderedComponent) {\n    var child = internalInstance._renderedComponent;\n\n    if (getElementType(child) !== react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown) {\n      children.push(child);\n    }\n  } else if (internalInstance._renderedChildren) {\n    var renderedChildren = internalInstance._renderedChildren;\n\n    for (var name in renderedChildren) {\n      var _child = renderedChildren[name];\n\n      if (getElementType(_child) !== react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown) {\n        children.push(_child);\n      }\n    }\n  } // Note: we skip the case where children are just strings or numbers\n  // because the new DevTools skips over host text nodes anyway.\n\n\n  return children;\n}\n\nfunction attach(hook, rendererID, renderer, global) {\n  var idToInternalInstanceMap = new Map();\n  var internalInstanceToIDMap = new WeakMap();\n  var internalInstanceToRootIDMap = new WeakMap();\n  var getElementIDForHostInstance = null;\n  var findHostInstanceForInternalID;\n\n  var getNearestMountedDOMNode = function getNearestMountedDOMNode(node) {\n    // Not implemented.\n    return null;\n  };\n\n  if (renderer.ComponentTree) {\n    getElementIDForHostInstance = function getElementIDForHostInstance(node) {\n      var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);\n      return internalInstanceToIDMap.get(internalInstance) || null;\n    };\n\n    findHostInstanceForInternalID = function findHostInstanceForInternalID(id) {\n      var internalInstance = idToInternalInstanceMap.get(id);\n      return renderer.ComponentTree.getNodeFromInstance(internalInstance);\n    };\n\n    getNearestMountedDOMNode = function getNearestMountedDOMNode(node) {\n      var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);\n\n      if (internalInstance != null) {\n        return renderer.ComponentTree.getNodeFromInstance(internalInstance);\n      }\n\n      return null;\n    };\n  } else if (renderer.Mount.getID && renderer.Mount.getNode) {\n    getElementIDForHostInstance = function getElementIDForHostInstance(node) {\n      // Not implemented.\n      return null;\n    };\n\n    findHostInstanceForInternalID = function findHostInstanceForInternalID(id) {\n      // Not implemented.\n      return null;\n    };\n  }\n\n  function getDisplayNameForElementID(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n    return internalInstance ? getData(internalInstance).displayName : null;\n  }\n\n  function getID(internalInstance) {\n    if (_typeof(internalInstance) !== 'object' || internalInstance === null) {\n      throw new Error('Invalid internal instance: ' + internalInstance);\n    }\n\n    if (!internalInstanceToIDMap.has(internalInstance)) {\n      var _id = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getUID)();\n\n      internalInstanceToIDMap.set(internalInstance, _id);\n      idToInternalInstanceMap.set(_id, internalInstance);\n    }\n\n    return internalInstanceToIDMap.get(internalInstance);\n  }\n\n  function areEqualArrays(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  } // This is shared mutable state that lets us keep track of where we are.\n\n\n  var parentIDStack = [];\n  var oldReconcilerMethods = null;\n\n  if (renderer.Reconciler) {\n    // React 15\n    oldReconcilerMethods = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.decorateMany)(renderer.Reconciler, {\n      mountComponent: function mountComponent(fn, args) {\n        var internalInstance = args[0];\n        var hostContainerInfo = args[3];\n\n        if (getElementType(internalInstance) === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        if (hostContainerInfo._topLevelWrapper === undefined) {\n          // SSR\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance); // Push the operation.\n\n        var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;\n        recordMount(internalInstance, id, parentID);\n        parentIDStack.push(id); // Remember the root.\n\n        internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n      performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {\n        var internalInstance = args[0];\n\n        if (getElementType(internalInstance) === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance);\n        parentIDStack.push(id);\n        var prevChildren = getChildren(internalInstance);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          var nextChildren = getChildren(internalInstance);\n\n          if (!areEqualArrays(prevChildren, nextChildren)) {\n            // Push the operation\n            recordReorder(internalInstance, id, nextChildren);\n          }\n\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n      receiveComponent: function receiveComponent(fn, args) {\n        var internalInstance = args[0];\n\n        if (getElementType(internalInstance) === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance);\n        parentIDStack.push(id);\n        var prevChildren = getChildren(internalInstance);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          var nextChildren = getChildren(internalInstance);\n\n          if (!areEqualArrays(prevChildren, nextChildren)) {\n            // Push the operation\n            recordReorder(internalInstance, id, nextChildren);\n          }\n\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n      unmountComponent: function unmountComponent(fn, args) {\n        var internalInstance = args[0];\n\n        if (getElementType(internalInstance) === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeOtherOrUnknown) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        var id = getID(internalInstance);\n        parentIDStack.push(id);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          var result = fn.apply(this, args);\n          parentIDStack.pop(); // Push the operation.\n\n          recordUnmount(internalInstance, id);\n          return result;\n        } catch (err) {\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            var rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      }\n    });\n  }\n\n  function cleanup() {\n    if (oldReconcilerMethods !== null) {\n      if (renderer.Component) {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_4__.restoreMany)(renderer.Component.Mixin, oldReconcilerMethods);\n      } else {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_4__.restoreMany)(renderer.Reconciler, oldReconcilerMethods);\n      }\n    }\n\n    oldReconcilerMethods = null;\n  }\n\n  function recordMount(internalInstance, id, parentID) {\n    var isRoot = parentID === 0;\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);\n    }\n\n    if (isRoot) {\n      // TODO Is this right? For all versions?\n      var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeRoot);\n      pushOperation(0); // StrictMode compliant?\n\n      pushOperation(0); // Profiling flag\n\n      pushOperation(0); // StrictMode supported?\n\n      pushOperation(hasOwnerMetadata ? 1 : 0);\n    } else {\n      var type = getElementType(internalInstance);\n\n      var _getData = getData(internalInstance),\n          displayName = _getData.displayName,\n          key = _getData.key;\n\n      var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;\n      var displayNameStringID = getStringID(displayName);\n      var keyStringID = getStringID(key);\n      pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD);\n      pushOperation(id);\n      pushOperation(type);\n      pushOperation(parentID);\n      pushOperation(ownerID);\n      pushOperation(displayNameStringID);\n      pushOperation(keyStringID);\n    }\n  }\n\n  function recordReorder(internalInstance, id, nextChildren) {\n    pushOperation(_constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REORDER_CHILDREN);\n    pushOperation(id);\n    var nextChildIDs = nextChildren.map(getID);\n    pushOperation(nextChildIDs.length);\n\n    for (var i = 0; i < nextChildIDs.length; i++) {\n      pushOperation(nextChildIDs[i]);\n    }\n  }\n\n  function recordUnmount(internalInstance, id) {\n    pendingUnmountedIDs.push(id);\n    idToInternalInstanceMap.delete(id);\n  }\n\n  function crawlAndRecordInitialMounts(id, parentID, rootID) {\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      console.group('crawlAndRecordInitialMounts() id:', id);\n    }\n\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      internalInstanceToRootIDMap.set(internalInstance, rootID);\n      recordMount(internalInstance, id, parentID);\n      getChildren(internalInstance).forEach(function (child) {\n        return crawlAndRecordInitialMounts(getID(child), id, rootID);\n      });\n    }\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      console.groupEnd();\n    }\n  }\n\n  function flushInitialOperations() {\n    // Crawl roots though and register any nodes that mounted before we were injected.\n    var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;\n\n    for (var key in roots) {\n      var internalInstance = roots[key];\n\n      var _id2 = getID(internalInstance);\n\n      crawlAndRecordInitialMounts(_id2, 0, _id2);\n      flushPendingEvents(_id2);\n    }\n  }\n\n  var pendingOperations = [];\n  var pendingStringTable = new Map();\n  var pendingUnmountedIDs = [];\n  var pendingStringTableLength = 0;\n  var pendingUnmountedRootID = null;\n\n  function flushPendingEvents(rootID) {\n    if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {\n      return;\n    }\n\n    var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n    var operations = new Array( // Identify which renderer this update is coming from.\n    2 + // [rendererID, rootFiberID]\n    // How big is the string table?\n    1 + // [stringTableLength]\n    // Then goes the actual string table.\n    pendingStringTableLength + ( // All unmounts are batched in a single message.\n    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations\n    pendingOperations.length); // Identify which renderer this update is coming from.\n    // This enables roots to be mapped to renderers,\n    // Which in turn enables fiber properations, states, and hooks to be inspected.\n\n    var i = 0;\n    operations[i++] = rendererID;\n    operations[i++] = rootID; // Now fill in the string table.\n    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n    operations[i++] = pendingStringTableLength;\n    pendingStringTable.forEach(function (value, key) {\n      operations[i++] = key.length;\n      var encodedKey = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.utfEncodeString)(key);\n\n      for (var j = 0; j < encodedKey.length; j++) {\n        operations[i + j] = encodedKey[j];\n      }\n\n      i += key.length;\n    });\n\n    if (numUnmountIDs > 0) {\n      // All unmounts except roots are batched in a single message.\n      operations[i++] = _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE; // The first number is how many unmounted IDs we're gonna send.\n\n      operations[i++] = numUnmountIDs; // Fill in the unmounts\n\n      for (var j = 0; j < pendingUnmountedIDs.length; j++) {\n        operations[i++] = pendingUnmountedIDs[j];\n      } // The root ID should always be unmounted last.\n\n\n      if (pendingUnmountedRootID !== null) {\n        operations[i] = pendingUnmountedRootID;\n        i++;\n      }\n    } // Fill in the rest of the operations.\n\n\n    for (var _j = 0; _j < pendingOperations.length; _j++) {\n      operations[i + _j] = pendingOperations[_j];\n    }\n\n    i += pendingOperations.length;\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      (0,_utils__WEBPACK_IMPORTED_MODULE_1__.printOperationsArray)(operations);\n    } // If we've already connected to the frontend, just pass the operations through.\n\n\n    hook.emit('operations', operations);\n    pendingOperations.length = 0;\n    pendingUnmountedIDs = [];\n    pendingUnmountedRootID = null;\n    pendingStringTable.clear();\n    pendingStringTableLength = 0;\n  }\n\n  function pushOperation(op) {\n    if (true) {\n      if (!Number.isInteger(op)) {\n        console.error('pushOperation() was called but the value is not an integer.', op);\n      }\n    }\n\n    pendingOperations.push(op);\n  }\n\n  function getStringID(str) {\n    if (str === null) {\n      return 0;\n    }\n\n    var existingID = pendingStringTable.get(str);\n\n    if (existingID !== undefined) {\n      return existingID;\n    }\n\n    var stringID = pendingStringTable.size + 1;\n    pendingStringTable.set(str, stringID); // The string table total length needs to account\n    // both for the string length, and for the array item\n    // that contains the length itself. Hence + 1.\n\n    pendingStringTableLength += str.length + 1;\n    return stringID;\n  }\n\n  var currentlyInspectedElementID = null;\n  var currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,\n  // so that we can send their data along if the element is re-rendered.\n\n  function mergeInspectedPaths(path) {\n    var current = currentlyInspectedPaths;\n    path.forEach(function (key) {\n      if (!current[key]) {\n        current[key] = {};\n      }\n\n      current = current[key];\n    });\n  }\n\n  function createIsPathAllowed(key) {\n    // This function helps prevent previously-inspected paths from being dehydrated in updates.\n    // This is important to avoid a bad user experience where expanded toggles collapse on update.\n    return function isPathAllowed(path) {\n      var current = currentlyInspectedPaths[key];\n\n      if (!current) {\n        return false;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        current = current[path[i]];\n\n        if (!current) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  } // Fast path props lookup for React Native style editor.\n\n\n  function getInstanceAndStyle(id) {\n    var instance = null;\n    var style = null;\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      instance = internalInstance._instance || null;\n      var element = internalInstance._currentElement;\n\n      if (element != null && element.props != null) {\n        style = element.props.style || null;\n      }\n    }\n\n    return {\n      instance: instance,\n      style: style\n    };\n  }\n\n  function updateSelectedElement(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      console.warn(\"Could not find instance with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    switch (getElementType(internalInstance)) {\n      case react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeClass:\n        global.$r = internalInstance._instance;\n        break;\n\n      case react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeFunction:\n        var element = internalInstance._currentElement;\n\n        if (element == null) {\n          console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n          return;\n        }\n\n        global.$r = {\n          props: element.props,\n          type: element.type\n        };\n        break;\n\n      default:\n        global.$r = null;\n        break;\n    }\n  }\n\n  function storeAsGlobal(id, path, count) {\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      var value = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getInObject)(inspectedElement, path);\n      var key = \"$reactTemp\".concat(count);\n      window[key] = value;\n      console.log(key);\n      console.log(value);\n    }\n  }\n\n  function getSerializedElementValueByPath(id, path) {\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      var valueToCopy = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getInObject)(inspectedElement, path);\n      return (0,_utils__WEBPACK_IMPORTED_MODULE_2__.serializeToString)(valueToCopy);\n    }\n  }\n\n  function inspectElement(requestID, id, path, forceFullData) {\n    if (forceFullData || currentlyInspectedElementID !== id) {\n      currentlyInspectedElementID = id;\n      currentlyInspectedPaths = {};\n    }\n\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement === null) {\n      return {\n        id: id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    }\n\n    if (path !== null) {\n      mergeInspectedPaths(path);\n    } // Any time an inspected element has an update,\n    // we should update the selected $r value as wel.\n    // Do this before dehydration (cleanForBridge).\n\n\n    updateSelectedElement(id);\n    inspectedElement.context = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)(inspectedElement.context, createIsPathAllowed('context'));\n    inspectedElement.props = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)(inspectedElement.props, createIsPathAllowed('props'));\n    inspectedElement.state = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.cleanForBridge)(inspectedElement.state, createIsPathAllowed('state'));\n    return {\n      id: id,\n      responseID: requestID,\n      type: 'full-data',\n      value: inspectedElement\n    };\n  }\n\n  function inspectElementRaw(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      return null;\n    }\n\n    var _getData2 = getData(internalInstance),\n        key = _getData2.key;\n\n    var type = getElementType(internalInstance);\n    var context = null;\n    var owners = null;\n    var props = null;\n    var state = null;\n    var element = internalInstance._currentElement;\n\n    if (element !== null) {\n      props = element.props;\n      var owner = element._owner;\n\n      if (owner) {\n        owners = [];\n\n        while (owner != null) {\n          owners.push({\n            displayName: getData(owner).displayName || 'Unknown',\n            id: getID(owner),\n            key: element.key,\n            type: getElementType(owner)\n          });\n\n          if (owner._currentElement) {\n            owner = owner._currentElement._owner;\n          }\n        }\n      }\n    }\n\n    var publicInstance = internalInstance._instance;\n\n    if (publicInstance != null) {\n      context = publicInstance.context || null;\n      state = publicInstance.state || null;\n    } // Not implemented\n\n\n    var errors = [];\n    var warnings = [];\n    return {\n      id: id,\n      // Does the current renderer support editable hooks and function props?\n      canEditHooks: false,\n      canEditFunctionProps: false,\n      // Does the current renderer support advanced editing interface?\n      canEditHooksAndDeletePaths: false,\n      canEditHooksAndRenamePaths: false,\n      canEditFunctionPropsDeletePaths: false,\n      canEditFunctionPropsRenamePaths: false,\n      // Toggle error boundary did not exist in legacy versions\n      canToggleError: false,\n      isErrored: false,\n      // Suspense did not exist in legacy versions\n      canToggleSuspense: false,\n      // Can view component source location.\n      canViewSource: type === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeClass || type === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeFunction,\n      source: null,\n      // Only legacy context exists in legacy versions.\n      hasLegacyContext: true,\n      type: type,\n      key: key != null ? key : null,\n      // Inspectable properties.\n      context: context,\n      hooks: null,\n      props: props,\n      state: state,\n      errors: errors,\n      warnings: warnings,\n      // List of owners\n      owners: owners,\n      rootType: null,\n      rendererPackageName: null,\n      rendererVersion: null,\n      plugins: {\n        stylex: null\n      }\n    };\n  }\n\n  function logElementToConsole(id) {\n    var result = inspectElementRaw(id);\n\n    if (result === null) {\n      console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n      return;\n    }\n\n    var displayName = getDisplayNameForElementID(id);\n    var supportsGroup = typeof console.groupCollapsed === 'function';\n\n    if (supportsGroup) {\n      console.groupCollapsed(\"[Click to expand] %c<\".concat(displayName || 'Component', \" />\"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n      'color: var(--dom-tag-name-color); font-weight: normal;');\n    }\n\n    if (result.props !== null) {\n      console.log('Props:', result.props);\n    }\n\n    if (result.state !== null) {\n      console.log('State:', result.state);\n    }\n\n    if (result.context !== null) {\n      console.log('Context:', result.context);\n    }\n\n    var hostInstance = findHostInstanceForInternalID(id);\n\n    if (hostInstance !== null) {\n      console.log('Node:', hostInstance);\n    }\n\n    if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n      console.log('Right-click any value to save it as a global variable for further inspection.');\n    }\n\n    if (supportsGroup) {\n      console.groupEnd();\n    }\n  }\n\n  function getElementAttributeByPath(id, path) {\n    var inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getInObject)(inspectedElement, path);\n    }\n\n    return undefined;\n  }\n\n  function getElementSourceFunctionById(id) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      console.warn(\"Could not find instance with id \\\"\".concat(id, \"\\\"\"));\n      return null;\n    }\n\n    var element = internalInstance._currentElement;\n\n    if (element == null) {\n      console.warn(\"Could not find element with id \\\"\".concat(id, \"\\\"\"));\n      return null;\n    }\n\n    return element.type;\n  }\n\n  function deletePath(type, id, hookID, path) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      var publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.deletePathInObject)(publicInstance.context, path);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            var element = internalInstance._currentElement;\n            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {\n              props: (0,_utils__WEBPACK_IMPORTED_MODULE_2__.copyWithDelete)(element.props, path)\n            });\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n\n          case 'state':\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.deletePathInObject)(publicInstance.state, path);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n        }\n      }\n    }\n  }\n\n  function renamePath(type, id, hookID, oldPath, newPath) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      var publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.renamePathInObject)(publicInstance.context, oldPath, newPath);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            var element = internalInstance._currentElement;\n            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {\n              props: (0,_utils__WEBPACK_IMPORTED_MODULE_2__.copyWithRename)(element.props, oldPath, newPath)\n            });\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n\n          case 'state':\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.renamePathInObject)(publicInstance.state, oldPath, newPath);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n        }\n      }\n    }\n  }\n\n  function overrideValueAtPath(type, id, hookID, path, value) {\n    var internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      var publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.setInObject)(publicInstance.context, path, value);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            var element = internalInstance._currentElement;\n            internalInstance._currentElement = _objectSpread(_objectSpread({}, element), {}, {\n              props: (0,_utils__WEBPACK_IMPORTED_MODULE_2__.copyWithSet)(element.props, path, value)\n            });\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n\n          case 'state':\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.setInObject)(publicInstance.state, path, value);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_4__.forceUpdate)(publicInstance);\n            break;\n        }\n      }\n    }\n  } // v16+ only features\n\n\n  var getProfilingData = function getProfilingData() {\n    throw new Error('getProfilingData not supported by this renderer');\n  };\n\n  var handleCommitFiberRoot = function handleCommitFiberRoot() {\n    throw new Error('handleCommitFiberRoot not supported by this renderer');\n  };\n\n  var handleCommitFiberUnmount = function handleCommitFiberUnmount() {\n    throw new Error('handleCommitFiberUnmount not supported by this renderer');\n  };\n\n  var handlePostCommitFiberRoot = function handlePostCommitFiberRoot() {\n    throw new Error('handlePostCommitFiberRoot not supported by this renderer');\n  };\n\n  var overrideError = function overrideError() {\n    throw new Error('overrideError not supported by this renderer');\n  };\n\n  var overrideSuspense = function overrideSuspense() {\n    throw new Error('overrideSuspense not supported by this renderer');\n  };\n\n  var startProfiling = function startProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n  };\n\n  var stopProfiling = function stopProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n  };\n\n  function getBestMatchForTrackedPath() {\n    // Not implemented.\n    return null;\n  }\n\n  function getPathForElement(id) {\n    // Not implemented.\n    return null;\n  }\n\n  function updateComponentFilters(componentFilters) {// Not implemented.\n  }\n\n  function getEnvironmentNames() {\n    // No RSC support.\n    return [];\n  }\n\n  function setTraceUpdatesEnabled(enabled) {// Not implemented.\n  }\n\n  function setTrackedPath(path) {// Not implemented.\n  }\n\n  function getOwnersList(id) {\n    // Not implemented.\n    return null;\n  }\n\n  function clearErrorsAndWarnings() {// Not implemented\n  }\n\n  function clearErrorsForElementID(id) {// Not implemented\n  }\n\n  function clearWarningsForElementID(id) {// Not implemented\n  }\n\n  function hasElementWithId(id) {\n    return idToInternalInstanceMap.has(id);\n  }\n\n  return {\n    clearErrorsAndWarnings: clearErrorsAndWarnings,\n    clearErrorsForElementID: clearErrorsForElementID,\n    clearWarningsForElementID: clearWarningsForElementID,\n    cleanup: cleanup,\n    getSerializedElementValueByPath: getSerializedElementValueByPath,\n    deletePath: deletePath,\n    flushInitialOperations: flushInitialOperations,\n    getBestMatchForTrackedPath: getBestMatchForTrackedPath,\n    getDisplayNameForElementID: getDisplayNameForElementID,\n    getNearestMountedDOMNode: getNearestMountedDOMNode,\n    getElementIDForHostInstance: getElementIDForHostInstance,\n    getInstanceAndStyle: getInstanceAndStyle,\n    findHostInstancesForElementID: function findHostInstancesForElementID(id) {\n      var hostInstance = findHostInstanceForInternalID(id);\n      return hostInstance == null ? null : [hostInstance];\n    },\n    getOwnersList: getOwnersList,\n    getPathForElement: getPathForElement,\n    getProfilingData: getProfilingData,\n    handleCommitFiberRoot: handleCommitFiberRoot,\n    handleCommitFiberUnmount: handleCommitFiberUnmount,\n    handlePostCommitFiberRoot: handlePostCommitFiberRoot,\n    hasElementWithId: hasElementWithId,\n    inspectElement: inspectElement,\n    logElementToConsole: logElementToConsole,\n    overrideError: overrideError,\n    overrideSuspense: overrideSuspense,\n    overrideValueAtPath: overrideValueAtPath,\n    renamePath: renamePath,\n    getElementAttributeByPath: getElementAttributeByPath,\n    getElementSourceFunctionById: getElementSourceFunctionById,\n    renderer: renderer,\n    setTraceUpdatesEnabled: setTraceUpdatesEnabled,\n    setTrackedPath: setTrackedPath,\n    startProfiling: startProfiling,\n    stopProfiling: stopProfiling,\n    storeAsGlobal: storeAsGlobal,\n    updateComponentFilters: updateComponentFilters,\n    getEnvironmentNames: getEnvironmentNames\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2xlZ2FjeS9yZW5kZXJlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBT0E7QUFDQTtBQU9BO0FBT0E7QUFNQTs7QUFxQkE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFFQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQU1BO0FBQ0E7QUFFQTtBQUdBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFHQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBSUE7QUFDQTs7QUFHQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFySkE7QUF1SkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBS0E7O0FBRUE7QUFDQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFEQTtBQUFBO0FBQUE7O0FBSUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUlBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTs7QUFFQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBOztBQUVBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUVBO0FBSUE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUxBO0FBQUE7O0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBOUNBO0FBa0RBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBR0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBTUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7O0FBRUE7QUFPQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTs7QUFFQTtBQU9BOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUVBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBeUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2xlZ2FjeS9yZW5kZXJlci5qcz9iMjNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7XG4gIEVsZW1lbnRUeXBlQ2xhc3MsXG4gIEVsZW1lbnRUeXBlRnVuY3Rpb24sXG4gIEVsZW1lbnRUeXBlUm9vdCxcbiAgRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50LFxuICBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2Zyb250ZW5kL3R5cGVzJztcbmltcG9ydCB7Z2V0VUlELCB1dGZFbmNvZGVTdHJpbmcsIHByaW50T3BlcmF0aW9uc0FycmF5fSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQge1xuICBjbGVhbkZvckJyaWRnZSxcbiAgY29weVdpdGhEZWxldGUsXG4gIGNvcHlXaXRoUmVuYW1lLFxuICBjb3B5V2l0aFNldCxcbiAgc2VyaWFsaXplVG9TdHJpbmcsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIGRlbGV0ZVBhdGhJbk9iamVjdCxcbiAgZ2V0RGlzcGxheU5hbWUsXG4gIGdldEluT2JqZWN0LFxuICByZW5hbWVQYXRoSW5PYmplY3QsXG4gIHNldEluT2JqZWN0LFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzJztcbmltcG9ydCB7XG4gIF9fREVCVUdfXyxcbiAgVFJFRV9PUEVSQVRJT05fQURELFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkUsXG4gIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4sXG59IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQge2RlY29yYXRlTWFueSwgZm9yY2VVcGRhdGUsIHJlc3RvcmVNYW55fSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IHR5cGUge1xuICBEZXZUb29sc0hvb2ssXG4gIEdldEVsZW1lbnRJREZvckhvc3RJbnN0YW5jZSxcbiAgSW5zcGVjdGVkRWxlbWVudFBheWxvYWQsXG4gIEluc3RhbmNlQW5kU3R5bGUsXG4gIEhvc3RJbnN0YW5jZSxcbiAgUGF0aEZyYW1lLFxuICBQYXRoTWF0Y2gsXG4gIFJlbmRlcmVySW50ZXJmYWNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIENvbXBvbmVudEZpbHRlcixcbiAgRWxlbWVudFR5cGUsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge0luc3BlY3RlZEVsZW1lbnQsIFNlcmlhbGl6ZWRFbGVtZW50fSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIEludGVybmFsSW5zdGFuY2UgPSBPYmplY3Q7XG50eXBlIExlZ2FjeVJlbmRlcmVyID0gT2JqZWN0O1xuXG5mdW5jdGlvbiBnZXREYXRhKGludGVybmFsSW5zdGFuY2U6IEludGVybmFsSW5zdGFuY2UpIHtcbiAgbGV0IGRpc3BsYXlOYW1lID0gbnVsbDtcbiAgbGV0IGtleSA9IG51bGw7XG5cbiAgLy8gIT0gdXNlZCBkZWxpYmVyYXRlbHkgaGVyZSB0byBjYXRjaCB1bmRlZmluZWQgYW5kIG51bGxcbiAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQua2V5KSB7XG4gICAgICBrZXkgPSBTdHJpbmcoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQua2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50VHlwZSA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gZWxlbWVudFR5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoZWxlbWVudFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlzcGxheU5hbWUsXG4gICAga2V5LFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlOiBJbnRlcm5hbEluc3RhbmNlKTogRWxlbWVudFR5cGUge1xuICAvLyAhPSB1c2VkIGRlbGliZXJhdGVseSBoZXJlIHRvIGNhdGNoIHVuZGVmaW5lZCBhbmQgbnVsbFxuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZUZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd247XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2U6IE9iamVjdCk6IEFycmF5PGFueT4ge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgaXMgYSBuYXRpdmUgbm9kZSB3aXRob3V0IHJlbmRlcmVkIGNoaWxkcmVuLCBidXQgd2l0aFxuICAvLyBtdWx0aXBsZSBzdHJpbmcgY2hpbGRyZW4sIHRoZW4gdGhlIGBlbGVtZW50YCB0aGF0IGdldHMgcGFzc2VkIGluIGhlcmUgaXNcbiAgLy8gYSBwbGFpbiB2YWx1ZSAtLSBhIHN0cmluZyBvciBudW1iZXIuXG4gIGlmICh0eXBlb2YgaW50ZXJuYWxJbnN0YW5jZSAhPT0gJ29iamVjdCcpIHtcbiAgICAvLyBObyBjaGlsZHJlblxuICB9IGVsc2UgaWYgKFxuICAgIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ID09PSBudWxsIHx8XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgPT09IGZhbHNlXG4gICkge1xuICAgIC8vIE5vIGNoaWxkcmVuXG4gIH0gZWxzZSBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICBjb25zdCBjaGlsZCA9IGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIGlmIChnZXRFbGVtZW50VHlwZShjaGlsZCkgIT09IEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24pIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgY29uc3QgcmVuZGVyZWRDaGlsZHJlbiA9IGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChnZXRFbGVtZW50VHlwZShjaGlsZCkgIT09IEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24pIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE5vdGU6IHdlIHNraXAgdGhlIGNhc2Ugd2hlcmUgY2hpbGRyZW4gYXJlIGp1c3Qgc3RyaW5ncyBvciBudW1iZXJzXG4gIC8vIGJlY2F1c2UgdGhlIG5ldyBEZXZUb29scyBza2lwcyBvdmVyIGhvc3QgdGV4dCBub2RlcyBhbnl3YXkuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaChcbiAgaG9vazogRGV2VG9vbHNIb29rLFxuICByZW5kZXJlcklEOiBudW1iZXIsXG4gIHJlbmRlcmVyOiBMZWdhY3lSZW5kZXJlcixcbiAgZ2xvYmFsOiBPYmplY3QsXG4pOiBSZW5kZXJlckludGVyZmFjZSB7XG4gIGNvbnN0IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwOiBNYXA8bnVtYmVyLCBJbnRlcm5hbEluc3RhbmNlPiA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZVRvSURNYXA6IFdlYWtNYXA8SW50ZXJuYWxJbnN0YW5jZSwgbnVtYmVyPiA9XG4gICAgbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZVRvUm9vdElETWFwOiBXZWFrTWFwPEludGVybmFsSW5zdGFuY2UsIG51bWJlcj4gPVxuICAgIG5ldyBXZWFrTWFwKCk7XG5cbiAgbGV0IGdldEVsZW1lbnRJREZvckhvc3RJbnN0YW5jZTogR2V0RWxlbWVudElERm9ySG9zdEluc3RhbmNlID1cbiAgICAoKG51bGw6IGFueSk6IEdldEVsZW1lbnRJREZvckhvc3RJbnN0YW5jZSk7XG4gIGxldCBmaW5kSG9zdEluc3RhbmNlRm9ySW50ZXJuYWxJRDogKGlkOiBudW1iZXIpID0+ID9Ib3N0SW5zdGFuY2U7XG4gIGxldCBnZXROZWFyZXN0TW91bnRlZERPTU5vZGUgPSAobm9kZTogRWxlbWVudCk6IG51bGwgfCBFbGVtZW50ID0+IHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgaWYgKHJlbmRlcmVyLkNvbXBvbmVudFRyZWUpIHtcbiAgICBnZXRFbGVtZW50SURGb3JIb3N0SW5zdGFuY2UgPSBub2RlID0+IHtcbiAgICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPVxuICAgICAgICByZW5kZXJlci5Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICAgICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2VUb0lETWFwLmdldChpbnRlcm5hbEluc3RhbmNlKSB8fCBudWxsO1xuICAgIH07XG4gICAgZmluZEhvc3RJbnN0YW5jZUZvckludGVybmFsSUQgPSAoaWQ6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGludGVybmFsSW5zdGFuY2UpO1xuICAgIH07XG4gICAgZ2V0TmVhcmVzdE1vdW50ZWRET01Ob2RlID0gKG5vZGU6IEVsZW1lbnQpOiBudWxsIHwgRWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID1cbiAgICAgICAgcmVuZGVyZXIuQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLkNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVuZGVyZXIuTW91bnQuZ2V0SUQgJiYgcmVuZGVyZXIuTW91bnQuZ2V0Tm9kZSkge1xuICAgIGdldEVsZW1lbnRJREZvckhvc3RJbnN0YW5jZSA9IG5vZGUgPT4ge1xuICAgICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmaW5kSG9zdEluc3RhbmNlRm9ySW50ZXJuYWxJRCA9IChpZDogbnVtYmVyKSA9PiB7XG4gICAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JFbGVtZW50SUQoaWQ6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlID8gZ2V0RGF0YShpbnRlcm5hbEluc3RhbmNlKS5kaXNwbGF5TmFtZSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJRChpbnRlcm5hbEluc3RhbmNlOiBJbnRlcm5hbEluc3RhbmNlKTogbnVtYmVyIHtcbiAgICBpZiAodHlwZW9mIGludGVybmFsSW5zdGFuY2UgIT09ICdvYmplY3QnIHx8IGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlcm5hbCBpbnN0YW5jZTogJyArIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2VUb0lETWFwLmhhcyhpbnRlcm5hbEluc3RhbmNlKSkge1xuICAgICAgY29uc3QgaWQgPSBnZXRVSUQoKTtcbiAgICAgIGludGVybmFsSW5zdGFuY2VUb0lETWFwLnNldChpbnRlcm5hbEluc3RhbmNlLCBpZCk7XG4gICAgICBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5zZXQoaWQsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gKChpbnRlcm5hbEluc3RhbmNlVG9JRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk6IGFueSk6IG51bWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVFcXVhbEFycmF5cyhhOiBBcnJheTxhbnk+LCBiOiBBcnJheTxhbnk+KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBUaGlzIGlzIHNoYXJlZCBtdXRhYmxlIHN0YXRlIHRoYXQgbGV0cyB1cyBrZWVwIHRyYWNrIG9mIHdoZXJlIHdlIGFyZS5cbiAgbGV0IHBhcmVudElEU3RhY2sgPSBbXTtcblxuICBsZXQgb2xkUmVjb25jaWxlck1ldGhvZHMgPSBudWxsO1xuICBpZiAocmVuZGVyZXIuUmVjb25jaWxlcikge1xuICAgIC8vIFJlYWN0IDE1XG4gICAgb2xkUmVjb25jaWxlck1ldGhvZHMgPSBkZWNvcmF0ZU1hbnkocmVuZGVyZXIuUmVjb25jaWxlciwge1xuICAgICAgbW91bnRDb21wb25lbnQoZm4sIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IGhvc3RDb250YWluZXJJbmZvID0gYXJnc1szXTtcbiAgICAgICAgaWYgKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpID09PSBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RDb250YWluZXJJbmZvLl90b3BMZXZlbFdyYXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFNTUlxuICAgICAgICAgIC8vICRGbG93Rml4TWVbb2JqZWN0LXRoaXMtcmVmZXJlbmNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWQgPSBnZXRJRChpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgICAgLy8gUHVzaCB0aGUgb3BlcmF0aW9uLlxuICAgICAgICBjb25zdCBwYXJlbnRJRCA9XG4gICAgICAgICAgcGFyZW50SURTdGFjay5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHBhcmVudElEU3RhY2tbcGFyZW50SURTdGFjay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICByZWNvcmRNb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCwgcGFyZW50SUQpO1xuICAgICAgICBwYXJlbnRJRFN0YWNrLnB1c2goaWQpO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSByb290LlxuICAgICAgICBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuc2V0KFxuICAgICAgICAgIGludGVybmFsSW5zdGFuY2UsXG4gICAgICAgICAgZ2V0SUQoaG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlciksXG4gICAgICAgICk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIHBhcmVudElEU3RhY2sucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcGFyZW50SURTdGFjayA9IFtdO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocGFyZW50SURTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RJRCA9IGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAocm9vdElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvb3QgSUQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoZm4sIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKSA9PT0gRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bikge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbb2JqZWN0LXRoaXMtcmVmZXJlbmNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWQgPSBnZXRJRChpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgICAgcGFyZW50SURTdGFjay5wdXNoKGlkKTtcblxuICAgICAgICBjb25zdCBwcmV2Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgICAgY29uc3QgbmV4dENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKCFhcmVFcXVhbEFycmF5cyhwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbikpIHtcbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgcmVjb3JkUmVvcmRlcihpbnRlcm5hbEluc3RhbmNlLCBpZCwgbmV4dENoaWxkcmVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHBhcmVudElEU3RhY2sgPSBbXTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHBhcmVudElEU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCByb290SUQgPSBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuZ2V0KGludGVybmFsSW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKHJvb3RJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCByb290IElELicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3RJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVjZWl2ZUNvbXBvbmVudChmbiwgYXJncykge1xuICAgICAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gYXJnc1swXTtcbiAgICAgICAgaWYgKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpID09PSBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZCA9IGdldElEKGludGVybmFsSW5zdGFuY2UpO1xuICAgICAgICBwYXJlbnRJRFN0YWNrLnB1c2goaWQpO1xuXG4gICAgICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9IGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbb2JqZWN0LXRoaXMtcmVmZXJlbmNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgICBjb25zdCBuZXh0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoIWFyZUVxdWFsQXJyYXlzKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuKSkge1xuICAgICAgICAgICAgLy8gUHVzaCB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAgICByZWNvcmRSZW9yZGVyKGludGVybmFsSW5zdGFuY2UsIGlkLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudElEU3RhY2sucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcGFyZW50SURTdGFjayA9IFtdO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocGFyZW50SURTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RJRCA9IGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAocm9vdElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvb3QgSUQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50Q29tcG9uZW50KGZuLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSkgPT09IEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24pIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW29iamVjdC10aGlzLXJlZmVyZW5jZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkID0gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgIHBhcmVudElEU3RhY2sucHVzaChpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtvYmplY3QtdGhpcy1yZWZlcmVuY2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgLy8gUHVzaCB0aGUgb3BlcmF0aW9uLlxuICAgICAgICAgIHJlY29yZFVubW91bnQoaW50ZXJuYWxJbnN0YW5jZSwgaWQpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcGFyZW50SURTdGFjayA9IFtdO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocGFyZW50SURTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RJRCA9IGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAocm9vdElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvb3QgSUQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGlmIChvbGRSZWNvbmNpbGVyTWV0aG9kcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlcmVyLkNvbXBvbmVudCkge1xuICAgICAgICByZXN0b3JlTWFueShyZW5kZXJlci5Db21wb25lbnQuTWl4aW4sIG9sZFJlY29uY2lsZXJNZXRob2RzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RvcmVNYW55KHJlbmRlcmVyLlJlY29uY2lsZXIsIG9sZFJlY29uY2lsZXJNZXRob2RzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2xkUmVjb25jaWxlck1ldGhvZHMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTW91bnQoXG4gICAgaW50ZXJuYWxJbnN0YW5jZTogSW50ZXJuYWxJbnN0YW5jZSxcbiAgICBpZDogbnVtYmVyLFxuICAgIHBhcmVudElEOiBudW1iZXIsXG4gICkge1xuICAgIGNvbnN0IGlzUm9vdCA9IHBhcmVudElEID09PSAwO1xuXG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICclY3JlY29yZE1vdW50KCknLFxuICAgICAgICAnY29sb3I6IGdyZWVuOyBmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgICBpZCxcbiAgICAgICAgZ2V0RGF0YShpbnRlcm5hbEluc3RhbmNlKS5kaXNwbGF5TmFtZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgLy8gVE9ETyBJcyB0aGlzIHJpZ2h0PyBGb3IgYWxsIHZlcnNpb25zP1xuICAgICAgY29uc3QgaGFzT3duZXJNZXRhZGF0YSA9XG4gICAgICAgIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICE9IG51bGwgJiZcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyICE9IG51bGw7XG5cbiAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fQUREKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihFbGVtZW50VHlwZVJvb3QpO1xuICAgICAgcHVzaE9wZXJhdGlvbigwKTsgLy8gU3RyaWN0TW9kZSBjb21wbGlhbnQ/XG4gICAgICBwdXNoT3BlcmF0aW9uKDApOyAvLyBQcm9maWxpbmcgZmxhZ1xuICAgICAgcHVzaE9wZXJhdGlvbigwKTsgLy8gU3RyaWN0TW9kZSBzdXBwb3J0ZWQ/XG4gICAgICBwdXNoT3BlcmF0aW9uKGhhc093bmVyTWV0YWRhdGEgPyAxIDogMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgIGNvbnN0IHtkaXNwbGF5TmFtZSwga2V5fSA9IGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgIGNvbnN0IG93bmVySUQgPVxuICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAhPSBudWxsICYmXG4gICAgICAgIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciAhPSBudWxsXG4gICAgICAgICAgPyBnZXRJRChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpXG4gICAgICAgICAgOiAwO1xuXG4gICAgICBjb25zdCBkaXNwbGF5TmFtZVN0cmluZ0lEID0gZ2V0U3RyaW5nSUQoZGlzcGxheU5hbWUpO1xuICAgICAgY29uc3Qga2V5U3RyaW5nSUQgPSBnZXRTdHJpbmdJRChrZXkpO1xuICAgICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9BREQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHR5cGUpO1xuICAgICAgcHVzaE9wZXJhdGlvbihwYXJlbnRJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKG93bmVySUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihkaXNwbGF5TmFtZVN0cmluZ0lEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oa2V5U3RyaW5nSUQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFJlb3JkZXIoXG4gICAgaW50ZXJuYWxJbnN0YW5jZTogSW50ZXJuYWxJbnN0YW5jZSxcbiAgICBpZDogbnVtYmVyLFxuICAgIG5leHRDaGlsZHJlbjogQXJyYXk8SW50ZXJuYWxJbnN0YW5jZT4sXG4gICkge1xuICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTik7XG4gICAgcHVzaE9wZXJhdGlvbihpZCk7XG4gICAgY29uc3QgbmV4dENoaWxkSURzID0gbmV4dENoaWxkcmVuLm1hcChnZXRJRCk7XG4gICAgcHVzaE9wZXJhdGlvbihuZXh0Q2hpbGRJRHMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRDaGlsZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHVzaE9wZXJhdGlvbihuZXh0Q2hpbGRJRHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFVubW91bnQoaW50ZXJuYWxJbnN0YW5jZTogSW50ZXJuYWxJbnN0YW5jZSwgaWQ6IG51bWJlcikge1xuICAgIHBlbmRpbmdVbm1vdW50ZWRJRHMucHVzaChpZCk7XG4gICAgaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZGVsZXRlKGlkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cyhcbiAgICBpZDogbnVtYmVyLFxuICAgIHBhcmVudElEOiBudW1iZXIsXG4gICAgcm9vdElEOiBudW1iZXIsXG4gICkge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXAoJ2NyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cygpIGlkOicsIGlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuc2V0KGludGVybmFsSW5zdGFuY2UsIHJvb3RJRCk7XG4gICAgICByZWNvcmRNb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCwgcGFyZW50SUQpO1xuICAgICAgZ2V0Q2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSkuZm9yRWFjaChjaGlsZCA9PlxuICAgICAgICBjcmF3bEFuZFJlY29yZEluaXRpYWxNb3VudHMoZ2V0SUQoY2hpbGQpLCBpZCwgcm9vdElEKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMoKSB7XG4gICAgLy8gQ3Jhd2wgcm9vdHMgdGhvdWdoIGFuZCByZWdpc3RlciBhbnkgbm9kZXMgdGhhdCBtb3VudGVkIGJlZm9yZSB3ZSB3ZXJlIGluamVjdGVkLlxuXG4gICAgY29uc3Qgcm9vdHMgPVxuICAgICAgcmVuZGVyZXIuTW91bnQuX2luc3RhbmNlc0J5UmVhY3RSb290SUQgfHxcbiAgICAgIHJlbmRlcmVyLk1vdW50Ll9pbnN0YW5jZXNCeUNvbnRhaW5lcklEO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcm9vdHMpIHtcbiAgICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSByb290c1trZXldO1xuICAgICAgY29uc3QgaWQgPSBnZXRJRChpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgIGNyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cyhpZCwgMCwgaWQpO1xuICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKGlkKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwZW5kaW5nT3BlcmF0aW9uczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICBjb25zdCBwZW5kaW5nU3RyaW5nVGFibGU6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gIGxldCBwZW5kaW5nVW5tb3VudGVkSURzOiBBcnJheTxudW1iZXI+ID0gW107XG4gIGxldCBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGg6IG51bWJlciA9IDA7XG4gIGxldCBwZW5kaW5nVW5tb3VudGVkUm9vdElEOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEOiBudW1iZXIpIHtcbiAgICBpZiAoXG4gICAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHBlbmRpbmdVbm1vdW50ZWRJRHMubGVuZ3RoID09PSAwICYmXG4gICAgICBwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbnVtVW5tb3VudElEcyA9XG4gICAgICBwZW5kaW5nVW5tb3VudGVkSURzLmxlbmd0aCArIChwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsID8gMCA6IDEpO1xuXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IG5ldyBBcnJheTxudW1iZXI+KFxuICAgICAgLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgICAyICsgLy8gW3JlbmRlcmVySUQsIHJvb3RGaWJlcklEXVxuICAgICAgICAvLyBIb3cgYmlnIGlzIHRoZSBzdHJpbmcgdGFibGU/XG4gICAgICAgIDEgKyAvLyBbc3RyaW5nVGFibGVMZW5ndGhdXG4gICAgICAgIC8vIFRoZW4gZ29lcyB0aGUgYWN0dWFsIHN0cmluZyB0YWJsZS5cbiAgICAgICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoICtcbiAgICAgICAgLy8gQWxsIHVubW91bnRzIGFyZSBiYXRjaGVkIGluIGEgc2luZ2xlIG1lc3NhZ2UuXG4gICAgICAgIC8vIFtUUkVFX09QRVJBVElPTl9SRU1PVkUsIHJlbW92ZWRJRExlbmd0aCwgLi4uaWRzXVxuICAgICAgICAobnVtVW5tb3VudElEcyA+IDAgPyAyICsgbnVtVW5tb3VudElEcyA6IDApICtcbiAgICAgICAgLy8gTW91bnQgb3BlcmF0aW9uc1xuICAgICAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgsXG4gICAgKTtcblxuICAgIC8vIElkZW50aWZ5IHdoaWNoIHJlbmRlcmVyIHRoaXMgdXBkYXRlIGlzIGNvbWluZyBmcm9tLlxuICAgIC8vIFRoaXMgZW5hYmxlcyByb290cyB0byBiZSBtYXBwZWQgdG8gcmVuZGVyZXJzLFxuICAgIC8vIFdoaWNoIGluIHR1cm4gZW5hYmxlcyBmaWJlciBwcm9wZXJhdGlvbnMsIHN0YXRlcywgYW5kIGhvb2tzIHRvIGJlIGluc3BlY3RlZC5cbiAgICBsZXQgaSA9IDA7XG4gICAgb3BlcmF0aW9uc1tpKytdID0gcmVuZGVyZXJJRDtcbiAgICBvcGVyYXRpb25zW2krK10gPSByb290SUQ7XG5cbiAgICAvLyBOb3cgZmlsbCBpbiB0aGUgc3RyaW5nIHRhYmxlLlxuICAgIC8vIFtzdHJpbmdUYWJsZUxlbmd0aCwgc3RyMUxlbmd0aCwgLi4uc3RyMSwgc3RyMkxlbmd0aCwgLi4uc3RyMiwgLi4uXVxuICAgIG9wZXJhdGlvbnNbaSsrXSA9IHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aDtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgb3BlcmF0aW9uc1tpKytdID0ga2V5Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSB1dGZFbmNvZGVTdHJpbmcoa2V5KTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZW5jb2RlZEtleS5sZW5ndGg7IGorKykge1xuICAgICAgICBvcGVyYXRpb25zW2kgKyBqXSA9IGVuY29kZWRLZXlbal07XG4gICAgICB9XG4gICAgICBpICs9IGtleS5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBpZiAobnVtVW5tb3VudElEcyA+IDApIHtcbiAgICAgIC8vIEFsbCB1bm1vdW50cyBleGNlcHQgcm9vdHMgYXJlIGJhdGNoZWQgaW4gYSBzaW5nbGUgbWVzc2FnZS5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IFRSRUVfT1BFUkFUSU9OX1JFTU9WRTtcbiAgICAgIC8vIFRoZSBmaXJzdCBudW1iZXIgaXMgaG93IG1hbnkgdW5tb3VudGVkIElEcyB3ZSdyZSBnb25uYSBzZW5kLlxuICAgICAgb3BlcmF0aW9uc1tpKytdID0gbnVtVW5tb3VudElEcztcbiAgICAgIC8vIEZpbGwgaW4gdGhlIHVubW91bnRzXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBlbmRpbmdVbm1vdW50ZWRJRHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1VubW91bnRlZElEc1tqXTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByb290IElEIHNob3VsZCBhbHdheXMgYmUgdW5tb3VudGVkIGxhc3QuXG4gICAgICBpZiAocGVuZGluZ1VubW91bnRlZFJvb3RJRCAhPT0gbnVsbCkge1xuICAgICAgICBvcGVyYXRpb25zW2ldID0gcGVuZGluZ1VubW91bnRlZFJvb3RJRDtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG9wZXJhdGlvbnMuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgb3BlcmF0aW9uc1tpICsgal0gPSBwZW5kaW5nT3BlcmF0aW9uc1tqXTtcbiAgICB9XG4gICAgaSArPSBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGg7XG5cbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBwcmludE9wZXJhdGlvbnNBcnJheShvcGVyYXRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGNvbm5lY3RlZCB0byB0aGUgZnJvbnRlbmQsIGp1c3QgcGFzcyB0aGUgb3BlcmF0aW9ucyB0aHJvdWdoLlxuICAgIGhvb2suZW1pdCgnb3BlcmF0aW9ucycsIG9wZXJhdGlvbnMpO1xuXG4gICAgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID0gMDtcbiAgICBwZW5kaW5nVW5tb3VudGVkSURzID0gW107XG4gICAgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9IG51bGw7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmNsZWFyKCk7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hPcGVyYXRpb24ob3A6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob3ApKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ3B1c2hPcGVyYXRpb24oKSB3YXMgY2FsbGVkIGJ1dCB0aGUgdmFsdWUgaXMgbm90IGFuIGludGVnZXIuJyxcbiAgICAgICAgICBvcCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdJRChzdHI6IHN0cmluZyB8IG51bGwpOiBudW1iZXIge1xuICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0lEID0gcGVuZGluZ1N0cmluZ1RhYmxlLmdldChzdHIpO1xuICAgIGlmIChleGlzdGluZ0lEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0lEO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmdJRCA9IHBlbmRpbmdTdHJpbmdUYWJsZS5zaXplICsgMTtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuc2V0KHN0ciwgc3RyaW5nSUQpO1xuICAgIC8vIFRoZSBzdHJpbmcgdGFibGUgdG90YWwgbGVuZ3RoIG5lZWRzIHRvIGFjY291bnRcbiAgICAvLyBib3RoIGZvciB0aGUgc3RyaW5nIGxlbmd0aCwgYW5kIGZvciB0aGUgYXJyYXkgaXRlbVxuICAgIC8vIHRoYXQgY29udGFpbnMgdGhlIGxlbmd0aCBpdHNlbGYuIEhlbmNlICsgMS5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKz0gc3RyLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIHN0cmluZ0lEO1xuICB9XG5cbiAgbGV0IGN1cnJlbnRseUluc3BlY3RlZEVsZW1lbnRJRDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIGxldCBjdXJyZW50bHlJbnNwZWN0ZWRQYXRoczogT2JqZWN0ID0ge307XG5cbiAgLy8gVHJhY2sgdGhlIGludGVyc2VjdGlvbiBvZiBjdXJyZW50bHkgaW5zcGVjdGVkIHBhdGhzLFxuICAvLyBzbyB0aGF0IHdlIGNhbiBzZW5kIHRoZWlyIGRhdGEgYWxvbmcgaWYgdGhlIGVsZW1lbnQgaXMgcmUtcmVuZGVyZWQuXG4gIGZ1bmN0aW9uIG1lcmdlSW5zcGVjdGVkUGF0aHMocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikge1xuICAgIGxldCBjdXJyZW50ID0gY3VycmVudGx5SW5zcGVjdGVkUGF0aHM7XG4gICAgcGF0aC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRba2V5XSkge1xuICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJc1BhdGhBbGxvd2VkKGtleTogc3RyaW5nKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoZWxwcyBwcmV2ZW50IHByZXZpb3VzbHktaW5zcGVjdGVkIHBhdGhzIGZyb20gYmVpbmcgZGVoeWRyYXRlZCBpbiB1cGRhdGVzLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIGF2b2lkIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSB3aGVyZSBleHBhbmRlZCB0b2dnbGVzIGNvbGxhcHNlIG9uIHVwZGF0ZS5cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXRoQWxsb3dlZChwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICBsZXQgY3VycmVudCA9IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzW2tleV07XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhbaV1dO1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICAvLyBGYXN0IHBhdGggcHJvcHMgbG9va3VwIGZvciBSZWFjdCBOYXRpdmUgc3R5bGUgZWRpdG9yLlxuICBmdW5jdGlvbiBnZXRJbnN0YW5jZUFuZFN0eWxlKGlkOiBudW1iZXIpOiBJbnN0YW5jZUFuZFN0eWxlIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBudWxsO1xuICAgIGxldCBzdHlsZSA9IG51bGw7XG5cbiAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICBpbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlIHx8IG51bGw7XG5cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC5wcm9wcyAhPSBudWxsKSB7XG4gICAgICAgIHN0eWxlID0gZWxlbWVudC5wcm9wcy5zdHlsZSB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpbnN0YW5jZSxcbiAgICAgIHN0eWxlLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZEVsZW1lbnQoaWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgaW5zdGFuY2Ugd2l0aCBpZCBcIiR7aWR9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpKSB7XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlQ2xhc3M6XG4gICAgICAgIGdsb2JhbC4kciA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRWxlbWVudFR5cGVGdW5jdGlvbjpcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xvYmFsLiRyID0ge1xuICAgICAgICAgIHByb3BzOiBlbGVtZW50LnByb3BzLFxuICAgICAgICAgIHR5cGU6IGVsZW1lbnQudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBnbG9iYWwuJHIgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9yZUFzR2xvYmFsKFxuICAgIGlkOiBudW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgICBjb3VudDogbnVtYmVyLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBpbnNwZWN0ZWRFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnRSYXcoaWQpO1xuICAgIGlmIChpbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldEluT2JqZWN0KGluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgICAgY29uc3Qga2V5ID0gYCRyZWFjdFRlbXAke2NvdW50fWA7XG5cbiAgICAgIHdpbmRvd1trZXldID0gdmFsdWU7XG5cbiAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VyaWFsaXplZEVsZW1lbnRWYWx1ZUJ5UGF0aChcbiAgICBpZDogbnVtYmVyLFxuICAgIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICk6ID9zdHJpbmcge1xuICAgIGNvbnN0IGluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG4gICAgaWYgKGluc3BlY3RlZEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHZhbHVlVG9Db3B5ID0gZ2V0SW5PYmplY3QoaW5zcGVjdGVkRWxlbWVudCwgcGF0aCk7XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVUb1N0cmluZyh2YWx1ZVRvQ29weSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdEVsZW1lbnQoXG4gICAgcmVxdWVzdElEOiBudW1iZXIsXG4gICAgaWQ6IG51bWJlcixcbiAgICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+IHwgbnVsbCxcbiAgICBmb3JjZUZ1bGxEYXRhOiBib29sZWFuLFxuICApOiBJbnNwZWN0ZWRFbGVtZW50UGF5bG9hZCB7XG4gICAgaWYgKGZvcmNlRnVsbERhdGEgfHwgY3VycmVudGx5SW5zcGVjdGVkRWxlbWVudElEICE9PSBpZCkge1xuICAgICAgY3VycmVudGx5SW5zcGVjdGVkRWxlbWVudElEID0gaWQ7XG4gICAgICBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG4gICAgaWYgKGluc3BlY3RlZEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgIHR5cGU6ICdub3QtZm91bmQnLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgbWVyZ2VJbnNwZWN0ZWRQYXRocyhwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBBbnkgdGltZSBhbiBpbnNwZWN0ZWQgZWxlbWVudCBoYXMgYW4gdXBkYXRlLFxuICAgIC8vIHdlIHNob3VsZCB1cGRhdGUgdGhlIHNlbGVjdGVkICRyIHZhbHVlIGFzIHdlbC5cbiAgICAvLyBEbyB0aGlzIGJlZm9yZSBkZWh5ZHJhdGlvbiAoY2xlYW5Gb3JCcmlkZ2UpLlxuICAgIHVwZGF0ZVNlbGVjdGVkRWxlbWVudChpZCk7XG5cbiAgICBpbnNwZWN0ZWRFbGVtZW50LmNvbnRleHQgPSBjbGVhbkZvckJyaWRnZShcbiAgICAgIGluc3BlY3RlZEVsZW1lbnQuY29udGV4dCxcbiAgICAgIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ2NvbnRleHQnKSxcbiAgICApO1xuICAgIGluc3BlY3RlZEVsZW1lbnQucHJvcHMgPSBjbGVhbkZvckJyaWRnZShcbiAgICAgIGluc3BlY3RlZEVsZW1lbnQucHJvcHMsXG4gICAgICBjcmVhdGVJc1BhdGhBbGxvd2VkKCdwcm9wcycpLFxuICAgICk7XG4gICAgaW5zcGVjdGVkRWxlbWVudC5zdGF0ZSA9IGNsZWFuRm9yQnJpZGdlKFxuICAgICAgaW5zcGVjdGVkRWxlbWVudC5zdGF0ZSxcbiAgICAgIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ3N0YXRlJyksXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgIHR5cGU6ICdmdWxsLWRhdGEnLFxuICAgICAgdmFsdWU6IGluc3BlY3RlZEVsZW1lbnQsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50UmF3KGlkOiBudW1iZXIpOiBJbnNwZWN0ZWRFbGVtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7a2V5fSA9IGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgY29uc3QgdHlwZSA9IGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgbGV0IGNvbnRleHQgPSBudWxsO1xuICAgIGxldCBvd25lcnMgPSBudWxsO1xuICAgIGxldCBwcm9wcyA9IG51bGw7XG4gICAgbGV0IHN0YXRlID0gbnVsbDtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gICAgICBsZXQgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lcnMgPSAoW106IEFycmF5PFNlcmlhbGl6ZWRFbGVtZW50Pik7XG4gICAgICAgIHdoaWxlIChvd25lciAhPSBudWxsKSB7XG4gICAgICAgICAgb3duZXJzLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IGdldERhdGEob3duZXIpLmRpc3BsYXlOYW1lIHx8ICdVbmtub3duJyxcbiAgICAgICAgICAgIGlkOiBnZXRJRChvd25lciksXG4gICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICAgICAgdHlwZTogZ2V0RWxlbWVudFR5cGUob3duZXIpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvd25lci5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyID0gb3duZXIuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICBjb250ZXh0ID0gcHVibGljSW5zdGFuY2UuY29udGV4dCB8fCBudWxsO1xuICAgICAgc3RhdGUgPSBwdWJsaWNJbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIE5vdCBpbXBsZW1lbnRlZFxuICAgIGNvbnN0IGVycm9yczogQXJyYXk8W3N0cmluZywgbnVtYmVyXT4gPSBbXTtcbiAgICBjb25zdCB3YXJuaW5nczogQXJyYXk8W3N0cmluZywgbnVtYmVyXT4gPSBbXTtcblxuICAgIHJldHVybiB7XG4gICAgICBpZCxcblxuICAgICAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGVkaXRhYmxlIGhvb2tzIGFuZCBmdW5jdGlvbiBwcm9wcz9cbiAgICAgIGNhbkVkaXRIb29rczogZmFsc2UsXG4gICAgICBjYW5FZGl0RnVuY3Rpb25Qcm9wczogZmFsc2UsXG5cbiAgICAgIC8vIERvZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydCBhZHZhbmNlZCBlZGl0aW5nIGludGVyZmFjZT9cbiAgICAgIGNhbkVkaXRIb29rc0FuZERlbGV0ZVBhdGhzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRIb29rc0FuZFJlbmFtZVBhdGhzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzRGVsZXRlUGF0aHM6IGZhbHNlLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNSZW5hbWVQYXRoczogZmFsc2UsXG5cbiAgICAgIC8vIFRvZ2dsZSBlcnJvciBib3VuZGFyeSBkaWQgbm90IGV4aXN0IGluIGxlZ2FjeSB2ZXJzaW9uc1xuICAgICAgY2FuVG9nZ2xlRXJyb3I6IGZhbHNlLFxuICAgICAgaXNFcnJvcmVkOiBmYWxzZSxcblxuICAgICAgLy8gU3VzcGVuc2UgZGlkIG5vdCBleGlzdCBpbiBsZWdhY3kgdmVyc2lvbnNcbiAgICAgIGNhblRvZ2dsZVN1c3BlbnNlOiBmYWxzZSxcblxuICAgICAgLy8gQ2FuIHZpZXcgY29tcG9uZW50IHNvdXJjZSBsb2NhdGlvbi5cbiAgICAgIGNhblZpZXdTb3VyY2U6IHR5cGUgPT09IEVsZW1lbnRUeXBlQ2xhc3MgfHwgdHlwZSA9PT0gRWxlbWVudFR5cGVGdW5jdGlvbixcbiAgICAgIHNvdXJjZTogbnVsbCxcblxuICAgICAgLy8gT25seSBsZWdhY3kgY29udGV4dCBleGlzdHMgaW4gbGVnYWN5IHZlcnNpb25zLlxuICAgICAgaGFzTGVnYWN5Q29udGV4dDogdHJ1ZSxcblxuICAgICAgdHlwZTogdHlwZSxcblxuICAgICAga2V5OiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGwsXG5cbiAgICAgIC8vIEluc3BlY3RhYmxlIHByb3BlcnRpZXMuXG4gICAgICBjb250ZXh0LFxuICAgICAgaG9va3M6IG51bGwsXG4gICAgICBwcm9wcyxcbiAgICAgIHN0YXRlLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3MsXG5cbiAgICAgIC8vIExpc3Qgb2Ygb3duZXJzXG4gICAgICBvd25lcnMsXG5cbiAgICAgIHJvb3RUeXBlOiBudWxsLFxuICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogbnVsbCxcbiAgICAgIHJlbmRlcmVyVmVyc2lvbjogbnVsbCxcblxuICAgICAgcGx1Z2luczoge1xuICAgICAgICBzdHlsZXg6IG51bGwsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFbGVtZW50VG9Db25zb2xlKGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCByZXN1bHQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckVsZW1lbnRJRChpZCk7XG5cbiAgICBjb25zdCBzdXBwb3J0c0dyb3VwID0gdHlwZW9mIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKHN1cHBvcnRzR3JvdXApIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICAgIGBbQ2xpY2sgdG8gZXhwYW5kXSAlYzwke2Rpc3BsYXlOYW1lIHx8ICdDb21wb25lbnQnfSAvPmAsXG4gICAgICAgIC8vIC0tZG9tLXRhZy1uYW1lLWNvbG9yIGlzIHRoZSBDU1MgdmFyaWFibGUgQ2hyb21lIHN0eWxlcyBIVE1MIGVsZW1lbnRzIHdpdGggaW4gdGhlIGNvbnNvbGUuXG4gICAgICAgICdjb2xvcjogdmFyKC0tZG9tLXRhZy1uYW1lLWNvbG9yKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsnLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wcm9wcyAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ1Byb3BzOicsIHJlc3VsdC5wcm9wcyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuc3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdGF0ZTonLCByZXN1bHQuc3RhdGUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb250ZXh0OicsIHJlc3VsdC5jb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgaG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZUZvckludGVybmFsSUQoaWQpO1xuICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdOb2RlOicsIGhvc3RJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuY2hyb21lIHx8IC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICdSaWdodC1jbGljayBhbnkgdmFsdWUgdG8gc2F2ZSBpdCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBmb3IgZnVydGhlciBpbnNwZWN0aW9uLicsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRBdHRyaWJ1dGVCeVBhdGgoXG4gICAgaWQ6IG51bWJlcixcbiAgICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICApOiBtaXhlZCB7XG4gICAgY29uc3QgaW5zcGVjdGVkRWxlbWVudCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcbiAgICBpZiAoaW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGdldEluT2JqZWN0KGluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudFNvdXJjZUZ1bmN0aW9uQnlJZChpZDogbnVtYmVyKTogbnVsbCB8IEZ1bmN0aW9uIHtcbiAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGluc3RhbmNlIHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUGF0aChcbiAgICB0eXBlOiAnY29udGV4dCcgfCAnaG9va3MnIHwgJ3Byb3BzJyB8ICdzdGF0ZScsXG4gICAgaWQ6IG51bWJlcixcbiAgICBob29rSUQ6ID9udW1iZXIsXG4gICAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcHVibGljSW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZTtcbiAgICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgZGVsZXRlUGF0aEluT2JqZWN0KHB1YmxpY0luc3RhbmNlLmNvbnRleHQsIHBhdGgpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgLi4uZWxlbWVudCxcbiAgICAgICAgICAgICAgcHJvcHM6IGNvcHlXaXRoRGVsZXRlKGVsZW1lbnQucHJvcHMsIHBhdGgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICAgIGRlbGV0ZVBhdGhJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5zdGF0ZSwgcGF0aCk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmFtZVBhdGgoXG4gICAgdHlwZTogJ2NvbnRleHQnIHwgJ2hvb2tzJyB8ICdwcm9wcycgfCAnc3RhdGUnLFxuICAgIGlkOiBudW1iZXIsXG4gICAgaG9va0lEOiA/bnVtYmVyLFxuICAgIG9sZFBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICAgbmV3UGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcHVibGljSW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZTtcbiAgICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgcmVuYW1lUGF0aEluT2JqZWN0KHB1YmxpY0luc3RhbmNlLmNvbnRleHQsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgLi4uZWxlbWVudCxcbiAgICAgICAgICAgICAgcHJvcHM6IGNvcHlXaXRoUmVuYW1lKGVsZW1lbnQucHJvcHMsIG9sZFBhdGgsIG5ld1BhdGgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICAgIHJlbmFtZVBhdGhJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5zdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlVmFsdWVBdFBhdGgoXG4gICAgdHlwZTogJ2NvbnRleHQnIHwgJ2hvb2tzJyB8ICdwcm9wcycgfCAnc3RhdGUnLFxuICAgIGlkOiBudW1iZXIsXG4gICAgaG9va0lEOiA/bnVtYmVyLFxuICAgIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gICAgdmFsdWU6IGFueSxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcHVibGljSW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZTtcbiAgICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICAgICAgc2V0SW5PYmplY3QocHVibGljSW5zdGFuY2UuY29udGV4dCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgLi4uZWxlbWVudCxcbiAgICAgICAgICAgICAgcHJvcHM6IGNvcHlXaXRoU2V0KGVsZW1lbnQucHJvcHMsIHBhdGgsIHZhbHVlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgICBzZXRJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5zdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB2MTYrIG9ubHkgZmVhdHVyZXNcbiAgY29uc3QgZ2V0UHJvZmlsaW5nRGF0YSA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFByb2ZpbGluZ0RhdGEgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUNvbW1pdEZpYmVyUm9vdCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZUNvbW1pdEZpYmVyUm9vdCBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuICBjb25zdCBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcbiAgY29uc3Qgb3ZlcnJpZGVFcnJvciA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJyaWRlRXJyb3Igbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG4gIGNvbnN0IG92ZXJyaWRlU3VzcGVuc2UgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvdmVycmlkZVN1c3BlbnNlIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuICBjb25zdCBzdGFydFByb2ZpbGluZyA9ICgpID0+IHtcbiAgICAvLyBEbyBub3QgdGhyb3csIHNpbmNlIHRoaXMgd291bGQgYnJlYWsgYSBtdWx0aS1yb290IHNjZW5hcmlvIHdoZXJlIHYxNSBhbmQgdjE2IHdlcmUgYm90aCBwcmVzZW50LlxuICB9O1xuICBjb25zdCBzdG9wUHJvZmlsaW5nID0gKCkgPT4ge1xuICAgIC8vIERvIG5vdCB0aHJvdywgc2luY2UgdGhpcyB3b3VsZCBicmVhayBhIG11bHRpLXJvb3Qgc2NlbmFyaW8gd2hlcmUgdjE1IGFuZCB2MTYgd2VyZSBib3RoIHByZXNlbnQuXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGgoKTogUGF0aE1hdGNoIHwgbnVsbCB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGF0aEZvckVsZW1lbnQoaWQ6IG51bWJlcik6IEFycmF5PFBhdGhGcmFtZT4gfCBudWxsIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4pIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudE5hbWVzKCk6IEFycmF5PHN0cmluZz4ge1xuICAgIC8vIE5vIFJTQyBzdXBwb3J0LlxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQoZW5hYmxlZDogYm9vbGVhbikge1xuICAgIC8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYWNrZWRQYXRoKHBhdGg6IEFycmF5PFBhdGhGcmFtZT4gfCBudWxsKSB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkLlxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3duZXJzTGlzdChpZDogbnVtYmVyKTogQXJyYXk8U2VyaWFsaXplZEVsZW1lbnQ+IHwgbnVsbCB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3JzRm9yRWxlbWVudElEKGlkOiBudW1iZXIpIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyV2FybmluZ3NGb3JFbGVtZW50SUQoaWQ6IG51bWJlcikge1xuICAgIC8vIE5vdCBpbXBsZW1lbnRlZFxuICB9XG5cbiAgZnVuY3Rpb24gaGFzRWxlbWVudFdpdGhJZChpZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmhhcyhpZCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNsZWFyRXJyb3JzQW5kV2FybmluZ3MsXG4gICAgY2xlYXJFcnJvcnNGb3JFbGVtZW50SUQsXG4gICAgY2xlYXJXYXJuaW5nc0ZvckVsZW1lbnRJRCxcbiAgICBjbGVhbnVwLFxuICAgIGdldFNlcmlhbGl6ZWRFbGVtZW50VmFsdWVCeVBhdGgsXG4gICAgZGVsZXRlUGF0aCxcbiAgICBmbHVzaEluaXRpYWxPcGVyYXRpb25zLFxuICAgIGdldEJlc3RNYXRjaEZvclRyYWNrZWRQYXRoLFxuICAgIGdldERpc3BsYXlOYW1lRm9yRWxlbWVudElELFxuICAgIGdldE5lYXJlc3RNb3VudGVkRE9NTm9kZSxcbiAgICBnZXRFbGVtZW50SURGb3JIb3N0SW5zdGFuY2UsXG4gICAgZ2V0SW5zdGFuY2VBbmRTdHlsZSxcbiAgICBmaW5kSG9zdEluc3RhbmNlc0ZvckVsZW1lbnRJRDogKGlkOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VGb3JJbnRlcm5hbElEKGlkKTtcbiAgICAgIHJldHVybiBob3N0SW5zdGFuY2UgPT0gbnVsbCA/IG51bGwgOiBbaG9zdEluc3RhbmNlXTtcbiAgICB9LFxuICAgIGdldE93bmVyc0xpc3QsXG4gICAgZ2V0UGF0aEZvckVsZW1lbnQsXG4gICAgZ2V0UHJvZmlsaW5nRGF0YSxcbiAgICBoYW5kbGVDb21taXRGaWJlclJvb3QsXG4gICAgaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50LFxuICAgIGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3QsXG4gICAgaGFzRWxlbWVudFdpdGhJZCxcbiAgICBpbnNwZWN0RWxlbWVudCxcbiAgICBsb2dFbGVtZW50VG9Db25zb2xlLFxuICAgIG92ZXJyaWRlRXJyb3IsXG4gICAgb3ZlcnJpZGVTdXNwZW5zZSxcbiAgICBvdmVycmlkZVZhbHVlQXRQYXRoLFxuICAgIHJlbmFtZVBhdGgsXG4gICAgZ2V0RWxlbWVudEF0dHJpYnV0ZUJ5UGF0aCxcbiAgICBnZXRFbGVtZW50U291cmNlRnVuY3Rpb25CeUlkLFxuICAgIHJlbmRlcmVyLFxuICAgIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQsXG4gICAgc2V0VHJhY2tlZFBhdGgsXG4gICAgc3RhcnRQcm9maWxpbmcsXG4gICAgc3RvcFByb2ZpbGluZyxcbiAgICBzdG9yZUFzR2xvYmFsLFxuICAgIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnMsXG4gICAgZ2V0RW52aXJvbm1lbnROYW1lcyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/legacy/renderer.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/legacy/utils.js":
/*!************************************************************!*\
  !*** ../react-devtools-shared/src/backend/legacy/utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decorate\": () => (/* binding */ decorate),\n/* harmony export */   \"decorateMany\": () => (/* binding */ decorateMany),\n/* harmony export */   \"forceUpdate\": () => (/* binding */ forceUpdate),\n/* harmony export */   \"restoreMany\": () => (/* binding */ restoreMany)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction decorate(object, attr, fn) {\n  var old = object[attr]; // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations\n\n  object[attr] = function (instance) {\n    return fn.call(this, old, arguments);\n  };\n\n  return old;\n}\nfunction decorateMany(source, fns) {\n  var olds = {};\n\n  for (var name in fns) {\n    olds[name] = decorate(source, name, fns[name]);\n  }\n\n  return olds;\n}\nfunction restoreMany(source, olds) {\n  for (var name in olds) {\n    source[name] = olds[name];\n  }\n} // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations\n\nfunction forceUpdate(instance) {\n  if (typeof instance.forceUpdate === 'function') {\n    instance.forceUpdate();\n  } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {\n    instance.updater.enqueueForceUpdate(this, function () {}, 'forceUpdate');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2xlZ2FjeS91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7O0FBV0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2xlZ2FjeS91dGlscy5qcz9hZjMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtJbnRlcm5hbEluc3RhbmNlfSBmcm9tICcuL3JlbmRlcmVyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlKG9iamVjdDogT2JqZWN0LCBhdHRyOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IEZ1bmN0aW9uIHtcbiAgY29uc3Qgb2xkID0gb2JqZWN0W2F0dHJdO1xuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctdGhpcy1hbm5vdF0gd2VicGFjayBjb25maWcgbmVlZHMgdG8gYmUgdXBkYXRlZCB0byBhbGxvdyBgdGhpc2AgdHlwZSBhbm5vdGF0aW9uc1xuICBvYmplY3RbYXR0cl0gPSBmdW5jdGlvbiAoaW5zdGFuY2U6IEludGVybmFsSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBvbGQsIGFyZ3VtZW50cyk7XG4gIH07XG4gIHJldHVybiBvbGQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZU1hbnkoXG4gIHNvdXJjZTogT2JqZWN0LFxuICBmbnM6IHtbYXR0cjogc3RyaW5nXTogRnVuY3Rpb24sIC4uLn0sXG4pOiBPYmplY3Qge1xuICBjb25zdCBvbGRzOiB7W3N0cmluZ106ICRGbG93Rml4TWV9ID0ge307XG4gIGZvciAoY29uc3QgbmFtZSBpbiBmbnMpIHtcbiAgICBvbGRzW25hbWVdID0gZGVjb3JhdGUoc291cmNlLCBuYW1lLCBmbnNbbmFtZV0pO1xuICB9XG4gIHJldHVybiBvbGRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZU1hbnkoc291cmNlOiBPYmplY3QsIG9sZHM6IE9iamVjdCk6IHZvaWQge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gb2xkcykge1xuICAgIHNvdXJjZVtuYW1lXSA9IG9sZHNbbmFtZV07XG4gIH1cbn1cblxuLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdIHdlYnBhY2sgY29uZmlnIG5lZWRzIHRvIGJlIHVwZGF0ZWQgdG8gYWxsb3cgYHRoaXNgIHR5cGUgYW5ub3RhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBmb3JjZVVwZGF0ZShpbnN0YW5jZTogSW50ZXJuYWxJbnN0YW5jZSk6IHZvaWQge1xuICBpZiAodHlwZW9mIGluc3RhbmNlLmZvcmNlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgfSBlbHNlIGlmIChcbiAgICBpbnN0YW5jZS51cGRhdGVyICE9IG51bGwgJiZcbiAgICB0eXBlb2YgaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgKCkgPT4ge30sICdmb3JjZVVwZGF0ZScpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/legacy/utils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/profilingHooks.js":
/*!**************************************************************!*\
  !*** ../react-devtools-shared/src/backend/profilingHooks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createProfilingHooks\": () => (/* binding */ createProfilingHooks),\n/* harmony export */   \"setPerformanceMock_ONLY_FOR_TESTING\": () => (/* binding */ setPerformanceMock_ONLY_FOR_TESTING)\n/* harmony export */ });\n/* harmony import */ var shared_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shared/isArray */ \"../shared/isArray.js\");\n/* harmony import */ var react_devtools_timeline_src_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-timeline/src/constants */ \"../react-devtools-timeline/src/constants.js\");\n/* harmony import */ var _fiber_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fiber/DevToolsFiberComponentStack */ \"../react-devtools-shared/src/backend/fiber/DevToolsFiberComponentStack.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n // Add padding to the start/stop time of the profile.\n// This makes the UI nicer to use.\n\nvar TIME_OFFSET = 10;\nvar performanceTarget = null; // If performance exists and supports the subset of the User Timing API that we require.\n\nvar supportsUserTiming = typeof performance !== 'undefined' && // $FlowFixMe[method-unbinding]\ntypeof performance.mark === 'function' && // $FlowFixMe[method-unbinding]\ntypeof performance.clearMarks === 'function';\nvar supportsUserTimingV3 = false;\n\nif (supportsUserTiming) {\n  var CHECK_V3_MARK = '__v3';\n  var markOptions = {};\n  Object.defineProperty(markOptions, 'startTime', {\n    get: function get() {\n      supportsUserTimingV3 = true;\n      return 0;\n    },\n    set: function set() {}\n  });\n\n  try {\n    performance.mark(CHECK_V3_MARK, markOptions);\n  } catch (error) {// Ignore\n  } finally {\n    performance.clearMarks(CHECK_V3_MARK);\n  }\n}\n\nif (supportsUserTimingV3) {\n  performanceTarget = performance;\n} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\nvar getCurrentTime = // $FlowFixMe[method-unbinding]\n(typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n}; // Mocking the Performance Object (and User Timing APIs) for testing is fragile.\n// This API allows tests to directly override the User Timing APIs.\n\nfunction setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {\n  performanceTarget = performanceMock;\n  supportsUserTiming = performanceMock !== null;\n  supportsUserTimingV3 = performanceMock !== null;\n}\nfunction createProfilingHooks(_ref) {\n  var getDisplayNameForFiber = _ref.getDisplayNameForFiber,\n      getIsProfiling = _ref.getIsProfiling,\n      getLaneLabelMap = _ref.getLaneLabelMap,\n      workTagMap = _ref.workTagMap,\n      currentDispatcherRef = _ref.currentDispatcherRef,\n      reactVersion = _ref.reactVersion;\n  var currentBatchUID = 0;\n  var currentReactComponentMeasure = null;\n  var currentReactMeasuresStack = [];\n  var currentTimelineData = null;\n  var currentFiberStacks = new Map();\n  var isProfiling = false;\n  var nextRenderShouldStartNewBatch = false;\n\n  function getRelativeTime() {\n    var currentTime = getCurrentTime();\n\n    if (currentTimelineData) {\n      if (currentTimelineData.startTime === 0) {\n        currentTimelineData.startTime = currentTime - TIME_OFFSET;\n      }\n\n      return currentTime - currentTimelineData.startTime;\n    }\n\n    return 0;\n  }\n\n  function getInternalModuleRanges() {\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === 'function') {\n      // Ask the DevTools hook for module ranges that may have been reported by the current renderer(s).\n      // Don't do this eagerly like the laneToLabelMap,\n      // because some modules might not yet have registered their boundaries when the renderer is injected.\n      var ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges(); // This check would not be required,\n      // except that it's possible for things to override __REACT_DEVTOOLS_GLOBAL_HOOK__.\n\n\n      if ((0,shared_isArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(ranges)) {\n        return ranges;\n      }\n    }\n\n    return null;\n  }\n\n  function getTimelineData() {\n    return currentTimelineData;\n  }\n\n  function laneToLanesArray(lanes) {\n    var lanesArray = [];\n    var lane = 1;\n\n    for (var index = 0; index < react_devtools_timeline_src_constants__WEBPACK_IMPORTED_MODULE_1__.REACT_TOTAL_NUM_LANES; index++) {\n      if (lane & lanes) {\n        lanesArray.push(lane);\n      }\n\n      lane *= 2;\n    }\n\n    return lanesArray;\n  }\n\n  var laneToLabelMap = typeof getLaneLabelMap === 'function' ? getLaneLabelMap() : null;\n\n  function markMetadata() {\n    markAndClear(\"--react-version-\".concat(reactVersion));\n    markAndClear(\"--profiler-version-\".concat(react_devtools_timeline_src_constants__WEBPACK_IMPORTED_MODULE_1__.SCHEDULING_PROFILER_VERSION));\n    var ranges = getInternalModuleRanges();\n\n    if (ranges) {\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n\n        if ((0,shared_isArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(range) && range.length === 2) {\n          var _ranges$i = _slicedToArray(ranges[i], 2),\n              startStackFrame = _ranges$i[0],\n              stopStackFrame = _ranges$i[1];\n\n          markAndClear(\"--react-internal-module-start-\".concat(startStackFrame));\n          markAndClear(\"--react-internal-module-stop-\".concat(stopStackFrame));\n        }\n      }\n    }\n\n    if (laneToLabelMap != null) {\n      var labels = Array.from(laneToLabelMap.values()).join(',');\n      markAndClear(\"--react-lane-labels-\".concat(labels));\n    }\n  }\n\n  function markAndClear(markName) {\n    // This method won't be called unless these functions are defined, so we can skip the extra typeof check.\n    performanceTarget.mark(markName);\n    performanceTarget.clearMarks(markName);\n  }\n\n  function recordReactMeasureStarted(type, lanes) {\n    // Decide what depth thi work should be rendered at, based on what's on the top of the stack.\n    // It's okay to render over top of \"idle\" work but everything else should be on its own row.\n    var depth = 0;\n\n    if (currentReactMeasuresStack.length > 0) {\n      var top = currentReactMeasuresStack[currentReactMeasuresStack.length - 1];\n      depth = top.type === 'render-idle' ? top.depth : top.depth + 1;\n    }\n\n    var lanesArray = laneToLanesArray(lanes);\n    var reactMeasure = {\n      type: type,\n      batchUID: currentBatchUID,\n      depth: depth,\n      lanes: lanesArray,\n      timestamp: getRelativeTime(),\n      duration: 0\n    };\n    currentReactMeasuresStack.push(reactMeasure);\n\n    if (currentTimelineData) {\n      var _currentTimelineData = currentTimelineData,\n          batchUIDToMeasuresMap = _currentTimelineData.batchUIDToMeasuresMap,\n          laneToReactMeasureMap = _currentTimelineData.laneToReactMeasureMap;\n      var reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);\n\n      if (reactMeasures != null) {\n        reactMeasures.push(reactMeasure);\n      } else {\n        batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);\n      }\n\n      lanesArray.forEach(function (lane) {\n        reactMeasures = laneToReactMeasureMap.get(lane);\n\n        if (reactMeasures) {\n          reactMeasures.push(reactMeasure);\n        }\n      });\n    }\n  }\n\n  function recordReactMeasureCompleted(type) {\n    var currentTime = getRelativeTime();\n\n    if (currentReactMeasuresStack.length === 0) {\n      console.error('Unexpected type \"%s\" completed at %sms while currentReactMeasuresStack is empty.', type, currentTime); // Ignore work \"completion\" user timing mark that doesn't complete anything\n\n      return;\n    }\n\n    var top = currentReactMeasuresStack.pop(); // $FlowFixMe[incompatible-type]\n\n    if (top.type !== type) {\n      console.error('Unexpected type \"%s\" completed at %sms before \"%s\" completed.', type, currentTime, // $FlowFixMe[incompatible-use]\n      top.type);\n    } // $FlowFixMe[cannot-write] This property should not be writable outside of this function.\n    // $FlowFixMe[incompatible-use]\n\n\n    top.duration = currentTime - top.timestamp;\n\n    if (currentTimelineData) {\n      currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;\n    }\n  }\n\n  function markCommitStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('commit', lanes); // TODO (timeline) Re-think this approach to \"batching\"; I don't think it works for Suspense or pre-rendering.\n      // This issue applies to the User Timing data also.\n\n      nextRenderShouldStartNewBatch = true;\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--commit-start-\".concat(lanes)); // Some metadata only needs to be logged once per session,\n      // but if profiling information is being recorded via the Performance tab,\n      // DevTools has no way of knowing when the recording starts.\n      // Because of that, we log thie type of data periodically (once per commit).\n\n      markMetadata();\n    }\n  }\n\n  function markCommitStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('commit');\n      recordReactMeasureCompleted('render-idle');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--commit-stop');\n    }\n  }\n\n  function markComponentRenderStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'render',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-render-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentRenderStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-render-stop');\n    }\n  }\n\n  function markComponentLayoutEffectMountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'layout-effect-mount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-layout-effect-mount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentLayoutEffectMountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-layout-effect-mount-stop');\n    }\n  }\n\n  function markComponentLayoutEffectUnmountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'layout-effect-unmount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-layout-effect-unmount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentLayoutEffectUnmountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-layout-effect-unmount-stop');\n    }\n  }\n\n  function markComponentPassiveEffectMountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'passive-effect-mount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-passive-effect-mount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentPassiveEffectMountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-passive-effect-mount-stop');\n    }\n  }\n\n  function markComponentPassiveEffectUnmountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName: componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'passive-effect-unmount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--component-passive-effect-unmount-start-\".concat(componentName));\n      }\n    }\n  }\n\n  function markComponentPassiveEffectUnmountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-passive-effect-unmount-stop');\n    }\n  }\n\n  function markComponentErrored(fiber, thrownValue, lanes) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n      var phase = fiber.alternate === null ? 'mount' : 'update';\n      var message = '';\n\n      if (thrownValue !== null && _typeof(thrownValue) === 'object' && typeof thrownValue.message === 'string') {\n        message = thrownValue.message;\n      } else if (typeof thrownValue === 'string') {\n        message = thrownValue;\n      }\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          currentTimelineData.thrownErrors.push({\n            componentName: componentName,\n            message: message,\n            phase: phase,\n            timestamp: getRelativeTime(),\n            type: 'thrown-error'\n          });\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--error-\".concat(componentName, \"-\").concat(phase, \"-\").concat(message));\n      }\n    }\n  }\n\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // $FlowFixMe[incompatible-type]: Flow cannot handle polymorphic WeakMaps\n\n  var wakeableIDs = new PossiblyWeakMap();\n  var wakeableID = 0;\n\n  function getWakeableID(wakeable) {\n    if (!wakeableIDs.has(wakeable)) {\n      wakeableIDs.set(wakeable, wakeableID++);\n    }\n\n    return wakeableIDs.get(wakeable);\n  }\n\n  function markComponentSuspended(fiber, wakeable, lanes) {\n    if (isProfiling || supportsUserTimingV3) {\n      var eventType = wakeableIDs.has(wakeable) ? 'resuspend' : 'suspend';\n      var id = getWakeableID(wakeable);\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n      var phase = fiber.alternate === null ? 'mount' : 'update'; // Following the non-standard fn.displayName convention,\n      // frameworks like Relay may also annotate Promises with a displayName,\n      // describing what operation/data the thrown Promise is related to.\n      // When this is available we should pass it along to the Timeline.\n\n      var displayName = wakeable.displayName || '';\n      var suspenseEvent = null;\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        suspenseEvent = {\n          componentName: componentName,\n          depth: 0,\n          duration: 0,\n          id: \"\".concat(id),\n          phase: phase,\n          promiseName: displayName,\n          resolution: 'unresolved',\n          timestamp: getRelativeTime(),\n          type: 'suspense',\n          warning: null\n        };\n\n        if (currentTimelineData) {\n          currentTimelineData.suspenseEvents.push(suspenseEvent);\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--suspense-\".concat(eventType, \"-\").concat(id, \"-\").concat(componentName, \"-\").concat(phase, \"-\").concat(lanes, \"-\").concat(displayName));\n      }\n\n      wakeable.then(function () {\n        if (suspenseEvent) {\n          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;\n          suspenseEvent.resolution = 'resolved';\n        }\n\n        if (supportsUserTimingV3) {\n          markAndClear(\"--suspense-resolved-\".concat(id, \"-\").concat(componentName));\n        }\n      }, function () {\n        if (suspenseEvent) {\n          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;\n          suspenseEvent.resolution = 'rejected';\n        }\n\n        if (supportsUserTimingV3) {\n          markAndClear(\"--suspense-rejected-\".concat(id, \"-\").concat(componentName));\n        }\n      });\n    }\n  }\n\n  function markLayoutEffectsStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('layout-effects', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--layout-effects-start-\".concat(lanes));\n    }\n  }\n\n  function markLayoutEffectsStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('layout-effects');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--layout-effects-stop');\n    }\n  }\n\n  function markPassiveEffectsStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('passive-effects', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--passive-effects-start-\".concat(lanes));\n    }\n  }\n\n  function markPassiveEffectsStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('passive-effects');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--passive-effects-stop');\n    }\n  }\n\n  function markRenderStarted(lanes) {\n    if (isProfiling) {\n      if (nextRenderShouldStartNewBatch) {\n        nextRenderShouldStartNewBatch = false;\n        currentBatchUID++;\n      } // If this is a new batch of work, wrap an \"idle\" measure around it.\n      // Log it before the \"render\" measure to preserve the stack ordering.\n\n\n      if (currentReactMeasuresStack.length === 0 || currentReactMeasuresStack[currentReactMeasuresStack.length - 1].type !== 'render-idle') {\n        recordReactMeasureStarted('render-idle', lanes);\n      }\n\n      recordReactMeasureStarted('render', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--render-start-\".concat(lanes));\n    }\n  }\n\n  function markRenderYielded() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('render');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--render-yield');\n    }\n  }\n\n  function markRenderStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('render');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--render-stop');\n    }\n  }\n\n  function markRenderScheduled(lane) {\n    if (isProfiling) {\n      if (currentTimelineData) {\n        currentTimelineData.schedulingEvents.push({\n          lanes: laneToLanesArray(lane),\n          timestamp: getRelativeTime(),\n          type: 'schedule-render',\n          warning: null\n        });\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(\"--schedule-render-\".concat(lane));\n    }\n  }\n\n  function markForceUpdateScheduled(fiber, lane) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          currentTimelineData.schedulingEvents.push({\n            componentName: componentName,\n            lanes: laneToLanesArray(lane),\n            timestamp: getRelativeTime(),\n            type: 'schedule-force-update',\n            warning: null\n          });\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--schedule-forced-update-\".concat(lane, \"-\").concat(componentName));\n      }\n    }\n  }\n\n  function getParentFibers(fiber) {\n    var parents = [];\n    var parent = fiber;\n\n    while (parent !== null) {\n      parents.push(parent);\n      parent = parent.return;\n    }\n\n    return parents;\n  }\n\n  function markStateUpdateScheduled(fiber, lane) {\n    if (isProfiling || supportsUserTimingV3) {\n      var componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          var event = {\n            componentName: componentName,\n            // Store the parent fibers so we can post process\n            // them after we finish profiling\n            lanes: laneToLanesArray(lane),\n            timestamp: getRelativeTime(),\n            type: 'schedule-state-update',\n            warning: null\n          };\n          currentFiberStacks.set(event, getParentFibers(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n          currentTimelineData.schedulingEvents.push(event);\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(\"--schedule-state-update-\".concat(lane, \"-\").concat(componentName));\n      }\n    }\n  }\n\n  function toggleProfilingStatus(value) {\n    var recordTimeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (isProfiling !== value) {\n      isProfiling = value;\n\n      if (isProfiling) {\n        var internalModuleSourceToRanges = new Map();\n\n        if (supportsUserTimingV3) {\n          var ranges = getInternalModuleRanges();\n\n          if (ranges) {\n            for (var i = 0; i < ranges.length; i++) {\n              var range = ranges[i];\n\n              if ((0,shared_isArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(range) && range.length === 2) {\n                var _ranges$i2 = _slicedToArray(ranges[i], 2),\n                    startStackFrame = _ranges$i2[0],\n                    stopStackFrame = _ranges$i2[1];\n\n                markAndClear(\"--react-internal-module-start-\".concat(startStackFrame));\n                markAndClear(\"--react-internal-module-stop-\".concat(stopStackFrame));\n              }\n            }\n          }\n        }\n\n        var laneToReactMeasureMap = new Map();\n        var lane = 1;\n\n        for (var index = 0; index < react_devtools_timeline_src_constants__WEBPACK_IMPORTED_MODULE_1__.REACT_TOTAL_NUM_LANES; index++) {\n          laneToReactMeasureMap.set(lane, []);\n          lane *= 2;\n        }\n\n        currentBatchUID = 0;\n        currentReactComponentMeasure = null;\n        currentReactMeasuresStack = [];\n        currentFiberStacks = new Map();\n\n        if (recordTimeline) {\n          currentTimelineData = {\n            // Session wide metadata; only collected once.\n            internalModuleSourceToRanges: internalModuleSourceToRanges,\n            laneToLabelMap: laneToLabelMap || new Map(),\n            reactVersion: reactVersion,\n            // Data logged by React during profiling session.\n            componentMeasures: [],\n            schedulingEvents: [],\n            suspenseEvents: [],\n            thrownErrors: [],\n            // Data inferred based on what React logs.\n            batchUIDToMeasuresMap: new Map(),\n            duration: 0,\n            laneToReactMeasureMap: laneToReactMeasureMap,\n            startTime: 0,\n            // Data only available in Chrome profiles.\n            flamechart: [],\n            nativeEvents: [],\n            networkMeasures: [],\n            otherUserTimingMarks: [],\n            snapshots: [],\n            snapshotHeight: 0\n          };\n        }\n\n        nextRenderShouldStartNewBatch = true;\n      } else {\n        // This is __EXPENSIVE__.\n        // We could end up with hundreds of state updated, and for each one of them\n        // would try to create a component stack with possibly hundreds of Fibers.\n        // Creating a cache of component stacks won't help, generating a single stack is already expensive enough.\n        // We should find a way to lazily generate component stacks on demand, when user inspects a specific event.\n        // If we succeed with moving React DevTools Timeline Profiler to Performance panel, then Timeline Profiler would probably be removed.\n        // If not, then once enableOwnerStacks is adopted, revisit this again and cache component stacks per Fiber,\n        // but only return them when needed, sending hundreds of component stacks is beyond the Bridge's bandwidth.\n        // Postprocess Profile data\n        if (currentTimelineData !== null) {\n          currentTimelineData.schedulingEvents.forEach(function (event) {\n            if (event.type === 'schedule-state-update') {\n              // TODO(luna): We can optimize this by creating a map of\n              // fiber to component stack instead of generating the stack\n              // for every fiber every time\n              var fiberStack = currentFiberStacks.get(event);\n\n              if (fiberStack && currentDispatcherRef != null) {\n                event.componentStack = fiberStack.reduce(function (trace, fiber) {\n                  return trace + (0,_fiber_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__.describeFiber)(workTagMap, fiber, currentDispatcherRef);\n                }, '');\n              }\n            }\n          });\n        } // Clear the current fiber stacks so we don't hold onto the fibers\n        // in memory after profiling finishes\n\n\n        currentFiberStacks.clear();\n      }\n    }\n  }\n\n  return {\n    getTimelineData: getTimelineData,\n    profilingHooks: {\n      markCommitStarted: markCommitStarted,\n      markCommitStopped: markCommitStopped,\n      markComponentRenderStarted: markComponentRenderStarted,\n      markComponentRenderStopped: markComponentRenderStopped,\n      markComponentPassiveEffectMountStarted: markComponentPassiveEffectMountStarted,\n      markComponentPassiveEffectMountStopped: markComponentPassiveEffectMountStopped,\n      markComponentPassiveEffectUnmountStarted: markComponentPassiveEffectUnmountStarted,\n      markComponentPassiveEffectUnmountStopped: markComponentPassiveEffectUnmountStopped,\n      markComponentLayoutEffectMountStarted: markComponentLayoutEffectMountStarted,\n      markComponentLayoutEffectMountStopped: markComponentLayoutEffectMountStopped,\n      markComponentLayoutEffectUnmountStarted: markComponentLayoutEffectUnmountStarted,\n      markComponentLayoutEffectUnmountStopped: markComponentLayoutEffectUnmountStopped,\n      markComponentErrored: markComponentErrored,\n      markComponentSuspended: markComponentSuspended,\n      markLayoutEffectsStarted: markLayoutEffectsStarted,\n      markLayoutEffectsStopped: markLayoutEffectsStopped,\n      markPassiveEffectsStarted: markPassiveEffectsStarted,\n      markPassiveEffectsStopped: markPassiveEffectsStopped,\n      markRenderStarted: markRenderStarted,\n      markRenderYielded: markRenderYielded,\n      markRenderStopped: markRenderStopped,\n      markRenderScheduled: markRenderScheduled,\n      markForceUpdateScheduled: markForceUpdateScheduled,\n      markStateUpdateScheduled: markStateUpdateScheduled\n    },\n    toggleProfilingStatus: toggleProfilingStatus\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3Byb2ZpbGluZ0hvb2tzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFnQ0E7QUFDQTtBQUlBO0FBR0E7O0FBQ0E7QUFFQTs7QUFHQTtBQUdBO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUdBOztBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBTUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUdBOzs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFLQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBNUJBO0FBOEJBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3Byb2ZpbGluZ0hvb2tzLmpzPzA2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge1xuICBMYW5lLFxuICBMYW5lcyxcbiAgRGV2VG9vbHNQcm9maWxpbmdIb29rcyxcbiAgV29ya1RhZ01hcCxcbiAgQ3VycmVudERpc3BhdGNoZXJSZWYsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7RmliZXJ9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0SW50ZXJuYWxUeXBlcyc7XG5pbXBvcnQgdHlwZSB7V2FrZWFibGV9IGZyb20gJ3NoYXJlZC9SZWFjdFR5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgQmF0Y2hVSUQsXG4gIEludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMsXG4gIExhbmVUb0xhYmVsTWFwLFxuICBSZWFjdENvbXBvbmVudE1lYXN1cmUsXG4gIFJlYWN0TGFuZSxcbiAgUmVhY3RNZWFzdXJlLFxuICBSZWFjdE1lYXN1cmVUeXBlLFxuICBSZWFjdFNjaGVkdWxlU3RhdGVVcGRhdGVFdmVudCxcbiAgU2NoZWR1bGluZ0V2ZW50LFxuICBTdXNwZW5zZUV2ZW50LFxuICBUaW1lbGluZURhdGEsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXRpbWVsaW5lL3NyYy90eXBlcyc7XG5cbmltcG9ydCBpc0FycmF5IGZyb20gJ3NoYXJlZC9pc0FycmF5JztcbmltcG9ydCB7XG4gIFJFQUNUX1RPVEFMX05VTV9MQU5FUyxcbiAgU0NIRURVTElOR19QUk9GSUxFUl9WRVJTSU9OLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy10aW1lbGluZS9zcmMvY29uc3RhbnRzJztcbmltcG9ydCB7ZGVzY3JpYmVGaWJlcn0gZnJvbSAnLi9maWJlci9EZXZUb29sc0ZpYmVyQ29tcG9uZW50U3RhY2snO1xuXG4vLyBBZGQgcGFkZGluZyB0byB0aGUgc3RhcnQvc3RvcCB0aW1lIG9mIHRoZSBwcm9maWxlLlxuLy8gVGhpcyBtYWtlcyB0aGUgVUkgbmljZXIgdG8gdXNlLlxuY29uc3QgVElNRV9PRkZTRVQgPSAxMDtcblxubGV0IHBlcmZvcm1hbmNlVGFyZ2V0OiBQZXJmb3JtYW5jZSB8IG51bGwgPSBudWxsO1xuXG4vLyBJZiBwZXJmb3JtYW5jZSBleGlzdHMgYW5kIHN1cHBvcnRzIHRoZSBzdWJzZXQgb2YgdGhlIFVzZXIgVGltaW5nIEFQSSB0aGF0IHdlIHJlcXVpcmUuXG5sZXQgc3VwcG9ydHNVc2VyVGltaW5nID1cbiAgdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJlxuICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbic7XG5cbmxldCBzdXBwb3J0c1VzZXJUaW1pbmdWMyA9IGZhbHNlO1xuaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICBjb25zdCBDSEVDS19WM19NQVJLID0gJ19fdjMnO1xuICBjb25zdCBtYXJrT3B0aW9uczoge1xuICAgIGRldGFpbD86IG1peGVkLFxuICAgIHN0YXJ0VGltZT86IG51bWJlcixcbiAgfSA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFya09wdGlvbnMsICdzdGFydFRpbWUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBzdXBwb3J0c1VzZXJUaW1pbmdWMyA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKCkge30sXG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWFyayhDSEVDS19WM19NQVJLLCBtYXJrT3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWdub3JlXG4gIH0gZmluYWxseSB7XG4gICAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhDSEVDS19WM19NQVJLKTtcbiAgfVxufVxuXG5pZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgcGVyZm9ybWFuY2VUYXJnZXQgPSBwZXJmb3JtYW5jZTtcbn1cblxuLy8gU29tZSBlbnZpcm9ubWVudHMgKGUuZy4gUmVhY3QgTmF0aXZlIC8gSGVybWVzKSBkb24ndCBzdXBwb3J0IHRoZSBwZXJmb3JtYW5jZSBBUEkgeWV0LlxuY29uc3QgZ2V0Q3VycmVudFRpbWUgPVxuICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5cbi8vIE1vY2tpbmcgdGhlIFBlcmZvcm1hbmNlIE9iamVjdCAoYW5kIFVzZXIgVGltaW5nIEFQSXMpIGZvciB0ZXN0aW5nIGlzIGZyYWdpbGUuXG4vLyBUaGlzIEFQSSBhbGxvd3MgdGVzdHMgdG8gZGlyZWN0bHkgb3ZlcnJpZGUgdGhlIFVzZXIgVGltaW5nIEFQSXMuXG5leHBvcnQgZnVuY3Rpb24gc2V0UGVyZm9ybWFuY2VNb2NrX09OTFlfRk9SX1RFU1RJTkcoXG4gIHBlcmZvcm1hbmNlTW9jazogUGVyZm9ybWFuY2UgfCBudWxsLFxuKSB7XG4gIHBlcmZvcm1hbmNlVGFyZ2V0ID0gcGVyZm9ybWFuY2VNb2NrO1xuICBzdXBwb3J0c1VzZXJUaW1pbmcgPSBwZXJmb3JtYW5jZU1vY2sgIT09IG51bGw7XG4gIHN1cHBvcnRzVXNlclRpbWluZ1YzID0gcGVyZm9ybWFuY2VNb2NrICE9PSBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBHZXRUaW1lbGluZURhdGEgPSAoKSA9PiBUaW1lbGluZURhdGEgfCBudWxsO1xuZXhwb3J0IHR5cGUgVG9nZ2xlUHJvZmlsaW5nU3RhdHVzID0gKFxuICB2YWx1ZTogYm9vbGVhbixcbiAgcmVjb3JkVGltZWxpbmU/OiBib29sZWFuLFxuKSA9PiB2b2lkO1xuXG50eXBlIFJlc3BvbnNlID0ge1xuICBnZXRUaW1lbGluZURhdGE6IEdldFRpbWVsaW5lRGF0YSxcbiAgcHJvZmlsaW5nSG9va3M6IERldlRvb2xzUHJvZmlsaW5nSG9va3MsXG4gIHRvZ2dsZVByb2ZpbGluZ1N0YXR1czogVG9nZ2xlUHJvZmlsaW5nU3RhdHVzLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb2ZpbGluZ0hvb2tzKHtcbiAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlcixcbiAgZ2V0SXNQcm9maWxpbmcsXG4gIGdldExhbmVMYWJlbE1hcCxcbiAgd29ya1RhZ01hcCxcbiAgY3VycmVudERpc3BhdGNoZXJSZWYsXG4gIHJlYWN0VmVyc2lvbixcbn06IHtcbiAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlcjogKGZpYmVyOiBGaWJlcikgPT4gc3RyaW5nIHwgbnVsbCxcbiAgZ2V0SXNQcm9maWxpbmc6ICgpID0+IGJvb2xlYW4sXG4gIGdldExhbmVMYWJlbE1hcD86ICgpID0+IE1hcDxMYW5lLCBzdHJpbmc+IHwgbnVsbCxcbiAgY3VycmVudERpc3BhdGNoZXJSZWY/OiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgd29ya1RhZ01hcDogV29ya1RhZ01hcCxcbiAgcmVhY3RWZXJzaW9uOiBzdHJpbmcsXG59KTogUmVzcG9uc2Uge1xuICBsZXQgY3VycmVudEJhdGNoVUlEOiBCYXRjaFVJRCA9IDA7XG4gIGxldCBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlOiBSZWFjdENvbXBvbmVudE1lYXN1cmUgfCBudWxsID0gbnVsbDtcbiAgbGV0IGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2s6IEFycmF5PFJlYWN0TWVhc3VyZT4gPSBbXTtcbiAgbGV0IGN1cnJlbnRUaW1lbGluZURhdGE6IFRpbWVsaW5lRGF0YSB8IG51bGwgPSBudWxsO1xuICBsZXQgY3VycmVudEZpYmVyU3RhY2tzOiBNYXA8U2NoZWR1bGluZ0V2ZW50LCBBcnJheTxGaWJlcj4+ID0gbmV3IE1hcCgpO1xuICBsZXQgaXNQcm9maWxpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgbGV0IG5leHRSZW5kZXJTaG91bGRTdGFydE5ld0JhdGNoOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZ2V0UmVsYXRpdmVUaW1lKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YS5zdGFydFRpbWUgPT09IDApIHtcbiAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5zdGFydFRpbWUgPSBjdXJyZW50VGltZSAtIFRJTUVfT0ZGU0VUO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgLSBjdXJyZW50VGltZWxpbmVEYXRhLnN0YXJ0VGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEludGVybmFsTW9kdWxlUmFuZ2VzKCkge1xuICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5nZXRJbnRlcm5hbE1vZHVsZVJhbmdlcyA9PT1cbiAgICAgICAgJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgLy8gQXNrIHRoZSBEZXZUb29scyBob29rIGZvciBtb2R1bGUgcmFuZ2VzIHRoYXQgbWF5IGhhdmUgYmVlbiByZXBvcnRlZCBieSB0aGUgY3VycmVudCByZW5kZXJlcihzKS5cbiAgICAgIC8vIERvbid0IGRvIHRoaXMgZWFnZXJseSBsaWtlIHRoZSBsYW5lVG9MYWJlbE1hcCxcbiAgICAgIC8vIGJlY2F1c2Ugc29tZSBtb2R1bGVzIG1pZ2h0IG5vdCB5ZXQgaGF2ZSByZWdpc3RlcmVkIHRoZWlyIGJvdW5kYXJpZXMgd2hlbiB0aGUgcmVuZGVyZXIgaXMgaW5qZWN0ZWQuXG4gICAgICBjb25zdCByYW5nZXMgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMoKTtcblxuICAgICAgLy8gVGhpcyBjaGVjayB3b3VsZCBub3QgYmUgcmVxdWlyZWQsXG4gICAgICAvLyBleGNlcHQgdGhhdCBpdCdzIHBvc3NpYmxlIGZvciB0aGluZ3MgdG8gb3ZlcnJpZGUgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLlxuICAgICAgaWYgKGlzQXJyYXkocmFuZ2VzKSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGltZWxpbmVEYXRhKCk6IFRpbWVsaW5lRGF0YSB8IG51bGwge1xuICAgIHJldHVybiBjdXJyZW50VGltZWxpbmVEYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gbGFuZVRvTGFuZXNBcnJheShsYW5lczogTGFuZSkge1xuICAgIGNvbnN0IGxhbmVzQXJyYXkgPSBbXTtcblxuICAgIGxldCBsYW5lID0gMTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgUkVBQ1RfVE9UQUxfTlVNX0xBTkVTOyBpbmRleCsrKSB7XG4gICAgICBpZiAobGFuZSAmIGxhbmVzKSB7XG4gICAgICAgIGxhbmVzQXJyYXkucHVzaChsYW5lKTtcbiAgICAgIH1cbiAgICAgIGxhbmUgKj0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFuZXNBcnJheTtcbiAgfVxuXG4gIGNvbnN0IGxhbmVUb0xhYmVsTWFwOiBMYW5lVG9MYWJlbE1hcCB8IG51bGwgPVxuICAgIHR5cGVvZiBnZXRMYW5lTGFiZWxNYXAgPT09ICdmdW5jdGlvbicgPyBnZXRMYW5lTGFiZWxNYXAoKSA6IG51bGw7XG5cbiAgZnVuY3Rpb24gbWFya01ldGFkYXRhKCkge1xuICAgIG1hcmtBbmRDbGVhcihgLS1yZWFjdC12ZXJzaW9uLSR7cmVhY3RWZXJzaW9ufWApO1xuICAgIG1hcmtBbmRDbGVhcihgLS1wcm9maWxlci12ZXJzaW9uLSR7U0NIRURVTElOR19QUk9GSUxFUl9WRVJTSU9OfWApO1xuXG4gICAgY29uc3QgcmFuZ2VzID0gZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMoKTtcbiAgICBpZiAocmFuZ2VzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGlzQXJyYXkocmFuZ2UpICYmIHJhbmdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IFtzdGFydFN0YWNrRnJhbWUsIHN0b3BTdGFja0ZyYW1lXSA9IHJhbmdlc1tpXTtcblxuICAgICAgICAgIG1hcmtBbmRDbGVhcihgLS1yZWFjdC1pbnRlcm5hbC1tb2R1bGUtc3RhcnQtJHtzdGFydFN0YWNrRnJhbWV9YCk7XG4gICAgICAgICAgbWFya0FuZENsZWFyKGAtLXJlYWN0LWludGVybmFsLW1vZHVsZS1zdG9wLSR7c3RvcFN0YWNrRnJhbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFuZVRvTGFiZWxNYXAgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gQXJyYXkuZnJvbShsYW5lVG9MYWJlbE1hcC52YWx1ZXMoKSkuam9pbignLCcpO1xuICAgICAgbWFya0FuZENsZWFyKGAtLXJlYWN0LWxhbmUtbGFiZWxzLSR7bGFiZWxzfWApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtBbmRDbGVhcihtYXJrTmFtZTogc3RyaW5nKSB7XG4gICAgLy8gVGhpcyBtZXRob2Qgd29uJ3QgYmUgY2FsbGVkIHVubGVzcyB0aGVzZSBmdW5jdGlvbnMgYXJlIGRlZmluZWQsIHNvIHdlIGNhbiBza2lwIHRoZSBleHRyYSB0eXBlb2YgY2hlY2suXG4gICAgKChwZXJmb3JtYW5jZVRhcmdldDogYW55KTogUGVyZm9ybWFuY2UpLm1hcmsobWFya05hbWUpO1xuICAgICgocGVyZm9ybWFuY2VUYXJnZXQ6IGFueSk6IFBlcmZvcm1hbmNlKS5jbGVhck1hcmtzKG1hcmtOYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQoXG4gICAgdHlwZTogUmVhY3RNZWFzdXJlVHlwZSxcbiAgICBsYW5lczogTGFuZXMsXG4gICk6IHZvaWQge1xuICAgIC8vIERlY2lkZSB3aGF0IGRlcHRoIHRoaSB3b3JrIHNob3VsZCBiZSByZW5kZXJlZCBhdCwgYmFzZWQgb24gd2hhdCdzIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICAgIC8vIEl0J3Mgb2theSB0byByZW5kZXIgb3ZlciB0b3Agb2YgXCJpZGxlXCIgd29yayBidXQgZXZlcnl0aGluZyBlbHNlIHNob3VsZCBiZSBvbiBpdHMgb3duIHJvdy5cbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGlmIChjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvcCA9XG4gICAgICAgIGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2tbY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGRlcHRoID0gdG9wLnR5cGUgPT09ICdyZW5kZXItaWRsZScgPyB0b3AuZGVwdGggOiB0b3AuZGVwdGggKyAxO1xuICAgIH1cblxuICAgIGNvbnN0IGxhbmVzQXJyYXkgPSBsYW5lVG9MYW5lc0FycmF5KGxhbmVzKTtcblxuICAgIGNvbnN0IHJlYWN0TWVhc3VyZTogUmVhY3RNZWFzdXJlID0ge1xuICAgICAgdHlwZSxcbiAgICAgIGJhdGNoVUlEOiBjdXJyZW50QmF0Y2hVSUQsXG4gICAgICBkZXB0aCxcbiAgICAgIGxhbmVzOiBsYW5lc0FycmF5LFxuICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgIH07XG5cbiAgICBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrLnB1c2gocmVhY3RNZWFzdXJlKTtcblxuICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICBjb25zdCB7YmF0Y2hVSURUb01lYXN1cmVzTWFwLCBsYW5lVG9SZWFjdE1lYXN1cmVNYXB9ID1cbiAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YTtcblxuICAgICAgbGV0IHJlYWN0TWVhc3VyZXMgPSBiYXRjaFVJRFRvTWVhc3VyZXNNYXAuZ2V0KGN1cnJlbnRCYXRjaFVJRCk7XG4gICAgICBpZiAocmVhY3RNZWFzdXJlcyAhPSBudWxsKSB7XG4gICAgICAgIHJlYWN0TWVhc3VyZXMucHVzaChyZWFjdE1lYXN1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwLnNldChjdXJyZW50QmF0Y2hVSUQsIFtyZWFjdE1lYXN1cmVdKTtcbiAgICAgIH1cblxuICAgICAgbGFuZXNBcnJheS5mb3JFYWNoKGxhbmUgPT4ge1xuICAgICAgICByZWFjdE1lYXN1cmVzID0gbGFuZVRvUmVhY3RNZWFzdXJlTWFwLmdldChsYW5lKTtcbiAgICAgICAgaWYgKHJlYWN0TWVhc3VyZXMpIHtcbiAgICAgICAgICByZWFjdE1lYXN1cmVzLnB1c2gocmVhY3RNZWFzdXJlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUmVhY3RNZWFzdXJlQ29tcGxldGVkKHR5cGU6IFJlYWN0TWVhc3VyZVR5cGUpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IGdldFJlbGF0aXZlVGltZSgpO1xuXG4gICAgaWYgKGN1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCB0eXBlIFwiJXNcIiBjb21wbGV0ZWQgYXQgJXNtcyB3aGlsZSBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrIGlzIGVtcHR5LicsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgKTtcbiAgICAgIC8vIElnbm9yZSB3b3JrIFwiY29tcGxldGlvblwiIHVzZXIgdGltaW5nIG1hcmsgdGhhdCBkb2Vzbid0IGNvbXBsZXRlIGFueXRoaW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdG9wID0gY3VycmVudFJlYWN0TWVhc3VyZXNTdGFjay5wb3AoKTtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuICAgIGlmICh0b3AudHlwZSAhPT0gdHlwZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgdHlwZSBcIiVzXCIgY29tcGxldGVkIGF0ICVzbXMgYmVmb3JlIFwiJXNcIiBjb21wbGV0ZWQuJyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV1cbiAgICAgICAgdG9wLnR5cGUsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBUaGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgd3JpdGFibGUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV1cbiAgICB0b3AuZHVyYXRpb24gPSBjdXJyZW50VGltZSAtIHRvcC50aW1lc3RhbXA7XG5cbiAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5kdXJhdGlvbiA9IGdldFJlbGF0aXZlVGltZSgpICsgVElNRV9PRkZTRVQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXM6IExhbmVzKTogdm9pZCB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVTdGFydGVkKCdjb21taXQnLCBsYW5lcyk7XG5cbiAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZS10aGluayB0aGlzIGFwcHJvYWNoIHRvIFwiYmF0Y2hpbmdcIjsgSSBkb24ndCB0aGluayBpdCB3b3JrcyBmb3IgU3VzcGVuc2Ugb3IgcHJlLXJlbmRlcmluZy5cbiAgICAgIC8vIFRoaXMgaXNzdWUgYXBwbGllcyB0byB0aGUgVXNlciBUaW1pbmcgZGF0YSBhbHNvLlxuICAgICAgbmV4dFJlbmRlclNob3VsZFN0YXJ0TmV3QmF0Y2ggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKGAtLWNvbW1pdC1zdGFydC0ke2xhbmVzfWApO1xuXG4gICAgICAvLyBTb21lIG1ldGFkYXRhIG9ubHkgbmVlZHMgdG8gYmUgbG9nZ2VkIG9uY2UgcGVyIHNlc3Npb24sXG4gICAgICAvLyBidXQgaWYgcHJvZmlsaW5nIGluZm9ybWF0aW9uIGlzIGJlaW5nIHJlY29yZGVkIHZpYSB0aGUgUGVyZm9ybWFuY2UgdGFiLFxuICAgICAgLy8gRGV2VG9vbHMgaGFzIG5vIHdheSBvZiBrbm93aW5nIHdoZW4gdGhlIHJlY29yZGluZyBzdGFydHMuXG4gICAgICAvLyBCZWNhdXNlIG9mIHRoYXQsIHdlIGxvZyB0aGllIHR5cGUgb2YgZGF0YSBwZXJpb2RpY2FsbHkgKG9uY2UgcGVyIGNvbW1pdCkuXG4gICAgICBtYXJrTWV0YWRhdGEoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCgnY29tbWl0Jyk7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVDb21wbGV0ZWQoJ3JlbmRlci1pZGxlJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tY29tbWl0LXN0b3AnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAncmVuZGVyJyxcbiAgICAgICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKGAtLWNvbXBvbmVudC1yZW5kZXItc3RhcnQtJHtjb21wb25lbnROYW1lfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk6IHZvaWQge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmNvbXBvbmVudE1lYXN1cmVzLnB1c2goXG4gICAgICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS5kdXJhdGlvbiA9XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgZ2V0UmVsYXRpdmVUaW1lKCkgLSBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLnRpbWVzdGFtcDtcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tY29tcG9uZW50LXJlbmRlci1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaWJlcjogRmliZXIpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAnbGF5b3V0LWVmZmVjdC1tb3VudCcsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihgLS1jb21wb25lbnQtbGF5b3V0LWVmZmVjdC1tb3VudC1zdGFydC0ke2NvbXBvbmVudE5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlKSB7XG4gICAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5jb21wb25lbnRNZWFzdXJlcy5wdXNoKFxuICAgICAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUuZHVyYXRpb24gPVxuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIGdldFJlbGF0aXZlVGltZSgpIC0gY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS50aW1lc3RhbXA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbXBvbmVudC1sYXlvdXQtZWZmZWN0LW1vdW50LXN0b3AnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXI6IEZpYmVyKTogdm9pZCB7XG4gICAgaWYgKGlzUHJvZmlsaW5nIHx8IHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBjb25zdCBjb21wb25lbnROYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ2xheW91dC1lZmZlY3QtdW5tb3VudCcsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihcbiAgICAgICAgICBgLS1jb21wb25lbnQtbGF5b3V0LWVmZmVjdC11bm1vdW50LXN0YXJ0LSR7Y29tcG9uZW50TmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlKSB7XG4gICAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5jb21wb25lbnRNZWFzdXJlcy5wdXNoKFxuICAgICAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUuZHVyYXRpb24gPVxuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICAgIGdldFJlbGF0aXZlVGltZSgpIC0gY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS50aW1lc3RhbXA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLWNvbXBvbmVudC1sYXlvdXQtZWZmZWN0LXVubW91bnQtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyOiBGaWJlcik6IHZvaWQge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZWNvcmQgYW5kIGNhY2hlIGNvbXBvbmVudCBzdGFja1xuICAgICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlID0ge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgICAgICAgIHR5cGU6ICdwYXNzaXZlLWVmZmVjdC1tb3VudCcsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihgLS1jb21wb25lbnQtcGFzc2l2ZS1lZmZlY3QtbW91bnQtc3RhcnQtJHtjb21wb25lbnROYW1lfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk6IHZvaWQge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLmNvbXBvbmVudE1lYXN1cmVzLnB1c2goXG4gICAgICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZS5kdXJhdGlvbiA9XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgZ2V0UmVsYXRpdmVUaW1lKCkgLSBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLnRpbWVzdGFtcDtcbiAgICAgICAgY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tY29tcG9uZW50LXBhc3NpdmUtZWZmZWN0LW1vdW50LXN0b3AnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyOiBGaWJlcik6IHZvaWQge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZWNvcmQgYW5kIGNhY2hlIGNvbXBvbmVudCBzdGFja1xuICAgICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlID0ge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgICAgICAgIHR5cGU6ICdwYXNzaXZlLWVmZmVjdC11bm1vdW50JyxcbiAgICAgICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKFxuICAgICAgICAgIGAtLWNvbXBvbmVudC1wYXNzaXZlLWVmZmVjdC11bm1vdW50LXN0YXJ0LSR7Y29tcG9uZW50TmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKTogdm9pZCB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICBpZiAoY3VycmVudFJlYWN0Q29tcG9uZW50TWVhc3VyZSkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEuY29tcG9uZW50TWVhc3VyZXMucHVzaChcbiAgICAgICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlLmR1cmF0aW9uID1cbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICBnZXRSZWxhdGl2ZVRpbWUoKSAtIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUudGltZXN0YW1wO1xuICAgICAgICBjdXJyZW50UmVhY3RDb21wb25lbnRNZWFzdXJlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1jb21wb25lbnQtcGFzc2l2ZS1lZmZlY3QtdW5tb3VudC1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudEVycm9yZWQoXG4gICAgZmliZXI6IEZpYmVyLFxuICAgIHRocm93blZhbHVlOiBtaXhlZCxcbiAgICBsYW5lczogTGFuZXMsXG4gICk6IHZvaWQge1xuICAgIGlmIChpc1Byb2ZpbGluZyB8fCBzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICAgIGNvbnN0IHBoYXNlID0gZmliZXIuYWx0ZXJuYXRlID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgaWYgKFxuICAgICAgICB0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiB0aHJvd25WYWx1ZS5tZXNzYWdlID09PSAnc3RyaW5nJ1xuICAgICAgKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aHJvd25WYWx1ZS5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aHJvd25WYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIC8vIFRPRE8gKHRpbWVsaW5lKSBSZWNvcmQgYW5kIGNhY2hlIGNvbXBvbmVudCBzdGFja1xuICAgICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICAgIGN1cnJlbnRUaW1lbGluZURhdGEudGhyb3duRXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAndGhyb3duLWVycm9yJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgbWFya0FuZENsZWFyKGAtLWVycm9yLSR7Y29tcG9uZW50TmFtZX0tJHtwaGFzZX0tJHttZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblxuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBjYW5ub3QgaGFuZGxlIHBvbHltb3JwaGljIFdlYWtNYXBzXG4gIGNvbnN0IHdha2VhYmxlSURzOiBXZWFrTWFwPFdha2VhYmxlLCBudW1iZXI+ID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICBsZXQgd2FrZWFibGVJRDogbnVtYmVyID0gMDtcbiAgZnVuY3Rpb24gZ2V0V2FrZWFibGVJRCh3YWtlYWJsZTogV2FrZWFibGUpOiBudW1iZXIge1xuICAgIGlmICghd2FrZWFibGVJRHMuaGFzKHdha2VhYmxlKSkge1xuICAgICAgd2FrZWFibGVJRHMuc2V0KHdha2VhYmxlLCB3YWtlYWJsZUlEKyspO1xuICAgIH1cbiAgICByZXR1cm4gKCh3YWtlYWJsZUlEcy5nZXQod2FrZWFibGUpOiBhbnkpOiBudW1iZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChcbiAgICBmaWJlcjogRmliZXIsXG4gICAgd2FrZWFibGU6IFdha2VhYmxlLFxuICAgIGxhbmVzOiBMYW5lcyxcbiAgKTogdm9pZCB7XG4gICAgaWYgKGlzUHJvZmlsaW5nIHx8IHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBjb25zdCBldmVudFR5cGUgPSB3YWtlYWJsZUlEcy5oYXMod2FrZWFibGUpID8gJ3Jlc3VzcGVuZCcgOiAnc3VzcGVuZCc7XG4gICAgICBjb25zdCBpZCA9IGdldFdha2VhYmxlSUQod2FrZWFibGUpO1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICAgIGNvbnN0IHBoYXNlID0gZmliZXIuYWx0ZXJuYXRlID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICAvLyBGb2xsb3dpbmcgdGhlIG5vbi1zdGFuZGFyZCBmbi5kaXNwbGF5TmFtZSBjb252ZW50aW9uLFxuICAgICAgLy8gZnJhbWV3b3JrcyBsaWtlIFJlbGF5IG1heSBhbHNvIGFubm90YXRlIFByb21pc2VzIHdpdGggYSBkaXNwbGF5TmFtZSxcbiAgICAgIC8vIGRlc2NyaWJpbmcgd2hhdCBvcGVyYXRpb24vZGF0YSB0aGUgdGhyb3duIFByb21pc2UgaXMgcmVsYXRlZCB0by5cbiAgICAgIC8vIFdoZW4gdGhpcyBpcyBhdmFpbGFibGUgd2Ugc2hvdWxkIHBhc3MgaXQgYWxvbmcgdG8gdGhlIFRpbWVsaW5lLlxuICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSAod2FrZWFibGU6IGFueSkuZGlzcGxheU5hbWUgfHwgJyc7XG5cbiAgICAgIGxldCBzdXNwZW5zZUV2ZW50OiBTdXNwZW5zZUV2ZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVE9ETyAodGltZWxpbmUpIFJlY29yZCBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrXG4gICAgICAgIHN1c3BlbnNlRXZlbnQgPSB7XG4gICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICBpZDogYCR7aWR9YCxcbiAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICBwcm9taXNlTmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgICAgcmVzb2x1dGlvbjogJ3VucmVzb2x2ZWQnLFxuICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgdHlwZTogJ3N1c3BlbnNlJyxcbiAgICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhKSB7XG4gICAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5zdXNwZW5zZUV2ZW50cy5wdXNoKHN1c3BlbnNlRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgICBtYXJrQW5kQ2xlYXIoXG4gICAgICAgICAgYC0tc3VzcGVuc2UtJHtldmVudFR5cGV9LSR7aWR9LSR7Y29tcG9uZW50TmFtZX0tJHtwaGFzZX0tJHtsYW5lc30tJHtkaXNwbGF5TmFtZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB3YWtlYWJsZS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgaWYgKHN1c3BlbnNlRXZlbnQpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlRXZlbnQuZHVyYXRpb24gPVxuICAgICAgICAgICAgICBnZXRSZWxhdGl2ZVRpbWUoKSAtIHN1c3BlbnNlRXZlbnQudGltZXN0YW1wO1xuICAgICAgICAgICAgc3VzcGVuc2VFdmVudC5yZXNvbHV0aW9uID0gJ3Jlc29sdmVkJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgICAgIG1hcmtBbmRDbGVhcihgLS1zdXNwZW5zZS1yZXNvbHZlZC0ke2lkfS0ke2NvbXBvbmVudE5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgaWYgKHN1c3BlbnNlRXZlbnQpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlRXZlbnQuZHVyYXRpb24gPVxuICAgICAgICAgICAgICBnZXRSZWxhdGl2ZVRpbWUoKSAtIHN1c3BlbnNlRXZlbnQudGltZXN0YW1wO1xuICAgICAgICAgICAgc3VzcGVuc2VFdmVudC5yZXNvbHV0aW9uID0gJ3JlamVjdGVkJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgICAgICAgIG1hcmtBbmRDbGVhcihgLS1zdXNwZW5zZS1yZWplY3RlZC0ke2lkfS0ke2NvbXBvbmVudE5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXM6IExhbmVzKTogdm9pZCB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVTdGFydGVkKCdsYXlvdXQtZWZmZWN0cycsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihgLS1sYXlvdXQtZWZmZWN0cy1zdGFydC0ke2xhbmVzfWApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCgnbGF5b3V0LWVmZmVjdHMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1sYXlvdXQtZWZmZWN0cy1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lczogTGFuZXMpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQoJ3Bhc3NpdmUtZWZmZWN0cycsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihgLS1wYXNzaXZlLWVmZmVjdHMtc3RhcnQtJHtsYW5lc31gKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk6IHZvaWQge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlQ29tcGxldGVkKCdwYXNzaXZlLWVmZmVjdHMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcignLS1wYXNzaXZlLWVmZmVjdHMtc3RvcCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzOiBMYW5lcyk6IHZvaWQge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgaWYgKG5leHRSZW5kZXJTaG91bGRTdGFydE5ld0JhdGNoKSB7XG4gICAgICAgIG5leHRSZW5kZXJTaG91bGRTdGFydE5ld0JhdGNoID0gZmFsc2U7XG4gICAgICAgIGN1cnJlbnRCYXRjaFVJRCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3IGJhdGNoIG9mIHdvcmssIHdyYXAgYW4gXCJpZGxlXCIgbWVhc3VyZSBhcm91bmQgaXQuXG4gICAgICAvLyBMb2cgaXQgYmVmb3JlIHRoZSBcInJlbmRlclwiIG1lYXN1cmUgdG8gcHJlc2VydmUgdGhlIHN0YWNrIG9yZGVyaW5nLlxuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrW2N1cnJlbnRSZWFjdE1lYXN1cmVzU3RhY2subGVuZ3RoIC0gMV0udHlwZSAhPT1cbiAgICAgICAgICAncmVuZGVyLWlkbGUnXG4gICAgICApIHtcbiAgICAgICAgcmVjb3JkUmVhY3RNZWFzdXJlU3RhcnRlZCgncmVuZGVyLWlkbGUnLCBsYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZVN0YXJ0ZWQoJ3JlbmRlcicsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihgLS1yZW5kZXItc3RhcnQtJHtsYW5lc31gKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJlY29yZFJlYWN0TWVhc3VyZUNvbXBsZXRlZCgncmVuZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICBtYXJrQW5kQ2xlYXIoJy0tcmVuZGVyLXlpZWxkJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlbmRlclN0b3BwZWQoKTogdm9pZCB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZWNvcmRSZWFjdE1lYXN1cmVDb21wbGV0ZWQoJ3JlbmRlcicpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgbWFya0FuZENsZWFyKCctLXJlbmRlci1zdG9wJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlbmRlclNjaGVkdWxlZChsYW5lOiBMYW5lKTogdm9pZCB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICBpZiAoY3VycmVudFRpbWVsaW5lRGF0YSkge1xuICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnNjaGVkdWxpbmdFdmVudHMucHVzaCh7XG4gICAgICAgICAgbGFuZXM6IGxhbmVUb0xhbmVzQXJyYXkobGFuZSksXG4gICAgICAgICAgdGltZXN0YW1wOiBnZXRSZWxhdGl2ZVRpbWUoKSxcbiAgICAgICAgICB0eXBlOiAnc2NoZWR1bGUtcmVuZGVyJyxcbiAgICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIG1hcmtBbmRDbGVhcihgLS1zY2hlZHVsZS1yZW5kZXItJHtsYW5lfWApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlcjogRmliZXIsIGxhbmU6IExhbmUpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnNjaGVkdWxpbmdFdmVudHMucHVzaCh7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgbGFuZXM6IGxhbmVUb0xhbmVzQXJyYXkobGFuZSksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGdldFJlbGF0aXZlVGltZSgpLFxuICAgICAgICAgICAgdHlwZTogJ3NjaGVkdWxlLWZvcmNlLXVwZGF0ZScsXG4gICAgICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmdWMykge1xuICAgICAgICBtYXJrQW5kQ2xlYXIoYC0tc2NoZWR1bGUtZm9yY2VkLXVwZGF0ZS0ke2xhbmV9LSR7Y29tcG9uZW50TmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJlbnRGaWJlcnMoZmliZXI6IEZpYmVyKTogQXJyYXk8RmliZXI+IHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IHBhcmVudDogbnVsbCB8IEZpYmVyID0gZmliZXI7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlcjogRmliZXIsIGxhbmU6IExhbmUpOiB2b2lkIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgfHwgc3VwcG9ydHNVc2VyVGltaW5nVjMpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICAvLyBUT0RPICh0aW1lbGluZSkgUmVjb3JkIGFuZCBjYWNoZSBjb21wb25lbnQgc3RhY2tcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lbGluZURhdGEpIHtcbiAgICAgICAgICBjb25zdCBldmVudDogUmVhY3RTY2hlZHVsZVN0YXRlVXBkYXRlRXZlbnQgPSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHBhcmVudCBmaWJlcnMgc28gd2UgY2FuIHBvc3QgcHJvY2Vzc1xuICAgICAgICAgICAgLy8gdGhlbSBhZnRlciB3ZSBmaW5pc2ggcHJvZmlsaW5nXG4gICAgICAgICAgICBsYW5lczogbGFuZVRvTGFuZXNBcnJheShsYW5lKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZ2V0UmVsYXRpdmVUaW1lKCksXG4gICAgICAgICAgICB0eXBlOiAnc2NoZWR1bGUtc3RhdGUtdXBkYXRlJyxcbiAgICAgICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdXJyZW50RmliZXJTdGFja3Muc2V0KGV2ZW50LCBnZXRQYXJlbnRGaWJlcnMoZmliZXIpKTtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgICBjdXJyZW50VGltZWxpbmVEYXRhLnNjaGVkdWxpbmdFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgIG1hcmtBbmRDbGVhcihgLS1zY2hlZHVsZS1zdGF0ZS11cGRhdGUtJHtsYW5lfS0ke2NvbXBvbmVudE5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9nZ2xlUHJvZmlsaW5nU3RhdHVzKFxuICAgIHZhbHVlOiBib29sZWFuLFxuICAgIHJlY29yZFRpbWVsaW5lOiBib29sZWFuID0gZmFsc2UsXG4gICkge1xuICAgIGlmIChpc1Byb2ZpbGluZyAhPT0gdmFsdWUpIHtcbiAgICAgIGlzUHJvZmlsaW5nID0gdmFsdWU7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgICBjb25zdCBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzOiBJbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzID1cbiAgICAgICAgICBuZXcgTWFwKCk7XG5cbiAgICAgICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZ1YzKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMoKTtcbiAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkocmFuZ2UpICYmIHJhbmdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydFN0YWNrRnJhbWUsIHN0b3BTdGFja0ZyYW1lXSA9IHJhbmdlc1tpXTtcblxuICAgICAgICAgICAgICAgIG1hcmtBbmRDbGVhcihcbiAgICAgICAgICAgICAgICAgIGAtLXJlYWN0LWludGVybmFsLW1vZHVsZS1zdGFydC0ke3N0YXJ0U3RhY2tGcmFtZX1gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWFya0FuZENsZWFyKGAtLXJlYWN0LWludGVybmFsLW1vZHVsZS1zdG9wLSR7c3RvcFN0YWNrRnJhbWV9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYW5lVG9SZWFjdE1lYXN1cmVNYXAgPSBuZXcgTWFwPFJlYWN0TGFuZSwgUmVhY3RNZWFzdXJlW10+KCk7XG4gICAgICAgIGxldCBsYW5lID0gMTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IFJFQUNUX1RPVEFMX05VTV9MQU5FUzsgaW5kZXgrKykge1xuICAgICAgICAgIGxhbmVUb1JlYWN0TWVhc3VyZU1hcC5zZXQobGFuZSwgW10pO1xuICAgICAgICAgIGxhbmUgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRCYXRjaFVJRCA9IDA7XG4gICAgICAgIGN1cnJlbnRSZWFjdENvbXBvbmVudE1lYXN1cmUgPSBudWxsO1xuICAgICAgICBjdXJyZW50UmVhY3RNZWFzdXJlc1N0YWNrID0gW107XG4gICAgICAgIGN1cnJlbnRGaWJlclN0YWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHJlY29yZFRpbWVsaW5lKSB7XG4gICAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YSA9IHtcbiAgICAgICAgICAgIC8vIFNlc3Npb24gd2lkZSBtZXRhZGF0YTsgb25seSBjb2xsZWN0ZWQgb25jZS5cbiAgICAgICAgICAgIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMsXG4gICAgICAgICAgICBsYW5lVG9MYWJlbE1hcDogbGFuZVRvTGFiZWxNYXAgfHwgbmV3IE1hcCgpLFxuICAgICAgICAgICAgcmVhY3RWZXJzaW9uLFxuXG4gICAgICAgICAgICAvLyBEYXRhIGxvZ2dlZCBieSBSZWFjdCBkdXJpbmcgcHJvZmlsaW5nIHNlc3Npb24uXG4gICAgICAgICAgICBjb21wb25lbnRNZWFzdXJlczogW10sXG4gICAgICAgICAgICBzY2hlZHVsaW5nRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHN1c3BlbnNlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHRocm93bkVycm9yczogW10sXG5cbiAgICAgICAgICAgIC8vIERhdGEgaW5mZXJyZWQgYmFzZWQgb24gd2hhdCBSZWFjdCBsb2dzLlxuICAgICAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGxhbmVUb1JlYWN0TWVhc3VyZU1hcCxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogMCxcblxuICAgICAgICAgICAgLy8gRGF0YSBvbmx5IGF2YWlsYWJsZSBpbiBDaHJvbWUgcHJvZmlsZXMuXG4gICAgICAgICAgICBmbGFtZWNoYXJ0OiBbXSxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50czogW10sXG4gICAgICAgICAgICBuZXR3b3JrTWVhc3VyZXM6IFtdLFxuICAgICAgICAgICAgb3RoZXJVc2VyVGltaW5nTWFya3M6IFtdLFxuICAgICAgICAgICAgc25hcHNob3RzOiBbXSxcbiAgICAgICAgICAgIHNuYXBzaG90SGVpZ2h0OiAwLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFJlbmRlclNob3VsZFN0YXJ0TmV3QmF0Y2ggPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBfX0VYUEVOU0lWRV9fLlxuICAgICAgICAvLyBXZSBjb3VsZCBlbmQgdXAgd2l0aCBodW5kcmVkcyBvZiBzdGF0ZSB1cGRhdGVkLCBhbmQgZm9yIGVhY2ggb25lIG9mIHRoZW1cbiAgICAgICAgLy8gd291bGQgdHJ5IHRvIGNyZWF0ZSBhIGNvbXBvbmVudCBzdGFjayB3aXRoIHBvc3NpYmx5IGh1bmRyZWRzIG9mIEZpYmVycy5cbiAgICAgICAgLy8gQ3JlYXRpbmcgYSBjYWNoZSBvZiBjb21wb25lbnQgc3RhY2tzIHdvbid0IGhlbHAsIGdlbmVyYXRpbmcgYSBzaW5nbGUgc3RhY2sgaXMgYWxyZWFkeSBleHBlbnNpdmUgZW5vdWdoLlxuICAgICAgICAvLyBXZSBzaG91bGQgZmluZCBhIHdheSB0byBsYXppbHkgZ2VuZXJhdGUgY29tcG9uZW50IHN0YWNrcyBvbiBkZW1hbmQsIHdoZW4gdXNlciBpbnNwZWN0cyBhIHNwZWNpZmljIGV2ZW50LlxuICAgICAgICAvLyBJZiB3ZSBzdWNjZWVkIHdpdGggbW92aW5nIFJlYWN0IERldlRvb2xzIFRpbWVsaW5lIFByb2ZpbGVyIHRvIFBlcmZvcm1hbmNlIHBhbmVsLCB0aGVuIFRpbWVsaW5lIFByb2ZpbGVyIHdvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWQuXG4gICAgICAgIC8vIElmIG5vdCwgdGhlbiBvbmNlIGVuYWJsZU93bmVyU3RhY2tzIGlzIGFkb3B0ZWQsIHJldmlzaXQgdGhpcyBhZ2FpbiBhbmQgY2FjaGUgY29tcG9uZW50IHN0YWNrcyBwZXIgRmliZXIsXG4gICAgICAgIC8vIGJ1dCBvbmx5IHJldHVybiB0aGVtIHdoZW4gbmVlZGVkLCBzZW5kaW5nIGh1bmRyZWRzIG9mIGNvbXBvbmVudCBzdGFja3MgaXMgYmV5b25kIHRoZSBCcmlkZ2UncyBiYW5kd2lkdGguXG5cbiAgICAgICAgLy8gUG9zdHByb2Nlc3MgUHJvZmlsZSBkYXRhXG4gICAgICAgIGlmIChjdXJyZW50VGltZWxpbmVEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFRpbWVsaW5lRGF0YS5zY2hlZHVsaW5nRXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdzY2hlZHVsZS1zdGF0ZS11cGRhdGUnKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8obHVuYSk6IFdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IGNyZWF0aW5nIGEgbWFwIG9mXG4gICAgICAgICAgICAgIC8vIGZpYmVyIHRvIGNvbXBvbmVudCBzdGFjayBpbnN0ZWFkIG9mIGdlbmVyYXRpbmcgdGhlIHN0YWNrXG4gICAgICAgICAgICAgIC8vIGZvciBldmVyeSBmaWJlciBldmVyeSB0aW1lXG4gICAgICAgICAgICAgIGNvbnN0IGZpYmVyU3RhY2sgPSBjdXJyZW50RmliZXJTdGFja3MuZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgICAgaWYgKGZpYmVyU3RhY2sgJiYgY3VycmVudERpc3BhdGNoZXJSZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmNvbXBvbmVudFN0YWNrID0gZmliZXJTdGFjay5yZWR1Y2UoKHRyYWNlLCBmaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UgK1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZUZpYmVyKHdvcmtUYWdNYXAsIGZpYmVyLCBjdXJyZW50RGlzcGF0Y2hlclJlZilcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciB0aGUgY3VycmVudCBmaWJlciBzdGFja3Mgc28gd2UgZG9uJ3QgaG9sZCBvbnRvIHRoZSBmaWJlcnNcbiAgICAgICAgLy8gaW4gbWVtb3J5IGFmdGVyIHByb2ZpbGluZyBmaW5pc2hlc1xuICAgICAgICBjdXJyZW50RmliZXJTdGFja3MuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldFRpbWVsaW5lRGF0YSxcbiAgICBwcm9maWxpbmdIb29rczoge1xuICAgICAgbWFya0NvbW1pdFN0YXJ0ZWQsXG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCxcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkLFxuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQsXG4gICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkLFxuICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQsXG4gICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkLFxuICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCxcbiAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCxcbiAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCxcbiAgICAgIG1hcmtDb21wb25lbnRFcnJvcmVkLFxuICAgICAgbWFya0NvbXBvbmVudFN1c3BlbmRlZCxcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCxcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCxcbiAgICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQsXG4gICAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkLFxuICAgICAgbWFya1JlbmRlclN0YXJ0ZWQsXG4gICAgICBtYXJrUmVuZGVyWWllbGRlZCxcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkLFxuICAgICAgbWFya1JlbmRlclNjaGVkdWxlZCxcbiAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCxcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCxcbiAgICB9LFxuICAgIHRvZ2dsZVByb2ZpbGluZ1N0YXR1cyxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/profilingHooks.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/shared/DevToolsComponentStackFrame.js":
/*!**********************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/shared/DevToolsComponentStackFrame.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"describeBuiltInComponentFrame\": () => (/* binding */ describeBuiltInComponentFrame),\n/* harmony export */   \"describeClassComponentFrame\": () => (/* binding */ describeClassComponentFrame),\n/* harmony export */   \"describeDebugInfoFrame\": () => (/* binding */ describeDebugInfoFrame),\n/* harmony export */   \"describeFunctionComponentFrame\": () => (/* binding */ describeFunctionComponentFrame),\n/* harmony export */   \"describeNativeComponentFrame\": () => (/* binding */ describeNativeComponentFrame)\n/* harmony export */ });\n/* harmony import */ var _DevToolsConsolePatching__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DevToolsConsolePatching */ \"../react-devtools-shared/src/backend/shared/DevToolsConsolePatching.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactComponentStackFrame.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n// The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n\nvar prefix;\nfunction describeBuiltInComponentFrame(name) {\n  if (prefix === undefined) {\n    // Extract the VM specific prefix used by each line.\n    try {\n      throw Error();\n    } catch (x) {\n      var match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = match && match[1] || '';\n    }\n  }\n\n  var suffix = '';\n\n  if (true) {\n    suffix = ' (<anonymous>)';\n  } else {} // We use the prefix to ensure our stacks line up with native stack frames.\n  // We use a suffix to ensure it gets parsed natively.\n\n\n  return '\\n' + prefix + name + suffix;\n}\nfunction describeDebugInfoFrame(name, env) {\n  return describeBuiltInComponentFrame(name + (env ? ' [' + env + ']' : ''));\n}\nvar reentry = false;\nvar componentFrameCache;\n\nif (true) {\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct, currentDispatcherRef) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  if (true) {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.\n  //\n  // Note that unlike the code this was forked from (in ReactComponentStackFrame)\n  // DevTools should override the dispatcher even when DevTools is compiled in production mode,\n  // because the app itself may be in development mode and log errors/warnings.\n\n  var previousDispatcher = currentDispatcherRef.H;\n  currentDispatcherRef.H = null;\n  (0,_DevToolsConsolePatching__WEBPACK_IMPORTED_MODULE_0__.disableLogs)();\n\n  try {\n    // NOTE: keep in sync with the implementation in ReactComponentStackFrame\n\n    /**\n     * Finding a common stack frame between sample and control errors can be\n     * tricky given the different types and levels of stack trace truncation from\n     * different JS VMs. So instead we'll attempt to control what that common\n     * frame should be through this object method:\n     * Having both the sample and control errors be in the function under the\n     * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n     * `displayName` properties of the function ensures that a stack\n     * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n     * it for both control and sample stacks.\n     */\n    var RunInRootFrame = {\n      DetermineComponentFrameRoot: function DetermineComponentFrameRoot() {\n        var control;\n\n        try {\n          // This should throw.\n          if (construct) {\n            // Something should be setting the props in the constructor.\n            var Fake = function Fake() {\n              throw Error();\n            }; // $FlowFixMe[prop-missing]\n\n\n            Object.defineProperty(Fake.prototype, 'props', {\n              set: function set() {\n                // We use a throwing setter instead of frozen or non-writable props\n                // because that won't throw in a non-strict mode function.\n                throw Error();\n              }\n            });\n\n            if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' && Reflect.construct) {\n              // We construct a different control for this case to include any extra\n              // frames added by the construct call.\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                control = x;\n              }\n\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x) {\n                control = x;\n              } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x) {\n              control = x;\n            } // TODO(luna): This will currently only throw if the function component\n            // tries to access React/ReactDOM/props. We should probably make this throw\n            // in simple components too\n\n\n            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n            // component, which we don't yet support. Attach a noop catch handler to\n            // silence the error.\n            // TODO: Implement component stacks for async client components?\n\n            if (maybePromise && typeof maybePromise.catch === 'function') {\n              maybePromise.catch(function () {});\n            }\n          }\n        } catch (sample) {\n          // This is inlined manually because closure doesn't do it for us.\n          if (sample && control && typeof sample.stack === 'string') {\n            return [sample.stack, control.stack];\n          }\n        }\n\n        return [null, null];\n      }\n    }; // $FlowFixMe[prop-missing]\n\n    RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n    if (namePropDescriptor && namePropDescriptor.configurable) {\n      // V8 utilizes a function's `name` property when generating a stack trace.\n      Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n      // is set to `false`.\n      // $FlowFixMe[cannot-write]\n      'name', {\n        value: 'DetermineComponentFrameRoot'\n      });\n    }\n\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        _RunInRootFrame$Deter2 = _slicedToArray(_RunInRootFrame$Deter, 2),\n        sampleStack = _RunInRootFrame$Deter2[0],\n        controlStack = _RunInRootFrame$Deter2[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n    Error.prepareStackTrace = previousPrepareStackTrace;\n    currentDispatcherRef.H = previousDispatcher;\n    (0,_DevToolsConsolePatching__WEBPACK_IMPORTED_MODULE_0__.reenableLogs)();\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  if (true) {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeClassComponentFrame(ctor, currentDispatcherRef) {\n  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);\n}\nfunction describeFunctionComponentFrame(fn, currentDispatcherRef) {\n  return describeNativeComponentFrame(fn, false, currentDispatcherRef);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3NoYXJlZC9EZXZUb29sc0NvbXBvbmVudFN0YWNrRnJhbWUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBSUE7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQTlEQTs7QUFpRUE7QUFFQTs7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBaEdBO0FBQUE7QUFBQTtBQUFBOztBQW9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBSUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9zaGFyZWQvRGV2VG9vbHNDb21wb25lbnRTdGFja0ZyYW1lLmpzP2MyZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLy8gVGhpcyBpcyBhIERldlRvb2xzIGZvcmsgb2YgUmVhY3RDb21wb25lbnRTdGFja0ZyYW1lLlxuLy8gVGhpcyBmb3JrIGVuYWJsZXMgRGV2VG9vbHMgdG8gdXNlIHRoZSBzYW1lIFwibmF0aXZlXCIgY29tcG9uZW50IHN0YWNrIGZvcm1hdCxcbi8vIHdoaWxlIHN0aWxsIG1haW50YWluaW5nIHN1cHBvcnQgZm9yIG11bHRpcGxlIHJlbmRlcmVyIHZlcnNpb25zXG4vLyAod2hpY2ggdXNlIGRpZmZlcmVudCB2YWx1ZXMgZm9yIFJlYWN0VHlwZU9mV29yaykuXG5cbmltcG9ydCB0eXBlIHtDdXJyZW50RGlzcGF0Y2hlclJlZn0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vLyBUaGUgc2hhcmVkIGNvbnNvbGUgcGF0Y2hpbmcgY29kZSBpcyBERVYtb25seS5cbi8vIFdlIGNhbid0IHVzZSBpdCBzaW5jZSBEZXZUb29scyBvbmx5IHNoaXBzIHByb2R1Y3Rpb24gYnVpbGRzLlxuaW1wb3J0IHtkaXNhYmxlTG9ncywgcmVlbmFibGVMb2dzfSBmcm9tICcuL0RldlRvb2xzQ29uc29sZVBhdGNoaW5nJztcblxubGV0IHByZWZpeDtcbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCAnJztcbiAgICB9XG4gIH1cbiAgbGV0IHN1ZmZpeCA9ICcnO1xuICBpZiAoX19JU19DSFJPTUVfXyB8fCBfX0lTX0VER0VfXyB8fCBfX0lTX05BVElWRV9fKSB7XG4gICAgc3VmZml4ID0gJyAoPGFub255bW91cz4pJztcbiAgfSBlbHNlIGlmIChfX0lTX0ZJUkVGT1hfXykge1xuICAgIHN1ZmZpeCA9ICdAdW5rbm93bjowOjAnO1xuICB9XG4gIC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuICAvLyBXZSB1c2UgYSBzdWZmaXggdG8gZW5zdXJlIGl0IGdldHMgcGFyc2VkIG5hdGl2ZWx5LlxuICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzY3JpYmVEZWJ1Z0luZm9GcmFtZShuYW1lOiBzdHJpbmcsIGVudjogP3N0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lICsgKGVudiA/ICcgWycgKyBlbnYgKyAnXScgOiAnJykpO1xufVxuXG5sZXQgcmVlbnRyeSA9IGZhbHNlO1xubGV0IGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5pZiAoX19ERVZfXykge1xuICBjb25zdCBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwPCRGbG93Rml4TWUsIHN0cmluZz4oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gIGZuOiBGdW5jdGlvbixcbiAgY29uc3RydWN0OiBib29sZWFuLFxuICBjdXJyZW50RGlzcGF0Y2hlclJlZjogQ3VycmVudERpc3BhdGNoZXJSZWYsXG4pOiBzdHJpbmcge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcblxuICByZWVudHJ5ID0gdHJ1ZTtcblxuICAvLyBPdmVycmlkZSB0aGUgZGlzcGF0Y2hlciBzbyBlZmZlY3RzIHNjaGVkdWxlZCBieSB0aGlzIHNoYWxsb3cgcmVuZGVyIGFyZSB0aHJvd24gYXdheS5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHVubGlrZSB0aGUgY29kZSB0aGlzIHdhcyBmb3JrZWQgZnJvbSAoaW4gUmVhY3RDb21wb25lbnRTdGFja0ZyYW1lKVxuICAvLyBEZXZUb29scyBzaG91bGQgb3ZlcnJpZGUgdGhlIGRpc3BhdGNoZXIgZXZlbiB3aGVuIERldlRvb2xzIGlzIGNvbXBpbGVkIGluIHByb2R1Y3Rpb24gbW9kZSxcbiAgLy8gYmVjYXVzZSB0aGUgYXBwIGl0c2VsZiBtYXkgYmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSBhbmQgbG9nIGVycm9ycy93YXJuaW5ncy5cbiAgY29uc3QgcHJldmlvdXNEaXNwYXRjaGVyID0gY3VycmVudERpc3BhdGNoZXJSZWYuSDtcbiAgY3VycmVudERpc3BhdGNoZXJSZWYuSCA9IG51bGw7XG4gIGRpc2FibGVMb2dzKCk7XG4gIHRyeSB7XG4gICAgLy8gTk9URToga2VlcCBpbiBzeW5jIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIGluIFJlYWN0Q29tcG9uZW50U3RhY2tGcmFtZVxuXG4gICAgLyoqXG4gICAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICAgKi9cbiAgICBjb25zdCBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpOiBbP3N0cmluZywgP3N0cmluZ10ge1xuICAgICAgICBsZXQgY29udHJvbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0IEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuICAgICAgICAgICAgY29uc3QgbWF5YmVQcm9taXNlID0gZm4oKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICB9LFxuICAgIH07XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICAgIGNvbnN0IG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAnbmFtZScsXG4gICAgKTtcbiAgICAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuICAgIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAgICAgJ25hbWUnLFxuICAgICAgICB7dmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnfSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgW3NhbXBsZVN0YWNrLCBjb250cm9sU3RhY2tdID1cbiAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpO1xuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIGNvbnN0IHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgY29uc3QgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIGxldCBzID0gMDtcbiAgICAgIGxldCBjID0gMDtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgcyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpXG4gICAgICApIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKFxuICAgICAgICBjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKVxuICAgICAgKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH1cbiAgICAgIC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTtcbiAgICAgICAgICAgICAgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICBsZXQgZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIGZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBmcmFtZSA9IGZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBmcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG5cbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZi5IID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgIHJlZW5hYmxlTG9ncygpO1xuICB9XG4gIC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cbiAgY29uc3QgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICBjb25zdCBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuICBpZiAoX19ERVZfXykge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShcbiAgY3RvcjogRnVuY3Rpb24sXG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBDdXJyZW50RGlzcGF0Y2hlclJlZixcbik6IHN0cmluZyB7XG4gIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsIHRydWUsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShcbiAgZm46IEZ1bmN0aW9uLFxuICBjdXJyZW50RGlzcGF0Y2hlclJlZjogQ3VycmVudERpc3BhdGNoZXJSZWYsXG4pOiBzdHJpbmcge1xuICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/shared/DevToolsComponentStackFrame.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/shared/DevToolsConsolePatching.js":
/*!******************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/shared/DevToolsConsolePatching.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"disableLogs\": () => (/* binding */ disableLogs),\n/* harmony export */   \"reenableLogs\": () => (/* binding */ reenableLogs)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of shared/ConsolePatchingDev.\n// The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  if (disabledDepth === 0) {\n    prevLog = console.log;\n    prevInfo = console.info;\n    prevWarn = console.warn;\n    prevError = console.error;\n    prevGroup = console.group;\n    prevGroupCollapsed = console.groupCollapsed;\n    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n    var props = {\n      configurable: true,\n      enumerable: true,\n      value: disabledLog,\n      writable: true\n    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      info: props,\n      log: props,\n      warn: props,\n      error: props,\n      group: props,\n      groupCollapsed: props,\n      groupEnd: props\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  disabledDepth++;\n}\nfunction reenableLogs() {\n  disabledDepth--;\n\n  if (disabledDepth === 0) {\n    var props = {\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      log: _objectSpread(_objectSpread({}, props), {}, {\n        value: prevLog\n      }),\n      info: _objectSpread(_objectSpread({}, props), {}, {\n        value: prevInfo\n      }),\n      warn: _objectSpread(_objectSpread({}, props), {}, {\n        value: prevWarn\n      }),\n      error: _objectSpread(_objectSpread({}, props), {}, {\n        value: prevError\n      }),\n      group: _objectSpread(_objectSpread({}, props), {}, {\n        value: prevGroup\n      }),\n      groupCollapsed: _objectSpread(_objectSpread({}, props), {}, {\n        value: prevGroupCollapsed\n      }),\n      groupEnd: _objectSpread(_objectSpread({}, props), {}, {\n        value: prevGroupEnd\n      })\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  if (disabledDepth < 0) {\n    console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3NoYXJlZC9EZXZUb29sc0NvbnNvbGVQYXRjaGluZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFQQTtBQVNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUlBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvc2hhcmVkL0RldlRvb2xzQ29uc29sZVBhdGNoaW5nLmpzP2MyM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLy8gVGhpcyBpcyBhIERldlRvb2xzIGZvcmsgb2Ygc2hhcmVkL0NvbnNvbGVQYXRjaGluZ0Rldi5cbi8vIFRoZSBzaGFyZWQgY29uc29sZSBwYXRjaGluZyBjb2RlIGlzIERFVi1vbmx5LlxuLy8gV2UgY2FuJ3QgdXNlIGl0IHNpbmNlIERldlRvb2xzIG9ubHkgc2hpcHMgcHJvZHVjdGlvbiBidWlsZHMuXG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cblxubGV0IGRpc2FibGVkRGVwdGggPSAwO1xubGV0IHByZXZMb2c7XG5sZXQgcHJldkluZm87XG5sZXQgcHJldldhcm47XG5sZXQgcHJldkVycm9yO1xubGV0IHByZXZHcm91cDtcbmxldCBwcmV2R3JvdXBDb2xsYXBzZWQ7XG5sZXQgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKTogdm9pZCB7XG4gIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH07XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgIGluZm86IHByb3BzLFxuICAgICAgbG9nOiBwcm9wcyxcbiAgICAgIHdhcm46IHByb3BzLFxuICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgZ3JvdXBFbmQ6IHByb3BzLFxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gIH1cbiAgZGlzYWJsZWREZXB0aCsrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCk6IHZvaWQge1xuICBkaXNhYmxlZERlcHRoLS07XG4gIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfTtcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgbG9nOiB7Li4ucHJvcHMsIHZhbHVlOiBwcmV2TG9nfSxcbiAgICAgIGluZm86IHsuLi5wcm9wcywgdmFsdWU6IHByZXZJbmZvfSxcbiAgICAgIHdhcm46IHsuLi5wcm9wcywgdmFsdWU6IHByZXZXYXJufSxcbiAgICAgIGVycm9yOiB7Li4ucHJvcHMsIHZhbHVlOiBwcmV2RXJyb3J9LFxuICAgICAgZ3JvdXA6IHsuLi5wcm9wcywgdmFsdWU6IHByZXZHcm91cH0sXG4gICAgICBncm91cENvbGxhcHNlZDogey4uLnByb3BzLCB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkfSxcbiAgICAgIGdyb3VwRW5kOiB7Li4ucHJvcHMsIHZhbHVlOiBwcmV2R3JvdXBFbmR9LFxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gIH1cbiAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArXG4gICAgICAgICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/shared/DevToolsConsolePatching.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js":
/*!*************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"formatOwnerStack\": () => (/* binding */ formatOwnerStack)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of shared/ReactOwnerStackFrames.\nfunction formatOwnerStack(error) {\n  var prevPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var stack = error.stack;\n  Error.prepareStackTrace = prevPrepareStackTrace;\n\n  if (stack.startsWith('Error: react-stack-top-frame\\n')) {\n    // V8's default formatting prefixes with the error message which we\n    // don't want/need.\n    stack = stack.slice(29);\n  }\n\n  var idx = stack.indexOf('\\n');\n\n  if (idx !== -1) {\n    // Pop the JSX frame.\n    stack = stack.slice(idx + 1);\n  }\n\n  idx = stack.indexOf('react-stack-bottom-frame');\n\n  if (idx !== -1) {\n    idx = stack.lastIndexOf('\\n', idx);\n  }\n\n  if (idx !== -1) {\n    // Cut off everything after the bottom frame since it'll be internals.\n    stack = stack.slice(0, idx);\n  } else {\n    // We didn't find any internal callsite out to user space.\n    // This means that this was called outside an owner or the owner is fully internal.\n    // To keep things light we exclude the entire trace in this case.\n    return '';\n  }\n\n  return stack;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3NoYXJlZC9EZXZUb29sc093bmVyU3RhY2suanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7OztBQVNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvc2hhcmVkL0RldlRvb2xzT3duZXJTdGFjay5qcz9iMDBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIHNoYXJlZC9SZWFjdE93bmVyU3RhY2tGcmFtZXMuXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPd25lclN0YWNrKGVycm9yOiBFcnJvcik6IHN0cmluZyB7XG4gIGNvbnN0IHByZXZQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICBsZXQgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2UHJlcGFyZVN0YWNrVHJhY2U7XG4gIGlmIChzdGFjay5zdGFydHNXaXRoKCdFcnJvcjogcmVhY3Qtc3RhY2stdG9wLWZyYW1lXFxuJykpIHtcbiAgICAvLyBWOCdzIGRlZmF1bHQgZm9ybWF0dGluZyBwcmVmaXhlcyB3aXRoIHRoZSBlcnJvciBtZXNzYWdlIHdoaWNoIHdlXG4gICAgLy8gZG9uJ3Qgd2FudC9uZWVkLlxuICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMjkpO1xuICB9XG4gIGxldCBpZHggPSBzdGFjay5pbmRleE9mKCdcXG4nKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAvLyBQb3AgdGhlIEpTWCBmcmFtZS5cbiAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGlkeCArIDEpO1xuICB9XG4gIGlkeCA9IHN0YWNrLmluZGV4T2YoJ3JlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZScpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGlkeCA9IHN0YWNrLmxhc3RJbmRleE9mKCdcXG4nLCBpZHgpO1xuICB9XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgLy8gQ3V0IG9mZiBldmVyeXRoaW5nIGFmdGVyIHRoZSBib3R0b20gZnJhbWUgc2luY2UgaXQnbGwgYmUgaW50ZXJuYWxzLlxuICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgaWR4KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBkaWRuJ3QgZmluZCBhbnkgaW50ZXJuYWwgY2FsbHNpdGUgb3V0IHRvIHVzZXIgc3BhY2UuXG4gICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoaXMgd2FzIGNhbGxlZCBvdXRzaWRlIGFuIG93bmVyIG9yIHRoZSBvd25lciBpcyBmdWxseSBpbnRlcm5hbC5cbiAgICAvLyBUbyBrZWVwIHRoaW5ncyBsaWdodCB3ZSBleGNsdWRlIHRoZSBlbnRpcmUgdHJhY2UgaW4gdGhpcyBjYXNlLlxuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gc3RhY2s7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/shared/DevToolsOwnerStack.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/shared/DevToolsServerComponentLogs.js":
/*!**********************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/shared/DevToolsServerComponentLogs.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"componentInfoToComponentLogsMap\": () => (/* binding */ componentInfoToComponentLogsMap)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This keeps track of Server Component logs which may come from.\n// This is in a shared module because Server Component logs don't come from a specific renderer\n// but can become associated with a Virtual Instance of any renderer.\n// This keeps it around as long as the ComponentInfo is alive which\n// lets the Fiber get reparented/remounted and still observe the previous errors/warnings.\n// Unless we explicitly clear the logs from a Fiber.\nvar componentInfoToComponentLogsMap = new WeakMap();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3NoYXJlZC9EZXZUb29sc1NlcnZlckNvbXBvbmVudExvZ3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3NoYXJlZC9EZXZUb29sc1NlcnZlckNvbXBvbmVudExvZ3MuanM/MDNhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vLyBUaGlzIGtlZXBzIHRyYWNrIG9mIFNlcnZlciBDb21wb25lbnQgbG9ncyB3aGljaCBtYXkgY29tZSBmcm9tLlxuLy8gVGhpcyBpcyBpbiBhIHNoYXJlZCBtb2R1bGUgYmVjYXVzZSBTZXJ2ZXIgQ29tcG9uZW50IGxvZ3MgZG9uJ3QgY29tZSBmcm9tIGEgc3BlY2lmaWMgcmVuZGVyZXJcbi8vIGJ1dCBjYW4gYmVjb21lIGFzc29jaWF0ZWQgd2l0aCBhIFZpcnR1YWwgSW5zdGFuY2Ugb2YgYW55IHJlbmRlcmVyLlxuXG5pbXBvcnQgdHlwZSB7UmVhY3RDb21wb25lbnRJbmZvfSBmcm9tICdzaGFyZWQvUmVhY3RUeXBlcyc7XG5cbnR5cGUgQ29tcG9uZW50TG9ncyA9IHtcbiAgZXJyb3JzOiBNYXA8c3RyaW5nLCBudW1iZXI+LFxuICBlcnJvcnNDb3VudDogbnVtYmVyLFxuICB3YXJuaW5nczogTWFwPHN0cmluZywgbnVtYmVyPixcbiAgd2FybmluZ3NDb3VudDogbnVtYmVyLFxufTtcblxuLy8gVGhpcyBrZWVwcyBpdCBhcm91bmQgYXMgbG9uZyBhcyB0aGUgQ29tcG9uZW50SW5mbyBpcyBhbGl2ZSB3aGljaFxuLy8gbGV0cyB0aGUgRmliZXIgZ2V0IHJlcGFyZW50ZWQvcmVtb3VudGVkIGFuZCBzdGlsbCBvYnNlcnZlIHRoZSBwcmV2aW91cyBlcnJvcnMvd2FybmluZ3MuXG4vLyBVbmxlc3Mgd2UgZXhwbGljaXRseSBjbGVhciB0aGUgbG9ncyBmcm9tIGEgRmliZXIuXG5leHBvcnQgY29uc3QgY29tcG9uZW50SW5mb1RvQ29tcG9uZW50TG9nc01hcDogV2Vha01hcDxcbiAgUmVhY3RDb21wb25lbnRJbmZvLFxuICBDb21wb25lbnRMb2dzLFxuPiA9IG5ldyBXZWFrTWFwKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/shared/DevToolsServerComponentLogs.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/shared/ReactSymbols.js":
/*!*******************************************************************!*\
  !*** ../react-devtools-shared/src/backend/shared/ReactSymbols.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONCURRENT_MODE_NUMBER\": () => (/* binding */ CONCURRENT_MODE_NUMBER),\n/* harmony export */   \"CONCURRENT_MODE_SYMBOL_STRING\": () => (/* binding */ CONCURRENT_MODE_SYMBOL_STRING),\n/* harmony export */   \"CONSUMER_SYMBOL_STRING\": () => (/* binding */ CONSUMER_SYMBOL_STRING),\n/* harmony export */   \"CONTEXT_NUMBER\": () => (/* binding */ CONTEXT_NUMBER),\n/* harmony export */   \"CONTEXT_SYMBOL_STRING\": () => (/* binding */ CONTEXT_SYMBOL_STRING),\n/* harmony export */   \"DEBUG_TRACING_MODE_NUMBER\": () => (/* binding */ DEBUG_TRACING_MODE_NUMBER),\n/* harmony export */   \"DEBUG_TRACING_MODE_SYMBOL_STRING\": () => (/* binding */ DEBUG_TRACING_MODE_SYMBOL_STRING),\n/* harmony export */   \"DEPRECATED_ASYNC_MODE_SYMBOL_STRING\": () => (/* binding */ DEPRECATED_ASYNC_MODE_SYMBOL_STRING),\n/* harmony export */   \"ELEMENT_SYMBOL_STRING\": () => (/* binding */ ELEMENT_SYMBOL_STRING),\n/* harmony export */   \"FORWARD_REF_NUMBER\": () => (/* binding */ FORWARD_REF_NUMBER),\n/* harmony export */   \"FORWARD_REF_SYMBOL_STRING\": () => (/* binding */ FORWARD_REF_SYMBOL_STRING),\n/* harmony export */   \"FRAGMENT_NUMBER\": () => (/* binding */ FRAGMENT_NUMBER),\n/* harmony export */   \"FRAGMENT_SYMBOL_STRING\": () => (/* binding */ FRAGMENT_SYMBOL_STRING),\n/* harmony export */   \"LAZY_NUMBER\": () => (/* binding */ LAZY_NUMBER),\n/* harmony export */   \"LAZY_SYMBOL_STRING\": () => (/* binding */ LAZY_SYMBOL_STRING),\n/* harmony export */   \"LEGACY_ELEMENT_NUMBER\": () => (/* binding */ LEGACY_ELEMENT_NUMBER),\n/* harmony export */   \"LEGACY_ELEMENT_SYMBOL_STRING\": () => (/* binding */ LEGACY_ELEMENT_SYMBOL_STRING),\n/* harmony export */   \"MEMO_NUMBER\": () => (/* binding */ MEMO_NUMBER),\n/* harmony export */   \"MEMO_SYMBOL_STRING\": () => (/* binding */ MEMO_SYMBOL_STRING),\n/* harmony export */   \"PORTAL_NUMBER\": () => (/* binding */ PORTAL_NUMBER),\n/* harmony export */   \"PORTAL_SYMBOL_STRING\": () => (/* binding */ PORTAL_SYMBOL_STRING),\n/* harmony export */   \"PROFILER_NUMBER\": () => (/* binding */ PROFILER_NUMBER),\n/* harmony export */   \"PROFILER_SYMBOL_STRING\": () => (/* binding */ PROFILER_SYMBOL_STRING),\n/* harmony export */   \"PROVIDER_NUMBER\": () => (/* binding */ PROVIDER_NUMBER),\n/* harmony export */   \"PROVIDER_SYMBOL_STRING\": () => (/* binding */ PROVIDER_SYMBOL_STRING),\n/* harmony export */   \"REACT_MEMO_CACHE_SENTINEL\": () => (/* binding */ REACT_MEMO_CACHE_SENTINEL),\n/* harmony export */   \"SCOPE_NUMBER\": () => (/* binding */ SCOPE_NUMBER),\n/* harmony export */   \"SCOPE_SYMBOL_STRING\": () => (/* binding */ SCOPE_SYMBOL_STRING),\n/* harmony export */   \"SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING\": () => (/* binding */ SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING),\n/* harmony export */   \"SERVER_CONTEXT_SYMBOL_STRING\": () => (/* binding */ SERVER_CONTEXT_SYMBOL_STRING),\n/* harmony export */   \"STRICT_MODE_NUMBER\": () => (/* binding */ STRICT_MODE_NUMBER),\n/* harmony export */   \"STRICT_MODE_SYMBOL_STRING\": () => (/* binding */ STRICT_MODE_SYMBOL_STRING),\n/* harmony export */   \"SUSPENSE_LIST_NUMBER\": () => (/* binding */ SUSPENSE_LIST_NUMBER),\n/* harmony export */   \"SUSPENSE_LIST_SYMBOL_STRING\": () => (/* binding */ SUSPENSE_LIST_SYMBOL_STRING),\n/* harmony export */   \"SUSPENSE_NUMBER\": () => (/* binding */ SUSPENSE_NUMBER),\n/* harmony export */   \"SUSPENSE_SYMBOL_STRING\": () => (/* binding */ SUSPENSE_SYMBOL_STRING)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.\n// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:\n// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)\n// 2. DevTools must support both Symbol and numeric forms of each symbol;\n//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.\nvar CONCURRENT_MODE_NUMBER = 0xeacf;\nvar CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';\nvar CONTEXT_NUMBER = 0xeace;\nvar CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';\nvar SERVER_CONTEXT_SYMBOL_STRING = 'Symbol(react.server_context)';\nvar DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';\nvar ELEMENT_SYMBOL_STRING = 'Symbol(react.transitional.element)';\nvar LEGACY_ELEMENT_NUMBER = 0xeac7;\nvar LEGACY_ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';\nvar DEBUG_TRACING_MODE_NUMBER = 0xeae1;\nvar DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';\nvar FORWARD_REF_NUMBER = 0xead0;\nvar FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';\nvar FRAGMENT_NUMBER = 0xeacb;\nvar FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';\nvar LAZY_NUMBER = 0xead4;\nvar LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';\nvar MEMO_NUMBER = 0xead3;\nvar MEMO_SYMBOL_STRING = 'Symbol(react.memo)';\nvar PORTAL_NUMBER = 0xeaca;\nvar PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';\nvar PROFILER_NUMBER = 0xead2;\nvar PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';\nvar PROVIDER_NUMBER = 0xeacd;\nvar PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';\nvar CONSUMER_SYMBOL_STRING = 'Symbol(react.consumer)';\nvar SCOPE_NUMBER = 0xead7;\nvar SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';\nvar STRICT_MODE_NUMBER = 0xeacc;\nvar STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';\nvar SUSPENSE_NUMBER = 0xead1;\nvar SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';\nvar SUSPENSE_LIST_NUMBER = 0xead8;\nvar SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';\nvar SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = 'Symbol(react.server_context.defaultValue)';\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3NoYXJlZC9SZWFjdFN5bWJvbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9zaGFyZWQvUmVhY3RTeW1ib2xzLmpzPzBlN2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLy8gVGhpcyBsaXN0IHNob3VsZCBiZSBrZXB0IHVwZGF0ZWQgdG8gcmVmbGVjdCBhZGRpdGlvbnMgdG8gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnLlxuLy8gRGV2VG9vbHMgY2FuJ3QgaW1wb3J0IHN5bWJvbHMgZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scycgZGlyZWN0bHkgZm9yIHR3byByZWFzb25zOlxuLy8gMS4gRGV2VG9vbHMgcmVxdWlyZXMgc3ltYm9scyB3aGljaCBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gbW9yZSByZWNlbnQgdmVyc2lvbnMgKGUuZy4gY29uY3VycmVudCBtb2RlKVxuLy8gMi4gRGV2VG9vbHMgbXVzdCBzdXBwb3J0IGJvdGggU3ltYm9sIGFuZCBudW1lcmljIGZvcm1zIG9mIGVhY2ggc3ltYm9sO1xuLy8gICAgU2luY2UgZS5nLiBzdGFuZGFsb25lIERldlRvb2xzIHJ1bnMgaW4gYSBzZXBhcmF0ZSBwcm9jZXNzLCBpdCBjYW4ndCByZWx5IG9uIGl0cyBvd24gRVMgY2FwYWJpbGl0aWVzLlxuXG5leHBvcnQgY29uc3QgQ09OQ1VSUkVOVF9NT0RFX05VTUJFUiA9IDB4ZWFjZjtcbmV4cG9ydCBjb25zdCBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuY29uY3VycmVudF9tb2RlKSc7XG5cbmV4cG9ydCBjb25zdCBDT05URVhUX05VTUJFUiA9IDB4ZWFjZTtcbmV4cG9ydCBjb25zdCBDT05URVhUX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmNvbnRleHQpJztcblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9DT05URVhUX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnNlcnZlcl9jb250ZXh0KSc7XG5cbmV4cG9ydCBjb25zdCBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuYXN5bmNfbW9kZSknO1xuXG5leHBvcnQgY29uc3QgRUxFTUVOVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudCknO1xuZXhwb3J0IGNvbnN0IExFR0FDWV9FTEVNRU5UX05VTUJFUiA9IDB4ZWFjNztcbmV4cG9ydCBjb25zdCBMRUdBQ1lfRUxFTUVOVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5lbGVtZW50KSc7XG5cbmV4cG9ydCBjb25zdCBERUJVR19UUkFDSU5HX01PREVfTlVNQkVSID0gMHhlYWUxO1xuZXhwb3J0IGNvbnN0IERFQlVHX1RSQUNJTkdfTU9ERV9TWU1CT0xfU1RSSU5HID1cbiAgJ1N5bWJvbChyZWFjdC5kZWJ1Z190cmFjZV9tb2RlKSc7XG5cbmV4cG9ydCBjb25zdCBGT1JXQVJEX1JFRl9OVU1CRVIgPSAweGVhZDA7XG5leHBvcnQgY29uc3QgRk9SV0FSRF9SRUZfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZm9yd2FyZF9yZWYpJztcblxuZXhwb3J0IGNvbnN0IEZSQUdNRU5UX05VTUJFUiA9IDB4ZWFjYjtcbmV4cG9ydCBjb25zdCBGUkFHTUVOVF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5mcmFnbWVudCknO1xuXG5leHBvcnQgY29uc3QgTEFaWV9OVU1CRVIgPSAweGVhZDQ7XG5leHBvcnQgY29uc3QgTEFaWV9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5sYXp5KSc7XG5cbmV4cG9ydCBjb25zdCBNRU1PX05VTUJFUiA9IDB4ZWFkMztcbmV4cG9ydCBjb25zdCBNRU1PX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0Lm1lbW8pJztcblxuZXhwb3J0IGNvbnN0IFBPUlRBTF9OVU1CRVIgPSAweGVhY2E7XG5leHBvcnQgY29uc3QgUE9SVEFMX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnBvcnRhbCknO1xuXG5leHBvcnQgY29uc3QgUFJPRklMRVJfTlVNQkVSID0gMHhlYWQyO1xuZXhwb3J0IGNvbnN0IFBST0ZJTEVSX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnByb2ZpbGVyKSc7XG5cbmV4cG9ydCBjb25zdCBQUk9WSURFUl9OVU1CRVIgPSAweGVhY2Q7XG5leHBvcnQgY29uc3QgUFJPVklERVJfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QucHJvdmlkZXIpJztcblxuZXhwb3J0IGNvbnN0IENPTlNVTUVSX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmNvbnN1bWVyKSc7XG5cbmV4cG9ydCBjb25zdCBTQ09QRV9OVU1CRVIgPSAweGVhZDc7XG5leHBvcnQgY29uc3QgU0NPUEVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc2NvcGUpJztcblxuZXhwb3J0IGNvbnN0IFNUUklDVF9NT0RFX05VTUJFUiA9IDB4ZWFjYztcbmV4cG9ydCBjb25zdCBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5zdHJpY3RfbW9kZSknO1xuXG5leHBvcnQgY29uc3QgU1VTUEVOU0VfTlVNQkVSID0gMHhlYWQxO1xuZXhwb3J0IGNvbnN0IFNVU1BFTlNFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnN1c3BlbnNlKSc7XG5cbmV4cG9ydCBjb25zdCBTVVNQRU5TRV9MSVNUX05VTUJFUiA9IDB4ZWFkODtcbmV4cG9ydCBjb25zdCBTVVNQRU5TRV9MSVNUX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnN1c3BlbnNlX2xpc3QpJztcblxuZXhwb3J0IGNvbnN0IFNFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRF9TWU1CT0xfU1RSSU5HID1cbiAgJ1N5bWJvbChyZWFjdC5zZXJ2ZXJfY29udGV4dC5kZWZhdWx0VmFsdWUpJztcblxuZXhwb3J0IGNvbnN0IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw6IHN5bWJvbCA9IFN5bWJvbC5mb3IoXG4gICdyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsJyxcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/shared/ReactSymbols.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/utils/formatConsoleArguments.js":
/*!****************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/utils/formatConsoleArguments.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ formatConsoleArguments)\n/* harmony export */ });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Do not add / import anything to this file.\n// This function could be used from multiple places, including hook.\n// Skips CSS and object arguments, inlines other in the first argument as a template string\nfunction formatConsoleArguments(maybeMessage) {\n  for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    inputArgs[_key - 1] = arguments[_key];\n  }\n\n  if (inputArgs.length === 0 || typeof maybeMessage !== 'string') {\n    return [maybeMessage].concat(inputArgs);\n  }\n\n  var args = inputArgs.slice();\n  var template = '';\n  var argumentsPointer = 0;\n\n  for (var i = 0; i < maybeMessage.length; ++i) {\n    var currentChar = maybeMessage[i];\n\n    if (currentChar !== '%') {\n      template += currentChar;\n      continue;\n    }\n\n    var nextChar = maybeMessage[i + 1];\n    ++i; // Only keep CSS and objects, inline other arguments\n\n    switch (nextChar) {\n      case 'c':\n      case 'O':\n      case 'o':\n        {\n          ++argumentsPointer;\n          template += \"%\".concat(nextChar);\n          break;\n        }\n\n      case 'd':\n      case 'i':\n        {\n          var _args$splice = args.splice(argumentsPointer, 1),\n              _args$splice2 = _slicedToArray(_args$splice, 1),\n              arg = _args$splice2[0];\n\n          template += parseInt(arg, 10).toString();\n          break;\n        }\n\n      case 'f':\n        {\n          var _args$splice3 = args.splice(argumentsPointer, 1),\n              _args$splice4 = _slicedToArray(_args$splice3, 1),\n              _arg = _args$splice4[0];\n\n          template += parseFloat(_arg).toString();\n          break;\n        }\n\n      case 's':\n        {\n          var _args$splice5 = args.splice(argumentsPointer, 1),\n              _args$splice6 = _slicedToArray(_args$splice5, 1),\n              _arg2 = _args$splice6[0];\n\n          template += _arg2.toString();\n          break;\n        }\n\n      default:\n        template += \"%\".concat(nextChar);\n    }\n  }\n\n  return [template].concat(_toConsumableArray(args));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2Zvcm1hdENvbnNvbGVBcmd1bWVudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQURBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQTlCQTtBQWdDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2Zvcm1hdENvbnNvbGVBcmd1bWVudHMuanM/NTkwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vLyBEbyBub3QgYWRkIC8gaW1wb3J0IGFueXRoaW5nIHRvIHRoaXMgZmlsZS5cbi8vIFRoaXMgZnVuY3Rpb24gY291bGQgYmUgdXNlZCBmcm9tIG11bHRpcGxlIHBsYWNlcywgaW5jbHVkaW5nIGhvb2suXG5cbi8vIFNraXBzIENTUyBhbmQgb2JqZWN0IGFyZ3VtZW50cywgaW5saW5lcyBvdGhlciBpbiB0aGUgZmlyc3QgYXJndW1lbnQgYXMgYSB0ZW1wbGF0ZSBzdHJpbmdcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdENvbnNvbGVBcmd1bWVudHMoXG4gIG1heWJlTWVzc2FnZTogYW55LFxuICAuLi5pbnB1dEFyZ3M6ICRSZWFkT25seUFycmF5PGFueT5cbik6ICRSZWFkT25seUFycmF5PGFueT4ge1xuICBpZiAoaW5wdXRBcmdzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgbWF5YmVNZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBbbWF5YmVNZXNzYWdlLCAuLi5pbnB1dEFyZ3NdO1xuICB9XG5cbiAgY29uc3QgYXJncyA9IGlucHV0QXJncy5zbGljZSgpO1xuXG4gIGxldCB0ZW1wbGF0ZSA9ICcnO1xuICBsZXQgYXJndW1lbnRzUG9pbnRlciA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF5YmVNZXNzYWdlLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY3VycmVudENoYXIgPSBtYXliZU1lc3NhZ2VbaV07XG4gICAgaWYgKGN1cnJlbnRDaGFyICE9PSAnJScpIHtcbiAgICAgIHRlbXBsYXRlICs9IGN1cnJlbnRDaGFyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dENoYXIgPSBtYXliZU1lc3NhZ2VbaSArIDFdO1xuICAgICsraTtcblxuICAgIC8vIE9ubHkga2VlcCBDU1MgYW5kIG9iamVjdHMsIGlubGluZSBvdGhlciBhcmd1bWVudHNcbiAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICBjYXNlICdjJzpcbiAgICAgIGNhc2UgJ08nOlxuICAgICAgY2FzZSAnbyc6IHtcbiAgICAgICAgKythcmd1bWVudHNQb2ludGVyO1xuICAgICAgICB0ZW1wbGF0ZSArPSBgJSR7bmV4dENoYXJ9YDtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2QnOlxuICAgICAgY2FzZSAnaSc6IHtcbiAgICAgICAgY29uc3QgW2FyZ10gPSBhcmdzLnNwbGljZShhcmd1bWVudHNQb2ludGVyLCAxKTtcbiAgICAgICAgdGVtcGxhdGUgKz0gcGFyc2VJbnQoYXJnLCAxMCkudG9TdHJpbmcoKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2YnOiB7XG4gICAgICAgIGNvbnN0IFthcmddID0gYXJncy5zcGxpY2UoYXJndW1lbnRzUG9pbnRlciwgMSk7XG4gICAgICAgIHRlbXBsYXRlICs9IHBhcnNlRmxvYXQoYXJnKS50b1N0cmluZygpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAncyc6IHtcbiAgICAgICAgY29uc3QgW2FyZ10gPSBhcmdzLnNwbGljZShhcmd1bWVudHNQb2ludGVyLCAxKTtcbiAgICAgICAgdGVtcGxhdGUgKz0gYXJnLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRlbXBsYXRlICs9IGAlJHtuZXh0Q2hhcn1gO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbdGVtcGxhdGUsIC4uLmFyZ3NdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/utils/formatConsoleArguments.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/utils/formatWithStyles.js":
/*!**********************************************************************!*\
  !*** ../react-devtools-shared/src/backend/utils/formatWithStyles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ formatWithStyles)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Do not add / import anything to this file.\n// This function could be used from multiple places, including hook.\n// Formats an array of args with a style for console methods, using\n// the following algorithm:\n//     1. The first param is a string that contains %c\n//          - Bail out and return the args without modifying the styles.\n//            We don't want to affect styles that the developer deliberately set.\n//     2. The first param is a string that doesn't contain %c but contains\n//        string formatting\n//          - [`%c${args[0]}`, style, ...args.slice(1)]\n//          - Note: we assume that the string formatting that the developer uses\n//            is correct.\n//     3. The first param is a string that doesn't contain string formatting\n//        OR is not a string\n//          - Create a formatting string where:\n//                 boolean, string, symbol -> %s\n//                 number -> %f OR %i depending on if it's an int or float\n//                 default -> %o\nfunction formatWithStyles(inputArgs, style) {\n  if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c\n  typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {\n    return inputArgs;\n  } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)\n\n\n  var REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;\n\n  if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {\n    return [\"%c\".concat(inputArgs[0]), style].concat(_toConsumableArray(inputArgs.slice(1)));\n  } else {\n    var firstArg = inputArgs.reduce(function (formatStr, elem, i) {\n      if (i > 0) {\n        formatStr += ' ';\n      }\n\n      switch (_typeof(elem)) {\n        case 'string':\n        case 'boolean':\n        case 'symbol':\n          return formatStr += '%s';\n\n        case 'number':\n          var formatting = Number.isInteger(elem) ? '%i' : '%f';\n          return formatStr += formatting;\n\n        default:\n          return formatStr += '%o';\n      }\n    }, '%c');\n    return [firstArg, style].concat(_toConsumableArray(inputArgs));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2Zvcm1hdFdpdGhTdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBR0E7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdXRpbHMvZm9ybWF0V2l0aFN0eWxlcy5qcz85YzBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIERvIG5vdCBhZGQgLyBpbXBvcnQgYW55dGhpbmcgdG8gdGhpcyBmaWxlLlxuLy8gVGhpcyBmdW5jdGlvbiBjb3VsZCBiZSB1c2VkIGZyb20gbXVsdGlwbGUgcGxhY2VzLCBpbmNsdWRpbmcgaG9vay5cblxuLy8gRm9ybWF0cyBhbiBhcnJheSBvZiBhcmdzIHdpdGggYSBzdHlsZSBmb3IgY29uc29sZSBtZXRob2RzLCB1c2luZ1xuLy8gdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4vLyAgICAgMS4gVGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nIHRoYXQgY29udGFpbnMgJWNcbi8vICAgICAgICAgIC0gQmFpbCBvdXQgYW5kIHJldHVybiB0aGUgYXJncyB3aXRob3V0IG1vZGlmeWluZyB0aGUgc3R5bGVzLlxuLy8gICAgICAgICAgICBXZSBkb24ndCB3YW50IHRvIGFmZmVjdCBzdHlsZXMgdGhhdCB0aGUgZGV2ZWxvcGVyIGRlbGliZXJhdGVseSBzZXQuXG4vLyAgICAgMi4gVGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCBjb250YWluICVjIGJ1dCBjb250YWluc1xuLy8gICAgICAgIHN0cmluZyBmb3JtYXR0aW5nXG4vLyAgICAgICAgICAtIFtgJWMke2FyZ3NbMF19YCwgc3R5bGUsIC4uLmFyZ3Muc2xpY2UoMSldXG4vLyAgICAgICAgICAtIE5vdGU6IHdlIGFzc3VtZSB0aGF0IHRoZSBzdHJpbmcgZm9ybWF0dGluZyB0aGF0IHRoZSBkZXZlbG9wZXIgdXNlc1xuLy8gICAgICAgICAgICBpcyBjb3JyZWN0LlxuLy8gICAgIDMuIFRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZyB0aGF0IGRvZXNuJ3QgY29udGFpbiBzdHJpbmcgZm9ybWF0dGluZ1xuLy8gICAgICAgIE9SIGlzIG5vdCBhIHN0cmluZ1xuLy8gICAgICAgICAgLSBDcmVhdGUgYSBmb3JtYXR0aW5nIHN0cmluZyB3aGVyZTpcbi8vICAgICAgICAgICAgICAgICBib29sZWFuLCBzdHJpbmcsIHN5bWJvbCAtPiAlc1xuLy8gICAgICAgICAgICAgICAgIG51bWJlciAtPiAlZiBPUiAlaSBkZXBlbmRpbmcgb24gaWYgaXQncyBhbiBpbnQgb3IgZmxvYXRcbi8vICAgICAgICAgICAgICAgICBkZWZhdWx0IC0+ICVvXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRXaXRoU3R5bGVzKFxuICBpbnB1dEFyZ3M6ICRSZWFkT25seUFycmF5PGFueT4sXG4gIHN0eWxlPzogc3RyaW5nLFxuKTogJFJlYWRPbmx5QXJyYXk8YW55PiB7XG4gIGlmIChcbiAgICBpbnB1dEFyZ3MgPT09IHVuZGVmaW5lZCB8fFxuICAgIGlucHV0QXJncyA9PT0gbnVsbCB8fFxuICAgIGlucHV0QXJncy5sZW5ndGggPT09IDAgfHxcbiAgICAvLyBNYXRjaGVzIGFueSBvZiAlYyBidXQgbm90ICUlY1xuICAgICh0eXBlb2YgaW5wdXRBcmdzWzBdID09PSAnc3RyaW5nJyAmJiBpbnB1dEFyZ3NbMF0ubWF0Y2goLyhbXiVdfF4pKCVjKS9nKSkgfHxcbiAgICBzdHlsZSA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiBpbnB1dEFyZ3M7XG4gIH1cblxuICAvLyBNYXRjaGVzIGFueSBvZiAlKG98T3xkfGl8c3xmKSwgYnV0IG5vdCAlJShvfE98ZHxpfHN8ZilcbiAgY29uc3QgUkVHRVhQID0gLyhbXiVdfF4pKCglJSkqKSglKFtvT2Rpc2ZdKSkvZztcbiAgaWYgKHR5cGVvZiBpbnB1dEFyZ3NbMF0gPT09ICdzdHJpbmcnICYmIGlucHV0QXJnc1swXS5tYXRjaChSRUdFWFApKSB7XG4gICAgcmV0dXJuIFtgJWMke2lucHV0QXJnc1swXX1gLCBzdHlsZSwgLi4uaW5wdXRBcmdzLnNsaWNlKDEpXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaXJzdEFyZyA9IGlucHV0QXJncy5yZWR1Y2UoKGZvcm1hdFN0ciwgZWxlbSwgaSkgPT4ge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGZvcm1hdFN0ciArPSAnICc7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBlbGVtKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgIHJldHVybiAoZm9ybWF0U3RyICs9ICclcycpO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIGNvbnN0IGZvcm1hdHRpbmcgPSBOdW1iZXIuaXNJbnRlZ2VyKGVsZW0pID8gJyVpJyA6ICclZic7XG4gICAgICAgICAgcmV0dXJuIChmb3JtYXRTdHIgKz0gZm9ybWF0dGluZyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChmb3JtYXRTdHIgKz0gJyVvJyk7XG4gICAgICB9XG4gICAgfSwgJyVjJyk7XG4gICAgcmV0dXJuIFtmaXJzdEFyZywgc3R5bGUsIC4uLmlucHV0QXJnc107XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/utils/formatWithStyles.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/utils/index.js":
/*!***********************************************************!*\
  !*** ../react-devtools-shared/src/backend/utils/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cleanForBridge\": () => (/* binding */ cleanForBridge),\n/* harmony export */   \"copyWithDelete\": () => (/* binding */ copyWithDelete),\n/* harmony export */   \"copyWithRename\": () => (/* binding */ copyWithRename),\n/* harmony export */   \"copyWithSet\": () => (/* binding */ copyWithSet),\n/* harmony export */   \"formatConsoleArguments\": () => (/* reexport safe */ _formatConsoleArguments__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"formatConsoleArgumentsToSingleString\": () => (/* binding */ formatConsoleArgumentsToSingleString),\n/* harmony export */   \"formatDurationToMicrosecondsGranularity\": () => (/* binding */ formatDurationToMicrosecondsGranularity),\n/* harmony export */   \"formatWithStyles\": () => (/* reexport safe */ _formatWithStyles__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"getEffectDurations\": () => (/* binding */ getEffectDurations),\n/* harmony export */   \"gt\": () => (/* binding */ gt),\n/* harmony export */   \"gte\": () => (/* binding */ gte),\n/* harmony export */   \"hasAssignedBackend\": () => (/* binding */ hasAssignedBackend),\n/* harmony export */   \"isReactNativeEnvironment\": () => (/* binding */ isReactNativeEnvironment),\n/* harmony export */   \"isSynchronousXHRSupported\": () => (/* binding */ isSynchronousXHRSupported),\n/* harmony export */   \"parseSourceFromComponentStack\": () => (/* binding */ parseSourceFromComponentStack),\n/* harmony export */   \"serializeToString\": () => (/* binding */ serializeToString)\n/* harmony export */ });\n/* harmony import */ var compare_versions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! compare-versions */ \"../../node_modules/compare-versions/lib/esm/index.js\");\n/* harmony import */ var react_devtools_shared_src_hydration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/hydration */ \"../react-devtools-shared/src/hydration.js\");\n/* harmony import */ var shared_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/isArray */ \"../shared/isArray.js\");\n/* harmony import */ var _formatWithStyles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatWithStyles */ \"../react-devtools-shared/src/backend/utils/formatWithStyles.js\");\n/* harmony import */ var _formatConsoleArguments__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatConsoleArguments */ \"../react-devtools-shared/src/backend/utils/formatConsoleArguments.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n // TODO: update this to the first React version that has a corresponding DevTools backend\n\nvar FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = '999.9.9';\nfunction hasAssignedBackend(version) {\n  if (version == null || version === '') {\n    return false;\n  }\n\n  return gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);\n}\nfunction cleanForBridge(data, isPathAllowed) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (data !== null) {\n    var cleanedPaths = [];\n    var unserializablePaths = [];\n    var cleanedData = (0,react_devtools_shared_src_hydration__WEBPACK_IMPORTED_MODULE_0__.dehydrate)(data, cleanedPaths, unserializablePaths, path, isPathAllowed);\n    return {\n      data: cleanedData,\n      cleaned: cleanedPaths,\n      unserializable: unserializablePaths\n    };\n  } else {\n    return null;\n  }\n}\nfunction copyWithDelete(obj, path) {\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var key = path[index];\n  var updated = (0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(obj) ? obj.slice() : _objectSpread({}, obj);\n\n  if (index + 1 === path.length) {\n    if ((0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(updated)) {\n      updated.splice(key, 1);\n    } else {\n      delete updated[key];\n    }\n  } else {\n    // $FlowFixMe[incompatible-use] number or string is fine here\n    updated[key] = copyWithDelete(obj[key], path, index + 1);\n  }\n\n  return updated;\n} // This function expects paths to be the same except for the final value.\n// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']\n\nfunction copyWithRename(obj, oldPath, newPath) {\n  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var oldKey = oldPath[index];\n  var updated = (0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(obj) ? obj.slice() : _objectSpread({}, obj);\n\n  if (index + 1 === oldPath.length) {\n    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here\n\n    updated[newKey] = updated[oldKey];\n\n    if ((0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(updated)) {\n      updated.splice(oldKey, 1);\n    } else {\n      delete updated[oldKey];\n    }\n  } else {\n    // $FlowFixMe[incompatible-use] number or string is fine here\n    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);\n  }\n\n  return updated;\n}\nfunction copyWithSet(obj, path, value) {\n  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (index >= path.length) {\n    return value;\n  }\n\n  var key = path[index];\n  var updated = (0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(obj) ? obj.slice() : _objectSpread({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here\n\n  updated[key] = copyWithSet(obj[key], path, value, index + 1);\n  return updated;\n}\nfunction getEffectDurations(root) {\n  // Profiling durations are only available for certain builds.\n  // If available, they'll be stored on the HostRoot.\n  var effectDuration = null;\n  var passiveEffectDuration = null;\n  var hostRoot = root.current;\n\n  if (hostRoot != null) {\n    var stateNode = hostRoot.stateNode;\n\n    if (stateNode != null) {\n      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;\n      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;\n    }\n  }\n\n  return {\n    effectDuration: effectDuration,\n    passiveEffectDuration: passiveEffectDuration\n  };\n}\nfunction serializeToString(data) {\n  if (data === undefined) {\n    return 'undefined';\n  }\n\n  if (typeof data === 'function') {\n    return data.toString();\n  }\n\n  var cache = new Set(); // Use a custom replacer function to protect against circular references.\n\n  return JSON.stringify(data, function (key, value) {\n    if (_typeof(value) === 'object' && value !== null) {\n      if (cache.has(value)) {\n        return;\n      }\n\n      cache.add(value);\n    }\n\n    if (typeof value === 'bigint') {\n      return value.toString() + 'n';\n    }\n\n    return value;\n  }, 2);\n}\n\nfunction safeToString(val) {\n  try {\n    return String(val);\n  } catch (err) {\n    if (_typeof(val) === 'object') {\n      // An object with no prototype and no `[Symbol.toPrimitive]()`, `toString()`, and `valueOf()` methods would throw.\n      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion\n      return '[object Object]';\n    }\n\n    throw err;\n  }\n} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1\n// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\n// Implements s, d, i and f placeholders\n\n\nfunction formatConsoleArgumentsToSingleString(maybeMessage) {\n  for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    inputArgs[_key - 1] = arguments[_key];\n  }\n\n  var args = inputArgs.slice();\n  var formatted = safeToString(maybeMessage); // If the first argument is a string, check for substitutions.\n\n  if (typeof maybeMessage === 'string') {\n    if (args.length) {\n      var REGEXP = /(%?)(%([jds]))/g; // $FlowFixMe[incompatible-call]\n\n      formatted = formatted.replace(REGEXP, function (match, escaped, ptn, flag) {\n        var arg = args.shift();\n\n        switch (flag) {\n          case 's':\n            // $FlowFixMe[unsafe-addition]\n            arg += '';\n            break;\n\n          case 'd':\n          case 'i':\n            arg = parseInt(arg, 10).toString();\n            break;\n\n          case 'f':\n            arg = parseFloat(arg).toString();\n            break;\n        }\n\n        if (!escaped) {\n          return arg;\n        }\n\n        args.unshift(arg);\n        return match;\n      });\n    }\n  } // Arguments that remain after formatting.\n\n\n  if (args.length) {\n    for (var i = 0; i < args.length; i++) {\n      formatted += ' ' + safeToString(args[i]);\n    }\n  } // Update escaped %% values.\n\n\n  formatted = formatted.replace(/%{2,2}/g, '%');\n  return String(formatted);\n}\nfunction isSynchronousXHRSupported() {\n  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));\n}\nfunction gt() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0,compare_versions__WEBPACK_IMPORTED_MODULE_4__.compareVersions)(a, b) === 1;\n}\nfunction gte() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0,compare_versions__WEBPACK_IMPORTED_MODULE_4__.compareVersions)(a, b) > -1;\n}\nvar isReactNativeEnvironment = function isReactNativeEnvironment() {\n  // We've been relying on this for such a long time\n  // We should probably define the client for DevTools on the backend side and share it with the frontend\n  return window.document == null;\n};\n\nfunction extractLocation(url) {\n  if (url.indexOf(':') === -1) {\n    return null;\n  } // remove any parentheses from start and end\n\n\n  var withoutParentheses = url.replace(/^\\(+/, '').replace(/\\)+$/, '');\n  var locationParts = /(at )?(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(withoutParentheses);\n\n  if (locationParts == null) {\n    return null;\n  }\n\n  var _locationParts = _slicedToArray(locationParts, 5),\n      sourceURL = _locationParts[2],\n      line = _locationParts[3],\n      column = _locationParts[4];\n\n  return {\n    sourceURL: sourceURL,\n    line: line,\n    column: column\n  };\n}\n\nvar CHROME_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n\nfunction parseSourceFromChromeStack(stack) {\n  var frames = stack.split('\\n'); // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n  var _iterator = _createForOfIteratorHelper(frames),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var frame = _step.value;\n      var sanitizedFrame = frame.trim();\n      var locationInParenthesesMatch = sanitizedFrame.match(/ (\\(.+\\)$)/);\n      var possibleLocation = locationInParenthesesMatch ? locationInParenthesesMatch[1] : sanitizedFrame;\n      var location = extractLocation(possibleLocation); // Continue the search until at least sourceURL is found\n\n      if (location == null) {\n        continue;\n      }\n\n      var sourceURL = location.sourceURL,\n          _location$line = location.line,\n          line = _location$line === void 0 ? '1' : _location$line,\n          _location$column = location.column,\n          column = _location$column === void 0 ? '1' : _location$column;\n      return {\n        sourceURL: sourceURL,\n        line: parseInt(line, 10),\n        column: parseInt(column, 10)\n      };\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n}\n\nfunction parseSourceFromFirefoxStack(stack) {\n  var frames = stack.split('\\n'); // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n  var _iterator2 = _createForOfIteratorHelper(frames),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var frame = _step2.value;\n      var sanitizedFrame = frame.trim();\n      var frameWithoutFunctionName = sanitizedFrame.replace(/((.*\".+\"[^@]*)?[^@]*)(?:@)/, '');\n      var location = extractLocation(frameWithoutFunctionName); // Continue the search until at least sourceURL is found\n\n      if (location == null) {\n        continue;\n      }\n\n      var sourceURL = location.sourceURL,\n          _location$line2 = location.line,\n          line = _location$line2 === void 0 ? '1' : _location$line2,\n          _location$column2 = location.column,\n          column = _location$column2 === void 0 ? '1' : _location$column2;\n      return {\n        sourceURL: sourceURL,\n        line: parseInt(line, 10),\n        column: parseInt(column, 10)\n      };\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return null;\n}\n\nfunction parseSourceFromComponentStack(componentStack) {\n  if (componentStack.match(CHROME_STACK_REGEXP)) {\n    return parseSourceFromChromeStack(componentStack);\n  }\n\n  return parseSourceFromFirefoxStack(componentStack);\n} // 0.123456789 => 0.123\n// Expects high-resolution timestamp in milliseconds, like from performance.now()\n// Mainly used for optimizing the size of serialized profiling payload\n\nfunction formatDurationToMicrosecondsGranularity(duration) {\n  return Math.round(duration * 1000) / 1000;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFHQTtBQURBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQVhBOztBQWFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBOztBQWJBO0FBQUE7QUFBQTtBQUFBOztBQWdCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBR0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQXhCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQTBCQTtBQUNBOztBQUVBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUF2QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF5QkE7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdXRpbHMvaW5kZXguanM/ZDcxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7Y29tcGFyZVZlcnNpb25zfSBmcm9tICdjb21wYXJlLXZlcnNpb25zJztcbmltcG9ydCB7ZGVoeWRyYXRlfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2h5ZHJhdGlvbic7XG5pbXBvcnQgaXNBcnJheSBmcm9tICdzaGFyZWQvaXNBcnJheSc7XG5cbmltcG9ydCB0eXBlIHtTb3VyY2V9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB0eXBlIHtEZWh5ZHJhdGVkRGF0YX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBmb3JtYXRXaXRoU3R5bGVzfSBmcm9tICcuL2Zvcm1hdFdpdGhTdHlsZXMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZvcm1hdENvbnNvbGVBcmd1bWVudHN9IGZyb20gJy4vZm9ybWF0Q29uc29sZUFyZ3VtZW50cyc7XG5cbi8vIFRPRE86IHVwZGF0ZSB0aGlzIHRvIHRoZSBmaXJzdCBSZWFjdCB2ZXJzaW9uIHRoYXQgaGFzIGEgY29ycmVzcG9uZGluZyBEZXZUb29scyBiYWNrZW5kXG5jb25zdCBGSVJTVF9ERVZUT09MU19CQUNLRU5EX0xPQ0tTVEVQX1ZFUiA9ICc5OTkuOS45JztcbmV4cG9ydCBmdW5jdGlvbiBoYXNBc3NpZ25lZEJhY2tlbmQodmVyc2lvbj86IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodmVyc2lvbiA9PSBudWxsIHx8IHZlcnNpb24gPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBndGUodmVyc2lvbiwgRklSU1RfREVWVE9PTFNfQkFDS0VORF9MT0NLU1RFUF9WRVIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5Gb3JCcmlkZ2UoXG4gIGRhdGE6IE9iamVjdCB8IG51bGwsXG4gIGlzUGF0aEFsbG93ZWQ6IChwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KSA9PiBib29sZWFuLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0gW10sXG4pOiBEZWh5ZHJhdGVkRGF0YSB8IG51bGwge1xuICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGNsZWFuZWRQYXRoczogQXJyYXk8QXJyYXk8c3RyaW5nIHwgbnVtYmVyPj4gPSBbXTtcbiAgICBjb25zdCB1bnNlcmlhbGl6YWJsZVBhdGhzOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PiA9IFtdO1xuICAgIGNvbnN0IGNsZWFuZWREYXRhID0gZGVoeWRyYXRlKFxuICAgICAgZGF0YSxcbiAgICAgIGNsZWFuZWRQYXRocyxcbiAgICAgIHVuc2VyaWFsaXphYmxlUGF0aHMsXG4gICAgICBwYXRoLFxuICAgICAgaXNQYXRoQWxsb3dlZCxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGNsZWFuZWREYXRhLFxuICAgICAgY2xlYW5lZDogY2xlYW5lZFBhdGhzLFxuICAgICAgdW5zZXJpYWxpemFibGU6IHVuc2VyaWFsaXphYmxlUGF0aHMsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weVdpdGhEZWxldGUoXG4gIG9iajogT2JqZWN0IHwgQXJyYXk8YW55PixcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgaW5kZXg6IG51bWJlciA9IDAsXG4pOiBPYmplY3QgfCBBcnJheTxhbnk+IHtcbiAgY29uc3Qga2V5ID0gcGF0aFtpbmRleF07XG4gIGNvbnN0IHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IHsuLi5vYmp9O1xuICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZSgoKGtleTogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZShvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGZpbmFsIHZhbHVlLlxuLy8gZS5nLiBbJ3BhdGgnLCAndG8nLCAnZm9vJ10gYW5kIFsncGF0aCcsICd0bycsICdiYXInXVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKFxuICBvYmo6IE9iamVjdCB8IEFycmF5PGFueT4sXG4gIG9sZFBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIG5ld1BhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIGluZGV4OiBudW1iZXIgPSAwLFxuKTogT2JqZWN0IHwgQXJyYXk8YW55PiB7XG4gIGNvbnN0IG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdO1xuICBjb25zdCB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiB7Li4ub2JqfTtcbiAgaWYgKGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBuZXdLZXkgPSBuZXdQYXRoW2luZGV4XTtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZSgoKG9sZEtleTogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZShvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlXaXRoU2V0KFxuICBvYmo6IE9iamVjdCB8IEFycmF5PGFueT4sXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIHZhbHVlOiBhbnksXG4gIGluZGV4OiBudW1iZXIgPSAwLFxuKTogT2JqZWN0IHwgQXJyYXk8YW55PiB7XG4gIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBrZXkgPSBwYXRoW2luZGV4XTtcbiAgY29uc3QgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogey4uLm9ian07XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXQob2JqW2tleV0sIHBhdGgsIHZhbHVlLCBpbmRleCArIDEpO1xuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVmZmVjdER1cmF0aW9ucyhyb290OiBPYmplY3QpOiB7XG4gIGVmZmVjdER1cmF0aW9uOiBhbnkgfCBudWxsLFxuICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IGFueSB8IG51bGwsXG59IHtcbiAgLy8gUHJvZmlsaW5nIGR1cmF0aW9ucyBhcmUgb25seSBhdmFpbGFibGUgZm9yIGNlcnRhaW4gYnVpbGRzLlxuICAvLyBJZiBhdmFpbGFibGUsIHRoZXknbGwgYmUgc3RvcmVkIG9uIHRoZSBIb3N0Um9vdC5cbiAgbGV0IGVmZmVjdER1cmF0aW9uID0gbnVsbDtcbiAgbGV0IHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IG51bGw7XG4gIGNvbnN0IGhvc3RSb290ID0gcm9vdC5jdXJyZW50O1xuICBpZiAoaG9zdFJvb3QgIT0gbnVsbCkge1xuICAgIGNvbnN0IHN0YXRlTm9kZSA9IGhvc3RSb290LnN0YXRlTm9kZTtcbiAgICBpZiAoc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgIGVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICE9IG51bGwgPyBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gOiBudWxsO1xuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiAhPSBudWxsXG4gICAgICAgICAgPyBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2VmZmVjdER1cmF0aW9uLCBwYXNzaXZlRWZmZWN0RHVyYXRpb259O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplVG9TdHJpbmcoZGF0YTogYW55KTogc3RyaW5nIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gIH1cblxuICBjb25zdCBjYWNoZSA9IG5ldyBTZXQ8bWl4ZWQ+KCk7XG4gIC8vIFVzZSBhIGN1c3RvbSByZXBsYWNlciBmdW5jdGlvbiB0byBwcm90ZWN0IGFnYWluc3QgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIGRhdGEsXG4gICAgKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FjaGUuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZS5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyAnbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICAyLFxuICApO1xufVxuXG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcodmFsOiBhbnkpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBBbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUgYW5kIG5vIGBbU3ltYm9sLnRvUHJpbWl0aXZlXSgpYCwgYHRvU3RyaW5nKClgLCBhbmQgYHZhbHVlT2YoKWAgbWV0aG9kcyB3b3VsZCB0aHJvdy5cbiAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcjc3RyaW5nX2NvZXJjaW9uXG4gICAgICByZXR1cm4gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG1wZnMvZm9ybWF0LXV0aWwvYmxvYi8wZTYyZDQzMGVmYjBhMWM1MTQ0ODcwOWFiZDNlMjQwNmMxNGQ4NDAxL2Zvcm1hdC5qcyNMMVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2NvbnNvbGUjVXNpbmdfc3RyaW5nX3N1YnN0aXR1dGlvbnNcbi8vIEltcGxlbWVudHMgcywgZCwgaSBhbmQgZiBwbGFjZWhvbGRlcnNcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDb25zb2xlQXJndW1lbnRzVG9TaW5nbGVTdHJpbmcoXG4gIG1heWJlTWVzc2FnZTogYW55LFxuICAuLi5pbnB1dEFyZ3M6ICRSZWFkT25seUFycmF5PGFueT5cbik6IHN0cmluZyB7XG4gIGNvbnN0IGFyZ3MgPSBpbnB1dEFyZ3Muc2xpY2UoKTtcblxuICBsZXQgZm9ybWF0dGVkOiBzdHJpbmcgPSBzYWZlVG9TdHJpbmcobWF5YmVNZXNzYWdlKTtcblxuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGNoZWNrIGZvciBzdWJzdGl0dXRpb25zLlxuICBpZiAodHlwZW9mIG1heWJlTWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFJFR0VYUCA9IC8oJT8pKCUoW2pkc10pKS9nO1xuXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoUkVHRVhQLCAobWF0Y2gsIGVzY2FwZWQsIHB0biwgZmxhZykgPT4ge1xuICAgICAgICBsZXQgYXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXVxuICAgICAgICAgICAgYXJnICs9ICcnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUludChhcmcsIDEwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUZsb2F0KGFyZykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy51bnNoaWZ0KGFyZyk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFyZ3VtZW50cyB0aGF0IHJlbWFpbiBhZnRlciBmb3JtYXR0aW5nLlxuICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvcm1hdHRlZCArPSAnICcgKyBzYWZlVG9TdHJpbmcoYXJnc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGVzY2FwZWQgJSUgdmFsdWVzLlxuICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZSgvJXsyLDJ9L2csICclJyk7XG5cbiAgcmV0dXJuIFN0cmluZyhmb3JtYXR0ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKFxuICAgIHdpbmRvdy5kb2N1bWVudCAmJlxuICAgIHdpbmRvdy5kb2N1bWVudC5mZWF0dXJlUG9saWN5ICYmXG4gICAgd2luZG93LmRvY3VtZW50LmZlYXR1cmVQb2xpY3kuYWxsb3dzRmVhdHVyZSgnc3luYy14aHInKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3QoYTogc3RyaW5nID0gJycsIGI6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYSwgYikgPT09IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBndGUoYTogc3RyaW5nID0gJycsIGI6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYSwgYikgPiAtMTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzUmVhY3ROYXRpdmVFbnZpcm9ubWVudCA9ICgpOiBib29sZWFuID0+IHtcbiAgLy8gV2UndmUgYmVlbiByZWx5aW5nIG9uIHRoaXMgZm9yIHN1Y2ggYSBsb25nIHRpbWVcbiAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRlZmluZSB0aGUgY2xpZW50IGZvciBEZXZUb29scyBvbiB0aGUgYmFja2VuZCBzaWRlIGFuZCBzaGFyZSBpdCB3aXRoIHRoZSBmcm9udGVuZFxuICByZXR1cm4gd2luZG93LmRvY3VtZW50ID09IG51bGw7XG59O1xuXG5mdW5jdGlvbiBleHRyYWN0TG9jYXRpb24oXG4gIHVybDogc3RyaW5nLFxuKTogbnVsbCB8IHtzb3VyY2VVUkw6IHN0cmluZywgbGluZT86IHN0cmluZywgY29sdW1uPzogc3RyaW5nfSB7XG4gIGlmICh1cmwuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBwYXJlbnRoZXNlcyBmcm9tIHN0YXJ0IGFuZCBlbmRcbiAgY29uc3Qgd2l0aG91dFBhcmVudGhlc2VzID0gdXJsLnJlcGxhY2UoL15cXCgrLywgJycpLnJlcGxhY2UoL1xcKSskLywgJycpO1xuICBjb25zdCBsb2NhdGlvblBhcnRzID0gLyhhdCApPyguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC8uZXhlYyhcbiAgICB3aXRob3V0UGFyZW50aGVzZXMsXG4gICk7XG5cbiAgaWYgKGxvY2F0aW9uUGFydHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgWywgLCBzb3VyY2VVUkwsIGxpbmUsIGNvbHVtbl0gPSBsb2NhdGlvblBhcnRzO1xuICByZXR1cm4ge3NvdXJjZVVSTCwgbGluZSwgY29sdW1ufTtcbn1cblxuY29uc3QgQ0hST01FX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG5mdW5jdGlvbiBwYXJzZVNvdXJjZUZyb21DaHJvbWVTdGFjayhzdGFjazogc3RyaW5nKTogU291cmNlIHwgbnVsbCB7XG4gIGNvbnN0IGZyYW1lcyA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWRGcmFtZSA9IGZyYW1lLnRyaW0oKTtcblxuICAgIGNvbnN0IGxvY2F0aW9uSW5QYXJlbnRoZXNlc01hdGNoID0gc2FuaXRpemVkRnJhbWUubWF0Y2goLyAoXFwoLitcXCkkKS8pO1xuICAgIGNvbnN0IHBvc3NpYmxlTG9jYXRpb24gPSBsb2NhdGlvbkluUGFyZW50aGVzZXNNYXRjaFxuICAgICAgPyBsb2NhdGlvbkluUGFyZW50aGVzZXNNYXRjaFsxXVxuICAgICAgOiBzYW5pdGl6ZWRGcmFtZTtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gZXh0cmFjdExvY2F0aW9uKHBvc3NpYmxlTG9jYXRpb24pO1xuICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggdW50aWwgYXQgbGVhc3Qgc291cmNlVVJMIGlzIGZvdW5kXG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHtzb3VyY2VVUkwsIGxpbmUgPSAnMScsIGNvbHVtbiA9ICcxJ30gPSBsb2NhdGlvbjtcblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2VVUkwsXG4gICAgICBsaW5lOiBwYXJzZUludChsaW5lLCAxMCksXG4gICAgICBjb2x1bW46IHBhcnNlSW50KGNvbHVtbiwgMTApLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VTb3VyY2VGcm9tRmlyZWZveFN0YWNrKHN0YWNrOiBzdHJpbmcpOiBTb3VyY2UgfCBudWxsIHtcbiAgY29uc3QgZnJhbWVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICBmb3IgKGNvbnN0IGZyYW1lIG9mIGZyYW1lcykge1xuICAgIGNvbnN0IHNhbml0aXplZEZyYW1lID0gZnJhbWUudHJpbSgpO1xuICAgIGNvbnN0IGZyYW1lV2l0aG91dEZ1bmN0aW9uTmFtZSA9IHNhbml0aXplZEZyYW1lLnJlcGxhY2UoXG4gICAgICAvKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS8sXG4gICAgICAnJyxcbiAgICApO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSBleHRyYWN0TG9jYXRpb24oZnJhbWVXaXRob3V0RnVuY3Rpb25OYW1lKTtcbiAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIHVudGlsIGF0IGxlYXN0IHNvdXJjZVVSTCBpcyBmb3VuZFxuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7c291cmNlVVJMLCBsaW5lID0gJzEnLCBjb2x1bW4gPSAnMSd9ID0gbG9jYXRpb247XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlVVJMLFxuICAgICAgbGluZTogcGFyc2VJbnQobGluZSwgMTApLFxuICAgICAgY29sdW1uOiBwYXJzZUludChjb2x1bW4sIDEwKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNvdXJjZUZyb21Db21wb25lbnRTdGFjayhcbiAgY29tcG9uZW50U3RhY2s6IHN0cmluZyxcbik6IFNvdXJjZSB8IG51bGwge1xuICBpZiAoY29tcG9uZW50U3RhY2subWF0Y2goQ0hST01FX1NUQUNLX1JFR0VYUCkpIHtcbiAgICByZXR1cm4gcGFyc2VTb3VyY2VGcm9tQ2hyb21lU3RhY2soY29tcG9uZW50U3RhY2spO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlU291cmNlRnJvbUZpcmVmb3hTdGFjayhjb21wb25lbnRTdGFjayk7XG59XG5cbi8vIDAuMTIzNDU2Nzg5ID0+IDAuMTIzXG4vLyBFeHBlY3RzIGhpZ2gtcmVzb2x1dGlvbiB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzLCBsaWtlIGZyb20gcGVyZm9ybWFuY2Uubm93KClcbi8vIE1haW5seSB1c2VkIGZvciBvcHRpbWl6aW5nIHRoZSBzaXplIG9mIHNlcmlhbGl6ZWQgcHJvZmlsaW5nIHBheWxvYWRcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREdXJhdGlvblRvTWljcm9zZWNvbmRzR3JhbnVsYXJpdHkoXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4pOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZChkdXJhdGlvbiAqIDEwMDApIC8gMTAwMDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/utils/index.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js":
/*!*****************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hideOverlay\": () => (/* binding */ hideOverlay),\n/* harmony export */   \"showOverlay\": () => (/* binding */ showOverlay)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\n/* harmony import */ var _Overlay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Overlay */ \"../react-devtools-shared/src/backend/views/Highlighter/Overlay.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nvar SHOW_DURATION = 2000;\nvar timeoutID = null;\nvar overlay = null;\n\nfunction hideOverlayNative(agent) {\n  agent.emit('hideNativeHighlight');\n}\n\nfunction hideOverlayWeb() {\n  timeoutID = null;\n\n  if (overlay !== null) {\n    overlay.remove();\n    overlay = null;\n  }\n}\n\nfunction hideOverlay(agent) {\n  return (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_0__.isReactNativeEnvironment)() ? hideOverlayNative(agent) : hideOverlayWeb();\n}\n\nfunction showOverlayNative(elements, agent) {\n  agent.emit('showNativeHighlight', elements);\n}\n\nfunction showOverlayWeb(elements, componentName, agent, hideAfterTimeout) {\n  if (timeoutID !== null) {\n    clearTimeout(timeoutID);\n  }\n\n  if (overlay === null) {\n    overlay = new _Overlay__WEBPACK_IMPORTED_MODULE_1__[\"default\"](agent);\n  }\n\n  overlay.inspect(elements, componentName);\n\n  if (hideAfterTimeout) {\n    timeoutID = setTimeout(function () {\n      return hideOverlay(agent);\n    }, SHOW_DURATION);\n  }\n}\n\nfunction showOverlay(elements, componentName, agent, hideAfterTimeout) {\n  return (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_0__.isReactNativeEnvironment)() ? showOverlayNative(elements, agent) : showOverlayWeb(elements, componentName, agent, hideAfterTimeout);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL0hpZ2hsaWdodGVyL0hpZ2hsaWdodGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFZQTtBQUVBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOztBQUVBO0FBSUE7QUFDQTs7QUFFQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBTUE7QUFRQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy9IaWdobGlnaHRlci9IaWdobGlnaHRlci5qcz84YTFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIEFnZW50IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9hZ2VudCc7XG5pbXBvcnQgdHlwZSB7SG9zdEluc3RhbmNlfSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbmltcG9ydCB7aXNSZWFjdE5hdGl2ZUVudmlyb25tZW50fSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdXRpbHMnO1xuXG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuL092ZXJsYXknO1xuXG5jb25zdCBTSE9XX0RVUkFUSU9OID0gMjAwMDtcblxubGV0IHRpbWVvdXRJRDogVGltZW91dElEIHwgbnVsbCA9IG51bGw7XG5sZXQgb3ZlcmxheTogT3ZlcmxheSB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBoaWRlT3ZlcmxheU5hdGl2ZShhZ2VudDogQWdlbnQpOiB2b2lkIHtcbiAgYWdlbnQuZW1pdCgnaGlkZU5hdGl2ZUhpZ2hsaWdodCcpO1xufVxuXG5mdW5jdGlvbiBoaWRlT3ZlcmxheVdlYigpOiB2b2lkIHtcbiAgdGltZW91dElEID0gbnVsbDtcblxuICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgIG92ZXJsYXkucmVtb3ZlKCk7XG4gICAgb3ZlcmxheSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGVPdmVybGF5KGFnZW50OiBBZ2VudCk6IHZvaWQge1xuICByZXR1cm4gaXNSZWFjdE5hdGl2ZUVudmlyb25tZW50KClcbiAgICA/IGhpZGVPdmVybGF5TmF0aXZlKGFnZW50KVxuICAgIDogaGlkZU92ZXJsYXlXZWIoKTtcbn1cblxuZnVuY3Rpb24gc2hvd092ZXJsYXlOYXRpdmUoXG4gIGVsZW1lbnRzOiAkUmVhZE9ubHlBcnJheTxIb3N0SW5zdGFuY2U+LFxuICBhZ2VudDogQWdlbnQsXG4pOiB2b2lkIHtcbiAgYWdlbnQuZW1pdCgnc2hvd05hdGl2ZUhpZ2hsaWdodCcsIGVsZW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2hvd092ZXJsYXlXZWIoXG4gIGVsZW1lbnRzOiAkUmVhZE9ubHlBcnJheTxIVE1MRWxlbWVudD4sXG4gIGNvbXBvbmVudE5hbWU6IHN0cmluZyB8IG51bGwsXG4gIGFnZW50OiBBZ2VudCxcbiAgaGlkZUFmdGVyVGltZW91dDogYm9vbGVhbixcbik6IHZvaWQge1xuICBpZiAodGltZW91dElEICE9PSBudWxsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH1cblxuICBpZiAob3ZlcmxheSA9PT0gbnVsbCkge1xuICAgIG92ZXJsYXkgPSBuZXcgT3ZlcmxheShhZ2VudCk7XG4gIH1cblxuICBvdmVybGF5Lmluc3BlY3QoZWxlbWVudHMsIGNvbXBvbmVudE5hbWUpO1xuXG4gIGlmIChoaWRlQWZ0ZXJUaW1lb3V0KSB7XG4gICAgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiBoaWRlT3ZlcmxheShhZ2VudCksIFNIT1dfRFVSQVRJT04pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93T3ZlcmxheShcbiAgZWxlbWVudHM6ICRSZWFkT25seUFycmF5PEhvc3RJbnN0YW5jZT4sXG4gIGNvbXBvbmVudE5hbWU6IHN0cmluZyB8IG51bGwsXG4gIGFnZW50OiBBZ2VudCxcbiAgaGlkZUFmdGVyVGltZW91dDogYm9vbGVhbixcbik6IHZvaWQge1xuICByZXR1cm4gaXNSZWFjdE5hdGl2ZUVudmlyb25tZW50KClcbiAgICA/IHNob3dPdmVybGF5TmF0aXZlKGVsZW1lbnRzLCBhZ2VudClcbiAgICA6IHNob3dPdmVybGF5V2ViKFxuICAgICAgICAoZWxlbWVudHM6ICRSZWFkT25seUFycmF5PGFueT4pLFxuICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICBhZ2VudCxcbiAgICAgICAgaGlkZUFmdGVyVGltZW91dCxcbiAgICAgICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/views/Highlighter/Overlay.js":
/*!*************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Overlay)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"../react-devtools-shared/src/backend/views/utils.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar assign = Object.assign; // Note that the Overlay components are not affected by the active Theme,\n// because they highlight elements in the main Chrome window (outside of devtools).\n// The colors below were chosen to roughly match those used by Chrome devtools.\n\nvar OverlayRect = /*#__PURE__*/function () {\n  function OverlayRect(doc, container) {\n    _classCallCheck(this, OverlayRect);\n\n    this.node = doc.createElement('div');\n    this.border = doc.createElement('div');\n    this.padding = doc.createElement('div');\n    this.content = doc.createElement('div');\n    this.border.style.borderColor = overlayStyles.border;\n    this.padding.style.borderColor = overlayStyles.padding;\n    this.content.style.backgroundColor = overlayStyles.background;\n    assign(this.node.style, {\n      borderColor: overlayStyles.margin,\n      pointerEvents: 'none',\n      position: 'fixed'\n    });\n    this.node.style.zIndex = '10000000';\n    this.node.appendChild(this.border);\n    this.border.appendChild(this.padding);\n    this.padding.appendChild(this.content);\n    container.appendChild(this.node);\n  }\n\n  _createClass(OverlayRect, [{\n    key: \"remove\",\n    value: function remove() {\n      if (this.node.parentNode) {\n        this.node.parentNode.removeChild(this.node);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(box, dims) {\n      boxWrap(dims, 'margin', this.node);\n      boxWrap(dims, 'border', this.border);\n      boxWrap(dims, 'padding', this.padding);\n      assign(this.content.style, {\n        height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',\n        width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'\n      });\n      assign(this.node.style, {\n        top: box.top - dims.marginTop + 'px',\n        left: box.left - dims.marginLeft + 'px'\n      });\n    }\n  }]);\n\n  return OverlayRect;\n}();\n\nvar OverlayTip = /*#__PURE__*/function () {\n  function OverlayTip(doc, container) {\n    _classCallCheck(this, OverlayTip);\n\n    this.tip = doc.createElement('div');\n    assign(this.tip.style, {\n      display: 'flex',\n      flexFlow: 'row nowrap',\n      backgroundColor: '#333740',\n      borderRadius: '2px',\n      fontFamily: '\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',\n      fontWeight: 'bold',\n      padding: '3px 5px',\n      pointerEvents: 'none',\n      position: 'fixed',\n      fontSize: '12px',\n      whiteSpace: 'nowrap'\n    });\n    this.nameSpan = doc.createElement('span');\n    this.tip.appendChild(this.nameSpan);\n    assign(this.nameSpan.style, {\n      color: '#ee78e6',\n      borderRight: '1px solid #aaaaaa',\n      paddingRight: '0.5rem',\n      marginRight: '0.5rem'\n    });\n    this.dimSpan = doc.createElement('span');\n    this.tip.appendChild(this.dimSpan);\n    assign(this.dimSpan.style, {\n      color: '#d7d7d7'\n    });\n    this.tip.style.zIndex = '10000000';\n    container.appendChild(this.tip);\n  }\n\n  _createClass(OverlayTip, [{\n    key: \"remove\",\n    value: function remove() {\n      if (this.tip.parentNode) {\n        this.tip.parentNode.removeChild(this.tip);\n      }\n    }\n  }, {\n    key: \"updateText\",\n    value: function updateText(name, width, height) {\n      this.nameSpan.textContent = name;\n      this.dimSpan.textContent = Math.round(width) + 'px × ' + Math.round(height) + 'px';\n    }\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(dims, bounds) {\n      var tipRect = this.tip.getBoundingClientRect();\n      var tipPos = findTipPos(dims, bounds, {\n        width: tipRect.width,\n        height: tipRect.height\n      });\n      assign(this.tip.style, tipPos.style);\n    }\n  }]);\n\n  return OverlayTip;\n}();\n\nvar Overlay = /*#__PURE__*/function () {\n  function Overlay(agent) {\n    _classCallCheck(this, Overlay);\n\n    // Find the root window, because overlays are positioned relative to it.\n    var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n    this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.\n\n    var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n    this.tipBoundsWindow = tipBoundsWindow;\n    var doc = currentWindow.document;\n    this.container = doc.createElement('div');\n    this.container.style.zIndex = '10000000';\n    this.tip = new OverlayTip(doc, this.container);\n    this.rects = [];\n    this.agent = agent;\n    doc.body.appendChild(this.container);\n  }\n\n  _createClass(Overlay, [{\n    key: \"remove\",\n    value: function remove() {\n      this.tip.remove();\n      this.rects.forEach(function (rect) {\n        rect.remove();\n      });\n      this.rects.length = 0;\n\n      if (this.container.parentNode) {\n        this.container.parentNode.removeChild(this.container);\n      }\n    }\n  }, {\n    key: \"inspect\",\n    value: function inspect(nodes, name) {\n      var _this = this;\n\n      // We can't get the size of text nodes or comment nodes. React as of v15\n      // heavily uses comment nodes to delimit text.\n      var elements = nodes.filter(function (node) {\n        return node.nodeType === Node.ELEMENT_NODE;\n      });\n\n      while (this.rects.length > elements.length) {\n        var rect = this.rects.pop(); // $FlowFixMe[incompatible-use]\n\n        rect.remove();\n      }\n\n      if (elements.length === 0) {\n        return;\n      }\n\n      while (this.rects.length < elements.length) {\n        this.rects.push(new OverlayRect(this.window.document, this.container));\n      }\n\n      var outerBox = {\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        left: Number.POSITIVE_INFINITY\n      };\n      elements.forEach(function (element, index) {\n        var box = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getNestedBoundingClientRect)(element, _this.window);\n        var dims = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getElementDimensions)(element);\n        outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);\n        outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);\n        outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);\n        outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);\n        var rect = _this.rects[index];\n        rect.update(box, dims);\n      });\n\n      if (!name) {\n        name = elements[0].nodeName.toLowerCase();\n        var node = elements[0];\n        var ownerName = this.agent.getComponentNameForHostInstance(node);\n\n        if (ownerName) {\n          name += ' (in ' + ownerName + ')';\n        }\n      }\n\n      this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);\n      var tipBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getNestedBoundingClientRect)(this.tipBoundsWindow.document.documentElement, this.window);\n      this.tip.updatePosition({\n        top: outerBox.top,\n        left: outerBox.left,\n        height: outerBox.bottom - outerBox.top,\n        width: outerBox.right - outerBox.left\n      }, {\n        top: tipBounds.top + this.tipBoundsWindow.scrollY,\n        left: tipBounds.left + this.tipBoundsWindow.scrollX,\n        height: this.tipBoundsWindow.innerHeight,\n        width: this.tipBoundsWindow.innerWidth\n      });\n    }\n  }]);\n\n  return Overlay;\n}();\n\n\n\nfunction findTipPos(dims, bounds, tipSize) {\n  var tipHeight = Math.max(tipSize.height, 20);\n  var tipWidth = Math.max(tipSize.width, 60);\n  var margin = 5;\n  var top;\n\n  if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {\n    if (dims.top + dims.height < bounds.top + 0) {\n      top = bounds.top + margin;\n    } else {\n      top = dims.top + dims.height + margin;\n    }\n  } else if (dims.top - tipHeight <= bounds.top + bounds.height) {\n    if (dims.top - tipHeight - margin < bounds.top + margin) {\n      top = bounds.top + margin;\n    } else {\n      top = dims.top - tipHeight - margin;\n    }\n  } else {\n    top = bounds.top + bounds.height - tipHeight - margin;\n  }\n\n  var left = dims.left + margin;\n\n  if (dims.left < bounds.left) {\n    left = bounds.left + margin;\n  }\n\n  if (dims.left + tipWidth > bounds.left + bounds.width) {\n    left = bounds.left + bounds.width - tipWidth - margin;\n  }\n\n  top += 'px';\n  left += 'px';\n  return {\n    style: {\n      top: top,\n      left: left\n    }\n  };\n}\n\nfunction boxWrap(dims, what, node) {\n  assign(node.style, {\n    borderTopWidth: dims[what + 'Top'] + 'px',\n    borderLeftWidth: dims[what + 'Left'] + 'px',\n    borderRightWidth: dims[what + 'Right'] + 'px',\n    borderBottomWidth: dims[what + 'Bottom'] + 'px',\n    borderStyle: 'solid'\n  });\n}\n\nvar overlayStyles = {\n  background: 'rgba(120, 170, 210, 0.7)',\n  padding: 'rgba(77, 200, 0, 0.3)',\n  margin: 'rgba(255, 155, 0, 0.3)',\n  border: 'rgba(255, 200, 50, 0.3)'\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL0hpZ2hsaWdodGVyL092ZXJsYXkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQU9BO0FBR0E7QUFDQTs7QUFFQTtBQU1BO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFSQTtBQWlCQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7QUFHQTtBQUtBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7Ozs7OztBQUdBO0FBUUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BOzs7Ozs7QUFySEE7O0FBd0hBO0FBS0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvSGlnaGxpZ2h0ZXIvT3ZlcmxheS5qcz80ZmE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7Z2V0RWxlbWVudERpbWVuc2lvbnMsIGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSB7UmVjdH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgQWdlbnQgZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2FnZW50JztcblxudHlwZSBCb3ggPSB7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9O1xuXG5jb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBOb3RlIHRoYXQgdGhlIE92ZXJsYXkgY29tcG9uZW50cyBhcmUgbm90IGFmZmVjdGVkIGJ5IHRoZSBhY3RpdmUgVGhlbWUsXG4vLyBiZWNhdXNlIHRoZXkgaGlnaGxpZ2h0IGVsZW1lbnRzIGluIHRoZSBtYWluIENocm9tZSB3aW5kb3cgKG91dHNpZGUgb2YgZGV2dG9vbHMpLlxuLy8gVGhlIGNvbG9ycyBiZWxvdyB3ZXJlIGNob3NlbiB0byByb3VnaGx5IG1hdGNoIHRob3NlIHVzZWQgYnkgQ2hyb21lIGRldnRvb2xzLlxuXG5jbGFzcyBPdmVybGF5UmVjdCB7XG4gIG5vZGU6IEhUTUxFbGVtZW50O1xuICBib3JkZXI6IEhUTUxFbGVtZW50O1xuICBwYWRkaW5nOiBIVE1MRWxlbWVudDtcbiAgY29udGVudDogSFRNTEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IoZG9jOiBEb2N1bWVudCwgY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMubm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmJvcmRlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5jb250ZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgdGhpcy5ib3JkZXIuc3R5bGUuYm9yZGVyQ29sb3IgPSBvdmVybGF5U3R5bGVzLmJvcmRlcjtcbiAgICB0aGlzLnBhZGRpbmcuc3R5bGUuYm9yZGVyQ29sb3IgPSBvdmVybGF5U3R5bGVzLnBhZGRpbmc7XG4gICAgdGhpcy5jb250ZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG92ZXJsYXlTdHlsZXMuYmFja2dyb3VuZDtcblxuICAgIGFzc2lnbih0aGlzLm5vZGUuc3R5bGUsIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvdmVybGF5U3R5bGVzLm1hcmdpbixcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIH0pO1xuXG4gICAgdGhpcy5ub2RlLnN0eWxlLnpJbmRleCA9ICcxMDAwMDAwMCc7XG5cbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ib3JkZXIpO1xuICAgIHRoaXMuYm9yZGVyLmFwcGVuZENoaWxkKHRoaXMucGFkZGluZyk7XG4gICAgdGhpcy5wYWRkaW5nLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gIH1cblxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShib3g6IFJlY3QsIGRpbXM6IGFueSkge1xuICAgIGJveFdyYXAoZGltcywgJ21hcmdpbicsIHRoaXMubm9kZSk7XG4gICAgYm94V3JhcChkaW1zLCAnYm9yZGVyJywgdGhpcy5ib3JkZXIpO1xuICAgIGJveFdyYXAoZGltcywgJ3BhZGRpbmcnLCB0aGlzLnBhZGRpbmcpO1xuXG4gICAgYXNzaWduKHRoaXMuY29udGVudC5zdHlsZSwge1xuICAgICAgaGVpZ2h0OlxuICAgICAgICBib3guaGVpZ2h0IC1cbiAgICAgICAgZGltcy5ib3JkZXJUb3AgLVxuICAgICAgICBkaW1zLmJvcmRlckJvdHRvbSAtXG4gICAgICAgIGRpbXMucGFkZGluZ1RvcCAtXG4gICAgICAgIGRpbXMucGFkZGluZ0JvdHRvbSArXG4gICAgICAgICdweCcsXG4gICAgICB3aWR0aDpcbiAgICAgICAgYm94LndpZHRoIC1cbiAgICAgICAgZGltcy5ib3JkZXJMZWZ0IC1cbiAgICAgICAgZGltcy5ib3JkZXJSaWdodCAtXG4gICAgICAgIGRpbXMucGFkZGluZ0xlZnQgLVxuICAgICAgICBkaW1zLnBhZGRpbmdSaWdodCArXG4gICAgICAgICdweCcsXG4gICAgfSk7XG5cbiAgICBhc3NpZ24odGhpcy5ub2RlLnN0eWxlLCB7XG4gICAgICB0b3A6IGJveC50b3AgLSBkaW1zLm1hcmdpblRvcCArICdweCcsXG4gICAgICBsZWZ0OiBib3gubGVmdCAtIGRpbXMubWFyZ2luTGVmdCArICdweCcsXG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgT3ZlcmxheVRpcCB7XG4gIHRpcDogSFRNTEVsZW1lbnQ7XG4gIG5hbWVTcGFuOiBIVE1MRWxlbWVudDtcbiAgZGltU3BhbjogSFRNTEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IoZG9jOiBEb2N1bWVudCwgY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMudGlwID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFzc2lnbih0aGlzLnRpcC5zdHlsZSwge1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleEZsb3c6ICdyb3cgbm93cmFwJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMzMzM3NDAnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICAgIGZvbnRGYW1pbHk6XG4gICAgICAgICdcIlNGTW9uby1SZWd1bGFyXCIsIENvbnNvbGFzLCBcIkxpYmVyYXRpb24gTW9ub1wiLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHBhZGRpbmc6ICczcHggNXB4JyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH0pO1xuXG4gICAgdGhpcy5uYW1lU3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy50aXAuYXBwZW5kQ2hpbGQodGhpcy5uYW1lU3Bhbik7XG4gICAgYXNzaWduKHRoaXMubmFtZVNwYW4uc3R5bGUsIHtcbiAgICAgIGNvbG9yOiAnI2VlNzhlNicsXG4gICAgICBib3JkZXJSaWdodDogJzFweCBzb2xpZCAjYWFhYWFhJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJzAuNXJlbScsXG4gICAgICBtYXJnaW5SaWdodDogJzAuNXJlbScsXG4gICAgfSk7XG4gICAgdGhpcy5kaW1TcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB0aGlzLnRpcC5hcHBlbmRDaGlsZCh0aGlzLmRpbVNwYW4pO1xuICAgIGFzc2lnbih0aGlzLmRpbVNwYW4uc3R5bGUsIHtcbiAgICAgIGNvbG9yOiAnI2Q3ZDdkNycsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRpcC5zdHlsZS56SW5kZXggPSAnMTAwMDAwMDAnO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRpcCk7XG4gIH1cblxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMudGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMudGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy50aXApO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRleHQobmFtZTogc3RyaW5nLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMubmFtZVNwYW4udGV4dENvbnRlbnQgPSBuYW1lO1xuICAgIHRoaXMuZGltU3Bhbi50ZXh0Q29udGVudCA9XG4gICAgICBNYXRoLnJvdW5kKHdpZHRoKSArICdweCDDlyAnICsgTWF0aC5yb3VuZChoZWlnaHQpICsgJ3B4JztcbiAgfVxuXG4gIHVwZGF0ZVBvc2l0aW9uKGRpbXM6IEJveCwgYm91bmRzOiBCb3gpIHtcbiAgICBjb25zdCB0aXBSZWN0ID0gdGhpcy50aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGlwUG9zID0gZmluZFRpcFBvcyhkaW1zLCBib3VuZHMsIHtcbiAgICAgIHdpZHRoOiB0aXBSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aXBSZWN0LmhlaWdodCxcbiAgICB9KTtcbiAgICBhc3NpZ24odGhpcy50aXAuc3R5bGUsIHRpcFBvcy5zdHlsZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcmxheSB7XG4gIHdpbmRvdzogYW55O1xuICB0aXBCb3VuZHNXaW5kb3c6IGFueTtcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgdGlwOiBPdmVybGF5VGlwO1xuICByZWN0czogQXJyYXk8T3ZlcmxheVJlY3Q+O1xuICBhZ2VudDogQWdlbnQ7XG5cbiAgY29uc3RydWN0b3IoYWdlbnQ6IEFnZW50KSB7XG4gICAgLy8gRmluZCB0aGUgcm9vdCB3aW5kb3csIGJlY2F1c2Ugb3ZlcmxheXMgYXJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gaXQuXG4gICAgY29uc3QgY3VycmVudFdpbmRvdyA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1RBUkdFVF9XSU5ET1dfXyB8fCB3aW5kb3c7XG4gICAgdGhpcy53aW5kb3cgPSBjdXJyZW50V2luZG93O1xuXG4gICAgLy8gV2hlbiBvcGVuZWQgaW4gc2hlbGxzL2RldiwgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIGJvdW5kIGJ5IHRoZSBhcHAgaWZyYW1lLCBub3QgYnkgdGhlIHRvcG1vc3Qgd2luZG93LlxuICAgIGNvbnN0IHRpcEJvdW5kc1dpbmRvdyA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1RBUkdFVF9XSU5ET1dfXyB8fCB3aW5kb3c7XG4gICAgdGhpcy50aXBCb3VuZHNXaW5kb3cgPSB0aXBCb3VuZHNXaW5kb3c7XG5cbiAgICBjb25zdCBkb2MgPSBjdXJyZW50V2luZG93LmRvY3VtZW50O1xuICAgIHRoaXMuY29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICcxMDAwMDAwMCc7XG5cbiAgICB0aGlzLnRpcCA9IG5ldyBPdmVybGF5VGlwKGRvYywgdGhpcy5jb250YWluZXIpO1xuICAgIHRoaXMucmVjdHMgPSBbXTtcblxuICAgIHRoaXMuYWdlbnQgPSBhZ2VudDtcblxuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLnRpcC5yZW1vdmUoKTtcbiAgICB0aGlzLnJlY3RzLmZvckVhY2gocmVjdCA9PiB7XG4gICAgICByZWN0LnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVjdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgaW5zcGVjdChub2RlczogJFJlYWRPbmx5QXJyYXk8SFRNTEVsZW1lbnQ+LCBuYW1lPzogP3N0cmluZykge1xuICAgIC8vIFdlIGNhbid0IGdldCB0aGUgc2l6ZSBvZiB0ZXh0IG5vZGVzIG9yIGNvbW1lbnQgbm9kZXMuIFJlYWN0IGFzIG9mIHYxNVxuICAgIC8vIGhlYXZpbHkgdXNlcyBjb21tZW50IG5vZGVzIHRvIGRlbGltaXQgdGV4dC5cbiAgICBjb25zdCBlbGVtZW50cyA9IG5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcblxuICAgIHdoaWxlICh0aGlzLnJlY3RzLmxlbmd0aCA+IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcmVjdCA9IHRoaXMucmVjdHMucG9wKCk7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdXG4gICAgICByZWN0LnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMucmVjdHMubGVuZ3RoIDwgZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlY3RzLnB1c2gobmV3IE92ZXJsYXlSZWN0KHRoaXMud2luZG93LmRvY3VtZW50LCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGVyQm94ID0ge1xuICAgICAgdG9wOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICByaWdodDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgYm90dG9tOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICBsZWZ0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgfTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gZ2V0TmVzdGVkQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRoaXMud2luZG93KTtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXRFbGVtZW50RGltZW5zaW9ucyhlbGVtZW50KTtcblxuICAgICAgb3V0ZXJCb3gudG9wID0gTWF0aC5taW4ob3V0ZXJCb3gudG9wLCBib3gudG9wIC0gZGltcy5tYXJnaW5Ub3ApO1xuICAgICAgb3V0ZXJCb3gucmlnaHQgPSBNYXRoLm1heChcbiAgICAgICAgb3V0ZXJCb3gucmlnaHQsXG4gICAgICAgIGJveC5sZWZ0ICsgYm94LndpZHRoICsgZGltcy5tYXJnaW5SaWdodCxcbiAgICAgICk7XG4gICAgICBvdXRlckJveC5ib3R0b20gPSBNYXRoLm1heChcbiAgICAgICAgb3V0ZXJCb3guYm90dG9tLFxuICAgICAgICBib3gudG9wICsgYm94LmhlaWdodCArIGRpbXMubWFyZ2luQm90dG9tLFxuICAgICAgKTtcbiAgICAgIG91dGVyQm94LmxlZnQgPSBNYXRoLm1pbihvdXRlckJveC5sZWZ0LCBib3gubGVmdCAtIGRpbXMubWFyZ2luTGVmdCk7XG5cbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnJlY3RzW2luZGV4XTtcbiAgICAgIHJlY3QudXBkYXRlKGJveCwgZGltcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIG5hbWUgPSBlbGVtZW50c1swXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjb25zdCBub2RlID0gZWxlbWVudHNbMF07XG4gICAgICBjb25zdCBvd25lck5hbWUgPSB0aGlzLmFnZW50LmdldENvbXBvbmVudE5hbWVGb3JIb3N0SW5zdGFuY2Uobm9kZSk7XG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIG5hbWUgKz0gJyAoaW4gJyArIG93bmVyTmFtZSArICcpJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRpcC51cGRhdGVUZXh0KFxuICAgICAgbmFtZSxcbiAgICAgIG91dGVyQm94LnJpZ2h0IC0gb3V0ZXJCb3gubGVmdCxcbiAgICAgIG91dGVyQm94LmJvdHRvbSAtIG91dGVyQm94LnRvcCxcbiAgICApO1xuICAgIGNvbnN0IHRpcEJvdW5kcyA9IGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdChcbiAgICAgIHRoaXMudGlwQm91bmRzV2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHRoaXMud2luZG93LFxuICAgICk7XG5cbiAgICB0aGlzLnRpcC51cGRhdGVQb3NpdGlvbihcbiAgICAgIHtcbiAgICAgICAgdG9wOiBvdXRlckJveC50b3AsXG4gICAgICAgIGxlZnQ6IG91dGVyQm94LmxlZnQsXG4gICAgICAgIGhlaWdodDogb3V0ZXJCb3guYm90dG9tIC0gb3V0ZXJCb3gudG9wLFxuICAgICAgICB3aWR0aDogb3V0ZXJCb3gucmlnaHQgLSBvdXRlckJveC5sZWZ0LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdG9wOiB0aXBCb3VuZHMudG9wICsgdGhpcy50aXBCb3VuZHNXaW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgbGVmdDogdGlwQm91bmRzLmxlZnQgKyB0aGlzLnRpcEJvdW5kc1dpbmRvdy5zY3JvbGxYLFxuICAgICAgICBoZWlnaHQ6IHRoaXMudGlwQm91bmRzV2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICB3aWR0aDogdGhpcy50aXBCb3VuZHNXaW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kVGlwUG9zKFxuICBkaW1zOiBCb3gsXG4gIGJvdW5kczogQm94LFxuICB0aXBTaXplOiB7aGVpZ2h0OiBudW1iZXIsIHdpZHRoOiBudW1iZXJ9LFxuKSB7XG4gIGNvbnN0IHRpcEhlaWdodCA9IE1hdGgubWF4KHRpcFNpemUuaGVpZ2h0LCAyMCk7XG4gIGNvbnN0IHRpcFdpZHRoID0gTWF0aC5tYXgodGlwU2l6ZS53aWR0aCwgNjApO1xuICBjb25zdCBtYXJnaW4gPSA1O1xuXG4gIGxldCB0b3A6IG51bWJlciB8IHN0cmluZztcbiAgaWYgKGRpbXMudG9wICsgZGltcy5oZWlnaHQgKyB0aXBIZWlnaHQgPD0gYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQpIHtcbiAgICBpZiAoZGltcy50b3AgKyBkaW1zLmhlaWdodCA8IGJvdW5kcy50b3AgKyAwKSB7XG4gICAgICB0b3AgPSBib3VuZHMudG9wICsgbWFyZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSBkaW1zLnRvcCArIGRpbXMuaGVpZ2h0ICsgbWFyZ2luO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaW1zLnRvcCAtIHRpcEhlaWdodCA8PSBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCkge1xuICAgIGlmIChkaW1zLnRvcCAtIHRpcEhlaWdodCAtIG1hcmdpbiA8IGJvdW5kcy50b3AgKyBtYXJnaW4pIHtcbiAgICAgIHRvcCA9IGJvdW5kcy50b3AgKyBtYXJnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IGRpbXMudG9wIC0gdGlwSGVpZ2h0IC0gbWFyZ2luO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIHRpcEhlaWdodCAtIG1hcmdpbjtcbiAgfVxuXG4gIGxldCBsZWZ0OiBudW1iZXIgfCBzdHJpbmcgPSBkaW1zLmxlZnQgKyBtYXJnaW47XG4gIGlmIChkaW1zLmxlZnQgPCBib3VuZHMubGVmdCkge1xuICAgIGxlZnQgPSBib3VuZHMubGVmdCArIG1hcmdpbjtcbiAgfVxuICBpZiAoZGltcy5sZWZ0ICsgdGlwV2lkdGggPiBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCkge1xuICAgIGxlZnQgPSBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIHRpcFdpZHRoIC0gbWFyZ2luO1xuICB9XG5cbiAgdG9wICs9ICdweCc7XG4gIGxlZnQgKz0gJ3B4JztcbiAgcmV0dXJuIHtcbiAgICBzdHlsZToge3RvcCwgbGVmdH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJveFdyYXAoZGltczogYW55LCB3aGF0OiBzdHJpbmcsIG5vZGU6IEhUTUxFbGVtZW50KSB7XG4gIGFzc2lnbihub2RlLnN0eWxlLCB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IGRpbXNbd2hhdCArICdUb3AnXSArICdweCcsXG4gICAgYm9yZGVyTGVmdFdpZHRoOiBkaW1zW3doYXQgKyAnTGVmdCddICsgJ3B4JyxcbiAgICBib3JkZXJSaWdodFdpZHRoOiBkaW1zW3doYXQgKyAnUmlnaHQnXSArICdweCcsXG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IGRpbXNbd2hhdCArICdCb3R0b20nXSArICdweCcsXG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gIH0pO1xufVxuXG5jb25zdCBvdmVybGF5U3R5bGVzID0ge1xuICBiYWNrZ3JvdW5kOiAncmdiYSgxMjAsIDE3MCwgMjEwLCAwLjcpJyxcbiAgcGFkZGluZzogJ3JnYmEoNzcsIDIwMCwgMCwgMC4zKScsXG4gIG1hcmdpbjogJ3JnYmEoMjU1LCAxNTUsIDAsIDAuMyknLFxuICBib3JkZXI6ICdyZ2JhKDI1NSwgMjAwLCA1MCwgMC4zKScsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/views/Highlighter/Overlay.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/views/Highlighter/index.js":
/*!***********************************************************************!*\
  !*** ../react-devtools-shared/src/backend/views/Highlighter/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ setupHighlighter)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/agent */ \"../react-devtools-shared/src/backend/agent.js\");\n/* harmony import */ var _Highlighter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Highlighter */ \"../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n// This plug-in provides in-page highlighting of the selected element.\n// It is used by the browser extension and the standalone DevTools shell (when connected to a browser).\n// It is not currently the mechanism used to highlight React Native views.\n// That is done by the React Native Inspector component.\nvar iframesListeningTo = new Set();\nfunction setupHighlighter(bridge, agent) {\n  bridge.addListener('clearHostInstanceHighlight', clearHostInstanceHighlight);\n  bridge.addListener('highlightHostInstance', highlightHostInstance);\n  bridge.addListener('shutdown', stopInspectingHost);\n  bridge.addListener('startInspectingHost', startInspectingHost);\n  bridge.addListener('stopInspectingHost', stopInspectingHost);\n\n  function startInspectingHost() {\n    registerListenersOnWindow(window);\n  }\n\n  function registerListenersOnWindow(window) {\n    // This plug-in may run in non-DOM environments (e.g. React Native).\n    if (window && typeof window.addEventListener === 'function') {\n      window.addEventListener('click', onClick, true);\n      window.addEventListener('mousedown', onMouseEvent, true);\n      window.addEventListener('mouseover', onMouseEvent, true);\n      window.addEventListener('mouseup', onMouseEvent, true);\n      window.addEventListener('pointerdown', onPointerDown, true);\n      window.addEventListener('pointermove', onPointerMove, true);\n      window.addEventListener('pointerup', onPointerUp, true);\n    } else {\n      agent.emit('startInspectingNative');\n    }\n  }\n\n  function stopInspectingHost() {\n    (0,_Highlighter__WEBPACK_IMPORTED_MODULE_1__.hideOverlay)(agent);\n    removeListenersOnWindow(window);\n    iframesListeningTo.forEach(function (frame) {\n      try {\n        removeListenersOnWindow(frame.contentWindow);\n      } catch (error) {// This can error when the iframe is on a cross-origin.\n      }\n    });\n    iframesListeningTo = new Set();\n  }\n\n  function removeListenersOnWindow(window) {\n    // This plug-in may run in non-DOM environments (e.g. React Native).\n    if (window && typeof window.removeEventListener === 'function') {\n      window.removeEventListener('click', onClick, true);\n      window.removeEventListener('mousedown', onMouseEvent, true);\n      window.removeEventListener('mouseover', onMouseEvent, true);\n      window.removeEventListener('mouseup', onMouseEvent, true);\n      window.removeEventListener('pointerdown', onPointerDown, true);\n      window.removeEventListener('pointermove', onPointerMove, true);\n      window.removeEventListener('pointerup', onPointerUp, true);\n    } else {\n      agent.emit('stopInspectingNative');\n    }\n  }\n\n  function clearHostInstanceHighlight() {\n    (0,_Highlighter__WEBPACK_IMPORTED_MODULE_1__.hideOverlay)(agent);\n  }\n\n  function highlightHostInstance(_ref) {\n    var displayName = _ref.displayName,\n        hideAfterTimeout = _ref.hideAfterTimeout,\n        id = _ref.id,\n        openBuiltinElementsPanel = _ref.openBuiltinElementsPanel,\n        rendererID = _ref.rendererID,\n        scrollIntoView = _ref.scrollIntoView;\n    var renderer = agent.rendererInterfaces[rendererID];\n\n    if (renderer == null) {\n      console.warn(\"Invalid renderer id \\\"\".concat(rendererID, \"\\\" for element \\\"\").concat(id, \"\\\"\"));\n      (0,_Highlighter__WEBPACK_IMPORTED_MODULE_1__.hideOverlay)(agent);\n      return;\n    } // In some cases fiber may already be unmounted\n\n\n    if (!renderer.hasElementWithId(id)) {\n      (0,_Highlighter__WEBPACK_IMPORTED_MODULE_1__.hideOverlay)(agent);\n      return;\n    }\n\n    var nodes = renderer.findHostInstancesForElementID(id);\n\n    if (nodes != null && nodes[0] != null) {\n      var node = nodes[0]; // $FlowFixMe[method-unbinding]\n\n      if (scrollIntoView && typeof node.scrollIntoView === 'function') {\n        // If the node isn't visible show it before highlighting it.\n        // We may want to reconsider this; it might be a little disruptive.\n        node.scrollIntoView({\n          block: 'nearest',\n          inline: 'nearest'\n        });\n      }\n\n      (0,_Highlighter__WEBPACK_IMPORTED_MODULE_1__.showOverlay)(nodes, displayName, agent, hideAfterTimeout);\n\n      if (openBuiltinElementsPanel) {\n        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;\n        bridge.send('syncSelectionToBuiltinElementsPanel');\n      }\n    } else {\n      (0,_Highlighter__WEBPACK_IMPORTED_MODULE_1__.hideOverlay)(agent);\n    }\n  }\n\n  function onClick(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    stopInspectingHost();\n    bridge.send('stopInspectingHost', true);\n  }\n\n  function onMouseEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  function onPointerDown(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    selectElementForNode(getEventTarget(event));\n  }\n\n  var lastHoveredNode = null;\n\n  function onPointerMove(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    var target = getEventTarget(event);\n    if (lastHoveredNode === target) return;\n    lastHoveredNode = target;\n\n    if (target.tagName === 'IFRAME') {\n      var iframe = target;\n\n      try {\n        if (!iframesListeningTo.has(iframe)) {\n          var _window = iframe.contentWindow;\n          registerListenersOnWindow(_window);\n          iframesListeningTo.add(iframe);\n        }\n      } catch (error) {// This can error when the iframe is on a cross-origin.\n      }\n    } // Don't pass the name explicitly.\n    // It will be inferred from DOM tag and Fiber owner.\n\n\n    (0,_Highlighter__WEBPACK_IMPORTED_MODULE_1__.showOverlay)([target], null, agent, false);\n    selectElementForNode(target);\n  }\n\n  function onPointerUp(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  var selectElementForNode = function selectElementForNode(node) {\n    var id = agent.getIDForHostInstance(node);\n\n    if (id !== null) {\n      bridge.send('selectElement', id);\n    }\n  };\n\n  function getEventTarget(event) {\n    if (event.composed) {\n      return event.composedPath()[0];\n    }\n\n    return event.target;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL0hpZ2hsaWdodGVyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFlQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL0hpZ2hsaWdodGVyL2luZGV4LmpzP2MxZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IEFnZW50IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9hZ2VudCc7XG5pbXBvcnQge2hpZGVPdmVybGF5LCBzaG93T3ZlcmxheX0gZnJvbSAnLi9IaWdobGlnaHRlcic7XG5cbmltcG9ydCB0eXBlIHtCYWNrZW5kQnJpZGdlfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JyaWRnZSc7XG5cbi8vIFRoaXMgcGx1Zy1pbiBwcm92aWRlcyBpbi1wYWdlIGhpZ2hsaWdodGluZyBvZiB0aGUgc2VsZWN0ZWQgZWxlbWVudC5cbi8vIEl0IGlzIHVzZWQgYnkgdGhlIGJyb3dzZXIgZXh0ZW5zaW9uIGFuZCB0aGUgc3RhbmRhbG9uZSBEZXZUb29scyBzaGVsbCAod2hlbiBjb25uZWN0ZWQgdG8gYSBicm93c2VyKS5cbi8vIEl0IGlzIG5vdCBjdXJyZW50bHkgdGhlIG1lY2hhbmlzbSB1c2VkIHRvIGhpZ2hsaWdodCBSZWFjdCBOYXRpdmUgdmlld3MuXG4vLyBUaGF0IGlzIGRvbmUgYnkgdGhlIFJlYWN0IE5hdGl2ZSBJbnNwZWN0b3IgY29tcG9uZW50LlxuXG5sZXQgaWZyYW1lc0xpc3RlbmluZ1RvOiBTZXQ8SFRNTElGcmFtZUVsZW1lbnQ+ID0gbmV3IFNldCgpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cEhpZ2hsaWdodGVyKFxuICBicmlkZ2U6IEJhY2tlbmRCcmlkZ2UsXG4gIGFnZW50OiBBZ2VudCxcbik6IHZvaWQge1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2NsZWFySG9zdEluc3RhbmNlSGlnaGxpZ2h0JywgY2xlYXJIb3N0SW5zdGFuY2VIaWdobGlnaHQpO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2hpZ2hsaWdodEhvc3RJbnN0YW5jZScsIGhpZ2hsaWdodEhvc3RJbnN0YW5jZSk7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCBzdG9wSW5zcGVjdGluZ0hvc3QpO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0YXJ0SW5zcGVjdGluZ0hvc3QnLCBzdGFydEluc3BlY3RpbmdIb3N0KTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdzdG9wSW5zcGVjdGluZ0hvc3QnLCBzdG9wSW5zcGVjdGluZ0hvc3QpO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0SW5zcGVjdGluZ0hvc3QoKSB7XG4gICAgcmVnaXN0ZXJMaXN0ZW5lcnNPbldpbmRvdyh3aW5kb3cpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnNPbldpbmRvdyh3aW5kb3c6IGFueSkge1xuICAgIC8vIFRoaXMgcGx1Zy1pbiBtYXkgcnVuIGluIG5vbi1ET00gZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSkuXG4gICAgaWYgKHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2VudC5lbWl0KCdzdGFydEluc3BlY3RpbmdOYXRpdmUnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wSW5zcGVjdGluZ0hvc3QoKSB7XG4gICAgaGlkZU92ZXJsYXkoYWdlbnQpO1xuICAgIHJlbW92ZUxpc3RlbmVyc09uV2luZG93KHdpbmRvdyk7XG4gICAgaWZyYW1lc0xpc3RlbmluZ1RvLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnNPbldpbmRvdyhmcmFtZS5jb250ZW50V2luZG93KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoaXMgY2FuIGVycm9yIHdoZW4gdGhlIGlmcmFtZSBpcyBvbiBhIGNyb3NzLW9yaWdpbi5cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZnJhbWVzTGlzdGVuaW5nVG8gPSBuZXcgU2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnNPbldpbmRvdyh3aW5kb3c6IGFueSkge1xuICAgIC8vIFRoaXMgcGx1Zy1pbiBtYXkgcnVuIGluIG5vbi1ET00gZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSkuXG4gICAgaWYgKHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2VudC5lbWl0KCdzdG9wSW5zcGVjdGluZ05hdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFySG9zdEluc3RhbmNlSGlnaGxpZ2h0KCkge1xuICAgIGhpZGVPdmVybGF5KGFnZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEhvc3RJbnN0YW5jZSh7XG4gICAgZGlzcGxheU5hbWUsXG4gICAgaGlkZUFmdGVyVGltZW91dCxcbiAgICBpZCxcbiAgICBvcGVuQnVpbHRpbkVsZW1lbnRzUGFuZWwsXG4gICAgcmVuZGVyZXJJRCxcbiAgICBzY3JvbGxJbnRvVmlldyxcbiAgfToge1xuICAgIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsLFxuICAgIGhpZGVBZnRlclRpbWVvdXQ6IGJvb2xlYW4sXG4gICAgaWQ6IG51bWJlcixcbiAgICBvcGVuQnVpbHRpbkVsZW1lbnRzUGFuZWw6IGJvb2xlYW4sXG4gICAgcmVuZGVyZXJJRDogbnVtYmVyLFxuICAgIHNjcm9sbEludG9WaWV3OiBib29sZWFuLFxuICAgIC4uLlxuICB9KSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBhZ2VudC5yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG4gICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCByZW5kZXJlciBpZCBcIiR7cmVuZGVyZXJJRH1cIiBmb3IgZWxlbWVudCBcIiR7aWR9XCJgKTtcblxuICAgICAgaGlkZU92ZXJsYXkoYWdlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIHNvbWUgY2FzZXMgZmliZXIgbWF5IGFscmVhZHkgYmUgdW5tb3VudGVkXG4gICAgaWYgKCFyZW5kZXJlci5oYXNFbGVtZW50V2l0aElkKGlkKSkge1xuICAgICAgaGlkZU92ZXJsYXkoYWdlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gcmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZXNGb3JFbGVtZW50SUQoaWQpO1xuXG4gICAgaWYgKG5vZGVzICE9IG51bGwgJiYgbm9kZXNbMF0gIT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgaWYgKHNjcm9sbEludG9WaWV3ICYmIHR5cGVvZiBub2RlLnNjcm9sbEludG9WaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHRoZSBub2RlIGlzbid0IHZpc2libGUgc2hvdyBpdCBiZWZvcmUgaGlnaGxpZ2h0aW5nIGl0LlxuICAgICAgICAvLyBXZSBtYXkgd2FudCB0byByZWNvbnNpZGVyIHRoaXM7IGl0IG1pZ2h0IGJlIGEgbGl0dGxlIGRpc3J1cHRpdmUuXG4gICAgICAgIG5vZGUuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiAnbmVhcmVzdCcsIGlubGluZTogJ25lYXJlc3QnfSk7XG4gICAgICB9XG5cbiAgICAgIHNob3dPdmVybGF5KG5vZGVzLCBkaXNwbGF5TmFtZSwgYWdlbnQsIGhpZGVBZnRlclRpbWVvdXQpO1xuXG4gICAgICBpZiAob3BlbkJ1aWx0aW5FbGVtZW50c1BhbmVsKSB7XG4gICAgICAgIHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uJDAgPSBub2RlO1xuICAgICAgICBicmlkZ2Uuc2VuZCgnc3luY1NlbGVjdGlvblRvQnVpbHRpbkVsZW1lbnRzUGFuZWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZU92ZXJsYXkoYWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgc3RvcEluc3BlY3RpbmdIb3N0KCk7XG5cbiAgICBicmlkZ2Uuc2VuZCgnc3RvcEluc3BlY3RpbmdIb3N0JywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlRXZlbnQoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudDogTW91c2VFdmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBzZWxlY3RFbGVtZW50Rm9yTm9kZShnZXRFdmVudFRhcmdldChldmVudCkpO1xuICB9XG5cbiAgbGV0IGxhc3RIb3ZlcmVkTm9kZTogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudDogTW91c2VFdmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmIChsYXN0SG92ZXJlZE5vZGUgPT09IHRhcmdldCkgcmV0dXJuO1xuICAgIGxhc3RIb3ZlcmVkTm9kZSA9IHRhcmdldDtcblxuICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lGUkFNRScpIHtcbiAgICAgIGNvbnN0IGlmcmFtZTogSFRNTElGcmFtZUVsZW1lbnQgPSAodGFyZ2V0OiBhbnkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpZnJhbWVzTGlzdGVuaW5nVG8uaGFzKGlmcmFtZSkpIHtcbiAgICAgICAgICBjb25zdCB3aW5kb3cgPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICAgICAgICByZWdpc3Rlckxpc3RlbmVyc09uV2luZG93KHdpbmRvdyk7XG4gICAgICAgICAgaWZyYW1lc0xpc3RlbmluZ1RvLmFkZChpZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGlzIGNhbiBlcnJvciB3aGVuIHRoZSBpZnJhbWUgaXMgb24gYSBjcm9zcy1vcmlnaW4uXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcGFzcyB0aGUgbmFtZSBleHBsaWNpdGx5LlxuICAgIC8vIEl0IHdpbGwgYmUgaW5mZXJyZWQgZnJvbSBET00gdGFnIGFuZCBGaWJlciBvd25lci5cbiAgICBzaG93T3ZlcmxheShbdGFyZ2V0XSwgbnVsbCwgYWdlbnQsIGZhbHNlKTtcblxuICAgIHNlbGVjdEVsZW1lbnRGb3JOb2RlKHRhcmdldCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudDogTW91c2VFdmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBjb25zdCBzZWxlY3RFbGVtZW50Rm9yTm9kZSA9IChub2RlOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGlkID0gYWdlbnQuZ2V0SURGb3JIb3N0SW5zdGFuY2Uobm9kZSk7XG4gICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICBicmlkZ2Uuc2VuZCgnc2VsZWN0RWxlbWVudCcsIGlkKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoZXZlbnQ6IE1vdXNlRXZlbnQpOiBIVE1MRWxlbWVudCB7XG4gICAgaWYgKGV2ZW50LmNvbXBvc2VkKSB7XG4gICAgICByZXR1cm4gKGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdOiBhbnkpO1xuICAgIH1cblxuICAgIHJldHVybiAoZXZlbnQudGFyZ2V0OiBhbnkpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/views/Highlighter/index.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js":
/*!*************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"destroy\": () => (/* binding */ destroy),\n/* harmony export */   \"draw\": () => (/* binding */ draw),\n/* harmony export */   \"groupAndSortNodes\": () => (/* binding */ groupAndSortNodes)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n // Note these colors are in sync with DevTools Profiler chart colors.\n\nvar COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];\nvar canvas = null;\n\nfunction drawNative(nodeToData, agent) {\n  var nodesToDraw = [];\n  iterateNodes(nodeToData, function (_ref) {\n    var color = _ref.color,\n        node = _ref.node;\n    nodesToDraw.push({\n      node: node,\n      color: color\n    });\n  });\n  agent.emit('drawTraceUpdates', nodesToDraw);\n  var mergedNodes = groupAndSortNodes(nodeToData);\n  agent.emit('drawGroupedTraceUpdatesWithNames', mergedNodes);\n}\n\nfunction drawWeb(nodeToData) {\n  if (canvas === null) {\n    initialize();\n  }\n\n  var dpr = window.devicePixelRatio || 1;\n  var canvasFlow = canvas;\n  canvasFlow.width = window.innerWidth * dpr;\n  canvasFlow.height = window.innerHeight * dpr;\n  canvasFlow.style.width = \"\".concat(window.innerWidth, \"px\");\n  canvasFlow.style.height = \"\".concat(window.innerHeight, \"px\");\n  var context = canvasFlow.getContext('2d');\n  context.scale(dpr, dpr);\n  context.clearRect(0, 0, canvasFlow.width / dpr, canvasFlow.height / dpr);\n  var mergedNodes = groupAndSortNodes(nodeToData);\n  mergedNodes.forEach(function (group) {\n    drawGroupBorders(context, group);\n    drawGroupLabel(context, group);\n  });\n}\n\nfunction groupAndSortNodes(nodeToData) {\n  var positionGroups = new Map();\n  iterateNodes(nodeToData, function (_ref2) {\n    var _positionGroups$get;\n\n    var rect = _ref2.rect,\n        color = _ref2.color,\n        displayName = _ref2.displayName,\n        count = _ref2.count;\n    if (!rect) return;\n    var key = \"\".concat(rect.left, \",\").concat(rect.top);\n    if (!positionGroups.has(key)) positionGroups.set(key, []);\n    (_positionGroups$get = positionGroups.get(key)) === null || _positionGroups$get === void 0 ? void 0 : _positionGroups$get.push({\n      rect: rect,\n      color: color,\n      displayName: displayName,\n      count: count\n    });\n  });\n  return Array.from(positionGroups.values()).sort(function (groupA, groupB) {\n    var maxCountA = Math.max.apply(Math, _toConsumableArray(groupA.map(function (item) {\n      return item.count;\n    })));\n    var maxCountB = Math.max.apply(Math, _toConsumableArray(groupB.map(function (item) {\n      return item.count;\n    })));\n    return maxCountA - maxCountB;\n  });\n}\n\nfunction drawGroupBorders(context, group) {\n  group.forEach(function (_ref3) {\n    var color = _ref3.color,\n        rect = _ref3.rect;\n    context.beginPath();\n    context.strokeStyle = color;\n    context.rect(rect.left, rect.top, rect.width - 1, rect.height - 1);\n    context.stroke();\n  });\n}\n\nfunction drawGroupLabel(context, group) {\n  var mergedName = group.map(function (_ref4) {\n    var displayName = _ref4.displayName,\n        count = _ref4.count;\n    return displayName ? \"\".concat(displayName).concat(count > 1 ? \" x\".concat(count) : '') : '';\n  }).filter(Boolean).join(', ');\n\n  if (mergedName) {\n    drawLabel(context, group[0].rect, mergedName, group[0].color);\n  }\n}\n\nfunction draw(nodeToData, agent) {\n  return (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_0__.isReactNativeEnvironment)() ? drawNative(nodeToData, agent) : drawWeb(nodeToData);\n}\n\nfunction iterateNodes(nodeToData, execute) {\n  nodeToData.forEach(function (data, node) {\n    var colorIndex = Math.min(COLORS.length - 1, data.count - 1);\n    var color = COLORS[colorIndex];\n    execute({\n      color: color,\n      node: node,\n      count: data.count,\n      displayName: data.displayName,\n      expirationTime: data.expirationTime,\n      lastMeasuredAt: data.lastMeasuredAt,\n      rect: data.rect\n    });\n  });\n}\n\nfunction drawLabel(context, rect, text, color) {\n  var left = rect.left,\n      top = rect.top;\n  context.font = '10px monospace';\n  context.textBaseline = 'middle';\n  context.textAlign = 'center';\n  var padding = 2;\n  var textHeight = 14;\n  var metrics = context.measureText(text);\n  var backgroundWidth = metrics.width + padding * 2;\n  var backgroundHeight = textHeight;\n  var labelX = left;\n  var labelY = top - backgroundHeight;\n  context.fillStyle = color;\n  context.fillRect(labelX, labelY, backgroundWidth, backgroundHeight);\n  context.fillStyle = '#000000';\n  context.fillText(text, labelX + backgroundWidth / 2, labelY + backgroundHeight / 2);\n}\n\nfunction destroyNative(agent) {\n  agent.emit('disableTraceUpdates');\n}\n\nfunction destroyWeb() {\n  if (canvas !== null) {\n    if (canvas.parentNode != null) {\n      canvas.parentNode.removeChild(canvas);\n    }\n\n    canvas = null;\n  }\n}\n\nfunction destroy(agent) {\n  return (0,react_devtools_shared_src_backend_utils__WEBPACK_IMPORTED_MODULE_0__.isReactNativeEnvironment)() ? destroyNative(agent) : destroyWeb();\n}\n\nfunction initialize() {\n  canvas = window.document.createElement('canvas');\n  canvas.style.cssText = \"\\n    xx-background-color: red;\\n    xx-opacity: 0.5;\\n    bottom: 0;\\n    left: 0;\\n    pointer-events: none;\\n    position: fixed;\\n    right: 0;\\n    top: 0;\\n    z-index: 1000000000;\\n  \";\n  var root = window.document.documentElement;\n  root.insertBefore(canvas, root.firstChild);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL1RyYWNlVXBkYXRlcy9jYW52YXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQWNBOztBQUdBO0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBV0E7QUFHQTtBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBUUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBOztBQUVBO0FBS0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy9UcmFjZVVwZGF0ZXMvY2FudmFzLmpzPzUyNGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0RhdGF9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHR5cGUge1JlY3R9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHtIb3N0SW5zdGFuY2V9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIEFnZW50IGZyb20gJy4uLy4uL2FnZW50JztcblxuaW1wb3J0IHtpc1JlYWN0TmF0aXZlRW52aXJvbm1lbnR9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC91dGlscyc7XG5cbi8vIE5vdGUgdGhlc2UgY29sb3JzIGFyZSBpbiBzeW5jIHdpdGggRGV2VG9vbHMgUHJvZmlsZXIgY2hhcnQgY29sb3JzLlxuY29uc3QgQ09MT1JTID0gW1xuICAnIzM3YWZhOScsXG4gICcjNjNiMTllJyxcbiAgJyM4MGIzOTMnLFxuICAnIzk3YjQ4OCcsXG4gICcjYWJiNjdkJyxcbiAgJyNiZWI3NzEnLFxuICAnI2NmYjk2NScsXG4gICcjZGZiYTU3JyxcbiAgJyNlZmJiNDknLFxuICAnI2ZlYmMzOCcsXG5dO1xuXG5sZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBkcmF3TmF0aXZlKG5vZGVUb0RhdGE6IE1hcDxIb3N0SW5zdGFuY2UsIERhdGE+LCBhZ2VudDogQWdlbnQpIHtcbiAgY29uc3Qgbm9kZXNUb0RyYXcgPSBbXTtcbiAgaXRlcmF0ZU5vZGVzKG5vZGVUb0RhdGEsICh7Y29sb3IsIG5vZGV9KSA9PiB7XG4gICAgbm9kZXNUb0RyYXcucHVzaCh7bm9kZSwgY29sb3J9KTtcbiAgfSk7XG5cbiAgYWdlbnQuZW1pdCgnZHJhd1RyYWNlVXBkYXRlcycsIG5vZGVzVG9EcmF3KTtcblxuICBjb25zdCBtZXJnZWROb2RlcyA9IGdyb3VwQW5kU29ydE5vZGVzKG5vZGVUb0RhdGEpO1xuICBhZ2VudC5lbWl0KCdkcmF3R3JvdXBlZFRyYWNlVXBkYXRlc1dpdGhOYW1lcycsIG1lcmdlZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gZHJhd1dlYihub2RlVG9EYXRhOiBNYXA8SG9zdEluc3RhbmNlLCBEYXRhPikge1xuICBpZiAoY2FudmFzID09PSBudWxsKSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgY29uc3QgY2FudmFzRmxvdzogSFRNTENhbnZhc0VsZW1lbnQgPSAoKGNhbnZhczogYW55KTogSFRNTENhbnZhc0VsZW1lbnQpO1xuICBjYW52YXNGbG93LndpZHRoID0gd2luZG93LmlubmVyV2lkdGggKiBkcHI7XG4gIGNhbnZhc0Zsb3cuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICogZHByO1xuICBjYW52YXNGbG93LnN0eWxlLndpZHRoID0gYCR7d2luZG93LmlubmVyV2lkdGh9cHhgO1xuICBjYW52YXNGbG93LnN0eWxlLmhlaWdodCA9IGAke3dpbmRvdy5pbm5lckhlaWdodH1weGA7XG5cbiAgY29uc3QgY29udGV4dCA9IGNhbnZhc0Zsb3cuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY29udGV4dC5zY2FsZShkcHIsIGRwcik7XG5cbiAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzRmxvdy53aWR0aCAvIGRwciwgY2FudmFzRmxvdy5oZWlnaHQgLyBkcHIpO1xuXG4gIGNvbnN0IG1lcmdlZE5vZGVzID0gZ3JvdXBBbmRTb3J0Tm9kZXMobm9kZVRvRGF0YSk7XG5cbiAgbWVyZ2VkTm9kZXMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgZHJhd0dyb3VwQm9yZGVycyhjb250ZXh0LCBncm91cCk7XG4gICAgZHJhd0dyb3VwTGFiZWwoY29udGV4dCwgZ3JvdXApO1xuICB9KTtcbn1cblxudHlwZSBHcm91cEl0ZW0gPSB7XG4gIHJlY3Q6IFJlY3QsXG4gIGNvbG9yOiBzdHJpbmcsXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsLFxuICBjb3VudDogbnVtYmVyLFxufTtcblxuZXhwb3J0IHR5cGUge0dyb3VwSXRlbX07XG5cbmV4cG9ydCBmdW5jdGlvbiBncm91cEFuZFNvcnROb2RlcyhcbiAgbm9kZVRvRGF0YTogTWFwPEhvc3RJbnN0YW5jZSwgRGF0YT4sXG4pOiBBcnJheTxBcnJheTxHcm91cEl0ZW0+PiB7XG4gIGNvbnN0IHBvc2l0aW9uR3JvdXBzOiBNYXA8c3RyaW5nLCBBcnJheTxHcm91cEl0ZW0+PiA9IG5ldyBNYXAoKTtcblxuICBpdGVyYXRlTm9kZXMobm9kZVRvRGF0YSwgKHtyZWN0LCBjb2xvciwgZGlzcGxheU5hbWUsIGNvdW50fSkgPT4ge1xuICAgIGlmICghcmVjdCkgcmV0dXJuO1xuICAgIGNvbnN0IGtleSA9IGAke3JlY3QubGVmdH0sJHtyZWN0LnRvcH1gO1xuICAgIGlmICghcG9zaXRpb25Hcm91cHMuaGFzKGtleSkpIHBvc2l0aW9uR3JvdXBzLnNldChrZXksIFtdKTtcbiAgICBwb3NpdGlvbkdyb3Vwcy5nZXQoa2V5KT8ucHVzaCh7cmVjdCwgY29sb3IsIGRpc3BsYXlOYW1lLCBjb3VudH0pO1xuICB9KTtcblxuICByZXR1cm4gQXJyYXkuZnJvbShwb3NpdGlvbkdyb3Vwcy52YWx1ZXMoKSkuc29ydCgoZ3JvdXBBLCBncm91cEIpID0+IHtcbiAgICBjb25zdCBtYXhDb3VudEEgPSBNYXRoLm1heCguLi5ncm91cEEubWFwKGl0ZW0gPT4gaXRlbS5jb3VudCkpO1xuICAgIGNvbnN0IG1heENvdW50QiA9IE1hdGgubWF4KC4uLmdyb3VwQi5tYXAoaXRlbSA9PiBpdGVtLmNvdW50KSk7XG4gICAgcmV0dXJuIG1heENvdW50QSAtIG1heENvdW50QjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRyYXdHcm91cEJvcmRlcnMoXG4gIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZ3JvdXA6IEFycmF5PEdyb3VwSXRlbT4sXG4pIHtcbiAgZ3JvdXAuZm9yRWFjaCgoe2NvbG9yLCByZWN0fSkgPT4ge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQucmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LndpZHRoIC0gMSwgcmVjdC5oZWlnaHQgLSAxKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZHJhd0dyb3VwTGFiZWwoXG4gIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZ3JvdXA6IEFycmF5PEdyb3VwSXRlbT4sXG4pIHtcbiAgY29uc3QgbWVyZ2VkTmFtZSA9IGdyb3VwXG4gICAgLm1hcCgoe2Rpc3BsYXlOYW1lLCBjb3VudH0pID0+XG4gICAgICBkaXNwbGF5TmFtZSA/IGAke2Rpc3BsYXlOYW1lfSR7Y291bnQgPiAxID8gYCB4JHtjb3VudH1gIDogJyd9YCA6ICcnLFxuICAgIClcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmpvaW4oJywgJyk7XG5cbiAgaWYgKG1lcmdlZE5hbWUpIHtcbiAgICBkcmF3TGFiZWwoY29udGV4dCwgZ3JvdXBbMF0ucmVjdCwgbWVyZ2VkTmFtZSwgZ3JvdXBbMF0uY29sb3IpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3KG5vZGVUb0RhdGE6IE1hcDxIb3N0SW5zdGFuY2UsIERhdGE+LCBhZ2VudDogQWdlbnQpOiB2b2lkIHtcbiAgcmV0dXJuIGlzUmVhY3ROYXRpdmVFbnZpcm9ubWVudCgpXG4gICAgPyBkcmF3TmF0aXZlKG5vZGVUb0RhdGEsIGFnZW50KVxuICAgIDogZHJhd1dlYihub2RlVG9EYXRhKTtcbn1cblxudHlwZSBEYXRhV2l0aENvbG9yQW5kTm9kZSA9IHtcbiAgLi4uRGF0YSxcbiAgY29sb3I6IHN0cmluZyxcbiAgbm9kZTogSG9zdEluc3RhbmNlLFxufTtcblxuZnVuY3Rpb24gaXRlcmF0ZU5vZGVzKFxuICBub2RlVG9EYXRhOiBNYXA8SG9zdEluc3RhbmNlLCBEYXRhPixcbiAgZXhlY3V0ZTogKGRhdGE6IERhdGFXaXRoQ29sb3JBbmROb2RlKSA9PiB2b2lkLFxuKSB7XG4gIG5vZGVUb0RhdGEuZm9yRWFjaCgoZGF0YSwgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGNvbG9ySW5kZXggPSBNYXRoLm1pbihDT0xPUlMubGVuZ3RoIC0gMSwgZGF0YS5jb3VudCAtIDEpO1xuICAgIGNvbnN0IGNvbG9yID0gQ09MT1JTW2NvbG9ySW5kZXhdO1xuICAgIGV4ZWN1dGUoe1xuICAgICAgY29sb3IsXG4gICAgICBub2RlLFxuICAgICAgY291bnQ6IGRhdGEuY291bnQsXG4gICAgICBkaXNwbGF5TmFtZTogZGF0YS5kaXNwbGF5TmFtZSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBkYXRhLmV4cGlyYXRpb25UaW1lLFxuICAgICAgbGFzdE1lYXN1cmVkQXQ6IGRhdGEubGFzdE1lYXN1cmVkQXQsXG4gICAgICByZWN0OiBkYXRhLnJlY3QsXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkcmF3TGFiZWwoXG4gIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcmVjdDogUmVjdCxcbiAgdGV4dDogc3RyaW5nLFxuICBjb2xvcjogc3RyaW5nLFxuKTogdm9pZCB7XG4gIGNvbnN0IHtsZWZ0LCB0b3B9ID0gcmVjdDtcbiAgY29udGV4dC5mb250ID0gJzEwcHggbW9ub3NwYWNlJztcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblxuICBjb25zdCBwYWRkaW5nID0gMjtcbiAgY29uc3QgdGV4dEhlaWdodCA9IDE0O1xuXG4gIGNvbnN0IG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICBjb25zdCBiYWNrZ3JvdW5kV2lkdGggPSBtZXRyaWNzLndpZHRoICsgcGFkZGluZyAqIDI7XG4gIGNvbnN0IGJhY2tncm91bmRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICBjb25zdCBsYWJlbFggPSBsZWZ0O1xuICBjb25zdCBsYWJlbFkgPSB0b3AgLSBiYWNrZ3JvdW5kSGVpZ2h0O1xuXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gIGNvbnRleHQuZmlsbFJlY3QobGFiZWxYLCBsYWJlbFksIGJhY2tncm91bmRXaWR0aCwgYmFja2dyb3VuZEhlaWdodCk7XG5cbiAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMDAwMCc7XG4gIGNvbnRleHQuZmlsbFRleHQoXG4gICAgdGV4dCxcbiAgICBsYWJlbFggKyBiYWNrZ3JvdW5kV2lkdGggLyAyLFxuICAgIGxhYmVsWSArIGJhY2tncm91bmRIZWlnaHQgLyAyLFxuICApO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95TmF0aXZlKGFnZW50OiBBZ2VudCkge1xuICBhZ2VudC5lbWl0KCdkaXNhYmxlVHJhY2VVcGRhdGVzJyk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lXZWIoKSB7XG4gIGlmIChjYW52YXMgIT09IG51bGwpIHtcbiAgICBpZiAoY2FudmFzLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICB9XG4gICAgY2FudmFzID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveShhZ2VudDogQWdlbnQpOiB2b2lkIHtcbiAgcmV0dXJuIGlzUmVhY3ROYXRpdmVFbnZpcm9ubWVudCgpID8gZGVzdHJveU5hdGl2ZShhZ2VudCkgOiBkZXN0cm95V2ViKCk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoKTogdm9pZCB7XG4gIGNhbnZhcyA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgeHgtYmFja2dyb3VuZC1jb2xvcjogcmVkO1xuICAgIHh4LW9wYWNpdHk6IDAuNTtcbiAgICBib3R0b206IDA7XG4gICAgbGVmdDogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgcmlnaHQ6IDA7XG4gICAgdG9wOiAwO1xuICAgIHotaW5kZXg6IDEwMDAwMDAwMDA7XG4gIGA7XG5cbiAgY29uc3Qgcm9vdCA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHJvb3QuaW5zZXJ0QmVmb3JlKGNhbnZhcywgcm9vdC5maXJzdENoaWxkKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/views/TraceUpdates/index.js":
/*!************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/views/TraceUpdates/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initialize\": () => (/* binding */ initialize),\n/* harmony export */   \"toggleEnabled\": () => (/* binding */ toggleEnabled)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_backend_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/backend/agent */ \"../react-devtools-shared/src/backend/agent.js\");\n/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas */ \"../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"../react-devtools-shared/src/backend/views/utils.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n// How long the rect should be shown for?\nvar DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?\n// This can be important if we're getting a flurry of events (e.g. scroll update).\n\nvar MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?\n\nvar REMEASUREMENT_AFTER_DURATION = 250; // Markers for different types of HOCs\n\nvar HOC_MARKERS = new Map([['Forget', '✨'], ['Memo', '🧠']]); // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\nvar getCurrentTime = // $FlowFixMe[method-unbinding]\n(typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nvar nodeToData = new Map();\nvar agent = null;\nvar drawAnimationFrameID = null;\nvar isEnabled = false;\nvar redrawTimeoutID = null;\nfunction initialize(injectedAgent) {\n  agent = injectedAgent;\n  agent.addListener('traceUpdates', traceUpdates);\n}\nfunction toggleEnabled(value) {\n  isEnabled = value;\n\n  if (!isEnabled) {\n    nodeToData.clear();\n\n    if (drawAnimationFrameID !== null) {\n      cancelAnimationFrame(drawAnimationFrameID);\n      drawAnimationFrameID = null;\n    }\n\n    if (redrawTimeoutID !== null) {\n      clearTimeout(redrawTimeoutID);\n      redrawTimeoutID = null;\n    }\n\n    (0,_canvas__WEBPACK_IMPORTED_MODULE_1__.destroy)(agent);\n  }\n}\n\nfunction traceUpdates(nodes) {\n  if (!isEnabled) return;\n  nodes.forEach(function (node) {\n    var data = nodeToData.get(node);\n    var now = getCurrentTime();\n    var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;\n    var rect = data != null ? data.rect : null;\n\n    if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {\n      lastMeasuredAt = now;\n      rect = measureNode(node);\n    }\n\n    var displayName = agent.getComponentNameForHostInstance(node);\n\n    if (displayName) {\n      var _extractHOCNames = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.extractHOCNames)(displayName),\n          baseComponentName = _extractHOCNames.baseComponentName,\n          hocNames = _extractHOCNames.hocNames;\n\n      var markers = hocNames.map(function (hoc) {\n        return HOC_MARKERS.get(hoc) || '';\n      }).join('');\n      var enhancedDisplayName = markers ? \"\".concat(markers).concat(baseComponentName) : baseComponentName;\n      displayName = enhancedDisplayName;\n    }\n\n    nodeToData.set(node, {\n      count: data != null ? data.count + 1 : 1,\n      expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,\n      lastMeasuredAt: lastMeasuredAt,\n      rect: rect,\n      displayName: displayName\n    });\n  });\n\n  if (redrawTimeoutID !== null) {\n    clearTimeout(redrawTimeoutID);\n    redrawTimeoutID = null;\n  }\n\n  if (drawAnimationFrameID === null) {\n    drawAnimationFrameID = requestAnimationFrame(prepareToDraw);\n  }\n}\n\nfunction prepareToDraw() {\n  drawAnimationFrameID = null;\n  redrawTimeoutID = null;\n  var now = getCurrentTime();\n  var earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.\n\n  nodeToData.forEach(function (data, node) {\n    if (data.expirationTime < now) {\n      nodeToData.delete(node);\n    } else {\n      earliestExpiration = Math.min(earliestExpiration, data.expirationTime);\n    }\n  });\n  (0,_canvas__WEBPACK_IMPORTED_MODULE_1__.draw)(nodeToData, agent);\n\n  if (earliestExpiration !== Number.MAX_VALUE) {\n    redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);\n  }\n}\n\nfunction measureNode(node) {\n  if (!node || typeof node.getBoundingClientRect !== 'function') {\n    return null;\n  }\n\n  var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n  return (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getNestedBoundingClientRect)(node, currentWindow);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL1RyYWNlVXBkYXRlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUdBOztBQUNBOztBQUdBOztBQUdBOztBQU1BO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFBQTtBQUFBO0FBRUE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQVhBO0FBYUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy9UcmFjZVVwZGF0ZXMvaW5kZXguanM/NzUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgQWdlbnQgZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2FnZW50JztcbmltcG9ydCB7ZGVzdHJveSBhcyBkZXN0cm95Q2FudmFzLCBkcmF3fSBmcm9tICcuL2NhbnZhcyc7XG5pbXBvcnQge2V4dHJhY3RIT0NOYW1lcywgZ2V0TmVzdGVkQm91bmRpbmdDbGllbnRSZWN0fSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB0eXBlIHtIb3N0SW5zdGFuY2V9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHtSZWN0fSBmcm9tICcuLi91dGlscyc7XG5cbi8vIEhvdyBsb25nIHRoZSByZWN0IHNob3VsZCBiZSBzaG93biBmb3I/XG5jb25zdCBESVNQTEFZX0RVUkFUSU9OID0gMjUwO1xuXG4vLyBXaGF0J3MgdGhlIGxvbmdlc3Qgd2UgYXJlIHdpbGxpbmcgdG8gc2hvdyB0aGUgb3ZlcmxheSBmb3I/XG4vLyBUaGlzIGNhbiBiZSBpbXBvcnRhbnQgaWYgd2UncmUgZ2V0dGluZyBhIGZsdXJyeSBvZiBldmVudHMgKGUuZy4gc2Nyb2xsIHVwZGF0ZSkuXG5jb25zdCBNQVhfRElTUExBWV9EVVJBVElPTiA9IDMwMDA7XG5cbi8vIEhvdyBsb25nIHNob3VsZCBhIHJlY3QgYmUgY29uc2lkZXJlZCB2YWxpZCBmb3I/XG5jb25zdCBSRU1FQVNVUkVNRU5UX0FGVEVSX0RVUkFUSU9OID0gMjUwO1xuXG4vLyBNYXJrZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgSE9Dc1xuY29uc3QgSE9DX01BUktFUlMgPSBuZXcgTWFwKFtcbiAgWydGb3JnZXQnLCAn4pyoJ10sXG4gIFsnTWVtbycsICfwn6egJ10sXG5dKTtcblxuLy8gU29tZSBlbnZpcm9ubWVudHMgKGUuZy4gUmVhY3QgTmF0aXZlIC8gSGVybWVzKSBkb24ndCBzdXBwb3J0IHRoZSBwZXJmb3JtYW5jZSBBUEkgeWV0LlxuY29uc3QgZ2V0Q3VycmVudFRpbWUgPVxuICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5cbmV4cG9ydCB0eXBlIERhdGEgPSB7XG4gIGNvdW50OiBudW1iZXIsXG4gIGV4cGlyYXRpb25UaW1lOiBudW1iZXIsXG4gIGxhc3RNZWFzdXJlZEF0OiBudW1iZXIsXG4gIHJlY3Q6IFJlY3QgfCBudWxsLFxuICBkaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbCxcbn07XG5cbmNvbnN0IG5vZGVUb0RhdGE6IE1hcDxIb3N0SW5zdGFuY2UsIERhdGE+ID0gbmV3IE1hcCgpO1xuXG5sZXQgYWdlbnQ6IEFnZW50ID0gKChudWxsOiBhbnkpOiBBZ2VudCk7XG5sZXQgZHJhd0FuaW1hdGlvbkZyYW1lSUQ6IEFuaW1hdGlvbkZyYW1lSUQgfCBudWxsID0gbnVsbDtcbmxldCBpc0VuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbmxldCByZWRyYXdUaW1lb3V0SUQ6IFRpbWVvdXRJRCB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZShpbmplY3RlZEFnZW50OiBBZ2VudCk6IHZvaWQge1xuICBhZ2VudCA9IGluamVjdGVkQWdlbnQ7XG4gIGFnZW50LmFkZExpc3RlbmVyKCd0cmFjZVVwZGF0ZXMnLCB0cmFjZVVwZGF0ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlRW5hYmxlZCh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICBpc0VuYWJsZWQgPSB2YWx1ZTtcblxuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIG5vZGVUb0RhdGEuY2xlYXIoKTtcblxuICAgIGlmIChkcmF3QW5pbWF0aW9uRnJhbWVJRCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZHJhd0FuaW1hdGlvbkZyYW1lSUQpO1xuICAgICAgZHJhd0FuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChyZWRyYXdUaW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChyZWRyYXdUaW1lb3V0SUQpO1xuICAgICAgcmVkcmF3VGltZW91dElEID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZXN0cm95Q2FudmFzKGFnZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFjZVVwZGF0ZXMobm9kZXM6IFNldDxIb3N0SW5zdGFuY2U+KTogdm9pZCB7XG4gIGlmICghaXNFbmFibGVkKSByZXR1cm47XG5cbiAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICBjb25zdCBkYXRhID0gbm9kZVRvRGF0YS5nZXQobm9kZSk7XG4gICAgY29uc3Qgbm93ID0gZ2V0Q3VycmVudFRpbWUoKTtcblxuICAgIGxldCBsYXN0TWVhc3VyZWRBdCA9IGRhdGEgIT0gbnVsbCA/IGRhdGEubGFzdE1lYXN1cmVkQXQgOiAwO1xuICAgIGxldCByZWN0ID0gZGF0YSAhPSBudWxsID8gZGF0YS5yZWN0IDogbnVsbDtcblxuICAgIGlmIChyZWN0ID09PSBudWxsIHx8IGxhc3RNZWFzdXJlZEF0ICsgUkVNRUFTVVJFTUVOVF9BRlRFUl9EVVJBVElPTiA8IG5vdykge1xuICAgICAgbGFzdE1lYXN1cmVkQXQgPSBub3c7XG4gICAgICByZWN0ID0gbWVhc3VyZU5vZGUobm9kZSk7XG4gICAgfVxuXG4gICAgbGV0IGRpc3BsYXlOYW1lID0gYWdlbnQuZ2V0Q29tcG9uZW50TmFtZUZvckhvc3RJbnN0YW5jZShub2RlKTtcbiAgICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICAgIGNvbnN0IHtiYXNlQ29tcG9uZW50TmFtZSwgaG9jTmFtZXN9ID0gZXh0cmFjdEhPQ05hbWVzKGRpc3BsYXlOYW1lKTtcblxuICAgICAgY29uc3QgbWFya2VycyA9IGhvY05hbWVzLm1hcChob2MgPT4gSE9DX01BUktFUlMuZ2V0KGhvYykgfHwgJycpLmpvaW4oJycpO1xuXG4gICAgICBjb25zdCBlbmhhbmNlZERpc3BsYXlOYW1lID0gbWFya2Vyc1xuICAgICAgICA/IGAke21hcmtlcnN9JHtiYXNlQ29tcG9uZW50TmFtZX1gXG4gICAgICAgIDogYmFzZUNvbXBvbmVudE5hbWU7XG5cbiAgICAgIGRpc3BsYXlOYW1lID0gZW5oYW5jZWREaXNwbGF5TmFtZTtcbiAgICB9XG5cbiAgICBub2RlVG9EYXRhLnNldChub2RlLCB7XG4gICAgICBjb3VudDogZGF0YSAhPSBudWxsID8gZGF0YS5jb3VudCArIDEgOiAxLFxuICAgICAgZXhwaXJhdGlvblRpbWU6XG4gICAgICAgIGRhdGEgIT0gbnVsbFxuICAgICAgICAgID8gTWF0aC5taW4oXG4gICAgICAgICAgICAgIG5vdyArIE1BWF9ESVNQTEFZX0RVUkFUSU9OLFxuICAgICAgICAgICAgICBkYXRhLmV4cGlyYXRpb25UaW1lICsgRElTUExBWV9EVVJBVElPTixcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG5vdyArIERJU1BMQVlfRFVSQVRJT04sXG4gICAgICBsYXN0TWVhc3VyZWRBdCxcbiAgICAgIHJlY3QsXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKHJlZHJhd1RpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgIGNsZWFyVGltZW91dChyZWRyYXdUaW1lb3V0SUQpO1xuICAgIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG4gIH1cblxuICBpZiAoZHJhd0FuaW1hdGlvbkZyYW1lSUQgPT09IG51bGwpIHtcbiAgICBkcmF3QW5pbWF0aW9uRnJhbWVJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShwcmVwYXJlVG9EcmF3KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9EcmF3KCk6IHZvaWQge1xuICBkcmF3QW5pbWF0aW9uRnJhbWVJRCA9IG51bGw7XG4gIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG5cbiAgY29uc3Qgbm93ID0gZ2V0Q3VycmVudFRpbWUoKTtcbiAgbGV0IGVhcmxpZXN0RXhwaXJhdGlvbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgLy8gUmVtb3ZlIGFueSBpdGVtcyB0aGF0IGhhdmUgYWxyZWFkeSBleHBpcmVkLlxuICBub2RlVG9EYXRhLmZvckVhY2goKGRhdGEsIG5vZGUpID0+IHtcbiAgICBpZiAoZGF0YS5leHBpcmF0aW9uVGltZSA8IG5vdykge1xuICAgICAgbm9kZVRvRGF0YS5kZWxldGUobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVhcmxpZXN0RXhwaXJhdGlvbiA9IE1hdGgubWluKGVhcmxpZXN0RXhwaXJhdGlvbiwgZGF0YS5leHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9KTtcblxuICBkcmF3KG5vZGVUb0RhdGEsIGFnZW50KTtcblxuICBpZiAoZWFybGllc3RFeHBpcmF0aW9uICE9PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgcmVkcmF3VGltZW91dElEID0gc2V0VGltZW91dChwcmVwYXJlVG9EcmF3LCBlYXJsaWVzdEV4cGlyYXRpb24gLSBub3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVOb2RlKG5vZGU6IE9iamVjdCk6IFJlY3QgfCBudWxsIHtcbiAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgY3VycmVudFdpbmRvdyA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1RBUkdFVF9XSU5ET1dfXyB8fCB3aW5kb3c7XG5cbiAgcmV0dXJuIGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdChub2RlLCBjdXJyZW50V2luZG93KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/views/TraceUpdates/index.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/views/utils.js":
/*!***********************************************************!*\
  !*** ../react-devtools-shared/src/backend/views/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extractHOCNames\": () => (/* binding */ extractHOCNames),\n/* harmony export */   \"getBoundingClientRectWithBorderOffset\": () => (/* binding */ getBoundingClientRectWithBorderOffset),\n/* harmony export */   \"getElementDimensions\": () => (/* binding */ getElementDimensions),\n/* harmony export */   \"getNestedBoundingClientRect\": () => (/* binding */ getNestedBoundingClientRect),\n/* harmony export */   \"getOwnerIframe\": () => (/* binding */ getOwnerIframe),\n/* harmony export */   \"getOwnerWindow\": () => (/* binding */ getOwnerWindow),\n/* harmony export */   \"mergeRectOffsets\": () => (/* binding */ mergeRectOffsets)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Get the window object for the document that a node belongs to,\n// or return null if it cannot be found (node not attached to DOM,\n// etc).\nfunction getOwnerWindow(node) {\n  if (!node.ownerDocument) {\n    return null;\n  }\n\n  return node.ownerDocument.defaultView;\n} // Get the iframe containing a node, or return null if it cannot\n// be found (node not within iframe, etc).\n\nfunction getOwnerIframe(node) {\n  var nodeWindow = getOwnerWindow(node);\n\n  if (nodeWindow) {\n    return nodeWindow.frameElement;\n  }\n\n  return null;\n} // Get a bounding client rect for a node, with an\n// offset added to compensate for its border.\n\nfunction getBoundingClientRectWithBorderOffset(node) {\n  var dimensions = getElementDimensions(node);\n  return mergeRectOffsets([node.getBoundingClientRect(), {\n    top: dimensions.borderTop,\n    left: dimensions.borderLeft,\n    bottom: dimensions.borderBottom,\n    right: dimensions.borderRight,\n    // This width and height won't get used by mergeRectOffsets (since this\n    // is not the first rect in the array), but we set them so that this\n    // object type checks as a ClientRect.\n    width: 0,\n    height: 0\n  }]);\n} // Add together the top, left, bottom, and right properties of\n// each ClientRect, but keep the width and height of the first one.\n\nfunction mergeRectOffsets(rects) {\n  return rects.reduce(function (previousRect, rect) {\n    if (previousRect == null) {\n      return rect;\n    }\n\n    return {\n      top: previousRect.top + rect.top,\n      left: previousRect.left + rect.left,\n      width: previousRect.width,\n      height: previousRect.height,\n      bottom: previousRect.bottom + rect.bottom,\n      right: previousRect.right + rect.right\n    };\n  });\n} // Calculate a boundingClientRect for a node relative to boundaryWindow,\n// taking into account any offsets caused by intermediate iframes.\n\nfunction getNestedBoundingClientRect(node, boundaryWindow) {\n  var ownerIframe = getOwnerIframe(node);\n\n  if (ownerIframe && ownerIframe !== boundaryWindow) {\n    var rects = [node.getBoundingClientRect()];\n    var currentIframe = ownerIframe;\n    var onlyOneMore = false;\n\n    while (currentIframe) {\n      var rect = getBoundingClientRectWithBorderOffset(currentIframe);\n      rects.push(rect);\n      currentIframe = getOwnerIframe(currentIframe);\n\n      if (onlyOneMore) {\n        break;\n      } // We don't want to calculate iframe offsets upwards beyond\n      // the iframe containing the boundaryWindow, but we\n      // need to calculate the offset relative to the boundaryWindow.\n\n\n      if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {\n        onlyOneMore = true;\n      }\n    }\n\n    return mergeRectOffsets(rects);\n  } else {\n    return node.getBoundingClientRect();\n  }\n}\nfunction getElementDimensions(domElement) {\n  var calculatedStyle = window.getComputedStyle(domElement);\n  return {\n    borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),\n    borderRight: parseInt(calculatedStyle.borderRightWidth, 10),\n    borderTop: parseInt(calculatedStyle.borderTopWidth, 10),\n    borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),\n    marginLeft: parseInt(calculatedStyle.marginLeft, 10),\n    marginRight: parseInt(calculatedStyle.marginRight, 10),\n    marginTop: parseInt(calculatedStyle.marginTop, 10),\n    marginBottom: parseInt(calculatedStyle.marginBottom, 10),\n    paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),\n    paddingRight: parseInt(calculatedStyle.paddingRight, 10),\n    paddingTop: parseInt(calculatedStyle.paddingTop, 10),\n    paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)\n  };\n}\nfunction extractHOCNames(displayName) {\n  if (!displayName) return {\n    baseComponentName: '',\n    hocNames: []\n  };\n  var hocRegex = /([A-Z][a-zA-Z0-9]*?)\\((.*)\\)/g;\n  var hocNames = [];\n  var baseComponentName = displayName;\n  var match;\n\n  while ((match = hocRegex.exec(baseComponentName)) != null) {\n    if (Array.isArray(match)) {\n      var _match = match,\n          _match2 = _slicedToArray(_match, 3),\n          hocName = _match2[1],\n          inner = _match2[2];\n\n      hocNames.push(hocName);\n      baseComponentName = inner;\n    }\n  }\n\n  return {\n    baseComponentName: baseComponentName,\n    hocNames: hocNames\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUdBOztBQUNBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvdXRpbHMuanM/YjBlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlY3Qge1xuICBib3R0b206IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGxlZnQ6IG51bWJlcjtcbiAgcmlnaHQ6IG51bWJlcjtcbiAgdG9wOiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG59XG5cbi8vIEdldCB0aGUgd2luZG93IG9iamVjdCBmb3IgdGhlIGRvY3VtZW50IHRoYXQgYSBub2RlIGJlbG9uZ3MgdG8sXG4vLyBvciByZXR1cm4gbnVsbCBpZiBpdCBjYW5ub3QgYmUgZm91bmQgKG5vZGUgbm90IGF0dGFjaGVkIHRvIERPTSxcbi8vIGV0YykuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJXaW5kb3cobm9kZTogSFRNTEVsZW1lbnQpOiB0eXBlb2Ygd2luZG93IHwgbnVsbCB7XG4gIGlmICghbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcbn1cblxuLy8gR2V0IHRoZSBpZnJhbWUgY29udGFpbmluZyBhIG5vZGUsIG9yIHJldHVybiBudWxsIGlmIGl0IGNhbm5vdFxuLy8gYmUgZm91bmQgKG5vZGUgbm90IHdpdGhpbiBpZnJhbWUsIGV0YykuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJJZnJhbWUobm9kZTogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICBjb25zdCBub2RlV2luZG93ID0gZ2V0T3duZXJXaW5kb3cobm9kZSk7XG4gIGlmIChub2RlV2luZG93KSB7XG4gICAgcmV0dXJuIG5vZGVXaW5kb3cuZnJhbWVFbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBHZXQgYSBib3VuZGluZyBjbGllbnQgcmVjdCBmb3IgYSBub2RlLCB3aXRoIGFuXG4vLyBvZmZzZXQgYWRkZWQgdG8gY29tcGVuc2F0ZSBmb3IgaXRzIGJvcmRlci5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3RXaXRoQm9yZGVyT2Zmc2V0KG5vZGU6IEhUTUxFbGVtZW50KTogUmVjdCB7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXRFbGVtZW50RGltZW5zaW9ucyhub2RlKTtcbiAgcmV0dXJuIG1lcmdlUmVjdE9mZnNldHMoW1xuICAgIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAge1xuICAgICAgdG9wOiBkaW1lbnNpb25zLmJvcmRlclRvcCxcbiAgICAgIGxlZnQ6IGRpbWVuc2lvbnMuYm9yZGVyTGVmdCxcbiAgICAgIGJvdHRvbTogZGltZW5zaW9ucy5ib3JkZXJCb3R0b20sXG4gICAgICByaWdodDogZGltZW5zaW9ucy5ib3JkZXJSaWdodCxcbiAgICAgIC8vIFRoaXMgd2lkdGggYW5kIGhlaWdodCB3b24ndCBnZXQgdXNlZCBieSBtZXJnZVJlY3RPZmZzZXRzIChzaW5jZSB0aGlzXG4gICAgICAvLyBpcyBub3QgdGhlIGZpcnN0IHJlY3QgaW4gdGhlIGFycmF5KSwgYnV0IHdlIHNldCB0aGVtIHNvIHRoYXQgdGhpc1xuICAgICAgLy8gb2JqZWN0IHR5cGUgY2hlY2tzIGFzIGEgQ2xpZW50UmVjdC5cbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgIH0sXG4gIF0pO1xufVxuXG4vLyBBZGQgdG9nZXRoZXIgdGhlIHRvcCwgbGVmdCwgYm90dG9tLCBhbmQgcmlnaHQgcHJvcGVydGllcyBvZlxuLy8gZWFjaCBDbGllbnRSZWN0LCBidXQga2VlcCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZmlyc3Qgb25lLlxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUmVjdE9mZnNldHMocmVjdHM6IEFycmF5PFJlY3Q+KTogUmVjdCB7XG4gIHJldHVybiByZWN0cy5yZWR1Y2UoKHByZXZpb3VzUmVjdCwgcmVjdCkgPT4ge1xuICAgIGlmIChwcmV2aW91c1JlY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcHJldmlvdXNSZWN0LnRvcCArIHJlY3QudG9wLFxuICAgICAgbGVmdDogcHJldmlvdXNSZWN0LmxlZnQgKyByZWN0LmxlZnQsXG4gICAgICB3aWR0aDogcHJldmlvdXNSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBwcmV2aW91c1JlY3QuaGVpZ2h0LFxuICAgICAgYm90dG9tOiBwcmV2aW91c1JlY3QuYm90dG9tICsgcmVjdC5ib3R0b20sXG4gICAgICByaWdodDogcHJldmlvdXNSZWN0LnJpZ2h0ICsgcmVjdC5yaWdodCxcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgYm91bmRpbmdDbGllbnRSZWN0IGZvciBhIG5vZGUgcmVsYXRpdmUgdG8gYm91bmRhcnlXaW5kb3csXG4vLyB0YWtpbmcgaW50byBhY2NvdW50IGFueSBvZmZzZXRzIGNhdXNlZCBieSBpbnRlcm1lZGlhdGUgaWZyYW1lcy5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3QoXG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICBib3VuZGFyeVdpbmRvdzogdHlwZW9mIHdpbmRvdyxcbik6IFJlY3Qge1xuICBjb25zdCBvd25lcklmcmFtZSA9IGdldE93bmVySWZyYW1lKG5vZGUpO1xuICBpZiAob3duZXJJZnJhbWUgJiYgb3duZXJJZnJhbWUgIT09IGJvdW5kYXJ5V2luZG93KSB7XG4gICAgY29uc3QgcmVjdHM6IEFycmF5PFJlY3QgfCBDbGllbnRSZWN0PiA9IFtub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXTtcbiAgICBsZXQgY3VycmVudElmcmFtZTogbnVsbCB8IEhUTUxFbGVtZW50ID0gb3duZXJJZnJhbWU7XG4gICAgbGV0IG9ubHlPbmVNb3JlID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnRJZnJhbWUpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3RXaXRoQm9yZGVyT2Zmc2V0KGN1cnJlbnRJZnJhbWUpO1xuICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgIGN1cnJlbnRJZnJhbWUgPSBnZXRPd25lcklmcmFtZShjdXJyZW50SWZyYW1lKTtcblxuICAgICAgaWYgKG9ubHlPbmVNb3JlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjYWxjdWxhdGUgaWZyYW1lIG9mZnNldHMgdXB3YXJkcyBiZXlvbmRcbiAgICAgIC8vIHRoZSBpZnJhbWUgY29udGFpbmluZyB0aGUgYm91bmRhcnlXaW5kb3csIGJ1dCB3ZVxuICAgICAgLy8gbmVlZCB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgYm91bmRhcnlXaW5kb3cuXG4gICAgICBpZiAoY3VycmVudElmcmFtZSAmJiBnZXRPd25lcldpbmRvdyhjdXJyZW50SWZyYW1lKSA9PT0gYm91bmRhcnlXaW5kb3cpIHtcbiAgICAgICAgb25seU9uZU1vcmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZVJlY3RPZmZzZXRzKHJlY3RzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudERpbWVuc2lvbnMoZG9tRWxlbWVudDogSFRNTEVsZW1lbnQpOiB7XG4gIGJvcmRlckJvdHRvbTogbnVtYmVyLFxuICBib3JkZXJMZWZ0OiBudW1iZXIsXG4gIGJvcmRlclJpZ2h0OiBudW1iZXIsXG4gIGJvcmRlclRvcDogbnVtYmVyLFxuICBtYXJnaW5Cb3R0b206IG51bWJlcixcbiAgbWFyZ2luTGVmdDogbnVtYmVyLFxuICBtYXJnaW5SaWdodDogbnVtYmVyLFxuICBtYXJnaW5Ub3A6IG51bWJlcixcbiAgcGFkZGluZ0JvdHRvbTogbnVtYmVyLFxuICBwYWRkaW5nTGVmdDogbnVtYmVyLFxuICBwYWRkaW5nUmlnaHQ6IG51bWJlcixcbiAgcGFkZGluZ1RvcDogbnVtYmVyLFxufSB7XG4gIGNvbnN0IGNhbGN1bGF0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIGJvcmRlckxlZnQ6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSxcbiAgICBib3JkZXJSaWdodDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgsIDEwKSxcbiAgICBib3JkZXJUb3A6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApLFxuICAgIGJvcmRlckJvdHRvbTogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCksXG4gICAgbWFyZ2luTGVmdDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLm1hcmdpbkxlZnQsIDEwKSxcbiAgICBtYXJnaW5SaWdodDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLm1hcmdpblJpZ2h0LCAxMCksXG4gICAgbWFyZ2luVG9wOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luVG9wLCAxMCksXG4gICAgbWFyZ2luQm90dG9tOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luQm90dG9tLCAxMCksXG4gICAgcGFkZGluZ0xlZnQ6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5wYWRkaW5nTGVmdCwgMTApLFxuICAgIHBhZGRpbmdSaWdodDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdSaWdodCwgMTApLFxuICAgIHBhZGRpbmdUb3A6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5wYWRkaW5nVG9wLCAxMCksXG4gICAgcGFkZGluZ0JvdHRvbTogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RIT0NOYW1lcyhkaXNwbGF5TmFtZTogc3RyaW5nKToge1xuICBiYXNlQ29tcG9uZW50TmFtZTogc3RyaW5nLFxuICBob2NOYW1lczogc3RyaW5nW10sXG59IHtcbiAgaWYgKCFkaXNwbGF5TmFtZSkgcmV0dXJuIHtiYXNlQ29tcG9uZW50TmFtZTogJycsIGhvY05hbWVzOiBbXX07XG5cbiAgY29uc3QgaG9jUmVnZXggPSAvKFtBLVpdW2EtekEtWjAtOV0qPylcXCgoLiopXFwpL2c7XG4gIGNvbnN0IGhvY05hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgYmFzZUNvbXBvbmVudE5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSBob2NSZWdleC5leGVjKGJhc2VDb21wb25lbnROYW1lKSkgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgY29uc3QgWywgaG9jTmFtZSwgaW5uZXJdID0gbWF0Y2g7XG4gICAgICBob2NOYW1lcy5wdXNoKGhvY05hbWUpO1xuICAgICAgYmFzZUNvbXBvbmVudE5hbWUgPSBpbm5lcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhc2VDb21wb25lbnROYW1lLFxuICAgIGhvY05hbWVzLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/views/utils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/bridge.js":
/*!**********************************************!*\
  !*** ../react-devtools-shared/src/bridge.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BRIDGE_PROTOCOL\": () => (/* binding */ BRIDGE_PROTOCOL),\n/* harmony export */   \"currentBridgeProtocol\": () => (/* binding */ currentBridgeProtocol),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ \"../react-devtools-shared/src/events.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n// Bump protocol version whenever a backwards breaking change is made\n// in the messages sent between BackendBridge and FrontendBridge.\n// This mapping is embedded in both frontend and backend builds.\n//\n// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.\n//\n// When an older frontend connects to a newer backend,\n// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.\n//\n// When a newer frontend connects with an older protocol version,\n// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.\nvar BRIDGE_PROTOCOL = [// This version technically never existed,\n// but a backwards breaking change was added in 4.11,\n// so the safest guess to downgrade the frontend would be to version 4.10.\n{\n  version: 0,\n  minNpmVersion: '\"<4.11.0\"',\n  maxNpmVersion: '\"<4.11.0\"'\n}, // Versions 4.11.x – 4.12.x contained the backwards breaking change,\n// but we didn't add the \"fix\" of checking the protocol version until 4.13,\n// so we don't recommend downgrading to 4.11 or 4.12.\n{\n  version: 1,\n  minNpmVersion: '4.13.0',\n  maxNpmVersion: '4.21.0'\n}, // Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.\n{\n  version: 2,\n  minNpmVersion: '4.22.0',\n  maxNpmVersion: null\n}];\nvar currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];\n\nvar Bridge = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Bridge, _EventEmitter);\n\n  var _super = _createSuper(Bridge);\n\n  function Bridge(wall) {\n    var _this;\n\n    _classCallCheck(this, Bridge);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isShutdown\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_messageQueue\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_scheduledFlush\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_wallUnlisten\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_flush\", function () {\n      // This method is used after the bridge is marked as destroyed in shutdown sequence,\n      // so we do not bail out if the bridge marked as destroyed.\n      // It is a private method that the bridge ensures is only called at the right times.\n      try {\n        if (_this._messageQueue.length) {\n          for (var i = 0; i < _this._messageQueue.length; i += 2) {\n            var _this$_wall;\n\n            (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(_toConsumableArray(_this._messageQueue[i + 1])));\n          }\n\n          _this._messageQueue.length = 0;\n        }\n      } finally {\n        // We set this at the end in case new messages are added synchronously above.\n        // They're already handled so they shouldn't queue more flushes.\n        _this._scheduledFlush = false;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"overrideValueAtPath\", function (_ref) {\n      var id = _ref.id,\n          path = _ref.path,\n          rendererID = _ref.rendererID,\n          type = _ref.type,\n          value = _ref.value;\n\n      switch (type) {\n        case 'context':\n          _this.send('overrideContext', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n\n        case 'hooks':\n          _this.send('overrideHookState', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n\n        case 'props':\n          _this.send('overrideProps', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n\n        case 'state':\n          _this.send('overrideState', {\n            id: id,\n            path: path,\n            rendererID: rendererID,\n            wasForwarded: true,\n            value: value\n          });\n\n          break;\n      }\n    });\n\n    _this._wall = wall;\n    _this._wallUnlisten = wall.listen(function (message) {\n      if (message && message.event) {\n        _assertThisInitialized(_this).emit(message.event, message.payload);\n      }\n    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.\n    // We do this because React Native embeds the React DevTools backend,\n    // but cannot control which version of the frontend users use.\n\n    _this.addListener('overrideValueAtPath', _this.overrideValueAtPath);\n\n    return _this;\n  } // Listening directly to the wall isn't advised.\n  // It can be used to listen for legacy (v3) messages (since they use a different format).\n\n\n  _createClass(Bridge, [{\n    key: \"send\",\n    value: function send(event) {\n      if (this._isShutdown) {\n        console.warn(\"Cannot send message \\\"\".concat(event, \"\\\" through a Bridge that has been shutdown.\"));\n        return;\n      } // When we receive a message:\n      // - we add it to our queue of messages to be sent\n      // - if there hasn't been a message recently, we set a timer for 0 ms in\n      //   the future, allowing all messages created in the same tick to be sent\n      //   together\n      // - if there *has* been a message flushed in the last BATCH_DURATION ms\n      //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will\n      //   be set, and we'll simply add to the queue and wait for that\n\n\n      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        payload[_key - 1] = arguments[_key];\n      }\n\n      this._messageQueue.push(event, payload);\n\n      if (!this._scheduledFlush) {\n        this._scheduledFlush = true; // $FlowFixMe\n\n        if (typeof devtoolsJestTestScheduler === 'function') {\n          // This exists just for our own jest tests.\n          // They're written in such a way that we can neither mock queueMicrotask\n          // because then we break React DOM and we can't not mock it because then\n          // we can't synchronously flush it. So they need to be rewritten.\n          // $FlowFixMe\n          devtoolsJestTestScheduler(this._flush); // eslint-disable-line no-undef\n        } else {\n          queueMicrotask(this._flush);\n        }\n      }\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      if (this._isShutdown) {\n        console.warn('Bridge was already shutdown.');\n        return;\n      } // Queue the shutdown outgoing message for subscribers.\n\n\n      this.emit('shutdown');\n      this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.\n\n      this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.\n      // $FlowFixMe[cannot-write] This property is not writable.\n\n      this.addListener = function () {}; // $FlowFixMe[cannot-write] This property is not writable.\n\n\n      this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.\n      // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.\n\n\n      this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.\n\n      var wallUnlisten = this._wallUnlisten;\n\n      if (wallUnlisten) {\n        wallUnlisten();\n      } // Synchronously flush all queued outgoing messages.\n      // At this step the subscribers' code may run in this call stack.\n\n\n      do {\n        this._flush();\n      } while (this._messageQueue.length);\n    }\n  }, {\n    key: \"wall\",\n    get: function get() {\n      return this._wall;\n    }\n  }]);\n\n  return Bridge;\n}(_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Bridge);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7O0FBMk1BOzs7OztBQWFBO0FBQUE7O0FBQUE7O0FBQ0E7O0FBREE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFpR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhIQTtBQTBIQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFPQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQU9BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBT0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFPQTtBQXBDQTtBQXNDQTs7QUE5SkE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTs7QUFmQTtBQWdCQTtBQUdBOzs7OztBQU1BO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBZkE7QUFEQTtBQUNBOztBQWdCQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFHQTtBQUdBOztBQUNBOzs7QUFFQTtBQUdBOzs7QUFDQTs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQTFFQTtBQUNBO0FBQ0E7Ozs7QUFoQ0E7O0FBaUxBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UuanM/MTc5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vZXZlbnRzJztcblxuaW1wb3J0IHR5cGUge0NvbXBvbmVudEZpbHRlciwgV2FsbH0gZnJvbSAnLi9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIEluc3BlY3RlZEVsZW1lbnRQYXlsb2FkLFxuICBPd25lcnNMaXN0LFxuICBQcm9maWxpbmdEYXRhQmFja2VuZCxcbiAgUmVuZGVyZXJJRCxcbiAgRGV2VG9vbHNIb29rU2V0dGluZ3MsXG4gIFByb2ZpbGluZ1NldHRpbmdzLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1N0eWxlQW5kTGF5b3V0IGFzIFN0eWxlQW5kTGF5b3V0UGF5bG9hZH0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL05hdGl2ZVN0eWxlRWRpdG9yL3R5cGVzJztcblxuLy8gVGhpcyBtZXNzYWdlIHNwZWNpZmllcyB0aGUgdmVyc2lvbiBvZiB0aGUgRGV2VG9vbHMgcHJvdG9jb2wgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCxcbi8vIGFzIHdlbGwgYXMgdGhlIGVhcmxpZXN0IE5QTSB2ZXJzaW9uIChlLmcuIFwiNC4xMy4wXCIpIHRoYXQgcHJvdG9jb2wgaXMgc3VwcG9ydGVkIGJ5IG9uIHRoZSBmcm9udGVuZC5cbi8vIFRoaXMgZW5hYmxlcyBhbiBvbGRlciBmcm9udGVuZCB0byBkaXNwbGF5IGFuIHVwZ3JhZGUgbWVzc2FnZSB0byB1c2VycyBmb3IgYSBuZXdlciwgdW5zdXBwb3J0ZWQgYmFja2VuZC5cbmV4cG9ydCB0eXBlIEJyaWRnZVByb3RvY29sID0ge1xuICAvLyBWZXJzaW9uIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBmcm9udGVuZC9iYWNrZW5kLlxuICB2ZXJzaW9uOiBudW1iZXIsXG5cbiAgLy8gTlBNIHZlcnNpb24gcmFuZ2UgdGhhdCBhbHNvIHN1cHBvcnRzIHRoaXMgdmVyc2lvbi5cbiAgLy8gTm90ZSB0aGF0ICdtYXhOcG1WZXJzaW9uJyBpcyBvbmx5IHNldCB3aGVuIHRoZSB2ZXJzaW9uIGlzIGJ1bXBlZC5cbiAgbWluTnBtVmVyc2lvbjogc3RyaW5nLFxuICBtYXhOcG1WZXJzaW9uOiBzdHJpbmcgfCBudWxsLFxufTtcblxuLy8gQnVtcCBwcm90b2NvbCB2ZXJzaW9uIHdoZW5ldmVyIGEgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSBpcyBtYWRlXG4vLyBpbiB0aGUgbWVzc2FnZXMgc2VudCBiZXR3ZWVuIEJhY2tlbmRCcmlkZ2UgYW5kIEZyb250ZW5kQnJpZGdlLlxuLy8gVGhpcyBtYXBwaW5nIGlzIGVtYmVkZGVkIGluIGJvdGggZnJvbnRlbmQgYW5kIGJhY2tlbmQgYnVpbGRzLlxuLy9cbi8vIFRoZSBiYWNrZW5kIHByb3RvY29sIHdpbGwgYWx3YXlzIGJlIHRoZSBsYXRlc3QgZW50cnkgaW4gdGhlIEJSSURHRV9QUk9UT0NPTCBhcnJheS5cbi8vXG4vLyBXaGVuIGFuIG9sZGVyIGZyb250ZW5kIGNvbm5lY3RzIHRvIGEgbmV3ZXIgYmFja2VuZCxcbi8vIHRoZSBiYWNrZW5kIGNhbiBzZW5kIHRoZSBtaW5OcG1WZXJzaW9uIGFuZCB0aGUgZnJvbnRlbmQgY2FuIGRpc3BsYXkgYW4gTlBNIHVwZ3JhZGUgcHJvbXB0LlxuLy9cbi8vIFdoZW4gYSBuZXdlciBmcm9udGVuZCBjb25uZWN0cyB3aXRoIGFuIG9sZGVyIHByb3RvY29sIHZlcnNpb24sXG4vLyB0aGUgZnJvbnRlbmQgY2FuIHVzZSB0aGUgZW1iZWRkZWQgbWluTnBtVmVyc2lvbi9tYXhOcG1WZXJzaW9uIHZhbHVlcyB0byBkaXNwbGF5IGEgZG93bmdyYWRlIHByb21wdC5cbmV4cG9ydCBjb25zdCBCUklER0VfUFJPVE9DT0w6IEFycmF5PEJyaWRnZVByb3RvY29sPiA9IFtcbiAgLy8gVGhpcyB2ZXJzaW9uIHRlY2huaWNhbGx5IG5ldmVyIGV4aXN0ZWQsXG4gIC8vIGJ1dCBhIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2Ugd2FzIGFkZGVkIGluIDQuMTEsXG4gIC8vIHNvIHRoZSBzYWZlc3QgZ3Vlc3MgdG8gZG93bmdyYWRlIHRoZSBmcm9udGVuZCB3b3VsZCBiZSB0byB2ZXJzaW9uIDQuMTAuXG4gIHtcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG1pbk5wbVZlcnNpb246ICdcIjw0LjExLjBcIicsXG4gICAgbWF4TnBtVmVyc2lvbjogJ1wiPDQuMTEuMFwiJyxcbiAgfSxcbiAgLy8gVmVyc2lvbnMgNC4xMS54IOKAkyA0LjEyLnggY29udGFpbmVkIHRoZSBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlLFxuICAvLyBidXQgd2UgZGlkbid0IGFkZCB0aGUgXCJmaXhcIiBvZiBjaGVja2luZyB0aGUgcHJvdG9jb2wgdmVyc2lvbiB1bnRpbCA0LjEzLFxuICAvLyBzbyB3ZSBkb24ndCByZWNvbW1lbmQgZG93bmdyYWRpbmcgdG8gNC4xMSBvciA0LjEyLlxuICB7XG4gICAgdmVyc2lvbjogMSxcbiAgICBtaW5OcG1WZXJzaW9uOiAnNC4xMy4wJyxcbiAgICBtYXhOcG1WZXJzaW9uOiAnNC4yMS4wJyxcbiAgfSxcbiAgLy8gVmVyc2lvbiAyIGFkZHMgYSBTdHJpY3RNb2RlLWVuYWJsZWQgYW5kIHN1cHBvcnRzLVN0cmljdE1vZGUgYml0cyB0byBhZGQtcm9vdCBvcGVyYXRpb24uXG4gIHtcbiAgICB2ZXJzaW9uOiAyLFxuICAgIG1pbk5wbVZlcnNpb246ICc0LjIyLjAnLFxuICAgIG1heE5wbVZlcnNpb246IG51bGwsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgY3VycmVudEJyaWRnZVByb3RvY29sOiBCcmlkZ2VQcm90b2NvbCA9XG4gIEJSSURHRV9QUk9UT0NPTFtCUklER0VfUFJPVE9DT0wubGVuZ3RoIC0gMV07XG5cbnR5cGUgRWxlbWVudEFuZFJlbmRlcmVySUQgPSB7aWQ6IG51bWJlciwgcmVuZGVyZXJJRDogUmVuZGVyZXJJRH07XG5cbnR5cGUgTWVzc2FnZSA9IHtcbiAgZXZlbnQ6IHN0cmluZyxcbiAgcGF5bG9hZDogYW55LFxufTtcblxudHlwZSBIaWdobGlnaHRIb3N0SW5zdGFuY2UgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBkaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgaGlkZUFmdGVyVGltZW91dDogYm9vbGVhbixcbiAgb3BlbkJ1aWx0aW5FbGVtZW50c1BhbmVsOiBib29sZWFuLFxuICBzY3JvbGxJbnRvVmlldzogYm9vbGVhbixcbn07XG5cbnR5cGUgT3ZlcnJpZGVWYWx1ZSA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIHdhc0ZvcndhcmRlZD86IGJvb2xlYW4sXG4gIHZhbHVlOiBhbnksXG59O1xuXG50eXBlIE92ZXJyaWRlSG9va1N0YXRlID0ge1xuICAuLi5PdmVycmlkZVZhbHVlLFxuICBob29rSUQ6IG51bWJlcixcbn07XG5cbnR5cGUgUGF0aFR5cGUgPSAncHJvcHMnIHwgJ2hvb2tzJyB8ICdzdGF0ZScgfCAnY29udGV4dCc7XG5cbnR5cGUgRGVsZXRlUGF0aCA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIHR5cGU6IFBhdGhUeXBlLFxuICBob29rSUQ/OiA/bnVtYmVyLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxufTtcblxudHlwZSBSZW5hbWVQYXRoID0ge1xuICAuLi5FbGVtZW50QW5kUmVuZGVyZXJJRCxcbiAgdHlwZTogUGF0aFR5cGUsXG4gIGhvb2tJRD86ID9udW1iZXIsXG4gIG9sZFBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIG5ld1BhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG59O1xuXG50eXBlIE92ZXJyaWRlVmFsdWVBdFBhdGggPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICB0eXBlOiBQYXRoVHlwZSxcbiAgaG9va0lEPzogP251bWJlcixcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgdmFsdWU6IGFueSxcbn07XG5cbnR5cGUgT3ZlcnJpZGVFcnJvciA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIGZvcmNlRXJyb3I6IGJvb2xlYW4sXG59O1xuXG50eXBlIE92ZXJyaWRlU3VzcGVuc2UgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBmb3JjZUZhbGxiYWNrOiBib29sZWFuLFxufTtcblxudHlwZSBDb3B5RWxlbWVudFBhdGhQYXJhbXMgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxufTtcblxudHlwZSBWaWV3QXR0cmlidXRlU291cmNlUGFyYW1zID0ge1xuICAuLi5FbGVtZW50QW5kUmVuZGVyZXJJRCxcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbn07XG5cbnR5cGUgSW5zcGVjdEVsZW1lbnRQYXJhbXMgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBmb3JjZUZ1bGxEYXRhOiBib29sZWFuLFxuICBwYXRoOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgbnVsbCxcbiAgcmVxdWVzdElEOiBudW1iZXIsXG59O1xuXG50eXBlIFN0b3JlQXNHbG9iYWxQYXJhbXMgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBjb3VudDogbnVtYmVyLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxufTtcblxudHlwZSBOYXRpdmVTdHlsZUVkaXRvcl9SZW5hbWVBdHRyaWJ1dGVQYXJhbXMgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBvbGROYW1lOiBzdHJpbmcsXG4gIG5ld05hbWU6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbn07XG5cbnR5cGUgTmF0aXZlU3R5bGVFZGl0b3JfU2V0VmFsdWVQYXJhbXMgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBuYW1lOiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmcsXG59O1xuXG50eXBlIFNhdmVkUHJlZmVyZW5jZXNQYXJhbXMgPSB7XG4gIGNvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4sXG59O1xuXG5leHBvcnQgdHlwZSBCYWNrZW5kRXZlbnRzID0ge1xuICBiYWNrZW5kSW5pdGlhbGl6ZWQ6IFtdLFxuICBiYWNrZW5kVmVyc2lvbjogW3N0cmluZ10sXG4gIGJyaWRnZVByb3RvY29sOiBbQnJpZGdlUHJvdG9jb2xdLFxuICBleHRlbnNpb25CYWNrZW5kSW5pdGlhbGl6ZWQ6IFtdLFxuICBmYXN0UmVmcmVzaFNjaGVkdWxlZDogW10sXG4gIGdldFNhdmVkUHJlZmVyZW5jZXM6IFtdLFxuICBpbnNwZWN0ZWRFbGVtZW50OiBbSW5zcGVjdGVkRWxlbWVudFBheWxvYWRdLFxuICBpc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWRCeUJhY2tlbmQ6IFtib29sZWFuXSxcbiAgb3BlcmF0aW9uczogW0FycmF5PG51bWJlcj5dLFxuICBvd25lcnNMaXN0OiBbT3duZXJzTGlzdF0sXG4gIG92ZXJyaWRlQ29tcG9uZW50RmlsdGVyczogW0FycmF5PENvbXBvbmVudEZpbHRlcj5dLFxuICBlbnZpcm9ubWVudE5hbWVzOiBbQXJyYXk8c3RyaW5nPl0sXG4gIHByb2ZpbGluZ0RhdGE6IFtQcm9maWxpbmdEYXRhQmFja2VuZF0sXG4gIHByb2ZpbGluZ1N0YXR1czogW2Jvb2xlYW5dLFxuICByZWxvYWRBcHBGb3JQcm9maWxpbmc6IFtdLFxuICBzYXZlVG9DbGlwYm9hcmQ6IFtzdHJpbmddLFxuICBzZWxlY3RFbGVtZW50OiBbbnVtYmVyXSxcbiAgc2h1dGRvd246IFtdLFxuICBzdG9wSW5zcGVjdGluZ0hvc3Q6IFtib29sZWFuXSxcbiAgc3luY1NlbGVjdGlvbkZyb21CdWlsdGluRWxlbWVudHNQYW5lbDogW10sXG4gIHN5bmNTZWxlY3Rpb25Ub0J1aWx0aW5FbGVtZW50c1BhbmVsOiBbXSxcbiAgdW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb246IFtdLFxuXG4gIC8vIFJlYWN0IE5hdGl2ZSBzdHlsZSBlZGl0b3IgcGx1Zy1pbi5cbiAgaXNOYXRpdmVTdHlsZUVkaXRvclN1cHBvcnRlZDogW1xuICAgIHtpc1N1cHBvcnRlZDogYm9vbGVhbiwgdmFsaWRBdHRyaWJ1dGVzOiA/JFJlYWRPbmx5QXJyYXk8c3RyaW5nPn0sXG4gIF0sXG4gIE5hdGl2ZVN0eWxlRWRpdG9yX3N0eWxlQW5kTGF5b3V0OiBbU3R5bGVBbmRMYXlvdXRQYXlsb2FkXSxcblxuICBob29rU2V0dGluZ3M6IFskUmVhZE9ubHk8RGV2VG9vbHNIb29rU2V0dGluZ3M+XSxcbn07XG5cbnR5cGUgU3RhcnRQcm9maWxpbmdQYXJhbXMgPSBQcm9maWxpbmdTZXR0aW5ncztcbnR5cGUgUmVsb2FkQW5kUHJvZmlsaW5nUGFyYW1zID0gUHJvZmlsaW5nU2V0dGluZ3M7XG5cbnR5cGUgRnJvbnRlbmRFdmVudHMgPSB7XG4gIGNsZWFyRXJyb3JzQW5kV2FybmluZ3M6IFt7cmVuZGVyZXJJRDogUmVuZGVyZXJJRH1dLFxuICBjbGVhckVycm9yc0ZvckVsZW1lbnRJRDogW0VsZW1lbnRBbmRSZW5kZXJlcklEXSxcbiAgY2xlYXJIb3N0SW5zdGFuY2VIaWdobGlnaHQ6IFtdLFxuICBjbGVhcldhcm5pbmdzRm9yRWxlbWVudElEOiBbRWxlbWVudEFuZFJlbmRlcmVySURdLFxuICBjb3B5RWxlbWVudFBhdGg6IFtDb3B5RWxlbWVudFBhdGhQYXJhbXNdLFxuICBkZWxldGVQYXRoOiBbRGVsZXRlUGF0aF0sXG4gIGdldEJhY2tlbmRWZXJzaW9uOiBbXSxcbiAgZ2V0QnJpZGdlUHJvdG9jb2w6IFtdLFxuICBnZXRJZkhhc1Vuc3VwcG9ydGVkUmVuZGVyZXJWZXJzaW9uOiBbXSxcbiAgZ2V0T3duZXJzTGlzdDogW0VsZW1lbnRBbmRSZW5kZXJlcklEXSxcbiAgZ2V0UHJvZmlsaW5nRGF0YTogW3tyZW5kZXJlcklEOiBSZW5kZXJlcklEfV0sXG4gIGdldFByb2ZpbGluZ1N0YXR1czogW10sXG4gIGhpZ2hsaWdodEhvc3RJbnN0YW5jZTogW0hpZ2hsaWdodEhvc3RJbnN0YW5jZV0sXG4gIGluc3BlY3RFbGVtZW50OiBbSW5zcGVjdEVsZW1lbnRQYXJhbXNdLFxuICBsb2dFbGVtZW50VG9Db25zb2xlOiBbRWxlbWVudEFuZFJlbmRlcmVySURdLFxuICBvdmVycmlkZUVycm9yOiBbT3ZlcnJpZGVFcnJvcl0sXG4gIG92ZXJyaWRlU3VzcGVuc2U6IFtPdmVycmlkZVN1c3BlbnNlXSxcbiAgb3ZlcnJpZGVWYWx1ZUF0UGF0aDogW092ZXJyaWRlVmFsdWVBdFBhdGhdLFxuICBwcm9maWxpbmdEYXRhOiBbUHJvZmlsaW5nRGF0YUJhY2tlbmRdLFxuICByZWxvYWRBbmRQcm9maWxlOiBbUmVsb2FkQW5kUHJvZmlsaW5nUGFyYW1zXSxcbiAgcmVuYW1lUGF0aDogW1JlbmFtZVBhdGhdLFxuICBzYXZlZFByZWZlcmVuY2VzOiBbU2F2ZWRQcmVmZXJlbmNlc1BhcmFtc10sXG4gIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQ6IFtib29sZWFuXSxcbiAgc2h1dGRvd246IFtdLFxuICBzdGFydEluc3BlY3RpbmdIb3N0OiBbXSxcbiAgc3RhcnRQcm9maWxpbmc6IFtTdGFydFByb2ZpbGluZ1BhcmFtc10sXG4gIHN0b3BJbnNwZWN0aW5nSG9zdDogW2Jvb2xlYW5dLFxuICBzdG9wUHJvZmlsaW5nOiBbXSxcbiAgc3RvcmVBc0dsb2JhbDogW1N0b3JlQXNHbG9iYWxQYXJhbXNdLFxuICB1cGRhdGVDb21wb25lbnRGaWx0ZXJzOiBbQXJyYXk8Q29tcG9uZW50RmlsdGVyPl0sXG4gIGdldEVudmlyb25tZW50TmFtZXM6IFtdLFxuICB1cGRhdGVIb29rU2V0dGluZ3M6IFskUmVhZE9ubHk8RGV2VG9vbHNIb29rU2V0dGluZ3M+XSxcbiAgdmlld0F0dHJpYnV0ZVNvdXJjZTogW1ZpZXdBdHRyaWJ1dGVTb3VyY2VQYXJhbXNdLFxuICB2aWV3RWxlbWVudFNvdXJjZTogW0VsZW1lbnRBbmRSZW5kZXJlcklEXSxcblxuICAvLyBSZWFjdCBOYXRpdmUgc3R5bGUgZWRpdG9yIHBsdWctaW4uXG4gIE5hdGl2ZVN0eWxlRWRpdG9yX21lYXN1cmU6IFtFbGVtZW50QW5kUmVuZGVyZXJJRF0sXG4gIE5hdGl2ZVN0eWxlRWRpdG9yX3JlbmFtZUF0dHJpYnV0ZTogW05hdGl2ZVN0eWxlRWRpdG9yX1JlbmFtZUF0dHJpYnV0ZVBhcmFtc10sXG4gIE5hdGl2ZVN0eWxlRWRpdG9yX3NldFZhbHVlOiBbTmF0aXZlU3R5bGVFZGl0b3JfU2V0VmFsdWVQYXJhbXNdLFxuXG4gIC8vIFRlbXBvcmFyaWx5IHN1cHBvcnQgbmV3ZXIgc3RhbmRhbG9uZSBmcm9udC1lbmRzIHNlbmRpbmcgY29tbWFuZHMgdG8gb2xkZXIgZW1iZWRkZWQgYmFja2VuZHMuXG4gIC8vIFdlIGRvIHRoaXMgYmVjYXVzZSBSZWFjdCBOYXRpdmUgZW1iZWRzIHRoZSBSZWFjdCBEZXZUb29scyBiYWNrZW5kLFxuICAvLyBidXQgY2Fubm90IGNvbnRyb2wgd2hpY2ggdmVyc2lvbiBvZiB0aGUgZnJvbnRlbmQgdXNlcnMgdXNlLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgbm90aGluZyBpbiB0aGUgbmV3ZXIgYmFja2VuZCBhY3R1YWxseSBsaXN0ZW5zIHRvIHRoZXNlIGV2ZW50cyxcbiAgLy8gYnV0IHRoZSBuZXcgZnJvbnRlbmQgc3RpbGwgZGlzcGF0Y2hlcyB0aGVtIChpbiBjYXNlIG9sZGVyIGJhY2tlbmRzIGFyZSBsaXN0ZW5pbmcgdG8gdGhlbSBpbnN0ZWFkKS5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHRoaXMgYXBwcm9hY2ggZG9lcyBubyBzdXBwb3J0IHRoZSBjb21iaW5hdGlvbiBvZiBhIG5ld2VyIGJhY2tlbmQgd2l0aCBhbiBvbGRlciBmcm9udGVuZC5cbiAgLy8gSXQgd291bGQgYmUgbW9yZSB3b3JrIHRvIHN1cHBvcnQgYm90aCBhcHByb2FjaGVzIChhbmQgbm90IHJ1biBoYW5kbGVycyB0d2ljZSlcbiAgLy8gc28gSSBjaG9zZSB0byBzdXBwb3J0IHRoZSBtb3JlIGxpa2VseS9jb21tb24gc2NlbmFyaW8gKGFuZCB0aGUgb25lIG1vcmUgZGlmZmljdWx0IGZvciBhbiBlbmQgdXNlciB0byBcImZpeFwiKS5cbiAgb3ZlcnJpZGVDb250ZXh0OiBbT3ZlcnJpZGVWYWx1ZV0sXG4gIG92ZXJyaWRlSG9va1N0YXRlOiBbT3ZlcnJpZGVIb29rU3RhdGVdLFxuICBvdmVycmlkZVByb3BzOiBbT3ZlcnJpZGVWYWx1ZV0sXG4gIG92ZXJyaWRlU3RhdGU6IFtPdmVycmlkZVZhbHVlXSxcblxuICByZXN1bWVFbGVtZW50UG9sbGluZzogW10sXG4gIHBhdXNlRWxlbWVudFBvbGxpbmc6IFtdLFxuXG4gIGdldEhvb2tTZXR0aW5nczogW10sXG59O1xuXG5jbGFzcyBCcmlkZ2U8XG4gIE91dGdvaW5nRXZlbnRzOiBPYmplY3QsXG4gIEluY29taW5nRXZlbnRzOiBPYmplY3QsXG4+IGV4dGVuZHMgRXZlbnRFbWl0dGVyPHtcbiAgLi4uSW5jb21pbmdFdmVudHMsXG4gIC4uLk91dGdvaW5nRXZlbnRzLFxufT4ge1xuICBfaXNTaHV0ZG93bjogYm9vbGVhbiA9IGZhbHNlO1xuICBfbWVzc2FnZVF1ZXVlOiBBcnJheTxhbnk+ID0gW107XG4gIF9zY2hlZHVsZWRGbHVzaDogYm9vbGVhbiA9IGZhbHNlO1xuICBfd2FsbDogV2FsbDtcbiAgX3dhbGxVbmxpc3RlbjogRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcih3YWxsOiBXYWxsKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3dhbGwgPSB3YWxsO1xuXG4gICAgdGhpcy5fd2FsbFVubGlzdGVuID1cbiAgICAgIHdhbGwubGlzdGVuKChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UuZXZlbnQpIHtcbiAgICAgICAgICAodGhpczogYW55KS5lbWl0KG1lc3NhZ2UuZXZlbnQsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0pIHx8IG51bGw7XG5cbiAgICAvLyBUZW1wb3JhcmlseSBzdXBwb3J0IG9sZGVyIHN0YW5kYWxvbmUgZnJvbnQtZW5kcyBzZW5kaW5nIGNvbW1hbmRzIHRvIG5ld2VyIGVtYmVkZGVkIGJhY2tlbmRzLlxuICAgIC8vIFdlIGRvIHRoaXMgYmVjYXVzZSBSZWFjdCBOYXRpdmUgZW1iZWRzIHRoZSBSZWFjdCBEZXZUb29scyBiYWNrZW5kLFxuICAgIC8vIGJ1dCBjYW5ub3QgY29udHJvbCB3aGljaCB2ZXJzaW9uIG9mIHRoZSBmcm9udGVuZCB1c2VycyB1c2UuXG4gICAgdGhpcy5hZGRMaXN0ZW5lcignb3ZlcnJpZGVWYWx1ZUF0UGF0aCcsIHRoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCk7XG4gIH1cblxuICAvLyBMaXN0ZW5pbmcgZGlyZWN0bHkgdG8gdGhlIHdhbGwgaXNuJ3QgYWR2aXNlZC5cbiAgLy8gSXQgY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBsZWdhY3kgKHYzKSBtZXNzYWdlcyAoc2luY2UgdGhleSB1c2UgYSBkaWZmZXJlbnQgZm9ybWF0KS5cbiAgZ2V0IHdhbGwoKTogV2FsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGw7XG4gIH1cblxuICBzZW5kPEV2ZW50TmFtZTogJEtleXM8T3V0Z29pbmdFdmVudHM+PihcbiAgICBldmVudDogRXZlbnROYW1lLFxuICAgIC4uLnBheWxvYWQ6ICRFbGVtZW50VHlwZTxPdXRnb2luZ0V2ZW50cywgRXZlbnROYW1lPlxuICApIHtcbiAgICBpZiAodGhpcy5faXNTaHV0ZG93bikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgQ2Fubm90IHNlbmQgbWVzc2FnZSBcIiR7ZXZlbnR9XCIgdGhyb3VnaCBhIEJyaWRnZSB0aGF0IGhhcyBiZWVuIHNodXRkb3duLmAsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoZW4gd2UgcmVjZWl2ZSBhIG1lc3NhZ2U6XG4gICAgLy8gLSB3ZSBhZGQgaXQgdG8gb3VyIHF1ZXVlIG9mIG1lc3NhZ2VzIHRvIGJlIHNlbnRcbiAgICAvLyAtIGlmIHRoZXJlIGhhc24ndCBiZWVuIGEgbWVzc2FnZSByZWNlbnRseSwgd2Ugc2V0IGEgdGltZXIgZm9yIDAgbXMgaW5cbiAgICAvLyAgIHRoZSBmdXR1cmUsIGFsbG93aW5nIGFsbCBtZXNzYWdlcyBjcmVhdGVkIGluIHRoZSBzYW1lIHRpY2sgdG8gYmUgc2VudFxuICAgIC8vICAgdG9nZXRoZXJcbiAgICAvLyAtIGlmIHRoZXJlICpoYXMqIGJlZW4gYSBtZXNzYWdlIGZsdXNoZWQgaW4gdGhlIGxhc3QgQkFUQ0hfRFVSQVRJT04gbXNcbiAgICAvLyAgIChvciB3ZSdyZSB3YWl0aW5nIGZvciBvdXIgc2V0VGltZW91dC0wIHRvIGZpcmUpLCB0aGVuIF90aW1lb3V0SUQgd2lsbFxuICAgIC8vICAgYmUgc2V0LCBhbmQgd2UnbGwgc2ltcGx5IGFkZCB0byB0aGUgcXVldWUgYW5kIHdhaXQgZm9yIHRoYXRcbiAgICB0aGlzLl9tZXNzYWdlUXVldWUucHVzaChldmVudCwgcGF5bG9hZCk7XG4gICAgaWYgKCF0aGlzLl9zY2hlZHVsZWRGbHVzaCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkRmx1c2ggPSB0cnVlO1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgaWYgKHR5cGVvZiBkZXZ0b29sc0plc3RUZXN0U2NoZWR1bGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRoaXMgZXhpc3RzIGp1c3QgZm9yIG91ciBvd24gamVzdCB0ZXN0cy5cbiAgICAgICAgLy8gVGhleSdyZSB3cml0dGVuIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBjYW4gbmVpdGhlciBtb2NrIHF1ZXVlTWljcm90YXNrXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlbiB3ZSBicmVhayBSZWFjdCBET00gYW5kIHdlIGNhbid0IG5vdCBtb2NrIGl0IGJlY2F1c2UgdGhlblxuICAgICAgICAvLyB3ZSBjYW4ndCBzeW5jaHJvbm91c2x5IGZsdXNoIGl0LiBTbyB0aGV5IG5lZWQgdG8gYmUgcmV3cml0dGVuLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIGRldnRvb2xzSmVzdFRlc3RTY2hlZHVsZXIodGhpcy5fZmx1c2gpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayh0aGlzLl9mbHVzaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2h1dGRvd24oKSB7XG4gICAgaWYgKHRoaXMuX2lzU2h1dGRvd24pIHtcbiAgICAgIGNvbnNvbGUud2FybignQnJpZGdlIHdhcyBhbHJlYWR5IHNodXRkb3duLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFF1ZXVlIHRoZSBzaHV0ZG93biBvdXRnb2luZyBtZXNzYWdlIGZvciBzdWJzY3JpYmVycy5cbiAgICB0aGlzLmVtaXQoJ3NodXRkb3duJyk7XG4gICAgdGhpcy5zZW5kKCdzaHV0ZG93bicpO1xuXG4gICAgLy8gTWFyayB0aGlzIGJyaWRnZSBhcyBkZXN0cm95ZWQsIGkuZS4gZGlzYWJsZSBpdHMgcHVibGljIEFQSS5cbiAgICB0aGlzLl9pc1NodXRkb3duID0gdHJ1ZTtcblxuICAgIC8vIERpc2FibGUgdGhlIEFQSSBpbmhlcml0ZWQgZnJvbSBFdmVudEVtaXR0ZXIgdGhhdCBjYW4gYWRkIG1vcmUgbGlzdGVuZXJzIGFuZCBzZW5kIG1vcmUgbWVzc2FnZXMuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIFRoaXMgcHJvcGVydHkgaXMgbm90IHdyaXRhYmxlLlxuICAgIHRoaXMuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gVGhpcyBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG4gICAgdGhpcy5lbWl0ID0gZnVuY3Rpb24gKCkge307XG4gICAgLy8gTk9URTogVGhlcmUncyBhbHNvIEV2ZW50RW1pdHRlciBBUEkgbGlrZSBgb25gIGFuZCBgcHJlcGVuZExpc3RlbmVyYCB0aGF0IHdlIGRpZG4ndCBhZGQgdG8gb3VyIEZsb3cgdHlwZSBvZiBFdmVudEVtaXR0ZXIuXG5cbiAgICAvLyBVbnN1YnNjcmliZSB0aGlzIGJyaWRnZSBpbmNvbWluZyBtZXNzYWdlIGxpc3RlbmVycyB0byBiZSBzdXJlLCBhbmQgc28gdGhleSBkb24ndCBoYXZlIHRvIGRvIHRoYXQuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIFN0b3AgYWNjZXB0aW5nIGFuZCBlbWl0dGluZyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSB3YWxsLlxuICAgIGNvbnN0IHdhbGxVbmxpc3RlbiA9IHRoaXMuX3dhbGxVbmxpc3RlbjtcbiAgICBpZiAod2FsbFVubGlzdGVuKSB7XG4gICAgICB3YWxsVW5saXN0ZW4oKTtcbiAgICB9XG5cbiAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCBxdWV1ZWQgb3V0Z29pbmcgbWVzc2FnZXMuXG4gICAgLy8gQXQgdGhpcyBzdGVwIHRoZSBzdWJzY3JpYmVycycgY29kZSBtYXkgcnVuIGluIHRoaXMgY2FsbCBzdGFjay5cbiAgICBkbyB7XG4gICAgICB0aGlzLl9mbHVzaCgpO1xuICAgIH0gd2hpbGUgKHRoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGgpO1xuICB9XG5cbiAgX2ZsdXNoOiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgYWZ0ZXIgdGhlIGJyaWRnZSBpcyBtYXJrZWQgYXMgZGVzdHJveWVkIGluIHNodXRkb3duIHNlcXVlbmNlLFxuICAgIC8vIHNvIHdlIGRvIG5vdCBiYWlsIG91dCBpZiB0aGUgYnJpZGdlIG1hcmtlZCBhcyBkZXN0cm95ZWQuXG4gICAgLy8gSXQgaXMgYSBwcml2YXRlIG1ldGhvZCB0aGF0IHRoZSBicmlkZ2UgZW5zdXJlcyBpcyBvbmx5IGNhbGxlZCBhdCB0aGUgcmlnaHQgdGltZXMuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9tZXNzYWdlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbWVzc2FnZVF1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgdGhpcy5fd2FsbC5zZW5kKHRoaXMuX21lc3NhZ2VRdWV1ZVtpXSwgLi4udGhpcy5fbWVzc2FnZVF1ZXVlW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVzc2FnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFdlIHNldCB0aGlzIGF0IHRoZSBlbmQgaW4gY2FzZSBuZXcgbWVzc2FnZXMgYXJlIGFkZGVkIHN5bmNocm9ub3VzbHkgYWJvdmUuXG4gICAgICAvLyBUaGV5J3JlIGFscmVhZHkgaGFuZGxlZCBzbyB0aGV5IHNob3VsZG4ndCBxdWV1ZSBtb3JlIGZsdXNoZXMuXG4gICAgICB0aGlzLl9zY2hlZHVsZWRGbHVzaCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBUZW1wb3JhcmlseSBzdXBwb3J0IG9sZGVyIHN0YW5kYWxvbmUgYmFja2VuZHMgYnkgZm9yd2FyZGluZyBcIm92ZXJyaWRlVmFsdWVBdFBhdGhcIiBjb21tYW5kc1xuICAvLyB0byB0aGUgb2xkZXIgbWVzc2FnZSB0eXBlcyB0aGV5IG1heSBiZSBsaXN0ZW5pbmcgdG8uXG4gIG92ZXJyaWRlVmFsdWVBdFBhdGg6IE92ZXJyaWRlVmFsdWVBdFBhdGggPT4gdm9pZCA9ICh7XG4gICAgaWQsXG4gICAgcGF0aCxcbiAgICByZW5kZXJlcklELFxuICAgIHR5cGUsXG4gICAgdmFsdWUsXG4gIH06IE92ZXJyaWRlVmFsdWVBdFBhdGgpID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2NvbnRleHQnOlxuICAgICAgICB0aGlzLnNlbmQoJ292ZXJyaWRlQ29udGV4dCcsIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdob29rcyc6XG4gICAgICAgIHRoaXMuc2VuZCgnb3ZlcnJpZGVIb29rU3RhdGUnLCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgIHdhc0ZvcndhcmRlZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHJvcHMnOlxuICAgICAgICB0aGlzLnNlbmQoJ292ZXJyaWRlUHJvcHMnLCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgIHdhc0ZvcndhcmRlZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICB0aGlzLnNlbmQoJ292ZXJyaWRlU3RhdGUnLCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklELFxuICAgICAgICAgIHdhc0ZvcndhcmRlZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHR5cGUgQmFja2VuZEJyaWRnZSA9IEJyaWRnZTxCYWNrZW5kRXZlbnRzLCBGcm9udGVuZEV2ZW50cz47XG5leHBvcnQgdHlwZSBGcm9udGVuZEJyaWRnZSA9IEJyaWRnZTxGcm9udGVuZEV2ZW50cywgQmFja2VuZEV2ZW50cz47XG5cbmV4cG9ydCBkZWZhdWx0IEJyaWRnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/bridge.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js":
/*!****************************************************************************!*\
  !*** ../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"enableLogger\": () => (/* binding */ enableLogger),\n/* harmony export */   \"enableStyleXFeatures\": () => (/* binding */ enableStyleXFeatures),\n/* harmony export */   \"isInternalFacebookBuild\": () => (/* binding */ isInternalFacebookBuild)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/************************************************************************\n * This file is forked between different DevTools implementations.\n * It should never be imported directly!\n * It should always be imported from \"react-devtools-feature-flags\".\n ************************************************************************/\nvar enableLogger = false;\nvar enableStyleXFeatures = false;\nvar isInternalFacebookBuild = false;\n/************************************************************************\n * Do not edit the code below.\n * It ensures this fork exports the same types as the default flags file.\n ************************************************************************/\n\n// Flow magic to verify the exports of this file match the original version.\nnull;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25maWcvRGV2VG9vbHNGZWF0dXJlRmxhZ3MuY29yZS1vc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7OztBQVNBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7OztBQVFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2NvbmZpZy9EZXZUb29sc0ZlYXR1cmVGbGFncy5jb3JlLW9zcy5qcz8wYWU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRoaXMgZmlsZSBpcyBmb3JrZWQgYmV0d2VlbiBkaWZmZXJlbnQgRGV2VG9vbHMgaW1wbGVtZW50YXRpb25zLlxuICogSXQgc2hvdWxkIG5ldmVyIGJlIGltcG9ydGVkIGRpcmVjdGx5IVxuICogSXQgc2hvdWxkIGFsd2F5cyBiZSBpbXBvcnRlZCBmcm9tIFwicmVhY3QtZGV2dG9vbHMtZmVhdHVyZS1mbGFnc1wiLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZXhwb3J0IGNvbnN0IGVuYWJsZUxvZ2dlciA9IGZhbHNlO1xuZXhwb3J0IGNvbnN0IGVuYWJsZVN0eWxlWEZlYXR1cmVzID0gZmFsc2U7XG5leHBvcnQgY29uc3QgaXNJbnRlcm5hbEZhY2Vib29rQnVpbGQgPSBmYWxzZTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRG8gbm90IGVkaXQgdGhlIGNvZGUgYmVsb3cuXG4gKiBJdCBlbnN1cmVzIHRoaXMgZm9yayBleHBvcnRzIHRoZSBzYW1lIHR5cGVzIGFzIHRoZSBkZWZhdWx0IGZsYWdzIGZpbGUuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5pbXBvcnQgdHlwZW9mICogYXMgRmVhdHVyZUZsYWdzVHlwZSBmcm9tICcuL0RldlRvb2xzRmVhdHVyZUZsYWdzLmRlZmF1bHQnO1xuaW1wb3J0IHR5cGVvZiAqIGFzIEV4cG9ydHNUeXBlIGZyb20gJy4vRGV2VG9vbHNGZWF0dXJlRmxhZ3MuY29yZS1vc3MnO1xuXG4vLyBGbG93IG1hZ2ljIHRvIHZlcmlmeSB0aGUgZXhwb3J0cyBvZiB0aGlzIGZpbGUgbWF0Y2ggdGhlIG9yaWdpbmFsIHZlcnNpb24uXG4oKCgobnVsbDogYW55KTogRXhwb3J0c1R5cGUpOiBGZWF0dXJlRmxhZ3NUeXBlKTogRXhwb3J0c1R5cGUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/constants.js":
/*!*************************************************!*\
  !*** ../react-devtools-shared/src/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ANSI_STYLE_DIMMING_TEMPLATE\": () => (/* binding */ ANSI_STYLE_DIMMING_TEMPLATE),\n/* harmony export */   \"ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK\": () => (/* binding */ ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK),\n/* harmony export */   \"CHROME_WEBSTORE_EXTENSION_ID\": () => (/* binding */ CHROME_WEBSTORE_EXTENSION_ID),\n/* harmony export */   \"FIREFOX_CONSOLE_DIMMING_COLOR\": () => (/* binding */ FIREFOX_CONSOLE_DIMMING_COLOR),\n/* harmony export */   \"INTERNAL_EXTENSION_ID\": () => (/* binding */ INTERNAL_EXTENSION_ID),\n/* harmony export */   \"LOCAL_EXTENSION_ID\": () => (/* binding */ LOCAL_EXTENSION_ID),\n/* harmony export */   \"LOCAL_STORAGE_BROWSER_THEME\": () => (/* binding */ LOCAL_STORAGE_BROWSER_THEME),\n/* harmony export */   \"LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY\": () => (/* binding */ LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY),\n/* harmony export */   \"LOCAL_STORAGE_DEFAULT_TAB_KEY\": () => (/* binding */ LOCAL_STORAGE_DEFAULT_TAB_KEY),\n/* harmony export */   \"LOCAL_STORAGE_OPEN_IN_EDITOR_URL\": () => (/* binding */ LOCAL_STORAGE_OPEN_IN_EDITOR_URL),\n/* harmony export */   \"LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET\": () => (/* binding */ LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET),\n/* harmony export */   \"LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY\": () => (/* binding */ LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY),\n/* harmony export */   \"LOCAL_STORAGE_SUPPORTS_PROFILING_KEY\": () => (/* binding */ LOCAL_STORAGE_SUPPORTS_PROFILING_KEY),\n/* harmony export */   \"LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY\": () => (/* binding */ LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY),\n/* harmony export */   \"PROFILER_EXPORT_VERSION\": () => (/* binding */ PROFILER_EXPORT_VERSION),\n/* harmony export */   \"PROFILING_FLAG_BASIC_SUPPORT\": () => (/* binding */ PROFILING_FLAG_BASIC_SUPPORT),\n/* harmony export */   \"PROFILING_FLAG_TIMELINE_SUPPORT\": () => (/* binding */ PROFILING_FLAG_TIMELINE_SUPPORT),\n/* harmony export */   \"SESSION_STORAGE_LAST_SELECTION_KEY\": () => (/* binding */ SESSION_STORAGE_LAST_SELECTION_KEY),\n/* harmony export */   \"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\": () => (/* binding */ SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY),\n/* harmony export */   \"SESSION_STORAGE_RECORD_TIMELINE_KEY\": () => (/* binding */ SESSION_STORAGE_RECORD_TIMELINE_KEY),\n/* harmony export */   \"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\": () => (/* binding */ SESSION_STORAGE_RELOAD_AND_PROFILE_KEY),\n/* harmony export */   \"TREE_OPERATION_ADD\": () => (/* binding */ TREE_OPERATION_ADD),\n/* harmony export */   \"TREE_OPERATION_REMOVE\": () => (/* binding */ TREE_OPERATION_REMOVE),\n/* harmony export */   \"TREE_OPERATION_REMOVE_ROOT\": () => (/* binding */ TREE_OPERATION_REMOVE_ROOT),\n/* harmony export */   \"TREE_OPERATION_REORDER_CHILDREN\": () => (/* binding */ TREE_OPERATION_REORDER_CHILDREN),\n/* harmony export */   \"TREE_OPERATION_SET_SUBTREE_MODE\": () => (/* binding */ TREE_OPERATION_SET_SUBTREE_MODE),\n/* harmony export */   \"TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS\": () => (/* binding */ TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS),\n/* harmony export */   \"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\": () => (/* binding */ TREE_OPERATION_UPDATE_TREE_BASE_DURATION),\n/* harmony export */   \"__DEBUG__\": () => (/* binding */ __DEBUG__),\n/* harmony export */   \"__PERFORMANCE_PROFILE__\": () => (/* binding */ __PERFORMANCE_PROFILE__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar CHROME_WEBSTORE_EXTENSION_ID = 'fmkadmapgofadopljbjfkapdkoienihi';\nvar INTERNAL_EXTENSION_ID = 'dnjnjgbfilfphmojnmhliehogmojhclc';\nvar LOCAL_EXTENSION_ID = 'ikiahnapldjmdmpkmfhjdjilojjhgcbf'; // Flip this flag to true to enable verbose console debug logging.\n\nvar __DEBUG__ = false; // Flip this flag to true to enable performance.mark() and performance.measure() timings.\n\nvar __PERFORMANCE_PROFILE__ = false;\nvar TREE_OPERATION_ADD = 1;\nvar TREE_OPERATION_REMOVE = 2;\nvar TREE_OPERATION_REORDER_CHILDREN = 3;\nvar TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;\nvar TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;\nvar TREE_OPERATION_REMOVE_ROOT = 6;\nvar TREE_OPERATION_SET_SUBTREE_MODE = 7;\nvar PROFILING_FLAG_BASIC_SUPPORT = 1;\nvar PROFILING_FLAG_TIMELINE_SUPPORT = 2;\nvar LOCAL_STORAGE_DEFAULT_TAB_KEY = 'React::DevTools::defaultTab';\nvar LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';\nvar SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';\nvar LOCAL_STORAGE_OPEN_IN_EDITOR_URL = 'React::DevTools::openInEditorUrl';\nvar LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET = 'React::DevTools::openInEditorUrlPreset';\nvar LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';\nvar SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';\nvar SESSION_STORAGE_RECORD_TIMELINE_KEY = 'React::DevTools::recordTimeline';\nvar SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';\nvar LOCAL_STORAGE_BROWSER_THEME = 'React::DevTools::theme';\nvar LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';\nvar LOCAL_STORAGE_SUPPORTS_PROFILING_KEY = 'React::DevTools::supportsProfiling';\nvar PROFILER_EXPORT_VERSION = 5;\nvar FIREFOX_CONSOLE_DIMMING_COLOR = 'color: rgba(124, 124, 124, 0.75)';\nvar ANSI_STYLE_DIMMING_TEMPLATE = '\\x1b[2;38;2;124;124;124m%s\\x1b[0m';\nvar ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK = '\\x1b[2;38;2;124;124;124m%s %o\\x1b[0m';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2NvbnN0YW50cy5qcz9hMzA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCBjb25zdCBDSFJPTUVfV0VCU1RPUkVfRVhURU5TSU9OX0lEID0gJ2Zta2FkbWFwZ29mYWRvcGxqYmpma2FwZGtvaWVuaWhpJztcbmV4cG9ydCBjb25zdCBJTlRFUk5BTF9FWFRFTlNJT05fSUQgPSAnZG5qbmpnYmZpbGZwaG1vam5taGxpZWhvZ21vamhjbGMnO1xuZXhwb3J0IGNvbnN0IExPQ0FMX0VYVEVOU0lPTl9JRCA9ICdpa2lhaG5hcGxkam1kbXBrbWZoamRqaWxvampoZ2NiZic7XG5cbi8vIEZsaXAgdGhpcyBmbGFnIHRvIHRydWUgdG8gZW5hYmxlIHZlcmJvc2UgY29uc29sZSBkZWJ1ZyBsb2dnaW5nLlxuZXhwb3J0IGNvbnN0IF9fREVCVUdfXyA9IGZhbHNlO1xuXG4vLyBGbGlwIHRoaXMgZmxhZyB0byB0cnVlIHRvIGVuYWJsZSBwZXJmb3JtYW5jZS5tYXJrKCkgYW5kIHBlcmZvcm1hbmNlLm1lYXN1cmUoKSB0aW1pbmdzLlxuZXhwb3J0IGNvbnN0IF9fUEVSRk9STUFOQ0VfUFJPRklMRV9fID0gZmFsc2U7XG5cbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9BREQgPSAxO1xuZXhwb3J0IGNvbnN0IFRSRUVfT1BFUkFUSU9OX1JFTU9WRSA9IDI7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTiA9IDM7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTiA9IDQ7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyA9IDU7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fUkVNT1ZFX1JPT1QgPSA2O1xuZXhwb3J0IGNvbnN0IFRSRUVfT1BFUkFUSU9OX1NFVF9TVUJUUkVFX01PREUgPSA3O1xuXG5leHBvcnQgY29uc3QgUFJPRklMSU5HX0ZMQUdfQkFTSUNfU1VQUE9SVCA9IDBiMDE7XG5leHBvcnQgY29uc3QgUFJPRklMSU5HX0ZMQUdfVElNRUxJTkVfU1VQUE9SVCA9IDBiMTA7XG5cbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX0RFRkFVTFRfVEFCX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OmRlZmF1bHRUYWInO1xuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfQ09NUE9ORU5UX0ZJTFRFUl9QUkVGRVJFTkNFU19LRVkgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjpjb21wb25lbnRGaWx0ZXJzJztcbmV4cG9ydCBjb25zdCBTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6bGFzdFNlbGVjdGlvbic7XG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9PUEVOX0lOX0VESVRPUl9VUkwgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjpvcGVuSW5FZGl0b3JVcmwnO1xuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfT1BFTl9JTl9FRElUT1JfVVJMX1BSRVNFVCA9XG4gICdSZWFjdDo6RGV2VG9vbHM6Om9wZW5JbkVkaXRvclVybFByZXNldCc7XG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9QQVJTRV9IT09LX05BTUVTX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnBhcnNlSG9va05hbWVzJztcbmV4cG9ydCBjb25zdCBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6cmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zJztcbmV4cG9ydCBjb25zdCBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX1RJTUVMSU5FX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnJlY29yZFRpbWVsaW5lJztcbmV4cG9ydCBjb25zdCBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnJlbG9hZEFuZFByb2ZpbGUnO1xuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfQlJPV1NFUl9USEVNRSA9ICdSZWFjdDo6RGV2VG9vbHM6OnRoZW1lJztcbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX1RSQUNFX1VQREFURVNfRU5BQkxFRF9LRVkgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjp0cmFjZVVwZGF0ZXNFbmFibGVkJztcbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX1NVUFBPUlRTX1BST0ZJTElOR19LRVkgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjpzdXBwb3J0c1Byb2ZpbGluZyc7XG5cbmV4cG9ydCBjb25zdCBQUk9GSUxFUl9FWFBPUlRfVkVSU0lPTiA9IDU7XG5cbmV4cG9ydCBjb25zdCBGSVJFRk9YX0NPTlNPTEVfRElNTUlOR19DT0xPUiA9ICdjb2xvcjogcmdiYSgxMjQsIDEyNCwgMTI0LCAwLjc1KSc7XG5leHBvcnQgY29uc3QgQU5TSV9TVFlMRV9ESU1NSU5HX1RFTVBMQVRFID0gJ1xceDFiWzI7Mzg7MjsxMjQ7MTI0OzEyNG0lc1xceDFiWzBtJztcbmV4cG9ydCBjb25zdCBBTlNJX1NUWUxFX0RJTU1JTkdfVEVNUExBVEVfV0lUSF9DT01QT05FTlRfU1RBQ0sgPVxuICAnXFx4MWJbMjszODsyOzEyNDsxMjQ7MTI0bSVzICVvXFx4MWJbMG0nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/constants.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/constants.js":
/*!**********************************************************!*\
  !*** ../react-devtools-shared/src/devtools/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CHANGE_LOG_URL\": () => (/* binding */ CHANGE_LOG_URL),\n/* harmony export */   \"COMFORTABLE_LINE_HEIGHT\": () => (/* binding */ COMFORTABLE_LINE_HEIGHT),\n/* harmony export */   \"COMPACT_LINE_HEIGHT\": () => (/* binding */ COMPACT_LINE_HEIGHT),\n/* harmony export */   \"REACT_DEVTOOLS_WORKPLACE_URL\": () => (/* binding */ REACT_DEVTOOLS_WORKPLACE_URL),\n/* harmony export */   \"THEME_STYLES\": () => (/* binding */ THEME_STYLES),\n/* harmony export */   \"UNSUPPORTED_VERSION_URL\": () => (/* binding */ UNSUPPORTED_VERSION_URL)\n/* harmony export */ });\nvar CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md';\nvar UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back';\nvar REACT_DEVTOOLS_WORKPLACE_URL = 'https://fburl.com/react-devtools-workplace-group';\nvar THEME_STYLES = {\n  light: {\n    '--color-attribute-name': '#ef6632',\n    '--color-attribute-name-not-editable': '#23272f',\n    '--color-attribute-name-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-attribute-value': '#1a1aa6',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': '#1a1aa6',\n    '--color-background': '#ffffff',\n    '--color-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-background-inactive': '#e5e5e5',\n    '--color-background-invalid': '#fff0f0',\n    '--color-background-selected': '#0088fa',\n    '--color-button-background': '#ffffff',\n    '--color-button-background-focus': '#ededed',\n    '--color-button': '#5f6673',\n    '--color-button-disabled': '#cfd1d5',\n    '--color-button-active': '#0088fa',\n    '--color-button-focus': '#23272f',\n    '--color-button-hover': '#23272f',\n    '--color-border': '#eeeeee',\n    '--color-commit-did-not-render-fill': '#cfd1d5',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#cfd1d5',\n    '--color-commit-did-not-render-pattern-text': '#333333',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#6a51b2',\n    '--color-component-name-inverted': '#ffffff',\n    '--color-component-badge-background': '#e6e6e6',\n    '--color-component-badge-background-inverted': 'rgba(255, 255, 255, 0.25)',\n    '--color-component-badge-count': '#777d88',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-console-error-badge-text': '#ffffff',\n    '--color-console-error-background': '#fff0f0',\n    '--color-console-error-border': '#ffd6d6',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fe2e31',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#fffbe5',\n    '--color-console-warning-border': '#fff5c1',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#64460c',\n    '--color-context-background': 'rgba(0,0,0,.9)',\n    '--color-context-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-context-background-selected': '#178fb9',\n    '--color-context-border': '#3d424a',\n    '--color-context-text': '#ffffff',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#777d88',\n    '--color-dimmer': '#cfd1d5',\n    '--color-dimmest': '#eff0f1',\n    '--color-error-background': 'hsl(0, 100%, 97%)',\n    '--color-error-border': 'hsl(0, 100%, 92%)',\n    '--color-error-text': '#ff0000',\n    '--color-expand-collapse-toggle': '#777d88',\n    '--color-forget-badge-background': '#2683e2',\n    '--color-forget-badge-background-inverted': '#1a6bbc',\n    '--color-forget-text': '#fff',\n    '--color-link': '#0000ff',\n    '--color-modal-background': 'rgba(255, 255, 255, 0.75)',\n    '--color-bridge-version-npm-background': '#eff0f1',\n    '--color-bridge-version-npm-text': '#000000',\n    '--color-bridge-version-number': '#0088fa',\n    '--color-primitive-hook-badge-background': '#e5e5e5',\n    '--color-primitive-hook-badge-text': '#5f6673',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#3578e5',\n    '--color-record-inactive': '#0088fa',\n    '--color-resize-bar': '#eeeeee',\n    '--color-resize-bar-active': '#dcdcdc',\n    '--color-resize-bar-border': '#d1d1d1',\n    '--color-resize-bar-dot': '#333333',\n    '--color-timeline-internal-module': '#d1d1d1',\n    '--color-timeline-internal-module-hover': '#c9c9c9',\n    '--color-timeline-internal-module-text': '#444',\n    '--color-timeline-native-event': '#ccc',\n    '--color-timeline-native-event-hover': '#aaa',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#f0e7d1',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#e3ba52',\n    '--color-timeline-priority-background': '#f6f6f6',\n    '--color-timeline-priority-border': '#eeeeee',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#d3e5f6',\n    '--color-timeline-react-idle-hover': '#c3d9ef',\n    '--color-timeline-react-render': '#9fc3f3',\n    '--color-timeline-react-render-hover': '#83afe9',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#c88ff0',\n    '--color-timeline-react-commit-hover': '#b281d6',\n    '--color-timeline-react-commit-text': '#3e2c4a',\n    '--color-timeline-react-layout-effects': '#b281d6',\n    '--color-timeline-react-layout-effects-hover': '#9d71bd',\n    '--color-timeline-react-layout-effects-text': '#3e2c4a',\n    '--color-timeline-react-passive-effects': '#b281d6',\n    '--color-timeline-react-passive-effects-hover': '#9d71bd',\n    '--color-timeline-react-passive-effects-text': '#3e2c4a',\n    '--color-timeline-react-schedule': '#9fc3f3',\n    '--color-timeline-react-schedule-hover': '#2683E2',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#ffdf37',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#ee1638',\n    '--color-timeline-thrown-error-hover': '#da1030',\n    '--color-timeline-text-color': '#000000',\n    '--color-timeline-text-dim-color': '#ccc',\n    '--color-timeline-react-work-border': '#eeeeee',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(0, 136, 250, 0.1)',\n    '--color-selected-tree-highlight-inactive': 'rgba(0, 0, 0, 0.05)',\n    '--color-scroll-caret': 'rgba(150, 150, 150, 0.5)',\n    '--color-tab-selected-border': '#0088fa',\n    '--color-text': '#000000',\n    '--color-text-invalid': '#ff0000',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#0088fa',\n    '--color-toggle-background-off': '#cfd1d5',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#fb3655',\n    '--color-warning-background-hover': '#f82042',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#fd4d69',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#c2c2c2',\n    '--color-scroll-track': '#fafafa',\n    '--color-tooltip-background': 'rgba(0, 0, 0, 0.9)',\n    '--color-tooltip-text': '#ffffff'\n  },\n  dark: {\n    '--color-attribute-name': '#9d87d2',\n    '--color-attribute-name-not-editable': '#ededed',\n    '--color-attribute-name-inverted': '#282828',\n    '--color-attribute-value': '#cedae0',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': 'yellow',\n    '--color-background': '#282c34',\n    '--color-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-background-inactive': '#3d424a',\n    '--color-background-invalid': '#5c0000',\n    '--color-background-selected': '#178fb9',\n    '--color-button-background': '#282c34',\n    '--color-button-background-focus': '#3d424a',\n    '--color-button': '#afb3b9',\n    '--color-button-active': '#61dafb',\n    '--color-button-disabled': '#4f5766',\n    '--color-button-focus': '#a2e9fc',\n    '--color-button-hover': '#ededed',\n    '--color-border': '#3d424a',\n    '--color-commit-did-not-render-fill': '#777d88',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#666c77',\n    '--color-commit-did-not-render-pattern-text': '#ffffff',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#61dafb',\n    '--color-component-name-inverted': '#282828',\n    '--color-component-badge-background': '#5e6167',\n    '--color-component-badge-background-inverted': '#46494e',\n    '--color-component-badge-count': '#8f949d',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.85)',\n    '--color-console-error-badge-text': '#000000',\n    '--color-console-error-background': '#290000',\n    '--color-console-error-border': '#5c0000',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fc7f7f',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#332b00',\n    '--color-console-warning-border': '#665500',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#f5f2ed',\n    '--color-context-background': 'rgba(255,255,255,.95)',\n    '--color-context-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-context-background-selected': '#0088fa',\n    '--color-context-border': '#eeeeee',\n    '--color-context-text': '#000000',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#8f949d',\n    '--color-dimmer': '#777d88',\n    '--color-dimmest': '#4f5766',\n    '--color-error-background': '#200',\n    '--color-error-border': '#900',\n    '--color-error-text': '#f55',\n    '--color-expand-collapse-toggle': '#8f949d',\n    '--color-forget-badge-background': '#2683e2',\n    '--color-forget-badge-background-inverted': '#1a6bbc',\n    '--color-forget-text': '#fff',\n    '--color-link': '#61dafb',\n    '--color-modal-background': 'rgba(0, 0, 0, 0.75)',\n    '--color-bridge-version-npm-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-bridge-version-npm-text': '#ffffff',\n    '--color-bridge-version-number': 'yellow',\n    '--color-primitive-hook-badge-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-primitive-hook-badge-text': 'rgba(255, 255, 255, 0.7)',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#a2e9fc',\n    '--color-record-inactive': '#61dafb',\n    '--color-resize-bar': '#282c34',\n    '--color-resize-bar-active': '#31363f',\n    '--color-resize-bar-border': '#3d424a',\n    '--color-resize-bar-dot': '#cfd1d5',\n    '--color-timeline-internal-module': '#303542',\n    '--color-timeline-internal-module-hover': '#363b4a',\n    '--color-timeline-internal-module-text': '#7f8899',\n    '--color-timeline-native-event': '#b2b2b2',\n    '--color-timeline-native-event-hover': '#949494',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#e3dbc5',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#d6af4d',\n    '--color-timeline-priority-background': '#1d2129',\n    '--color-timeline-priority-border': '#282c34',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#3d485b',\n    '--color-timeline-react-idle-hover': '#465269',\n    '--color-timeline-react-render': '#2683E2',\n    '--color-timeline-react-render-hover': '#1a76d4',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#731fad',\n    '--color-timeline-react-commit-hover': '#611b94',\n    '--color-timeline-react-commit-text': '#e5c1ff',\n    '--color-timeline-react-layout-effects': '#611b94',\n    '--color-timeline-react-layout-effects-hover': '#51167a',\n    '--color-timeline-react-layout-effects-text': '#e5c1ff',\n    '--color-timeline-react-passive-effects': '#611b94',\n    '--color-timeline-react-passive-effects-hover': '#51167a',\n    '--color-timeline-react-passive-effects-text': '#e5c1ff',\n    '--color-timeline-react-schedule': '#2683E2',\n    '--color-timeline-react-schedule-hover': '#1a76d4',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#e4c00f',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#fb3655',\n    '--color-timeline-thrown-error-hover': '#f82042',\n    '--color-timeline-text-color': '#282c34',\n    '--color-timeline-text-dim-color': '#555b66',\n    '--color-timeline-react-work-border': '#3d424a',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(23, 143, 185, 0.15)',\n    '--color-selected-tree-highlight-inactive': 'rgba(255, 255, 255, 0.05)',\n    '--color-scroll-caret': '#4f5766',\n    '--color-shadow': 'rgba(0, 0, 0, 0.5)',\n    '--color-tab-selected-border': '#178fb9',\n    '--color-text': '#ffffff',\n    '--color-text-invalid': '#ff8080',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#178fb9',\n    '--color-toggle-background-off': '#777d88',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#ee1638',\n    '--color-warning-background-hover': '#da1030',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#ee1638',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#afb3b9',\n    '--color-scroll-track': '#313640',\n    '--color-tooltip-background': 'rgba(255, 255, 255, 0.95)',\n    '--color-tooltip-text': '#000000'\n  },\n  compact: {\n    '--font-size-monospace-small': '9px',\n    '--font-size-monospace-normal': '11px',\n    '--font-size-monospace-large': '15px',\n    '--font-size-sans-small': '10px',\n    '--font-size-sans-normal': '12px',\n    '--font-size-sans-large': '14px',\n    '--line-height-data': '18px'\n  },\n  comfortable: {\n    '--font-size-monospace-small': '10px',\n    '--font-size-monospace-normal': '13px',\n    '--font-size-monospace-large': '17px',\n    '--font-size-sans-small': '12px',\n    '--font-size-sans-normal': '14px',\n    '--font-size-sans-large': '16px',\n    '--line-height-data': '22px'\n  }\n}; // HACK\n//\n// Sometimes the inline target is rendered before root styles are applied,\n// which would result in e.g. NaN itemSize being passed to react-window list.\n\nvar COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable['--line-height-data'], 10);\nvar COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact['--line-height-data'], 10);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFHQTtBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpKQTtBQW1KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEpBO0FBb0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQWpUQTtBQTZUQTtBQUNBO0FBQ0E7O0FBQ0E7QUFJQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvY29uc3RhbnRzLmpzPzE3MzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IENIQU5HRV9MT0dfVVJMID1cbiAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtZGV2dG9vbHMvQ0hBTkdFTE9HLm1kJztcblxuZXhwb3J0IGNvbnN0IFVOU1VQUE9SVEVEX1ZFUlNJT05fVVJMID1cbiAgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvYmxvZy8yMDE5LzA4LzE1L25ldy1yZWFjdC1kZXZ0b29scy5odG1sI2hvdy1kby1pLWdldC10aGUtb2xkLXZlcnNpb24tYmFjayc7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9ERVZUT09MU19XT1JLUExBQ0VfVVJMID1cbiAgJ2h0dHBzOi8vZmJ1cmwuY29tL3JlYWN0LWRldnRvb2xzLXdvcmtwbGFjZS1ncm91cCc7XG5cbmltcG9ydCB0eXBlIHtcbiAgVGhlbWUsXG4gIERpc3BsYXlEZW5zaXR5LFxufSBmcm9tICcuL2RldnRvb2xzL3ZpZXdzL1NldHRpbmdzL1NldHRpbmdzQ29udGV4dCc7XG5cbmV4cG9ydCBjb25zdCBUSEVNRV9TVFlMRVM6IHtbc3R5bGU6IFRoZW1lIHwgRGlzcGxheURlbnNpdHldOiBhbnksIC4uLn0gPSB7XG4gIGxpZ2h0OiB7XG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUnOiAnI2VmNjYzMicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUtbm90LWVkaXRhYmxlJzogJyMyMzI3MmYnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lLWludmVydGVkJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLXZhbHVlJzogJyMxYTFhYTYnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZS1pbnZlcnRlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtZWRpdGFibGUtdmFsdWUnOiAnIzFhMWFhNicsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWhvdmVyJzogJ3JnYmEoMCwgMTM2LCAyNTAsIDAuMSknLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaW5hY3RpdmUnOiAnI2U1ZTVlNScsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1pbnZhbGlkJzogJyNmZmYwZjAnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWJhY2tncm91bmQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYnV0dG9uLWJhY2tncm91bmQtZm9jdXMnOiAnI2VkZWRlZCcsXG4gICAgJy0tY29sb3ItYnV0dG9uJzogJyM1ZjY2NzMnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1kaXNhYmxlZCc6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci1idXR0b24tYWN0aXZlJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1mb2N1cyc6ICcjMjMyNzJmJyxcbiAgICAnLS1jb2xvci1idXR0b24taG92ZXInOiAnIzIzMjcyZicsXG4gICAgJy0tY29sb3ItYm9yZGVyJzogJyNlZWVlZWUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1maWxsJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1maWxsLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLXBhdHRlcm4nOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLXBhdHRlcm4tdGV4dCc6ICcjMzMzMzMzJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMCc6ICcjMzdhZmE5JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMSc6ICcjNjNiMTllJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMic6ICcjODBiMzkzJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMyc6ICcjOTdiNDg4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNCc6ICcjYWJiNjdkJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNSc6ICcjYmViNzcxJyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNic6ICcjY2ZiOTY1JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNyc6ICcjZGZiYTU3JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtOCc6ICcjZWZiYjQ5JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtOSc6ICcjZmViYzM4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZ3JhZGllbnQtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtbmFtZSc6ICcjNmE1MWIyJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtbmFtZS1pbnZlcnRlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtYmFja2dyb3VuZCc6ICcjZTZlNmU2JyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtYmFja2dyb3VuZC1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtY291bnQnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWNvdW50LWludmVydGVkJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1iYWRnZS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFja2dyb3VuZCc6ICcjZmZmMGYwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJvcmRlcic6ICcjZmZkNmQ2JyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWljb24nOiAnI2ViMzk0MScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci10ZXh0JzogJyNmZTJlMzEnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWRnZS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWNrZ3JvdW5kJzogJyNmZmZiZTUnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1ib3JkZXInOiAnI2ZmZjVjMScsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWljb24nOiAnI2Y0YmQwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLXRleHQnOiAnIzY0NDYwYycsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwwLDAsLjkpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtaG92ZXInOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItY29udGV4dC1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbnRleHQtdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1kaW0nOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItZGltbWVyJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWRpbW1lc3QnOiAnI2VmZjBmMScsXG4gICAgJy0tY29sb3ItZXJyb3ItYmFja2dyb3VuZCc6ICdoc2woMCwgMTAwJSwgOTclKScsXG4gICAgJy0tY29sb3ItZXJyb3ItYm9yZGVyJzogJ2hzbCgwLCAxMDAlLCA5MiUpJyxcbiAgICAnLS1jb2xvci1lcnJvci10ZXh0JzogJyNmZjAwMDAnLFxuICAgICctLWNvbG9yLWV4cGFuZC1jb2xsYXBzZS10b2dnbGUnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItZm9yZ2V0LWJhZGdlLWJhY2tncm91bmQnOiAnIzI2ODNlMicsXG4gICAgJy0tY29sb3ItZm9yZ2V0LWJhZGdlLWJhY2tncm91bmQtaW52ZXJ0ZWQnOiAnIzFhNmJiYycsXG4gICAgJy0tY29sb3ItZm9yZ2V0LXRleHQnOiAnI2ZmZicsXG4gICAgJy0tY29sb3ItbGluayc6ICcjMDAwMGZmJyxcbiAgICAnLS1jb2xvci1tb2RhbC1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS1iYWNrZ3JvdW5kJzogJyNlZmYwZjEnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW51bWJlcic6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1wcmltaXRpdmUtaG9vay1iYWRnZS1iYWNrZ3JvdW5kJzogJyNlNWU1ZTUnLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLXRleHQnOiAnIzVmNjY3MycsXG4gICAgJy0tY29sb3ItcmVjb3JkLWFjdGl2ZSc6ICcjZmMzYTRiJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtaG92ZXInOiAnIzM1NzhlNScsXG4gICAgJy0tY29sb3ItcmVjb3JkLWluYWN0aXZlJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1hY3RpdmUnOiAnI2RjZGNkYycsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1ib3JkZXInOiAnI2QxZDFkMScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1kb3QnOiAnIzMzMzMzMycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlJzogJyNkMWQxZDEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZS1ob3Zlcic6ICcjYzljOWM5JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUtdGV4dCc6ICcjNDQ0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uYXRpdmUtZXZlbnQnOiAnI2NjYycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmF0aXZlLWV2ZW50LWhvdmVyJzogJyNhYWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstcHJpbWFyeSc6ICcjZmNmM2RjJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXByaW1hcnktaG92ZXInOiAnI2YwZTdkMScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1zZWNvbmRhcnknOiAnI2VmYzQ1NycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1zZWNvbmRhcnktaG92ZXInOiAnI2UzYmE1MicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcHJpb3JpdHktYmFja2dyb3VuZCc6ICcjZjZmNmY2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1wcmlvcml0eS1ib3JkZXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdXNlci10aW1pbmcnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdXNlci10aW1pbmctaG92ZXInOiAnIzkzOTU5YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtaWRsZSc6ICcjZDNlNWY2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1pZGxlLWhvdmVyJzogJyNjM2Q5ZWYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlcic6ICcjOWZjM2YzJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXItaG92ZXInOiAnIzgzYWZlOScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyLXRleHQnOiAnIzExMzY1ZScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0JzogJyNjODhmZjAnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdC1ob3Zlcic6ICcjYjI4MWQ2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQtdGV4dCc6ICcjM2UyYzRhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cyc6ICcjYjI4MWQ2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cy1ob3Zlcic6ICcjOWQ3MWJkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1sYXlvdXQtZWZmZWN0cy10ZXh0JzogJyMzZTJjNGEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cyc6ICcjYjI4MWQ2JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMtaG92ZXInOiAnIzlkNzFiZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLXRleHQnOiAnIzNlMmM0YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc2NoZWR1bGUnOiAnIzlmYzNmMycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc2NoZWR1bGUtaG92ZXInOiAnIzI2ODNFMicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVqZWN0ZWQnOiAnI2YxY2MxNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVqZWN0ZWQtaG92ZXInOiAnI2ZmZGYzNycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQnOiAnI2E2ZTU5ZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQtaG92ZXInOiAnIzg5ZDI4MScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtdW5yZXNvbHZlZCc6ICcjYzljYWNkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1zdXNwZW5zZS11bnJlc29sdmVkLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRocm93bi1lcnJvcic6ICcjZWUxNjM4JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10aHJvd24tZXJyb3ItaG92ZXInOiAnI2RhMTAzMCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGV4dC1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10ZXh0LWRpbS1jb2xvcic6ICcjY2NjJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC13b3JrLWJvcmRlcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci1zZWFyY2gtbWF0Y2gnOiAneWVsbG93JyxcbiAgICAnLS1jb2xvci1zZWFyY2gtbWF0Y2gtY3VycmVudCc6ICcjZjc5MjNiJyxcbiAgICAnLS1jb2xvci1zZWxlY3RlZC10cmVlLWhpZ2hsaWdodC1hY3RpdmUnOiAncmdiYSgwLCAxMzYsIDI1MCwgMC4xKScsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtaW5hY3RpdmUnOiAncmdiYSgwLCAwLCAwLCAwLjA1KScsXG4gICAgJy0tY29sb3Itc2Nyb2xsLWNhcmV0JzogJ3JnYmEoMTUwLCAxNTAsIDE1MCwgMC41KScsXG4gICAgJy0tY29sb3ItdGFiLXNlbGVjdGVkLWJvcmRlcic6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLXRleHQtaW52YWxpZCc6ICcjZmYwMDAwJyxcbiAgICAnLS1jb2xvci10ZXh0LXNlbGVjdGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLWludmFsaWQnOiAnI2ZjM2E0YicsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtb24nOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtb2ZmJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLXRvZ2dsZS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXdhcm5pbmctYmFja2dyb3VuZCc6ICcjZmIzNjU1JyxcbiAgICAnLS1jb2xvci13YXJuaW5nLWJhY2tncm91bmQtaG92ZXInOiAnI2Y4MjA0MicsXG4gICAgJy0tY29sb3Itd2FybmluZy10ZXh0LWNvbG9yJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXdhcm5pbmctdGV4dC1jb2xvci1pbnZlcnRlZCc6ICcjZmQ0ZDY5JyxcblxuICAgIC8vIFRoZSBzdHlsZXMgYmVsb3cgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoICdyb290LmNzcydcbiAgICAvLyBUaGV5IGFyZSByZXBlYXRlZCB0aGVyZSBiZWNhdXNlIHRoZXkncmUgdXNlZCBieSBlLmcuIHRvb2x0aXBzIG9yIGNvbnRleHQgbWVudXNcbiAgICAvLyB3aGljaCBnZXQgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgRE9NIHN1YnRyZWUgKHdoZXJlIG5vcm1hbCB0aGVtZS9zdHlsZXMgYXJlIHdyaXR0ZW4pLlxuICAgICctLWNvbG9yLXNjcm9sbC10aHVtYic6ICcjYzJjMmMyJyxcbiAgICAnLS1jb2xvci1zY3JvbGwtdHJhY2snOiAnI2ZhZmFmYScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC45KScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC10ZXh0JzogJyNmZmZmZmYnLFxuICB9LFxuICBkYXJrOiB7XG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUnOiAnIzlkODdkMicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUtbm90LWVkaXRhYmxlJzogJyNlZGVkZWQnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lLWludmVydGVkJzogJyMyODI4MjgnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZSc6ICcjY2VkYWUwJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtdmFsdWUtaW52ZXJ0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLWVkaXRhYmxlLXZhbHVlJzogJ3llbGxvdycsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZCc6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWhvdmVyJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKScsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1pbmFjdGl2ZSc6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWludmFsaWQnOiAnIzVjMDAwMCcsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1zZWxlY3RlZCc6ICcjMTc4ZmI5JyxcbiAgICAnLS1jb2xvci1idXR0b24tYmFja2dyb3VuZCc6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci1idXR0b24tYmFja2dyb3VuZC1mb2N1cyc6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1idXR0b24nOiAnI2FmYjNiOScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWFjdGl2ZSc6ICcjNjFkYWZiJyxcbiAgICAnLS1jb2xvci1idXR0b24tZGlzYWJsZWQnOiAnIzRmNTc2NicsXG4gICAgJy0tY29sb3ItYnV0dG9uLWZvY3VzJzogJyNhMmU5ZmMnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1ob3Zlcic6ICcjZWRlZGVkJyxcbiAgICAnLS1jb2xvci1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLWZpbGwnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWRpZC1ub3QtcmVuZGVyLWZpbGwtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItcGF0dGVybic6ICcjNjY2Yzc3JyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItcGF0dGVybi10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0wJzogJyMzN2FmYTknLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0xJzogJyM2M2IxOWUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0yJzogJyM4MGIzOTMnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0zJzogJyM5N2I0ODgnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC00JzogJyNhYmI2N2QnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC01JzogJyNiZWI3NzEnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC02JzogJyNjZmI5NjUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC03JzogJyNkZmJhNTcnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC04JzogJyNlZmJiNDknLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC05JzogJyNmZWJjMzgnLFxuICAgICctLWNvbG9yLWNvbW1pdC1ncmFkaWVudC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1uYW1lJzogJyM2MWRhZmInLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1uYW1lLWludmVydGVkJzogJyMyODI4MjgnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1iYWNrZ3JvdW5kJzogJyM1ZTYxNjcnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1iYWNrZ3JvdW5kLWludmVydGVkJzogJyM0NjQ5NGUnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1jb3VudCc6ICcjOGY5NDlkJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtY291bnQtaW52ZXJ0ZWQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjg1KScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1iYWRnZS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFja2dyb3VuZCc6ICcjMjkwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJvcmRlcic6ICcjNWMwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWljb24nOiAnI2ViMzk0MScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci10ZXh0JzogJyNmYzdmN2YnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWRnZS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWNrZ3JvdW5kJzogJyMzMzJiMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1ib3JkZXInOiAnIzY2NTUwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWljb24nOiAnI2Y0YmQwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLXRleHQnOiAnI2Y1ZjJlZCcsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LDI1NSwyNTUsLjk1KScsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kLWhvdmVyJzogJ3JnYmEoMCwgMTM2LCAyNTAsIDAuMSknLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZC1zZWxlY3RlZCc6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJvcmRlcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0LXNlbGVjdGVkJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWRpbSc6ICcjOGY5NDlkJyxcbiAgICAnLS1jb2xvci1kaW1tZXInOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItZGltbWVzdCc6ICcjNGY1NzY2JyxcbiAgICAnLS1jb2xvci1lcnJvci1iYWNrZ3JvdW5kJzogJyMyMDAnLFxuICAgICctLWNvbG9yLWVycm9yLWJvcmRlcic6ICcjOTAwJyxcbiAgICAnLS1jb2xvci1lcnJvci10ZXh0JzogJyNmNTUnLFxuICAgICctLWNvbG9yLWV4cGFuZC1jb2xsYXBzZS10b2dnbGUnOiAnIzhmOTQ5ZCcsXG4gICAgJy0tY29sb3ItZm9yZ2V0LWJhZGdlLWJhY2tncm91bmQnOiAnIzI2ODNlMicsXG4gICAgJy0tY29sb3ItZm9yZ2V0LWJhZGdlLWJhY2tncm91bmQtaW52ZXJ0ZWQnOiAnIzFhNmJiYycsXG4gICAgJy0tY29sb3ItZm9yZ2V0LXRleHQnOiAnI2ZmZicsXG4gICAgJy0tY29sb3ItbGluayc6ICcjNjFkYWZiJyxcbiAgICAnLS1jb2xvci1tb2RhbC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC43NSknLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW51bWJlcic6ICd5ZWxsb3cnLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLWJhY2tncm91bmQnOiAncmdiYSgwLCAwLCAwLCAwLjI1KScsXG4gICAgJy0tY29sb3ItcHJpbWl0aXZlLWhvb2stYmFkZ2UtdGV4dCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgICctLWNvbG9yLXJlY29yZC1hY3RpdmUnOiAnI2ZjM2E0YicsXG4gICAgJy0tY29sb3ItcmVjb3JkLWhvdmVyJzogJyNhMmU5ZmMnLFxuICAgICctLWNvbG9yLXJlY29yZC1pbmFjdGl2ZSc6ICcjNjFkYWZiJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItYWN0aXZlJzogJyMzMTM2M2YnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItYm9yZGVyJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXItZG90JzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLWludGVybmFsLW1vZHVsZSc6ICcjMzAzNTQyJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1pbnRlcm5hbC1tb2R1bGUtaG92ZXInOiAnIzM2M2I0YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtaW50ZXJuYWwtbW9kdWxlLXRleHQnOiAnIzdmODg5OScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmF0aXZlLWV2ZW50JzogJyNiMmIyYjInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5hdGl2ZS1ldmVudC1ob3Zlcic6ICcjOTQ5NDk0JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1uZXR3b3JrLXByaW1hcnknOiAnI2ZjZjNkYycsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtbmV0d29yay1wcmltYXJ5LWhvdmVyJzogJyNlM2RiYzUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstc2Vjb25kYXJ5JzogJyNlZmM0NTcnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLW5ldHdvcmstc2Vjb25kYXJ5LWhvdmVyJzogJyNkNmFmNGQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXByaW9yaXR5LWJhY2tncm91bmQnOiAnIzFkMjEyOScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcHJpb3JpdHktYm9yZGVyJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXVzZXItdGltaW5nJzogJyNjOWNhY2QnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXVzZXItdGltaW5nLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWlkbGUnOiAnIzNkNDg1YicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtaWRsZS1ob3Zlcic6ICcjNDY1MjY5JyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1yZW5kZXInOiAnIzI2ODNFMicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcmVuZGVyLWhvdmVyJzogJyMxYTc2ZDQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXJlbmRlci10ZXh0JzogJyMxMTM2NWUnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LWNvbW1pdCc6ICcjNzMxZmFkJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1jb21taXQtaG92ZXInOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtY29tbWl0LXRleHQnOiAnI2U1YzFmZicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMnOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMtaG92ZXInOiAnIzUxMTY3YScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtbGF5b3V0LWVmZmVjdHMtdGV4dCc6ICcjZTVjMWZmJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS1yZWFjdC1wYXNzaXZlLWVmZmVjdHMnOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLWhvdmVyJzogJyM1MTE2N2EnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXBhc3NpdmUtZWZmZWN0cy10ZXh0JzogJyNlNWMxZmYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXNjaGVkdWxlJzogJyMyNjgzRTInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXNjaGVkdWxlLWhvdmVyJzogJyMxYTc2ZDQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlamVjdGVkJzogJyNmMWNjMTQnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlamVjdGVkLWhvdmVyJzogJyNlNGMwMGYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlc29sdmVkJzogJyNhNmU1OWYnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXJlc29sdmVkLWhvdmVyJzogJyM4OWQyODEnLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXJlYWN0LXN1c3BlbnNlLXVucmVzb2x2ZWQnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtc3VzcGVuc2UtdW5yZXNvbHZlZC1ob3Zlcic6ICcjOTM5NTlhJyxcbiAgICAnLS1jb2xvci10aW1lbGluZS10aHJvd24tZXJyb3InOiAnI2ZiMzY1NScsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGhyb3duLWVycm9yLWhvdmVyJzogJyNmODIwNDInLFxuICAgICctLWNvbG9yLXRpbWVsaW5lLXRleHQtY29sb3InOiAnIzI4MmMzNCcsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtdGV4dC1kaW0tY29sb3InOiAnIzU1NWI2NicsXG4gICAgJy0tY29sb3ItdGltZWxpbmUtcmVhY3Qtd29yay1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoJzogJ3llbGxvdycsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoLWN1cnJlbnQnOiAnI2Y3OTIzYicsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtYWN0aXZlJzogJ3JnYmEoMjMsIDE0MywgMTg1LCAwLjE1KScsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtaW5hY3RpdmUnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA1KScsXG4gICAgJy0tY29sb3Itc2Nyb2xsLWNhcmV0JzogJyM0ZjU3NjYnLFxuICAgICctLWNvbG9yLXNoYWRvdyc6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICctLWNvbG9yLXRhYi1zZWxlY3RlZC1ib3JkZXInOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci10ZXh0LWludmFsaWQnOiAnI2ZmODA4MCcsXG4gICAgJy0tY29sb3ItdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1pbnZhbGlkJzogJyNmYzNhNGInLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9uJzogJyMxNzhmYjknLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9mZic6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci10b2dnbGUtdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLWJhY2tncm91bmQnOiAnI2VlMTYzOCcsXG4gICAgJy0tY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kLWhvdmVyJzogJyNkYTEwMzAnLFxuICAgICctLWNvbG9yLXdhcm5pbmctdGV4dC1jb2xvcic6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLXRleHQtY29sb3ItaW52ZXJ0ZWQnOiAnI2VlMTYzOCcsXG5cbiAgICAvLyBUaGUgc3R5bGVzIGJlbG93IHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCAncm9vdC5jc3MnXG4gICAgLy8gVGhleSBhcmUgcmVwZWF0ZWQgdGhlcmUgYmVjYXVzZSB0aGV5J3JlIHVzZWQgYnkgZS5nLiB0b29sdGlwcyBvciBjb250ZXh0IG1lbnVzXG4gICAgLy8gd2hpY2ggZ2V0IHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIERPTSBzdWJ0cmVlICh3aGVyZSBub3JtYWwgdGhlbWUvc3R5bGVzIGFyZSB3cml0dGVuKS5cbiAgICAnLS1jb2xvci1zY3JvbGwtdGh1bWInOiAnI2FmYjNiOScsXG4gICAgJy0tY29sb3Itc2Nyb2xsLXRyYWNrJzogJyMzMTM2NDAnLFxuICAgICctLWNvbG9yLXRvb2x0aXAtYmFja2dyb3VuZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTUpJyxcbiAgICAnLS1jb2xvci10b29sdGlwLXRleHQnOiAnIzAwMDAwMCcsXG4gIH0sXG4gIGNvbXBhY3Q6IHtcbiAgICAnLS1mb250LXNpemUtbW9ub3NwYWNlLXNtYWxsJzogJzlweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1ub3JtYWwnOiAnMTFweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1sYXJnZSc6ICcxNXB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1zbWFsbCc6ICcxMHB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1ub3JtYWwnOiAnMTJweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbGFyZ2UnOiAnMTRweCcsXG4gICAgJy0tbGluZS1oZWlnaHQtZGF0YSc6ICcxOHB4JyxcbiAgfSxcbiAgY29tZm9ydGFibGU6IHtcbiAgICAnLS1mb250LXNpemUtbW9ub3NwYWNlLXNtYWxsJzogJzEwcHgnLFxuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2Utbm9ybWFsJzogJzEzcHgnLFxuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2UtbGFyZ2UnOiAnMTdweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtc21hbGwnOiAnMTJweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbm9ybWFsJzogJzE0cHgnLFxuICAgICctLWZvbnQtc2l6ZS1zYW5zLWxhcmdlJzogJzE2cHgnLFxuICAgICctLWxpbmUtaGVpZ2h0LWRhdGEnOiAnMjJweCcsXG4gIH0sXG59O1xuXG4vLyBIQUNLXG4vL1xuLy8gU29tZXRpbWVzIHRoZSBpbmxpbmUgdGFyZ2V0IGlzIHJlbmRlcmVkIGJlZm9yZSByb290IHN0eWxlcyBhcmUgYXBwbGllZCxcbi8vIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBlLmcuIE5hTiBpdGVtU2l6ZSBiZWluZyBwYXNzZWQgdG8gcmVhY3Qtd2luZG93IGxpc3QuXG5jb25zdCBDT01GT1JUQUJMRV9MSU5FX0hFSUdIVDogbnVtYmVyID0gcGFyc2VJbnQoXG4gIFRIRU1FX1NUWUxFUy5jb21mb3J0YWJsZVsnLS1saW5lLWhlaWdodC1kYXRhJ10sXG4gIDEwLFxuKTtcbmNvbnN0IENPTVBBQ1RfTElORV9IRUlHSFQ6IG51bWJlciA9IHBhcnNlSW50KFxuICBUSEVNRV9TVFlMRVMuY29tcGFjdFsnLS1saW5lLWhlaWdodC1kYXRhJ10sXG4gIDEwLFxuKTtcblxuZXhwb3J0IHtDT01GT1JUQUJMRV9MSU5FX0hFSUdIVCwgQ09NUEFDVF9MSU5FX0hFSUdIVH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/constants.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/events.js":
/*!**********************************************!*\
  !*** ../react-devtools-shared/src/events.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventEmitter)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    _classCallCheck(this, EventEmitter);\n\n    _defineProperty(this, \"listenersMap\", new Map());\n  }\n\n  _createClass(EventEmitter, [{\n    key: \"addListener\",\n    value: function addListener(event, listener) {\n      var listeners = this.listenersMap.get(event);\n\n      if (listeners === undefined) {\n        this.listenersMap.set(event, [listener]);\n      } else {\n        var index = listeners.indexOf(listener);\n\n        if (index < 0) {\n          listeners.push(listener);\n        }\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var listeners = this.listenersMap.get(event);\n\n      if (listeners !== undefined) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        if (listeners.length === 1) {\n          // No need to clone or try/catch\n          var listener = listeners[0];\n          listener.apply(null, args);\n        } else {\n          var didThrow = false;\n          var caughtError = null;\n          var clonedListeners = Array.from(listeners);\n\n          for (var i = 0; i < clonedListeners.length; i++) {\n            var _listener = clonedListeners[i];\n\n            try {\n              _listener.apply(null, args);\n            } catch (error) {\n              if (caughtError === null) {\n                didThrow = true;\n                caughtError = error;\n              }\n            }\n          }\n\n          if (didThrow) {\n            throw caughtError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.listenersMap.clear();\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(event, listener) {\n      var listeners = this.listenersMap.get(event);\n\n      if (listeners !== undefined) {\n        var index = listeners.indexOf(listener);\n\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n      }\n    }\n  }]);\n\n  return EventEmitter;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9ldmVudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7Ozs7QUFDQTs7Ozs7QUFHQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBR0E7O0FBQ0E7QUFBQTtBQUhBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2V2ZW50cy5qcz85ZDIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50RW1pdHRlcjxFdmVudHM6IE9iamVjdD4ge1xuICBsaXN0ZW5lcnNNYXA6IE1hcDxzdHJpbmcsIEFycmF5PEZ1bmN0aW9uPj4gPSBuZXcgTWFwKCk7XG5cbiAgYWRkTGlzdGVuZXI8RXZlbnQ6ICRLZXlzPEV2ZW50cz4+KFxuICAgIGV2ZW50OiBFdmVudCxcbiAgICBsaXN0ZW5lcjogKC4uLiRFbGVtZW50VHlwZTxFdmVudHMsIEV2ZW50PikgPT4gYW55LFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc01hcC5nZXQoZXZlbnQpO1xuICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNNYXAuc2V0KGV2ZW50LCBbbGlzdGVuZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbWl0PEV2ZW50OiAkS2V5czxFdmVudHM+PihcbiAgICBldmVudDogRXZlbnQsXG4gICAgLi4uYXJnczogJEVsZW1lbnRUeXBlPEV2ZW50cywgRXZlbnQ+XG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzTWFwLmdldChldmVudCk7XG4gICAgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNsb25lIG9yIHRyeS9jYXRjaFxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyc1swXTtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGlkVGhyb3cgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcblxuICAgICAgICBjb25zdCBjbG9uZWRMaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGxpc3RlbmVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvbmVkTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBjbG9uZWRMaXN0ZW5lcnNbaV07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGlkVGhyb3cgPSB0cnVlO1xuICAgICAgICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWRUaHJvdykge1xuICAgICAgICAgIHRocm93IGNhdWdodEVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMubGlzdGVuZXJzTWFwLmNsZWFyKCk7XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcihldmVudDogJEtleXM8RXZlbnRzPiwgbGlzdGVuZXI6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNNYXAuZ2V0KGV2ZW50KTtcbiAgICBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/events.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/frontend/types.js":
/*!******************************************************!*\
  !*** ../react-devtools-shared/src/frontend/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComponentFilterDisplayName\": () => (/* binding */ ComponentFilterDisplayName),\n/* harmony export */   \"ComponentFilterElementType\": () => (/* binding */ ComponentFilterElementType),\n/* harmony export */   \"ComponentFilterEnvironmentName\": () => (/* binding */ ComponentFilterEnvironmentName),\n/* harmony export */   \"ComponentFilterHOC\": () => (/* binding */ ComponentFilterHOC),\n/* harmony export */   \"ComponentFilterLocation\": () => (/* binding */ ComponentFilterLocation),\n/* harmony export */   \"ElementTypeClass\": () => (/* binding */ ElementTypeClass),\n/* harmony export */   \"ElementTypeContext\": () => (/* binding */ ElementTypeContext),\n/* harmony export */   \"ElementTypeForwardRef\": () => (/* binding */ ElementTypeForwardRef),\n/* harmony export */   \"ElementTypeFunction\": () => (/* binding */ ElementTypeFunction),\n/* harmony export */   \"ElementTypeHostComponent\": () => (/* binding */ ElementTypeHostComponent),\n/* harmony export */   \"ElementTypeMemo\": () => (/* binding */ ElementTypeMemo),\n/* harmony export */   \"ElementTypeOtherOrUnknown\": () => (/* binding */ ElementTypeOtherOrUnknown),\n/* harmony export */   \"ElementTypeProfiler\": () => (/* binding */ ElementTypeProfiler),\n/* harmony export */   \"ElementTypeRoot\": () => (/* binding */ ElementTypeRoot),\n/* harmony export */   \"ElementTypeSuspense\": () => (/* binding */ ElementTypeSuspense),\n/* harmony export */   \"ElementTypeSuspenseList\": () => (/* binding */ ElementTypeSuspenseList),\n/* harmony export */   \"ElementTypeTracingMarker\": () => (/* binding */ ElementTypeTracingMarker),\n/* harmony export */   \"ElementTypeViewTransition\": () => (/* binding */ ElementTypeViewTransition),\n/* harmony export */   \"ElementTypeVirtual\": () => (/* binding */ ElementTypeVirtual),\n/* harmony export */   \"StrictMode\": () => (/* binding */ StrictMode)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * WARNING:\n * This file contains types that are designed for React DevTools UI and how it interacts with the backend.\n * They might be used in different versions of DevTools backends.\n * Be mindful of backwards compatibility when making changes.\n */\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new element types are added, use new numbers rather than re-ordering existing ones.\n//\n// Changing these types is also a backwards breaking change for the standalone shell,\n// since the frontend and backend must share the same values-\n// and the backend is embedded in certain environments (like React Native).\nvar ElementTypeClass = 1;\nvar ElementTypeContext = 2;\nvar ElementTypeFunction = 5;\nvar ElementTypeForwardRef = 6;\nvar ElementTypeHostComponent = 7;\nvar ElementTypeMemo = 8;\nvar ElementTypeOtherOrUnknown = 9;\nvar ElementTypeProfiler = 10;\nvar ElementTypeRoot = 11;\nvar ElementTypeSuspense = 12;\nvar ElementTypeSuspenseList = 13;\nvar ElementTypeTracingMarker = 14;\nvar ElementTypeVirtual = 15;\nvar ElementTypeViewTransition = 16; // Different types of elements displayed in the Elements tree.\n// These types may be used to visually distinguish types,\n// or to enable/disable certain functionality.\n\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new filter types are added, use new numbers rather than re-ordering existing ones.\nvar ComponentFilterElementType = 1;\nvar ComponentFilterDisplayName = 2;\nvar ComponentFilterLocation = 3;\nvar ComponentFilterHOC = 4;\nvar ComponentFilterEnvironmentName = 5;\nvar StrictMode = 1; // Each element on the frontend corresponds to an ElementID (e.g. a Fiber) on the backend.\n// Some of its information (e.g. id, type, displayName) come from the backend.\n// Other bits (e.g. weight and depth) are computed on the frontend for windowing and display purposes.\n// Elements are updated on a push basis– meaning the backend pushes updates to the frontend when needed.//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7QUFTQTs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0VBO0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcy5qcz9iMDMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8qKlxuICogV0FSTklORzpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0eXBlcyB0aGF0IGFyZSBkZXNpZ25lZCBmb3IgUmVhY3QgRGV2VG9vbHMgVUkgYW5kIGhvdyBpdCBpbnRlcmFjdHMgd2l0aCB0aGUgYmFja2VuZC5cbiAqIFRoZXkgbWlnaHQgYmUgdXNlZCBpbiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgRGV2VG9vbHMgYmFja2VuZHMuXG4gKiBCZSBtaW5kZnVsIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdoZW4gbWFraW5nIGNoYW5nZXMuXG4gKi9cblxuaW1wb3J0IHR5cGUge1xuICBEZWh5ZHJhdGVkLFxuICBVbnNlcmlhbGl6YWJsZSxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9oeWRyYXRpb24nO1xuaW1wb3J0IHR5cGUge1NvdXJjZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zaGFyZWQvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBCcm93c2VyVGhlbWUgPSAnZGFyaycgfCAnbGlnaHQnO1xuXG5leHBvcnQgdHlwZSBXYWxsID0ge1xuICAvLyBgbGlzdGVuYCByZXR1cm5zIHRoZSBcInVubGlzdGVuXCIgZnVuY3Rpb24uXG4gIGxpc3RlbjogKGZuOiBGdW5jdGlvbikgPT4gRnVuY3Rpb24sXG4gIHNlbmQ6IChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnksIHRyYW5zZmVyYWJsZT86IEFycmF5PGFueT4pID0+IHZvaWQsXG59O1xuXG4vLyBXQVJOSU5HXG4vLyBUaGUgdmFsdWVzIGJlbG93IGFyZSByZWZlcmVuY2VkIGJ5IENvbXBvbmVudEZpbHRlcnMgKHdoaWNoIGFyZSBzYXZlZCB2aWEgbG9jYWxTdG9yYWdlKS5cbi8vIERvIG5vdCBjaGFuZ2UgdGhlbSBvciBpdCB3aWxsIGJyZWFrIHByZXZpb3VzbHkgc2F2ZWQgdXNlciBjdXN0b21pemF0aW9ucy5cbi8vIElmIG5ldyBlbGVtZW50IHR5cGVzIGFyZSBhZGRlZCwgdXNlIG5ldyBudW1iZXJzIHJhdGhlciB0aGFuIHJlLW9yZGVyaW5nIGV4aXN0aW5nIG9uZXMuXG4vL1xuLy8gQ2hhbmdpbmcgdGhlc2UgdHlwZXMgaXMgYWxzbyBhIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2UgZm9yIHRoZSBzdGFuZGFsb25lIHNoZWxsLFxuLy8gc2luY2UgdGhlIGZyb250ZW5kIGFuZCBiYWNrZW5kIG11c3Qgc2hhcmUgdGhlIHNhbWUgdmFsdWVzLVxuLy8gYW5kIHRoZSBiYWNrZW5kIGlzIGVtYmVkZGVkIGluIGNlcnRhaW4gZW52aXJvbm1lbnRzIChsaWtlIFJlYWN0IE5hdGl2ZSkuXG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVDbGFzcyA9IDE7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVDb250ZXh0ID0gMjtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZUZ1bmN0aW9uID0gNTtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZUZvcndhcmRSZWYgPSA2O1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCA9IDc7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVNZW1vID0gODtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duID0gOTtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZVByb2ZpbGVyID0gMTA7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVSb290ID0gMTE7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVTdXNwZW5zZSA9IDEyO1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlU3VzcGVuc2VMaXN0ID0gMTM7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVUcmFjaW5nTWFya2VyID0gMTQ7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVWaXJ0dWFsID0gMTU7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVWaWV3VHJhbnNpdGlvbiA9IDE2O1xuXG4vLyBEaWZmZXJlbnQgdHlwZXMgb2YgZWxlbWVudHMgZGlzcGxheWVkIGluIHRoZSBFbGVtZW50cyB0cmVlLlxuLy8gVGhlc2UgdHlwZXMgbWF5IGJlIHVzZWQgdG8gdmlzdWFsbHkgZGlzdGluZ3Vpc2ggdHlwZXMsXG4vLyBvciB0byBlbmFibGUvZGlzYWJsZSBjZXJ0YWluIGZ1bmN0aW9uYWxpdHkuXG5leHBvcnQgdHlwZSBFbGVtZW50VHlwZSA9XG4gIHwgMVxuICB8IDJcbiAgfCA1XG4gIHwgNlxuICB8IDdcbiAgfCA4XG4gIHwgOVxuICB8IDEwXG4gIHwgMTFcbiAgfCAxMlxuICB8IDEzXG4gIHwgMTRcbiAgfCAxNVxuICB8IDE2O1xuXG4vLyBXQVJOSU5HXG4vLyBUaGUgdmFsdWVzIGJlbG93IGFyZSByZWZlcmVuY2VkIGJ5IENvbXBvbmVudEZpbHRlcnMgKHdoaWNoIGFyZSBzYXZlZCB2aWEgbG9jYWxTdG9yYWdlKS5cbi8vIERvIG5vdCBjaGFuZ2UgdGhlbSBvciBpdCB3aWxsIGJyZWFrIHByZXZpb3VzbHkgc2F2ZWQgdXNlciBjdXN0b21pemF0aW9ucy5cbi8vIElmIG5ldyBmaWx0ZXIgdHlwZXMgYXJlIGFkZGVkLCB1c2UgbmV3IG51bWJlcnMgcmF0aGVyIHRoYW4gcmUtb3JkZXJpbmcgZXhpc3Rpbmcgb25lcy5cbmV4cG9ydCBjb25zdCBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZSA9IDE7XG5leHBvcnQgY29uc3QgQ29tcG9uZW50RmlsdGVyRGlzcGxheU5hbWUgPSAyO1xuZXhwb3J0IGNvbnN0IENvbXBvbmVudEZpbHRlckxvY2F0aW9uID0gMztcbmV4cG9ydCBjb25zdCBDb21wb25lbnRGaWx0ZXJIT0MgPSA0O1xuZXhwb3J0IGNvbnN0IENvbXBvbmVudEZpbHRlckVudmlyb25tZW50TmFtZSA9IDU7XG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudEZpbHRlclR5cGUgPSAxIHwgMiB8IDMgfCA0IHwgNTtcblxuLy8gSGlkZSBhbGwgZWxlbWVudHMgb2YgdHlwZXMgaW4gdGhpcyBTZXQuXG4vLyBXZSBoaWRlIGhvc3QgY29tcG9uZW50cyBvbmx5IGJ5IGRlZmF1bHQuXG5leHBvcnQgdHlwZSBFbGVtZW50VHlwZUNvbXBvbmVudEZpbHRlciA9IHtcbiAgaXNFbmFibGVkOiBib29sZWFuLFxuICB0eXBlOiAxLFxuICB2YWx1ZTogRWxlbWVudFR5cGUsXG59O1xuXG4vLyBIaWRlIGFsbCBlbGVtZW50cyB3aXRoIGRpc3BsYXlOYW1lcyBvciBwYXRocyBtYXRjaGluZyBvbmUgb3IgbW9yZSBvZiB0aGUgUmVnRXhwcyBpbiB0aGlzIFNldC5cbi8vIFBhdGggZmlsdGVycyBhcmUgb25seSB1c2VkIHdoZW4gZWxlbWVudHMgaW5jbHVkZSBkZWJ1ZyBzb3VyY2UgbG9jYXRpb24uXG5leHBvcnQgdHlwZSBSZWdFeHBDb21wb25lbnRGaWx0ZXIgPSB7XG4gIGlzRW5hYmxlZDogYm9vbGVhbixcbiAgaXNWYWxpZDogYm9vbGVhbixcbiAgdHlwZTogMiB8IDMsXG4gIHZhbHVlOiBzdHJpbmcsXG59O1xuXG5leHBvcnQgdHlwZSBCb29sZWFuQ29tcG9uZW50RmlsdGVyID0ge1xuICBpc0VuYWJsZWQ6IGJvb2xlYW4sXG4gIGlzVmFsaWQ6IGJvb2xlYW4sXG4gIHR5cGU6IDQsXG59O1xuXG5leHBvcnQgdHlwZSBFbnZpcm9ubWVudE5hbWVDb21wb25lbnRGaWx0ZXIgPSB7XG4gIGlzRW5hYmxlZDogYm9vbGVhbixcbiAgaXNWYWxpZDogYm9vbGVhbixcbiAgdHlwZTogNSxcbiAgdmFsdWU6IHN0cmluZyxcbn07XG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudEZpbHRlciA9XG4gIHwgQm9vbGVhbkNvbXBvbmVudEZpbHRlclxuICB8IEVsZW1lbnRUeXBlQ29tcG9uZW50RmlsdGVyXG4gIHwgUmVnRXhwQ29tcG9uZW50RmlsdGVyXG4gIHwgRW52aXJvbm1lbnROYW1lQ29tcG9uZW50RmlsdGVyO1xuXG5leHBvcnQgdHlwZSBIb29rTmFtZSA9IHN0cmluZyB8IG51bGw7XG4vLyBNYXAgb2YgaG9vayBzb3VyY2UgKFwiPGZpbGVuYW1lPjo8bGluZS1udW1iZXI+Ojxjb2x1bW4tbnVtYmVyPlwiKSB0byBuYW1lLlxuLy8gSG9vayBzb3VyY2UgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBob29rIGl0c2VsZiBiZWNhdXNlIHRoZSBsYXR0ZXIgaXMgbm90IHN0YWJsZSBiZXR3ZWVuIGVsZW1lbnQgaW5zcGVjdGlvbnMuXG4vLyBXZSB1c2UgYSBNYXAgcmF0aGVyIHRoYW4gYW4gQXJyYXkgYmVjYXVzZSBvZiBuZXN0ZWQgaG9va3MgYW5kIHRyYXZlcnNhbCBvcmRlcmluZy5cbmV4cG9ydCB0eXBlIEhvb2tTb3VyY2VMb2NhdGlvbktleSA9IHN0cmluZztcbmV4cG9ydCB0eXBlIEhvb2tOYW1lcyA9IE1hcDxIb29rU291cmNlTG9jYXRpb25LZXksIEhvb2tOYW1lPjtcblxuZXhwb3J0IHR5cGUgTFJVQ2FjaGU8SywgVj4gPSB7XG4gIGRlbDogKGtleTogSykgPT4gdm9pZCxcbiAgZ2V0OiAoa2V5OiBLKSA9PiBWLFxuICBoYXM6IChrZXk6IEspID0+IGJvb2xlYW4sXG4gIHJlc2V0OiAoKSA9PiB2b2lkLFxuICBzZXQ6IChrZXk6IEssIHZhbHVlOiBWKSA9PiB2b2lkLFxufTtcblxuZXhwb3J0IHR5cGUgU3R5bGVYUGx1Z2luID0ge1xuICBzb3VyY2VzOiBBcnJheTxzdHJpbmc+LFxuICByZXNvbHZlZFN0eWxlczogT2JqZWN0LFxufTtcblxuZXhwb3J0IHR5cGUgUGx1Z2lucyA9IHtcbiAgc3R5bGV4OiBTdHlsZVhQbHVnaW4gfCBudWxsLFxufTtcblxuZXhwb3J0IGNvbnN0IFN0cmljdE1vZGUgPSAxO1xuXG4vLyBFYWNoIGVsZW1lbnQgb24gdGhlIGZyb250ZW5kIGNvcnJlc3BvbmRzIHRvIGFuIEVsZW1lbnRJRCAoZS5nLiBhIEZpYmVyKSBvbiB0aGUgYmFja2VuZC5cbi8vIFNvbWUgb2YgaXRzIGluZm9ybWF0aW9uIChlLmcuIGlkLCB0eXBlLCBkaXNwbGF5TmFtZSkgY29tZSBmcm9tIHRoZSBiYWNrZW5kLlxuLy8gT3RoZXIgYml0cyAoZS5nLiB3ZWlnaHQgYW5kIGRlcHRoKSBhcmUgY29tcHV0ZWQgb24gdGhlIGZyb250ZW5kIGZvciB3aW5kb3dpbmcgYW5kIGRpc3BsYXkgcHVycG9zZXMuXG4vLyBFbGVtZW50cyBhcmUgdXBkYXRlZCBvbiBhIHB1c2ggYmFzaXPigJMgbWVhbmluZyB0aGUgYmFja2VuZCBwdXNoZXMgdXBkYXRlcyB0byB0aGUgZnJvbnRlbmQgd2hlbiBuZWVkZWQuXG5leHBvcnQgdHlwZSBFbGVtZW50ID0ge1xuICBpZDogbnVtYmVyLFxuICBwYXJlbnRJRDogbnVtYmVyLFxuICBjaGlsZHJlbjogQXJyYXk8bnVtYmVyPixcbiAgdHlwZTogRWxlbWVudFR5cGUsXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsLFxuICBrZXk6IG51bWJlciB8IHN0cmluZyB8IG51bGwsXG5cbiAgaG9jRGlzcGxheU5hbWVzOiBudWxsIHwgQXJyYXk8c3RyaW5nPixcblxuICAvLyBTaG91bGQgdGhlIGVsZW1lbnRzIGNoaWxkcmVuIGJlIHZpc2libGUgaW4gdGhlIHRyZWU/XG4gIGlzQ29sbGFwc2VkOiBib29sZWFuLFxuXG4gIC8vIE93bmVyIChpZiBhdmFpbGFibGUpXG4gIG93bmVySUQ6IG51bWJlcixcblxuICAvLyBIb3cgbWFueSBsZXZlbHMgZGVlcCB3aXRoaW4gdGhlIHRyZWUgaXMgdGhpcyBlbGVtZW50P1xuICAvLyBUaGlzIGRldGVybWluZXMgaG93IG11Y2ggaW5kZW50YXRpb24gKGxlZnQgcGFkZGluZykgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIEVsZW1lbnRzIHRyZWUuXG4gIGRlcHRoOiBudW1iZXIsXG5cbiAgLy8gSG93IG1hbnkgbm9kZXMgKGluY2x1ZGluZyBpdHNlbGYpIGFyZSBiZWxvdyB0aGlzIEVsZW1lbnQgd2l0aGluIHRoZSB0cmVlLlxuICAvLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgdG8gcXVpY2tseSBkZXRlcm1pbmUgdGhlIHRvdGFsIG51bWJlciBvZiBFbGVtZW50cyxcbiAgLy8gYW5kIHRoZSBFbGVtZW50IGF0IGFueSBnaXZlbiBpbmRleCAoZm9yIHdpbmRvd2luZyBwdXJwb3NlcykuXG4gIHdlaWdodDogbnVtYmVyLFxuXG4gIC8vIFRoaXMgZWxlbWVudCBpcyBub3QgaW4gYSBTdHJpY3RNb2RlIGNvbXBsaWFudCBzdWJ0cmVlLlxuICAvLyBPbmx5IHRydWUgZm9yIFJlYWN0IHZlcnNpb25zIHN1cHBvcnRpbmcgU3RyaWN0TW9kZS5cbiAgaXNTdHJpY3RNb2RlTm9uQ29tcGxpYW50OiBib29sZWFuLFxuXG4gIC8vIElmIGNvbXBvbmVudCBpcyBjb21waWxlZCB3aXRoIEZvcmdldCwgdGhlIGJhY2tlbmQgd2lsbCBzZW5kIGl0cyBuYW1lIGFzIEZvcmdldCguLi4pXG4gIC8vIExhdGVyLCBvbiB0aGUgZnJvbnRlbmQgc2lkZSwgd2Ugd2lsbCBzdHJpcCBIT0MgbmFtZXMgYW5kIEZvcmdldCBwcmVmaXguXG4gIGNvbXBpbGVkV2l0aEZvcmdldDogYm9vbGVhbixcbn07XG5cbmV4cG9ydCB0eXBlIFNlcmlhbGl6ZWRFbGVtZW50ID0ge1xuICBkaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgaWQ6IG51bWJlcixcbiAga2V5OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsLFxuICBob2NEaXNwbGF5TmFtZXM6IEFycmF5PHN0cmluZz4gfCBudWxsLFxuICBjb21waWxlZFdpdGhGb3JnZXQ6IGJvb2xlYW4sXG4gIHR5cGU6IEVsZW1lbnRUeXBlLFxufTtcblxuZXhwb3J0IHR5cGUgT3duZXJzTGlzdCA9IHtcbiAgaWQ6IG51bWJlcixcbiAgb3duZXJzOiBBcnJheTxTZXJpYWxpemVkRWxlbWVudD4gfCBudWxsLFxufTtcblxuZXhwb3J0IHR5cGUgSW5zcGVjdGVkRWxlbWVudFJlc3BvbnNlVHlwZSA9XG4gIHwgJ2Vycm9yJ1xuICB8ICdmdWxsLWRhdGEnXG4gIHwgJ2h5ZHJhdGVkLXBhdGgnXG4gIHwgJ25vLWNoYW5nZSdcbiAgfCAnbm90LWZvdW5kJztcblxuZXhwb3J0IHR5cGUgSW5zcGVjdGVkRWxlbWVudFBhdGggPSBBcnJheTxzdHJpbmcgfCBudW1iZXI+O1xuXG5leHBvcnQgdHlwZSBJbnNwZWN0ZWRFbGVtZW50ID0ge1xuICBpZDogbnVtYmVyLFxuXG4gIC8vIERvZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydCBlZGl0YWJsZSBob29rcyBhbmQgZnVuY3Rpb24gcHJvcHM/XG4gIGNhbkVkaXRIb29rczogYm9vbGVhbixcbiAgY2FuRWRpdEZ1bmN0aW9uUHJvcHM6IGJvb2xlYW4sXG5cbiAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGFkdmFuY2VkIGVkaXRpbmcgaW50ZXJmYWNlP1xuICBjYW5FZGl0SG9va3NBbmREZWxldGVQYXRoczogYm9vbGVhbixcbiAgY2FuRWRpdEhvb2tzQW5kUmVuYW1lUGF0aHM6IGJvb2xlYW4sXG4gIGNhbkVkaXRGdW5jdGlvblByb3BzRGVsZXRlUGF0aHM6IGJvb2xlYW4sXG4gIGNhbkVkaXRGdW5jdGlvblByb3BzUmVuYW1lUGF0aHM6IGJvb2xlYW4sXG5cbiAgLy8gSXMgdGhpcyBFcnJvciwgYW5kIGNhbiBpdHMgdmFsdWUgYmUgb3ZlcnJpZGRlbiBub3c/XG4gIGlzRXJyb3JlZDogYm9vbGVhbixcbiAgY2FuVG9nZ2xlRXJyb3I6IGJvb2xlYW4sXG5cbiAgLy8gSXMgdGhpcyBTdXNwZW5zZSwgYW5kIGNhbiBpdHMgdmFsdWUgYmUgb3ZlcnJpZGRlbiBub3c/XG4gIGNhblRvZ2dsZVN1c3BlbnNlOiBib29sZWFuLFxuXG4gIC8vIENhbiB2aWV3IGNvbXBvbmVudCBzb3VyY2UgbG9jYXRpb24uXG4gIGNhblZpZXdTb3VyY2U6IGJvb2xlYW4sXG5cbiAgLy8gRG9lcyB0aGUgY29tcG9uZW50IGhhdmUgbGVnYWN5IGNvbnRleHQgYXR0YWNoZWQgdG8gaXQuXG4gIGhhc0xlZ2FjeUNvbnRleHQ6IGJvb2xlYW4sXG5cbiAgLy8gSW5zcGVjdGFibGUgcHJvcGVydGllcy5cbiAgY29udGV4dDogT2JqZWN0IHwgbnVsbCxcbiAgaG9va3M6IE9iamVjdCB8IG51bGwsXG4gIHByb3BzOiBPYmplY3QgfCBudWxsLFxuICBzdGF0ZTogT2JqZWN0IHwgbnVsbCxcbiAga2V5OiBudW1iZXIgfCBzdHJpbmcgfCBudWxsLFxuICBlcnJvcnM6IEFycmF5PFtzdHJpbmcsIG51bWJlcl0+LFxuICB3YXJuaW5nczogQXJyYXk8W3N0cmluZywgbnVtYmVyXT4sXG5cbiAgLy8gTGlzdCBvZiBvd25lcnNcbiAgb3duZXJzOiBBcnJheTxTZXJpYWxpemVkRWxlbWVudD4gfCBudWxsLFxuXG4gIC8vIExvY2F0aW9uIG9mIGNvbXBvbmVudCBpbiBzb3VyY2UgY29kZS5cbiAgc291cmNlOiBTb3VyY2UgfCBudWxsLFxuXG4gIHR5cGU6IEVsZW1lbnRUeXBlLFxuXG4gIC8vIE1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3QgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8uXG4gIHJvb3RUeXBlOiBzdHJpbmcgfCBudWxsLFxuXG4gIC8vIE1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVyIHRoYXQgY3JlYXRlZCB0aGlzIGVsZW1lbnQuXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6IHN0cmluZyB8IG51bGwsXG4gIHJlbmRlcmVyVmVyc2lvbjogc3RyaW5nIHwgbnVsbCxcblxuICAvLyBVSSBwbHVnaW5zL3Zpc3VhbGl6YXRpb25zIGZvciB0aGUgaW5zcGVjdGVkIGVsZW1lbnQuXG4gIHBsdWdpbnM6IFBsdWdpbnMsXG59O1xuXG4vLyBUT0RPOiBBZGQgcHJvZmlsaW5nIHR5cGVcblxudHlwZSBEYXRhID1cbiAgfCBzdHJpbmdcbiAgfCBEZWh5ZHJhdGVkXG4gIHwgVW5zZXJpYWxpemFibGVcbiAgfCBBcnJheTxEZWh5ZHJhdGVkPlxuICB8IEFycmF5PFVuc2VyaWFsaXphYmxlPlxuICB8IHtbc3RyaW5nXTogRGF0YX07XG5cbmV4cG9ydCB0eXBlIERlaHlkcmF0ZWREYXRhID0ge1xuICBjbGVhbmVkOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PixcbiAgZGF0YTogRGF0YSxcbiAgdW5zZXJpYWxpemFibGU6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/frontend/types.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/hook.js":
/*!********************************************!*\
  !*** ../react-devtools-shared/src/hook.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"installHook\": () => (/* binding */ installHook)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var _attachRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attachRenderer */ \"../react-devtools-shared/src/attachRenderer.js\");\n/* harmony import */ var react_devtools_shared_src_backend_utils_formatConsoleArguments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/backend/utils/formatConsoleArguments */ \"../react-devtools-shared/src/backend/utils/formatConsoleArguments.js\");\n/* harmony import */ var react_devtools_shared_src_backend_utils_formatWithStyles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/backend/utils/formatWithStyles */ \"../react-devtools-shared/src/backend/utils/formatWithStyles.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Install the hook on window, which is an event emitter.\n * Note: this global hook __REACT_DEVTOOLS_GLOBAL_HOOK__ is a de facto public API.\n * It's especially important to avoid creating direct dependency on the DevTools Backend.\n * That's why we still inline the whole event emitter implementation,\n * the string format implementation, and part of the console implementation here.\n *\n * \n */\n\n\n\n // React's custom built component stack strings match \"\\s{4}in\"\n// Chrome's prefix matches \"\\s{4}at\"\n\nvar PREFIX_REGEX = /\\s{4}(in|at)\\s{1}/; // Firefox and Safari have no prefix (\"\")\n// but we can fallback to looking for location info (e.g. \"foo.js:12:345\")\n\nvar ROW_COLUMN_NUMBER_REGEX = /:\\d+:\\d+(\\n|$)/;\n\nfunction isStringComponentStack(text) {\n  return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);\n} // We add a suffix to some frames that older versions of React didn't do.\n// To compare if it's equivalent we strip out the suffix to see if they're\n// still equivalent. Similarly, we sometimes use [] and sometimes () so we\n// strip them to for the comparison.\n\n\nvar frameDiffs = / \\(\\<anonymous\\>\\)$|\\@unknown\\:0\\:0$|\\(|\\)|\\[|\\]/gm;\n\nfunction areStackTracesEqual(a, b) {\n  return a.replace(frameDiffs, '') === b.replace(frameDiffs, '');\n}\n\nvar targetConsole = console;\nvar defaultProfilingSettings = {\n  recordChangeDescriptions: false,\n  recordTimeline: false\n};\nfunction installHook(target, maybeSettingsOrSettingsPromise) {\n  var shouldStartProfilingNow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var profilingSettings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultProfilingSettings;\n\n  if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {\n    return null;\n  }\n\n  function detectReactBuildType(renderer) {\n    try {\n      if (typeof renderer.version === 'string') {\n        // React DOM Fiber (16+)\n        if (renderer.bundleType > 0) {\n          // This is not a production build.\n          // We are currently only using 0 (PROD) and 1 (DEV)\n          // but might add 2 (PROFILE) in the future.\n          return 'development';\n        } // React 16 uses flat bundles. If we report the bundle as production\n        // version, it means we also minified and envified it ourselves.\n\n\n        return 'production'; // Note: There is still a risk that the CommonJS entry point has not\n        // been envified or uglified. In this case the user would have *both*\n        // development and production bundle, but only the prod one would run.\n        // This would be really bad. We have a separate check for this because\n        // it happens *outside* of the renderer injection. See `checkDCE` below.\n      } // $FlowFixMe[method-unbinding]\n\n\n      var _toString = Function.prototype.toString;\n\n      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {\n        // React DOM Stack\n        var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):\n\n\n        if (renderRootCode.indexOf('function') !== 0) {\n          // Hope for the best if we're not sure.\n          return 'production';\n        } // Check for React DOM Stack < 15.1.0 in development.\n        // If it contains \"storedMeasure\" call, it's wrapped in ReactPerf (DEV only).\n        // This would be true even if it's minified, as method name still matches.\n\n\n        if (renderRootCode.indexOf('storedMeasure') !== -1) {\n          return 'development';\n        } // For other versions (and configurations) it's not so easy.\n        // Let's quickly exclude proper production builds.\n        // If it contains a warning message, it's either a DEV build,\n        // or an PROD build without proper dead code elimination.\n\n\n        if (renderRootCode.indexOf('should be a pure function') !== -1) {\n          // Now how do we tell a DEV build from a bad PROD build?\n          // If we see NODE_ENV, we're going to assume this is a dev build\n          // because most likely it is referring to an empty shim.\n          if (renderRootCode.indexOf('NODE_ENV') !== -1) {\n            return 'development';\n          } // If we see \"development\", we're dealing with an envified DEV build\n          // (such as the official React DEV UMD).\n\n\n          if (renderRootCode.indexOf('development') !== -1) {\n            return 'development';\n          } // I've seen process.env.NODE_ENV !== 'production' being smartly\n          // replaced by `true` in DEV by Webpack. I don't know how that\n          // works but we can safely guard against it because `true` was\n          // never used in the function source since it was written.\n\n\n          if (renderRootCode.indexOf('true') !== -1) {\n            return 'development';\n          } // By now either it is a production build that has not been minified,\n          // or (worse) this is a minified development build using non-standard\n          // environment (e.g. \"staging\"). We're going to look at whether\n          // the function argument name is mangled:\n\n\n          if ( // 0.13 to 15\n          renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n          renderRootCode.indexOf('nextComponent') !== -1) {\n            // We can't be certain whether this is a development build or not,\n            // but it is definitely unminified.\n            return 'unminified';\n          } else {\n            // This is likely a minified development build.\n            return 'development';\n          }\n        } // By now we know that it's envified and dead code elimination worked,\n        // but what if it's still not minified? (Is this even possible?)\n        // Let's check matches for the first argument name.\n\n\n        if ( // 0.13 to 15\n        renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n        renderRootCode.indexOf('nextComponent') !== -1) {\n          return 'unminified';\n        } // Seems like we're using the production version.\n        // However, the branch above is Stack-only so this is 15 or earlier.\n\n\n        return 'outdated';\n      }\n    } catch (err) {// Weird environments may exist.\n      // This code needs a higher fault tolerance\n      // because it runs even with closed DevTools.\n      // TODO: should we catch errors in all injected code, and not just this part?\n    }\n\n    return 'production';\n  }\n\n  function checkDCE(fn) {\n    // This runs for production versions of React.\n    // Needs to be super safe.\n    try {\n      // $FlowFixMe[method-unbinding]\n      var _toString2 = Function.prototype.toString;\n\n      var code = _toString2.call(fn); // This is a string embedded in the passed function under DEV-only\n      // condition. However the function executes only in PROD. Therefore,\n      // if we see it, dead code elimination did not work.\n\n\n      if (code.indexOf('^_^') > -1) {\n        // Remember to report during next injection.\n        hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.\n        // Not synchronously so that it doesn't break the calling code.\n\n        setTimeout(function () {\n          throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://react.dev/link/perf-use-production-build');\n        });\n      }\n    } catch (err) {}\n  } // TODO: isProfiling should be stateful, and we should update it once profiling is finished\n\n\n  var isProfiling = shouldStartProfilingNow;\n  var uidCounter = 0;\n\n  function inject(renderer) {\n    var id = ++uidCounter;\n    renderers.set(id, renderer);\n    var reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer);\n    hook.emit('renderer', {\n      id: id,\n      renderer: renderer,\n      reactBuildType: reactBuildType\n    });\n    var rendererInterface = (0,_attachRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(hook, id, renderer, target, isProfiling, profilingSettings);\n\n    if (rendererInterface != null) {\n      hook.rendererInterfaces.set(id, rendererInterface);\n      hook.emit('renderer-attached', {\n        id: id,\n        rendererInterface: rendererInterface\n      });\n    } else {\n      hook.hasUnsupportedRendererAttached = true;\n      hook.emit('unsupported-renderer-version');\n    }\n\n    return id;\n  }\n\n  var hasDetectedBadDCE = false;\n\n  function sub(event, fn) {\n    hook.on(event, fn);\n    return function () {\n      return hook.off(event, fn);\n    };\n  }\n\n  function on(event, fn) {\n    if (!listeners[event]) {\n      listeners[event] = [];\n    }\n\n    listeners[event].push(fn);\n  }\n\n  function off(event, fn) {\n    if (!listeners[event]) {\n      return;\n    }\n\n    var index = listeners[event].indexOf(fn);\n\n    if (index !== -1) {\n      listeners[event].splice(index, 1);\n    }\n\n    if (!listeners[event].length) {\n      delete listeners[event];\n    }\n  }\n\n  function emit(event, data) {\n    if (listeners[event]) {\n      listeners[event].map(function (fn) {\n        return fn(data);\n      });\n    }\n  }\n\n  function getFiberRoots(rendererID) {\n    var roots = fiberRoots;\n\n    if (!roots[rendererID]) {\n      roots[rendererID] = new Set();\n    }\n\n    return roots[rendererID];\n  }\n\n  function onCommitFiberUnmount(rendererID, fiber) {\n    var rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handleCommitFiberUnmount(fiber);\n    }\n  }\n\n  function onCommitFiberRoot(rendererID, root, priorityLevel) {\n    var mountedRoots = hook.getFiberRoots(rendererID);\n    var current = root.current;\n    var isKnownRoot = mountedRoots.has(root);\n    var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.\n\n    if (!isKnownRoot && !isUnmounting) {\n      mountedRoots.add(root);\n    } else if (isKnownRoot && isUnmounting) {\n      mountedRoots.delete(root);\n    }\n\n    var rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handleCommitFiberRoot(root, priorityLevel);\n    }\n  }\n\n  function onPostCommitFiberRoot(rendererID, root) {\n    var rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handlePostCommitFiberRoot(root);\n    }\n  }\n\n  var isRunningDuringStrictModeInvocation = false;\n\n  function setStrictMode(rendererID, isStrictMode) {\n    isRunningDuringStrictModeInvocation = isStrictMode;\n\n    if (isStrictMode) {\n      patchConsoleForStrictMode();\n    } else {\n      unpatchConsoleForStrictMode();\n    }\n  }\n\n  var unpatchConsoleCallbacks = []; // For StrictMode we patch console once we are running in StrictMode and unpatch right after it\n  // So patching could happen multiple times during the runtime\n  // Notice how we don't patch error or warn methods, because they are already patched in patchConsoleForErrorsAndWarnings\n  // This will only happen once, when hook is installed\n\n  function patchConsoleForStrictMode() {\n    // Don't patch console in case settings were not injected\n    if (!hook.settings) {\n      return;\n    } // Don't patch twice\n\n\n    if (unpatchConsoleCallbacks.length > 0) {\n      return;\n    } // At this point 'error', 'warn', and 'trace' methods are already patched\n    // by React DevTools hook to append component stacks and other possible features.\n\n\n    var consoleMethodsToOverrideForStrictMode = ['group', 'groupCollapsed', 'info', 'log']; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    var _loop = function _loop() {\n      var method = _consoleMethodsToOver[_i];\n      var originalMethod = targetConsole[method];\n\n      var overrideMethod = function overrideMethod() {\n        var settings = hook.settings; // Something unexpected happened, fallback to just printing the console message.\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (settings == null) {\n          originalMethod.apply(void 0, args);\n          return;\n        }\n\n        if (settings.hideConsoleLogsInStrictMode) {\n          return;\n        } // Dim the text color of the double logs if we're not hiding them.\n        // Firefox doesn't support ANSI escape sequences\n\n\n        if (false) {} else {\n          originalMethod.apply(void 0, [react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.ANSI_STYLE_DIMMING_TEMPLATE].concat(_toConsumableArray(react_devtools_shared_src_backend_utils_formatConsoleArguments__WEBPACK_IMPORTED_MODULE_2__[\"default\"].apply(void 0, args))));\n        }\n      };\n\n      targetConsole[method] = overrideMethod;\n      unpatchConsoleCallbacks.push(function () {\n        targetConsole[method] = originalMethod;\n      });\n    };\n\n    for (var _i = 0, _consoleMethodsToOver = consoleMethodsToOverrideForStrictMode; _i < _consoleMethodsToOver.length; _i++) {\n      _loop();\n    }\n  }\n\n  function unpatchConsoleForStrictMode() {\n    unpatchConsoleCallbacks.forEach(function (callback) {\n      return callback();\n    });\n    unpatchConsoleCallbacks.length = 0;\n  }\n\n  var openModuleRangesStack = [];\n  var moduleRanges = [];\n\n  function getTopStackFrameString(error) {\n    var frames = error.stack.split('\\n');\n    var frame = frames.length > 1 ? frames[1] : null;\n    return frame;\n  }\n\n  function getInternalModuleRanges() {\n    return moduleRanges;\n  }\n\n  function registerInternalModuleStart(error) {\n    var startStackFrame = getTopStackFrameString(error);\n\n    if (startStackFrame !== null) {\n      openModuleRangesStack.push(startStackFrame);\n    }\n  }\n\n  function registerInternalModuleStop(error) {\n    if (openModuleRangesStack.length > 0) {\n      var startStackFrame = openModuleRangesStack.pop();\n      var stopStackFrame = getTopStackFrameString(error);\n\n      if (stopStackFrame !== null) {\n        // $FlowFixMe[incompatible-call]\n        moduleRanges.push([startStackFrame, stopStackFrame]);\n      }\n    }\n  } // For Errors and Warnings we only patch console once\n\n\n  function patchConsoleForErrorsAndWarnings() {\n    // Don't patch console in case settings were not injected\n    if (!hook.settings) {\n      return;\n    }\n\n    var consoleMethodsToOverrideForErrorsAndWarnings = ['error', 'trace', 'warn']; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    var _loop2 = function _loop2() {\n      var method = _consoleMethodsToOver2[_i2];\n      var originalMethod = targetConsole[method];\n\n      var overrideMethod = function overrideMethod() {\n        var settings = hook.settings; // Something unexpected happened, fallback to just printing the console message.\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (settings == null) {\n          originalMethod.apply(void 0, args);\n          return;\n        }\n\n        if (isRunningDuringStrictModeInvocation && settings.hideConsoleLogsInStrictMode) {\n          return;\n        }\n\n        var injectedComponentStackAsFakeError = false;\n        var alreadyHasComponentStack = false;\n\n        if (settings.appendComponentStack) {\n          var lastArg = args.length > 0 ? args[args.length - 1] : null;\n          alreadyHasComponentStack = typeof lastArg === 'string' && isStringComponentStack(lastArg); // The last argument should be a component stack.\n        }\n\n        var shouldShowInlineWarningsAndErrors = settings.showInlineWarningsAndErrors && (method === 'error' || method === 'warn'); // Search for the first renderer that has a current Fiber.\n        // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n        var _iterator = _createForOfIteratorHelper(hook.rendererInterfaces.values()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var rendererInterface = _step.value;\n            var onErrorOrWarning = rendererInterface.onErrorOrWarning,\n                getComponentStack = rendererInterface.getComponentStack;\n\n            try {\n              if (shouldShowInlineWarningsAndErrors) {\n                // patch() is called by two places: (1) the hook and (2) the renderer backend.\n                // The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.\n                if (onErrorOrWarning != null) {\n                  onErrorOrWarning(method, args.slice());\n                }\n              }\n            } catch (error) {\n              // Don't let a DevTools or React internal error interfere with logging.\n              setTimeout(function () {\n                throw error;\n              }, 0);\n            }\n\n            try {\n              if (settings.appendComponentStack && getComponentStack != null) {\n                // This needs to be directly in the wrapper so we can pop exactly one frame.\n                var topFrame = Error('react-stack-top-frame');\n                var match = getComponentStack(topFrame);\n\n                if (match !== null) {\n                  var enableOwnerStacks = match.enableOwnerStacks,\n                      componentStack = match.componentStack; // Empty string means we have a match but no component stack.\n                  // We don't need to look in other renderers but we also don't add anything.\n\n                  if (componentStack !== '') {\n                    // Create a fake Error so that when we print it we get native source maps. Every\n                    // browser will print the .stack property of the error and then parse it back for source\n                    // mapping. Rather than print the internal slot. So it doesn't matter that the internal\n                    // slot doesn't line up.\n                    var fakeError = new Error(''); // In Chromium, only the stack property is printed but in Firefox the <name>:<message>\n                    // gets printed so to make the colon make sense, we name it so we print Stack:\n                    // and similarly Safari leave an expandable slot.\n\n                    if (false) {} else {\n                      fakeError.name = enableOwnerStacks ? 'Stack' : 'Component Stack'; // This gets printed\n                    } // In Chromium, the stack property needs to start with ^[\\w.]*Error\\b to trigger stack\n                    // formatting. Otherwise it is left alone. So we prefix it. Otherwise we just override it\n                    // to our own stack.\n\n\n                    fakeError.stack =  true ? (enableOwnerStacks ? 'Error Stack:' : 'Error Component Stack:') + componentStack : 0;\n\n                    if (alreadyHasComponentStack) {\n                      // Only modify the component stack if it matches what we would've added anyway.\n                      // Otherwise we assume it was a non-React stack.\n                      if (areStackTracesEqual(args[args.length - 1], componentStack)) {\n                        var firstArg = args[0];\n\n                        if (args.length > 1 && typeof firstArg === 'string' && firstArg.endsWith('%s')) {\n                          args[0] = firstArg.slice(0, firstArg.length - 2); // Strip the %s param\n                        }\n\n                        args[args.length - 1] = fakeError;\n                        injectedComponentStackAsFakeError = true;\n                      }\n                    } else {\n                      args.push(fakeError);\n                      injectedComponentStackAsFakeError = true;\n                    }\n                  } // Don't add stacks from other renderers.\n\n\n                  break;\n                }\n              }\n            } catch (error) {\n              // Don't let a DevTools or React internal error interfere with logging.\n              setTimeout(function () {\n                throw error;\n              }, 0);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (settings.breakOnConsoleErrors) {\n          // --- Welcome to debugging with React DevTools ---\n          // This debugger statement means that you've enabled the \"break on warnings\" feature.\n          // Use the browser's Call Stack panel to step out of this override function\n          // to where the original warning or error was logged.\n          // eslint-disable-next-line no-debugger\n          debugger;\n        }\n\n        if (isRunningDuringStrictModeInvocation) {\n          // Dim the text color of the double logs if we're not hiding them.\n          // Firefox doesn't support ANSI escape sequences\n          if (false) { var argsWithCSSStyles; } else {\n            originalMethod.apply(void 0, [injectedComponentStackAsFakeError ? react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK : react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.ANSI_STYLE_DIMMING_TEMPLATE].concat(_toConsumableArray(react_devtools_shared_src_backend_utils_formatConsoleArguments__WEBPACK_IMPORTED_MODULE_2__[\"default\"].apply(void 0, args))));\n          }\n        } else {\n          originalMethod.apply(void 0, args);\n        }\n      };\n\n      targetConsole[method] = overrideMethod;\n    };\n\n    for (var _i2 = 0, _consoleMethodsToOver2 = consoleMethodsToOverrideForErrorsAndWarnings; _i2 < _consoleMethodsToOver2.length; _i2++) {\n      _loop2();\n    }\n  } // TODO: More meaningful names for \"rendererInterfaces\" and \"renderers\".\n\n\n  var fiberRoots = {};\n  var rendererInterfaces = new Map();\n  var listeners = {};\n  var renderers = new Map();\n  var backends = new Map();\n  var hook = {\n    rendererInterfaces: rendererInterfaces,\n    listeners: listeners,\n    backends: backends,\n    // Fast Refresh for web relies on this.\n    renderers: renderers,\n    hasUnsupportedRendererAttached: false,\n    emit: emit,\n    getFiberRoots: getFiberRoots,\n    inject: inject,\n    on: on,\n    off: off,\n    sub: sub,\n    // This is a legacy flag.\n    // React v16 checks the hook for this to ensure DevTools is new enough.\n    supportsFiber: true,\n    // React Flight Client checks the hook for this to ensure DevTools is new enough.\n    supportsFlight: true,\n    // React calls these methods.\n    checkDCE: checkDCE,\n    onCommitFiberUnmount: onCommitFiberUnmount,\n    onCommitFiberRoot: onCommitFiberRoot,\n    // React v18.0+\n    onPostCommitFiberRoot: onPostCommitFiberRoot,\n    setStrictMode: setStrictMode,\n    // Schedule Profiler runtime helpers.\n    // These internal React modules to report their own boundaries\n    // which in turn enables the profiler to dim or filter internal frames.\n    getInternalModuleRanges: getInternalModuleRanges,\n    registerInternalModuleStart: registerInternalModuleStart,\n    registerInternalModuleStop: registerInternalModuleStop\n  };\n\n  if (maybeSettingsOrSettingsPromise == null) {\n    // Set default settings\n    hook.settings = {\n      appendComponentStack: true,\n      breakOnConsoleErrors: false,\n      showInlineWarningsAndErrors: true,\n      hideConsoleLogsInStrictMode: false\n    };\n    patchConsoleForErrorsAndWarnings();\n  } else {\n    Promise.resolve(maybeSettingsOrSettingsPromise).then(function (settings) {\n      hook.settings = settings;\n      hook.emit('settingsInitialized', settings);\n      patchConsoleForErrorsAndWarnings();\n    }).catch(function () {\n      targetConsole.error(\"React DevTools failed to get Console Patching settings. Console won't be patched and some console features will not work.\");\n    });\n  }\n\n  Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {\n    // This property needs to be configurable for the test environment,\n    // else we won't be able to delete and recreate it between tests.\n    configurable: true,\n    enumerable: false,\n    get: function get() {\n      return hook;\n    }\n  });\n  return hook;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9ob29rLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0FBcUJBO0FBS0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFPQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBOztBQWJBO0FBcUJBO0FBQ0E7O0FBQ0E7QUFHQTs7QUFEQTtBQURBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBS0E7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBdERBOztBQXFCQTtBQUFBO0FBa0NBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBTkE7QUFhQTtBQUNBOztBQUNBO0FBQ0E7O0FBREE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBS0E7QUFDQTs7QUE3QkE7QUFBQTs7QUFBQTtBQThCQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQVNBO0FBR0E7QUFFQTtBQUNBOzs7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVIQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQThIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBcExBOztBQWFBO0FBQUE7QUF3S0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckNBOztBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBV0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvaG9vay5qcz8wNDc1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW5zdGFsbCB0aGUgaG9vayBvbiB3aW5kb3csIHdoaWNoIGlzIGFuIGV2ZW50IGVtaXR0ZXIuXG4gKiBOb3RlOiB0aGlzIGdsb2JhbCBob29rIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyBpcyBhIGRlIGZhY3RvIHB1YmxpYyBBUEkuXG4gKiBJdCdzIGVzcGVjaWFsbHkgaW1wb3J0YW50IHRvIGF2b2lkIGNyZWF0aW5nIGRpcmVjdCBkZXBlbmRlbmN5IG9uIHRoZSBEZXZUb29scyBCYWNrZW5kLlxuICogVGhhdCdzIHdoeSB3ZSBzdGlsbCBpbmxpbmUgdGhlIHdob2xlIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24sXG4gKiB0aGUgc3RyaW5nIGZvcm1hdCBpbXBsZW1lbnRhdGlvbiwgYW5kIHBhcnQgb2YgdGhlIGNvbnNvbGUgaW1wbGVtZW50YXRpb24gaGVyZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgRGV2VG9vbHNIb29rLFxuICBIYW5kbGVyLFxuICBSZWFjdFJlbmRlcmVyLFxuICBSZW5kZXJlcklELFxuICBSZW5kZXJlckludGVyZmFjZSxcbiAgRGV2VG9vbHNCYWNrZW5kLFxuICBEZXZUb29sc0hvb2tTZXR0aW5ncyxcbiAgUHJvZmlsaW5nU2V0dGluZ3MsXG59IGZyb20gJy4vYmFja2VuZC90eXBlcyc7XG5cbmltcG9ydCB7XG4gIEZJUkVGT1hfQ09OU09MRV9ESU1NSU5HX0NPTE9SLFxuICBBTlNJX1NUWUxFX0RJTU1JTkdfVEVNUExBVEUsXG4gIEFOU0lfU1RZTEVfRElNTUlOR19URU1QTEFURV9XSVRIX0NPTVBPTkVOVF9TVEFDSyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMnO1xuaW1wb3J0IGF0dGFjaFJlbmRlcmVyIGZyb20gJy4vYXR0YWNoUmVuZGVyZXInO1xuaW1wb3J0IGZvcm1hdENvbnNvbGVBcmd1bWVudHMgZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2Zvcm1hdENvbnNvbGVBcmd1bWVudHMnO1xuaW1wb3J0IGZvcm1hdFdpdGhTdHlsZXMgZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2Zvcm1hdFdpdGhTdHlsZXMnO1xuXG4vLyBSZWFjdCdzIGN1c3RvbSBidWlsdCBjb21wb25lbnQgc3RhY2sgc3RyaW5ncyBtYXRjaCBcIlxcc3s0fWluXCJcbi8vIENocm9tZSdzIHByZWZpeCBtYXRjaGVzIFwiXFxzezR9YXRcIlxuY29uc3QgUFJFRklYX1JFR0VYID0gL1xcc3s0fShpbnxhdClcXHN7MX0vO1xuLy8gRmlyZWZveCBhbmQgU2FmYXJpIGhhdmUgbm8gcHJlZml4IChcIlwiKVxuLy8gYnV0IHdlIGNhbiBmYWxsYmFjayB0byBsb29raW5nIGZvciBsb2NhdGlvbiBpbmZvIChlLmcuIFwiZm9vLmpzOjEyOjM0NVwiKVxuY29uc3QgUk9XX0NPTFVNTl9OVU1CRVJfUkVHRVggPSAvOlxcZCs6XFxkKyhcXG58JCkvO1xuXG5mdW5jdGlvbiBpc1N0cmluZ0NvbXBvbmVudFN0YWNrKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gUFJFRklYX1JFR0VYLnRlc3QodGV4dCkgfHwgUk9XX0NPTFVNTl9OVU1CRVJfUkVHRVgudGVzdCh0ZXh0KTtcbn1cblxuLy8gV2UgYWRkIGEgc3VmZml4IHRvIHNvbWUgZnJhbWVzIHRoYXQgb2xkZXIgdmVyc2lvbnMgb2YgUmVhY3QgZGlkbid0IGRvLlxuLy8gVG8gY29tcGFyZSBpZiBpdCdzIGVxdWl2YWxlbnQgd2Ugc3RyaXAgb3V0IHRoZSBzdWZmaXggdG8gc2VlIGlmIHRoZXkncmVcbi8vIHN0aWxsIGVxdWl2YWxlbnQuIFNpbWlsYXJseSwgd2Ugc29tZXRpbWVzIHVzZSBbXSBhbmQgc29tZXRpbWVzICgpIHNvIHdlXG4vLyBzdHJpcCB0aGVtIHRvIGZvciB0aGUgY29tcGFyaXNvbi5cbmNvbnN0IGZyYW1lRGlmZnMgPSAvIFxcKFxcPGFub255bW91c1xcPlxcKSR8XFxAdW5rbm93blxcOjBcXDowJHxcXCh8XFwpfFxcW3xcXF0vZ207XG5mdW5jdGlvbiBhcmVTdGFja1RyYWNlc0VxdWFsKGE6IHN0cmluZywgYjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBhLnJlcGxhY2UoZnJhbWVEaWZmcywgJycpID09PSBiLnJlcGxhY2UoZnJhbWVEaWZmcywgJycpO1xufVxuXG5jb25zdCB0YXJnZXRDb25zb2xlOiBPYmplY3QgPSBjb25zb2xlO1xuXG5jb25zdCBkZWZhdWx0UHJvZmlsaW5nU2V0dGluZ3M6IFByb2ZpbGluZ1NldHRpbmdzID0ge1xuICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM6IGZhbHNlLFxuICByZWNvcmRUaW1lbGluZTogZmFsc2UsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbEhvb2soXG4gIHRhcmdldDogYW55LFxuICBtYXliZVNldHRpbmdzT3JTZXR0aW5nc1Byb21pc2U/OlxuICAgIHwgRGV2VG9vbHNIb29rU2V0dGluZ3NcbiAgICB8IFByb21pc2U8RGV2VG9vbHNIb29rU2V0dGluZ3M+LFxuICBzaG91bGRTdGFydFByb2ZpbGluZ05vdzogYm9vbGVhbiA9IGZhbHNlLFxuICBwcm9maWxpbmdTZXR0aW5nczogUHJvZmlsaW5nU2V0dGluZ3MgPSBkZWZhdWx0UHJvZmlsaW5nU2V0dGluZ3MsXG4pOiBEZXZUb29sc0hvb2sgfCBudWxsIHtcbiAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgnX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fJykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGVjdFJlYWN0QnVpbGRUeXBlKHJlbmRlcmVyOiBSZWFjdFJlbmRlcmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIudmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gUmVhY3QgRE9NIEZpYmVyICgxNispXG4gICAgICAgIGlmIChyZW5kZXJlci5idW5kbGVUeXBlID4gMCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgcHJvZHVjdGlvbiBidWlsZC5cbiAgICAgICAgICAvLyBXZSBhcmUgY3VycmVudGx5IG9ubHkgdXNpbmcgMCAoUFJPRCkgYW5kIDEgKERFVilcbiAgICAgICAgICAvLyBidXQgbWlnaHQgYWRkIDIgKFBST0ZJTEUpIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWFjdCAxNiB1c2VzIGZsYXQgYnVuZGxlcy4gSWYgd2UgcmVwb3J0IHRoZSBidW5kbGUgYXMgcHJvZHVjdGlvblxuICAgICAgICAvLyB2ZXJzaW9uLCBpdCBtZWFucyB3ZSBhbHNvIG1pbmlmaWVkIGFuZCBlbnZpZmllZCBpdCBvdXJzZWx2ZXMuXG4gICAgICAgIHJldHVybiAncHJvZHVjdGlvbic7XG4gICAgICAgIC8vIE5vdGU6IFRoZXJlIGlzIHN0aWxsIGEgcmlzayB0aGF0IHRoZSBDb21tb25KUyBlbnRyeSBwb2ludCBoYXMgbm90XG4gICAgICAgIC8vIGJlZW4gZW52aWZpZWQgb3IgdWdsaWZpZWQuIEluIHRoaXMgY2FzZSB0aGUgdXNlciB3b3VsZCBoYXZlICpib3RoKlxuICAgICAgICAvLyBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiBidW5kbGUsIGJ1dCBvbmx5IHRoZSBwcm9kIG9uZSB3b3VsZCBydW4uXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgcmVhbGx5IGJhZC4gV2UgaGF2ZSBhIHNlcGFyYXRlIGNoZWNrIGZvciB0aGlzIGJlY2F1c2VcbiAgICAgICAgLy8gaXQgaGFwcGVucyAqb3V0c2lkZSogb2YgdGhlIHJlbmRlcmVyIGluamVjdGlvbi4gU2VlIGBjaGVja0RDRWAgYmVsb3cuXG4gICAgICB9XG5cbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgICAgaWYgKHJlbmRlcmVyLk1vdW50ICYmIHJlbmRlcmVyLk1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KSB7XG4gICAgICAgIC8vIFJlYWN0IERPTSBTdGFja1xuICAgICAgICBjb25zdCByZW5kZXJSb290Q29kZSA9IHRvU3RyaW5nLmNhbGwoXG4gICAgICAgICAgcmVuZGVyZXIuTW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQsXG4gICAgICAgICk7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgYmFkIHJlc3VsdHMgKGlmIHRoYXQgaXMgZXZlbiBwb3NzaWJsZSk6XG4gICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdmdW5jdGlvbicpICE9PSAwKSB7XG4gICAgICAgICAgLy8gSG9wZSBmb3IgdGhlIGJlc3QgaWYgd2UncmUgbm90IHN1cmUuXG4gICAgICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgUmVhY3QgRE9NIFN0YWNrIDwgMTUuMS4wIGluIGRldmVsb3BtZW50LlxuICAgICAgICAvLyBJZiBpdCBjb250YWlucyBcInN0b3JlZE1lYXN1cmVcIiBjYWxsLCBpdCdzIHdyYXBwZWQgaW4gUmVhY3RQZXJmIChERVYgb25seSkuXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgdHJ1ZSBldmVuIGlmIGl0J3MgbWluaWZpZWQsIGFzIG1ldGhvZCBuYW1lIHN0aWxsIG1hdGNoZXMuXG4gICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdzdG9yZWRNZWFzdXJlJykgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIG90aGVyIHZlcnNpb25zIChhbmQgY29uZmlndXJhdGlvbnMpIGl0J3Mgbm90IHNvIGVhc3kuXG4gICAgICAgIC8vIExldCdzIHF1aWNrbHkgZXhjbHVkZSBwcm9wZXIgcHJvZHVjdGlvbiBidWlsZHMuXG4gICAgICAgIC8vIElmIGl0IGNvbnRhaW5zIGEgd2FybmluZyBtZXNzYWdlLCBpdCdzIGVpdGhlciBhIERFViBidWlsZCxcbiAgICAgICAgLy8gb3IgYW4gUFJPRCBidWlsZCB3aXRob3V0IHByb3BlciBkZWFkIGNvZGUgZWxpbWluYXRpb24uXG4gICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uJykgIT09IC0xKSB7XG4gICAgICAgICAgLy8gTm93IGhvdyBkbyB3ZSB0ZWxsIGEgREVWIGJ1aWxkIGZyb20gYSBiYWQgUFJPRCBidWlsZD9cbiAgICAgICAgICAvLyBJZiB3ZSBzZWUgTk9ERV9FTlYsIHdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGlzIGlzIGEgZGV2IGJ1aWxkXG4gICAgICAgICAgLy8gYmVjYXVzZSBtb3N0IGxpa2VseSBpdCBpcyByZWZlcnJpbmcgdG8gYW4gZW1wdHkgc2hpbS5cbiAgICAgICAgICBpZiAocmVuZGVyUm9vdENvZGUuaW5kZXhPZignTk9ERV9FTlYnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB3ZSBzZWUgXCJkZXZlbG9wbWVudFwiLCB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gZW52aWZpZWQgREVWIGJ1aWxkXG4gICAgICAgICAgLy8gKHN1Y2ggYXMgdGhlIG9mZmljaWFsIFJlYWN0IERFViBVTUQpLlxuICAgICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdkZXZlbG9wbWVudCcpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEkndmUgc2VlbiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIGJlaW5nIHNtYXJ0bHlcbiAgICAgICAgICAvLyByZXBsYWNlZCBieSBgdHJ1ZWAgaW4gREVWIGJ5IFdlYnBhY2suIEkgZG9uJ3Qga25vdyBob3cgdGhhdFxuICAgICAgICAgIC8vIHdvcmtzIGJ1dCB3ZSBjYW4gc2FmZWx5IGd1YXJkIGFnYWluc3QgaXQgYmVjYXVzZSBgdHJ1ZWAgd2FzXG4gICAgICAgICAgLy8gbmV2ZXIgdXNlZCBpbiB0aGUgZnVuY3Rpb24gc291cmNlIHNpbmNlIGl0IHdhcyB3cml0dGVuLlxuICAgICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCd0cnVlJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnkgbm93IGVpdGhlciBpdCBpcyBhIHByb2R1Y3Rpb24gYnVpbGQgdGhhdCBoYXMgbm90IGJlZW4gbWluaWZpZWQsXG4gICAgICAgICAgLy8gb3IgKHdvcnNlKSB0aGlzIGlzIGEgbWluaWZpZWQgZGV2ZWxvcG1lbnQgYnVpbGQgdXNpbmcgbm9uLXN0YW5kYXJkXG4gICAgICAgICAgLy8gZW52aXJvbm1lbnQgKGUuZy4gXCJzdGFnaW5nXCIpLiBXZSdyZSBnb2luZyB0byBsb29rIGF0IHdoZXRoZXJcbiAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gYXJndW1lbnQgbmFtZSBpcyBtYW5nbGVkOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIDAuMTMgdG8gMTVcbiAgICAgICAgICAgIHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ25leHRFbGVtZW50JykgIT09IC0xIHx8XG4gICAgICAgICAgICAvLyAwLjEyXG4gICAgICAgICAgICByZW5kZXJSb290Q29kZS5pbmRleE9mKCduZXh0Q29tcG9uZW50JykgIT09IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBiZSBjZXJ0YWluIHdoZXRoZXIgdGhpcyBpcyBhIGRldmVsb3BtZW50IGJ1aWxkIG9yIG5vdCxcbiAgICAgICAgICAgIC8vIGJ1dCBpdCBpcyBkZWZpbml0ZWx5IHVubWluaWZpZWQuXG4gICAgICAgICAgICByZXR1cm4gJ3VubWluaWZpZWQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxpa2VseSBhIG1pbmlmaWVkIGRldmVsb3BtZW50IGJ1aWxkLlxuICAgICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJ5IG5vdyB3ZSBrbm93IHRoYXQgaXQncyBlbnZpZmllZCBhbmQgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdvcmtlZCxcbiAgICAgICAgLy8gYnV0IHdoYXQgaWYgaXQncyBzdGlsbCBub3QgbWluaWZpZWQ/IChJcyB0aGlzIGV2ZW4gcG9zc2libGU/KVxuICAgICAgICAvLyBMZXQncyBjaGVjayBtYXRjaGVzIGZvciB0aGUgZmlyc3QgYXJndW1lbnQgbmFtZS5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIDAuMTMgdG8gMTVcbiAgICAgICAgICByZW5kZXJSb290Q29kZS5pbmRleE9mKCduZXh0RWxlbWVudCcpICE9PSAtMSB8fFxuICAgICAgICAgIC8vIDAuMTJcbiAgICAgICAgICByZW5kZXJSb290Q29kZS5pbmRleE9mKCduZXh0Q29tcG9uZW50JykgIT09IC0xXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiAndW5taW5pZmllZCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlbXMgbGlrZSB3ZSdyZSB1c2luZyB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uLlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYnJhbmNoIGFib3ZlIGlzIFN0YWNrLW9ubHkgc28gdGhpcyBpcyAxNSBvciBlYXJsaWVyLlxuICAgICAgICByZXR1cm4gJ291dGRhdGVkJztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFdlaXJkIGVudmlyb25tZW50cyBtYXkgZXhpc3QuXG4gICAgICAvLyBUaGlzIGNvZGUgbmVlZHMgYSBoaWdoZXIgZmF1bHQgdG9sZXJhbmNlXG4gICAgICAvLyBiZWNhdXNlIGl0IHJ1bnMgZXZlbiB3aXRoIGNsb3NlZCBEZXZUb29scy5cbiAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBjYXRjaCBlcnJvcnMgaW4gYWxsIGluamVjdGVkIGNvZGUsIGFuZCBub3QganVzdCB0aGlzIHBhcnQ/XG4gICAgfVxuICAgIHJldHVybiAncHJvZHVjdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0RDRShmbjogRnVuY3Rpb24pIHtcbiAgICAvLyBUaGlzIHJ1bnMgZm9yIHByb2R1Y3Rpb24gdmVyc2lvbnMgb2YgUmVhY3QuXG4gICAgLy8gTmVlZHMgdG8gYmUgc3VwZXIgc2FmZS5cbiAgICB0cnkge1xuICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgY29uc3QgdG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICBjb25zdCBjb2RlID0gdG9TdHJpbmcuY2FsbChmbik7XG5cbiAgICAgIC8vIFRoaXMgaXMgYSBzdHJpbmcgZW1iZWRkZWQgaW4gdGhlIHBhc3NlZCBmdW5jdGlvbiB1bmRlciBERVYtb25seVxuICAgICAgLy8gY29uZGl0aW9uLiBIb3dldmVyIHRoZSBmdW5jdGlvbiBleGVjdXRlcyBvbmx5IGluIFBST0QuIFRoZXJlZm9yZSxcbiAgICAgIC8vIGlmIHdlIHNlZSBpdCwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGRpZCBub3Qgd29yay5cbiAgICAgIGlmIChjb2RlLmluZGV4T2YoJ15fXicpID4gLTEpIHtcbiAgICAgICAgLy8gUmVtZW1iZXIgdG8gcmVwb3J0IGR1cmluZyBuZXh0IGluamVjdGlvbi5cbiAgICAgICAgaGFzRGV0ZWN0ZWRCYWREQ0UgPSB0cnVlO1xuXG4gICAgICAgIC8vIEJvbnVzOiB0aHJvdyBhbiBleGNlcHRpb24gaG9waW5nIHRoYXQgaXQgZ2V0cyBwaWNrZWQgdXAgYnkgYSByZXBvcnRpbmcgc3lzdGVtLlxuICAgICAgICAvLyBOb3Qgc3luY2hyb25vdXNseSBzbyB0aGF0IGl0IGRvZXNuJ3QgYnJlYWsgdGhlIGNhbGxpbmcgY29kZS5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1JlYWN0IGlzIHJ1bm5pbmcgaW4gcHJvZHVjdGlvbiBtb2RlLCBidXQgZGVhZCBjb2RlICcgK1xuICAgICAgICAgICAgICAnZWxpbWluYXRpb24gaGFzIG5vdCBiZWVuIGFwcGxpZWQuIFJlYWQgaG93IHRvIGNvcnJlY3RseSAnICtcbiAgICAgICAgICAgICAgJ2NvbmZpZ3VyZSBSZWFjdCBmb3IgcHJvZHVjdGlvbjogJyArXG4gICAgICAgICAgICAgICdodHRwczovL3JlYWN0LmRldi9saW5rL3BlcmYtdXNlLXByb2R1Y3Rpb24tYnVpbGQnLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfVxuXG4gIC8vIFRPRE86IGlzUHJvZmlsaW5nIHNob3VsZCBiZSBzdGF0ZWZ1bCwgYW5kIHdlIHNob3VsZCB1cGRhdGUgaXQgb25jZSBwcm9maWxpbmcgaXMgZmluaXNoZWRcbiAgY29uc3QgaXNQcm9maWxpbmcgPSBzaG91bGRTdGFydFByb2ZpbGluZ05vdztcbiAgbGV0IHVpZENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbmplY3QocmVuZGVyZXI6IFJlYWN0UmVuZGVyZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGlkID0gKyt1aWRDb3VudGVyO1xuICAgIHJlbmRlcmVycy5zZXQoaWQsIHJlbmRlcmVyKTtcblxuICAgIGNvbnN0IHJlYWN0QnVpbGRUeXBlID0gaGFzRGV0ZWN0ZWRCYWREQ0VcbiAgICAgID8gJ2RlYWRjb2RlJ1xuICAgICAgOiBkZXRlY3RSZWFjdEJ1aWxkVHlwZShyZW5kZXJlcik7XG5cbiAgICBob29rLmVtaXQoJ3JlbmRlcmVyJywge1xuICAgICAgaWQsXG4gICAgICByZW5kZXJlcixcbiAgICAgIHJlYWN0QnVpbGRUeXBlLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVuZGVyZXJJbnRlcmZhY2UgPSBhdHRhY2hSZW5kZXJlcihcbiAgICAgIGhvb2ssXG4gICAgICBpZCxcbiAgICAgIHJlbmRlcmVyLFxuICAgICAgdGFyZ2V0LFxuICAgICAgaXNQcm9maWxpbmcsXG4gICAgICBwcm9maWxpbmdTZXR0aW5ncyxcbiAgICApO1xuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSAhPSBudWxsKSB7XG4gICAgICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5zZXQoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTtcbiAgICAgIGhvb2suZW1pdCgncmVuZGVyZXItYXR0YWNoZWQnLCB7aWQsIHJlbmRlcmVySW50ZXJmYWNlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2suaGFzVW5zdXBwb3J0ZWRSZW5kZXJlckF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIGhvb2suZW1pdCgndW5zdXBwb3J0ZWQtcmVuZGVyZXItdmVyc2lvbicpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGxldCBoYXNEZXRlY3RlZEJhZERDRSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHN1YihldmVudDogc3RyaW5nLCBmbjogSGFuZGxlcikge1xuICAgIGhvb2sub24oZXZlbnQsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4gaG9vay5vZmYoZXZlbnQsIGZuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKGV2ZW50OiBzdHJpbmcsIGZuOiBIYW5kbGVyKSB7XG4gICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChmbik7XG4gIH1cblxuICBmdW5jdGlvbiBvZmYoZXZlbnQ6IHN0cmluZywgZm46IEhhbmRsZXIpIHtcbiAgICBpZiAoIWxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnNbZXZlbnRdLmluZGV4T2YoZm4pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGxpc3RlbmVyc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdChldmVudDogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgICBpZiAobGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XS5tYXAoZm4gPT4gZm4oZGF0YSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpYmVyUm9vdHMocmVuZGVyZXJJRDogUmVuZGVyZXJJRCkge1xuICAgIGNvbnN0IHJvb3RzID0gZmliZXJSb290cztcbiAgICBpZiAoIXJvb3RzW3JlbmRlcmVySURdKSB7XG4gICAgICByb290c1tyZW5kZXJlcklEXSA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RzW3JlbmRlcmVySURdO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRDogUmVuZGVyZXJJRCwgZmliZXI6IGFueSkge1xuICAgIGNvbnN0IHJlbmRlcmVySW50ZXJmYWNlID0gcmVuZGVyZXJJbnRlcmZhY2VzLmdldChyZW5kZXJlcklEKTtcbiAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgcmVuZGVyZXJJbnRlcmZhY2UuaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50KGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbW1pdEZpYmVyUm9vdChcbiAgICByZW5kZXJlcklEOiBSZW5kZXJlcklELFxuICAgIHJvb3Q6IGFueSxcbiAgICBwcmlvcml0eUxldmVsOiB2b2lkIHwgbnVtYmVyLFxuICApIHtcbiAgICBjb25zdCBtb3VudGVkUm9vdHMgPSBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCk7XG4gICAgY29uc3QgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgICBjb25zdCBpc0tub3duUm9vdCA9IG1vdW50ZWRSb290cy5oYXMocm9vdCk7XG4gICAgY29uc3QgaXNVbm1vdW50aW5nID1cbiAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA9PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ID09IG51bGw7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIG1vdW50ZWQgcm9vdHMgc28gd2UgY2FuIGh5ZHJhdGUgd2hlbiBEZXZUb29scyBjb25uZWN0LlxuICAgIGlmICghaXNLbm93blJvb3QgJiYgIWlzVW5tb3VudGluZykge1xuICAgICAgbW91bnRlZFJvb3RzLmFkZChyb290KTtcbiAgICB9IGVsc2UgaWYgKGlzS25vd25Sb290ICYmIGlzVW5tb3VudGluZykge1xuICAgICAgbW91bnRlZFJvb3RzLmRlbGV0ZShyb290KTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyZXJJbnRlcmZhY2UgPSByZW5kZXJlckludGVyZmFjZXMuZ2V0KHJlbmRlcmVySUQpO1xuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSAhPSBudWxsKSB7XG4gICAgICByZW5kZXJlckludGVyZmFjZS5oYW5kbGVDb21taXRGaWJlclJvb3Qocm9vdCwgcHJpb3JpdHlMZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQ6IFJlbmRlcmVySUQsIHJvb3Q6IGFueSkge1xuICAgIGNvbnN0IHJlbmRlcmVySW50ZXJmYWNlID0gcmVuZGVyZXJJbnRlcmZhY2VzLmdldChyZW5kZXJlcklEKTtcbiAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgcmVuZGVyZXJJbnRlcmZhY2UuaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdChyb290KTtcbiAgICB9XG4gIH1cblxuICBsZXQgaXNSdW5uaW5nRHVyaW5nU3RyaWN0TW9kZUludm9jYXRpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gc2V0U3RyaWN0TW9kZShyZW5kZXJlcklEOiBSZW5kZXJlcklELCBpc1N0cmljdE1vZGU6IGJvb2xlYW4pIHtcbiAgICBpc1J1bm5pbmdEdXJpbmdTdHJpY3RNb2RlSW52b2NhdGlvbiA9IGlzU3RyaWN0TW9kZTtcblxuICAgIGlmIChpc1N0cmljdE1vZGUpIHtcbiAgICAgIHBhdGNoQ29uc29sZUZvclN0cmljdE1vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlKCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdW5wYXRjaENvbnNvbGVDYWxsYmFja3MgPSBbXTtcbiAgLy8gRm9yIFN0cmljdE1vZGUgd2UgcGF0Y2ggY29uc29sZSBvbmNlIHdlIGFyZSBydW5uaW5nIGluIFN0cmljdE1vZGUgYW5kIHVucGF0Y2ggcmlnaHQgYWZ0ZXIgaXRcbiAgLy8gU28gcGF0Y2hpbmcgY291bGQgaGFwcGVuIG11bHRpcGxlIHRpbWVzIGR1cmluZyB0aGUgcnVudGltZVxuICAvLyBOb3RpY2UgaG93IHdlIGRvbid0IHBhdGNoIGVycm9yIG9yIHdhcm4gbWV0aG9kcywgYmVjYXVzZSB0aGV5IGFyZSBhbHJlYWR5IHBhdGNoZWQgaW4gcGF0Y2hDb25zb2xlRm9yRXJyb3JzQW5kV2FybmluZ3NcbiAgLy8gVGhpcyB3aWxsIG9ubHkgaGFwcGVuIG9uY2UsIHdoZW4gaG9vayBpcyBpbnN0YWxsZWRcbiAgZnVuY3Rpb24gcGF0Y2hDb25zb2xlRm9yU3RyaWN0TW9kZSgpIHtcbiAgICAvLyBEb24ndCBwYXRjaCBjb25zb2xlIGluIGNhc2Ugc2V0dGluZ3Mgd2VyZSBub3QgaW5qZWN0ZWRcbiAgICBpZiAoIWhvb2suc2V0dGluZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwYXRjaCB0d2ljZVxuICAgIGlmICh1bnBhdGNoQ29uc29sZUNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCAnZXJyb3InLCAnd2FybicsIGFuZCAndHJhY2UnIG1ldGhvZHMgYXJlIGFscmVhZHkgcGF0Y2hlZFxuICAgIC8vIGJ5IFJlYWN0IERldlRvb2xzIGhvb2sgdG8gYXBwZW5kIGNvbXBvbmVudCBzdGFja3MgYW5kIG90aGVyIHBvc3NpYmxlIGZlYXR1cmVzLlxuICAgIGNvbnN0IGNvbnNvbGVNZXRob2RzVG9PdmVycmlkZUZvclN0cmljdE1vZGUgPSBbXG4gICAgICAnZ3JvdXAnLFxuICAgICAgJ2dyb3VwQ29sbGFwc2VkJyxcbiAgICAgICdpbmZvJyxcbiAgICAgICdsb2cnLFxuICAgIF07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGNvbnNvbGVNZXRob2RzVG9PdmVycmlkZUZvclN0cmljdE1vZGUpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gdGFyZ2V0Q29uc29sZVttZXRob2RdO1xuICAgICAgY29uc3Qgb3ZlcnJpZGVNZXRob2Q6ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiB2b2lkID0gKFxuICAgICAgICAuLi5hcmdzOiBhbnlbXVxuICAgICAgKSA9PiB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gaG9vay5zZXR0aW5ncztcbiAgICAgICAgLy8gU29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQsIGZhbGxiYWNrIHRvIGp1c3QgcHJpbnRpbmcgdGhlIGNvbnNvbGUgbWVzc2FnZS5cbiAgICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgICAgICBvcmlnaW5hbE1ldGhvZCguLi5hcmdzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGltIHRoZSB0ZXh0IGNvbG9yIG9mIHRoZSBkb3VibGUgbG9ncyBpZiB3ZSdyZSBub3QgaGlkaW5nIHRoZW0uXG4gICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IEFOU0kgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICBpZiAoX19JU19GSVJFRk9YX18pIHtcbiAgICAgICAgICBvcmlnaW5hbE1ldGhvZChcbiAgICAgICAgICAgIC4uLmZvcm1hdFdpdGhTdHlsZXMoYXJncywgRklSRUZPWF9DT05TT0xFX0RJTU1JTkdfQ09MT1IpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWxNZXRob2QoXG4gICAgICAgICAgICBBTlNJX1NUWUxFX0RJTU1JTkdfVEVNUExBVEUsXG4gICAgICAgICAgICAuLi5mb3JtYXRDb25zb2xlQXJndW1lbnRzKC4uLmFyZ3MpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRhcmdldENvbnNvbGVbbWV0aG9kXSA9IG92ZXJyaWRlTWV0aG9kO1xuICAgICAgdW5wYXRjaENvbnNvbGVDYWxsYmFja3MucHVzaCgoKSA9PiB7XG4gICAgICAgIHRhcmdldENvbnNvbGVbbWV0aG9kXSA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW5wYXRjaENvbnNvbGVGb3JTdHJpY3RNb2RlKCkge1xuICAgIHVucGF0Y2hDb25zb2xlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG4gICAgdW5wYXRjaENvbnNvbGVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHR5cGUgU3RhY2tGcmFtZVN0cmluZyA9IHN0cmluZztcblxuICBjb25zdCBvcGVuTW9kdWxlUmFuZ2VzU3RhY2s6IEFycmF5PFN0YWNrRnJhbWVTdHJpbmc+ID0gW107XG4gIGNvbnN0IG1vZHVsZVJhbmdlczogQXJyYXk8W1N0YWNrRnJhbWVTdHJpbmcsIFN0YWNrRnJhbWVTdHJpbmddPiA9IFtdO1xuXG4gIGZ1bmN0aW9uIGdldFRvcFN0YWNrRnJhbWVTdHJpbmcoZXJyb3I6IEVycm9yKTogU3RhY2tGcmFtZVN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IGZyYW1lcyA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBmcmFtZSA9IGZyYW1lcy5sZW5ndGggPiAxID8gZnJhbWVzWzFdIDogbnVsbDtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnRlcm5hbE1vZHVsZVJhbmdlcygpOiBBcnJheTxcbiAgICBbU3RhY2tGcmFtZVN0cmluZywgU3RhY2tGcmFtZVN0cmluZ10sXG4gID4ge1xuICAgIHJldHVybiBtb2R1bGVSYW5nZXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoZXJyb3I6IEVycm9yKSB7XG4gICAgY29uc3Qgc3RhcnRTdGFja0ZyYW1lID0gZ2V0VG9wU3RhY2tGcmFtZVN0cmluZyhlcnJvcik7XG4gICAgaWYgKHN0YXJ0U3RhY2tGcmFtZSAhPT0gbnVsbCkge1xuICAgICAgb3Blbk1vZHVsZVJhbmdlc1N0YWNrLnB1c2goc3RhcnRTdGFja0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChlcnJvcjogRXJyb3IpIHtcbiAgICBpZiAob3Blbk1vZHVsZVJhbmdlc1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHN0YXJ0U3RhY2tGcmFtZSA9IG9wZW5Nb2R1bGVSYW5nZXNTdGFjay5wb3AoKTtcbiAgICAgIGNvbnN0IHN0b3BTdGFja0ZyYW1lID0gZ2V0VG9wU3RhY2tGcmFtZVN0cmluZyhlcnJvcik7XG4gICAgICBpZiAoc3RvcFN0YWNrRnJhbWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgICAgICAgbW9kdWxlUmFuZ2VzLnB1c2goW3N0YXJ0U3RhY2tGcmFtZSwgc3RvcFN0YWNrRnJhbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGb3IgRXJyb3JzIGFuZCBXYXJuaW5ncyB3ZSBvbmx5IHBhdGNoIGNvbnNvbGUgb25jZVxuICBmdW5jdGlvbiBwYXRjaENvbnNvbGVGb3JFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICAvLyBEb24ndCBwYXRjaCBjb25zb2xlIGluIGNhc2Ugc2V0dGluZ3Mgd2VyZSBub3QgaW5qZWN0ZWRcbiAgICBpZiAoIWhvb2suc2V0dGluZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb25zb2xlTWV0aG9kc1RvT3ZlcnJpZGVGb3JFcnJvcnNBbmRXYXJuaW5ncyA9IFtcbiAgICAgICdlcnJvcicsXG4gICAgICAndHJhY2UnLFxuICAgICAgJ3dhcm4nLFxuICAgIF07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGNvbnNvbGVNZXRob2RzVG9PdmVycmlkZUZvckVycm9yc0FuZFdhcm5pbmdzKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IHRhcmdldENvbnNvbGVbbWV0aG9kXTtcbiAgICAgIGNvbnN0IG92ZXJyaWRlTWV0aG9kOiAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gdm9pZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gaG9vay5zZXR0aW5ncztcbiAgICAgICAgLy8gU29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQsIGZhbGxiYWNrIHRvIGp1c3QgcHJpbnRpbmcgdGhlIGNvbnNvbGUgbWVzc2FnZS5cbiAgICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgICAgICBvcmlnaW5hbE1ldGhvZCguLi5hcmdzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNSdW5uaW5nRHVyaW5nU3RyaWN0TW9kZUludm9jYXRpb24gJiZcbiAgICAgICAgICBzZXR0aW5ncy5oaWRlQ29uc29sZUxvZ3NJblN0cmljdE1vZGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluamVjdGVkQ29tcG9uZW50U3RhY2tBc0Zha2VFcnJvciA9IGZhbHNlO1xuICAgICAgICBsZXQgYWxyZWFkeUhhc0NvbXBvbmVudFN0YWNrID0gZmFsc2U7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hcHBlbmRDb21wb25lbnRTdGFjaykge1xuICAgICAgICAgIGNvbnN0IGxhc3RBcmcgPSBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgIGFscmVhZHlIYXNDb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ3N0cmluZycgJiYgaXNTdHJpbmdDb21wb25lbnRTdGFjayhsYXN0QXJnKTsgLy8gVGhlIGxhc3QgYXJndW1lbnQgc2hvdWxkIGJlIGEgY29tcG9uZW50IHN0YWNrLlxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkU2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzID1cbiAgICAgICAgICBzZXR0aW5ncy5zaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgJiZcbiAgICAgICAgICAobWV0aG9kID09PSAnZXJyb3InIHx8IG1ldGhvZCA9PT0gJ3dhcm4nKTtcblxuICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBmaXJzdCByZW5kZXJlciB0aGF0IGhhcyBhIGN1cnJlbnQgRmliZXIuXG4gICAgICAgIC8vIFdlIGRvbid0IGhhbmRsZSB0aGUgZWRnZSBjYXNlIG9mIHN0YWNrcyBmb3IgbW9yZSB0aGFuIG9uZSAoZS5nLiBpbnRlcmxlYXZlZCByZW5kZXJlcnM/KVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVySW50ZXJmYWNlIG9mIGhvb2sucmVuZGVyZXJJbnRlcmZhY2VzLnZhbHVlcygpKSB7XG4gICAgICAgICAgY29uc3Qge29uRXJyb3JPcldhcm5pbmcsIGdldENvbXBvbmVudFN0YWNrfSA9IHJlbmRlcmVySW50ZXJmYWNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSB7XG4gICAgICAgICAgICAgIC8vIHBhdGNoKCkgaXMgY2FsbGVkIGJ5IHR3byBwbGFjZXM6ICgxKSB0aGUgaG9vayBhbmQgKDIpIHRoZSByZW5kZXJlciBiYWNrZW5kLlxuICAgICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBpcyB3aGF0IGltcGxlbWVudHMgYSBtZXNzYWdlIHF1ZXVlLCBzbyBpdCdzIHRoZSBvbmx5IG9uZSB0aGF0IGluamVjdHMgb25FcnJvck9yV2FybmluZy5cbiAgICAgICAgICAgICAgaWYgKG9uRXJyb3JPcldhcm5pbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9uRXJyb3JPcldhcm5pbmcoXG4gICAgICAgICAgICAgICAgICAoKG1ldGhvZDogYW55KTogJ2Vycm9yJyB8ICd3YXJuJyksXG4gICAgICAgICAgICAgICAgICBhcmdzLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBsZXQgYSBEZXZUb29scyBvciBSZWFjdCBpbnRlcm5hbCBlcnJvciBpbnRlcmZlcmUgd2l0aCBsb2dnaW5nLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hcHBlbmRDb21wb25lbnRTdGFjayAmJiBnZXRDb21wb25lbnRTdGFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGlyZWN0bHkgaW4gdGhlIHdyYXBwZXIgc28gd2UgY2FuIHBvcCBleGFjdGx5IG9uZSBmcmFtZS5cbiAgICAgICAgICAgICAgY29uc3QgdG9wRnJhbWUgPSBFcnJvcigncmVhY3Qtc3RhY2stdG9wLWZyYW1lJyk7XG4gICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gZ2V0Q29tcG9uZW50U3RhY2sodG9wRnJhbWUpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7ZW5hYmxlT3duZXJTdGFja3MsIGNvbXBvbmVudFN0YWNrfSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIC8vIEVtcHR5IHN0cmluZyBtZWFucyB3ZSBoYXZlIGEgbWF0Y2ggYnV0IG5vIGNvbXBvbmVudCBzdGFjay5cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGxvb2sgaW4gb3RoZXIgcmVuZGVyZXJzIGJ1dCB3ZSBhbHNvIGRvbid0IGFkZCBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50U3RhY2sgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBmYWtlIEVycm9yIHNvIHRoYXQgd2hlbiB3ZSBwcmludCBpdCB3ZSBnZXQgbmF0aXZlIHNvdXJjZSBtYXBzLiBFdmVyeVxuICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlciB3aWxsIHByaW50IHRoZSAuc3RhY2sgcHJvcGVydHkgb2YgdGhlIGVycm9yIGFuZCB0aGVuIHBhcnNlIGl0IGJhY2sgZm9yIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgLy8gbWFwcGluZy4gUmF0aGVyIHRoYW4gcHJpbnQgdGhlIGludGVybmFsIHNsb3QuIFNvIGl0IGRvZXNuJ3QgbWF0dGVyIHRoYXQgdGhlIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAvLyBzbG90IGRvZXNuJ3QgbGluZSB1cC5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZha2VFcnJvciA9IG5ldyBFcnJvcignJyk7XG4gICAgICAgICAgICAgICAgICAvLyBJbiBDaHJvbWl1bSwgb25seSB0aGUgc3RhY2sgcHJvcGVydHkgaXMgcHJpbnRlZCBidXQgaW4gRmlyZWZveCB0aGUgPG5hbWU+OjxtZXNzYWdlPlxuICAgICAgICAgICAgICAgICAgLy8gZ2V0cyBwcmludGVkIHNvIHRvIG1ha2UgdGhlIGNvbG9uIG1ha2Ugc2Vuc2UsIHdlIG5hbWUgaXQgc28gd2UgcHJpbnQgU3RhY2s6XG4gICAgICAgICAgICAgICAgICAvLyBhbmQgc2ltaWxhcmx5IFNhZmFyaSBsZWF2ZSBhbiBleHBhbmRhYmxlIHNsb3QuXG4gICAgICAgICAgICAgICAgICBpZiAoX19JU19DSFJPTUVfXyB8fCBfX0lTX0VER0VfXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBCZWZvcmUgc2VuZGluZyB0aGUgc3RhY2sgdG8gQ2hyb21lIERldlRvb2xzIGZvciBmb3JtYXR0aW5nLFxuICAgICAgICAgICAgICAgICAgICAvLyBWOCB3aWxsIHJlY29uc3RydWN0IHRoaXMgYWNjb3JkaW5nIHRvIHRoZSB0ZW1wbGF0ZSA8bmFtZT46IDxtZXNzYWdlPjxzdGFjay1mcmFtZXM+XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnY4L3NyYy9pbnNwZWN0b3IvdmFsdWUtbWlycm9yLmNjO2w9MjUyLTMxMTtkcmM9YmRjNDhkMWIxMzEyY2M0MGMwMDI4MmVmYjFjOWM1ZjQxZGNkY2E5YVxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBoYXMgdG8gc3RhcnQgd2l0aCBeW1xcdy5dKkVycm9yXFxiIHRvIHRyaWdnZXIgc3RhY2sgZm9ybWF0dGluZy5cbiAgICAgICAgICAgICAgICAgICAgZmFrZUVycm9yLm5hbWUgPSBlbmFibGVPd25lclN0YWNrc1xuICAgICAgICAgICAgICAgICAgICAgID8gJ0Vycm9yIFN0YWNrJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ0Vycm9yIENvbXBvbmVudCBTdGFjayc7IC8vIFRoaXMgZ2V0cyBwcmludGVkXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmYWtlRXJyb3IubmFtZSA9IGVuYWJsZU93bmVyU3RhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgPyAnU3RhY2snXG4gICAgICAgICAgICAgICAgICAgICAgOiAnQ29tcG9uZW50IFN0YWNrJzsgLy8gVGhpcyBnZXRzIHByaW50ZWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIEluIENocm9taXVtLCB0aGUgc3RhY2sgcHJvcGVydHkgbmVlZHMgdG8gc3RhcnQgd2l0aCBeW1xcdy5dKkVycm9yXFxiIHRvIHRyaWdnZXIgc3RhY2tcbiAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRpbmcuIE90aGVyd2lzZSBpdCBpcyBsZWZ0IGFsb25lLiBTbyB3ZSBwcmVmaXggaXQuIE90aGVyd2lzZSB3ZSBqdXN0IG92ZXJyaWRlIGl0XG4gICAgICAgICAgICAgICAgICAvLyB0byBvdXIgb3duIHN0YWNrLlxuICAgICAgICAgICAgICAgICAgZmFrZUVycm9yLnN0YWNrID1cbiAgICAgICAgICAgICAgICAgICAgX19JU19DSFJPTUVfXyB8fCBfX0lTX0VER0VfXyB8fCBfX0lTX05BVElWRV9fXG4gICAgICAgICAgICAgICAgICAgICAgPyAoZW5hYmxlT3duZXJTdGFja3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnRXJyb3IgU3RhY2s6J1xuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdFcnJvciBDb21wb25lbnQgU3RhY2s6JykgKyBjb21wb25lbnRTdGFja1xuICAgICAgICAgICAgICAgICAgICAgIDogY29tcG9uZW50U3RhY2s7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5SGFzQ29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBtb2RpZnkgdGhlIGNvbXBvbmVudCBzdGFjayBpZiBpdCBtYXRjaGVzIHdoYXQgd2Ugd291bGQndmUgYWRkZWQgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXNzdW1lIGl0IHdhcyBhIG5vbi1SZWFjdCBzdGFjay5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIGFyZVN0YWNrVHJhY2VzRXF1YWwoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBjb21wb25lbnRTdGFjaylcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RBcmcgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGZpcnN0QXJnID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RBcmcuZW5kc1dpdGgoJyVzJylcbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBmaXJzdEFyZy5zbGljZSgwLCBmaXJzdEFyZy5sZW5ndGggLSAyKTsgLy8gU3RyaXAgdGhlICVzIHBhcmFtXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGZha2VFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICBpbmplY3RlZENvbXBvbmVudFN0YWNrQXNGYWtlRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goZmFrZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRDb21wb25lbnRTdGFja0FzRmFrZUVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgc3RhY2tzIGZyb20gb3RoZXIgcmVuZGVyZXJzLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGxldCBhIERldlRvb2xzIG9yIFJlYWN0IGludGVybmFsIGVycm9yIGludGVyZmVyZSB3aXRoIGxvZ2dpbmcuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYnJlYWtPbkNvbnNvbGVFcnJvcnMpIHtcbiAgICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgd2l0aCBSZWFjdCBEZXZUb29scyAtLS1cbiAgICAgICAgICAvLyBUaGlzIGRlYnVnZ2VyIHN0YXRlbWVudCBtZWFucyB0aGF0IHlvdSd2ZSBlbmFibGVkIHRoZSBcImJyZWFrIG9uIHdhcm5pbmdzXCIgZmVhdHVyZS5cbiAgICAgICAgICAvLyBVc2UgdGhlIGJyb3dzZXIncyBDYWxsIFN0YWNrIHBhbmVsIHRvIHN0ZXAgb3V0IG9mIHRoaXMgb3ZlcnJpZGUgZnVuY3Rpb25cbiAgICAgICAgICAvLyB0byB3aGVyZSB0aGUgb3JpZ2luYWwgd2FybmluZyBvciBlcnJvciB3YXMgbG9nZ2VkLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUnVubmluZ0R1cmluZ1N0cmljdE1vZGVJbnZvY2F0aW9uKSB7XG4gICAgICAgICAgLy8gRGltIHRoZSB0ZXh0IGNvbG9yIG9mIHRoZSBkb3VibGUgbG9ncyBpZiB3ZSdyZSBub3QgaGlkaW5nIHRoZW0uXG4gICAgICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgQU5TSSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgaWYgKF9fSVNfRklSRUZPWF9fKSB7XG4gICAgICAgICAgICBsZXQgYXJnc1dpdGhDU1NTdHlsZXMgPSBmb3JtYXRXaXRoU3R5bGVzKFxuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBGSVJFRk9YX0NPTlNPTEVfRElNTUlOR19DT0xPUixcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChpbmplY3RlZENvbXBvbmVudFN0YWNrQXNGYWtlRXJyb3IpIHtcbiAgICAgICAgICAgICAgYXJnc1dpdGhDU1NTdHlsZXMgPSBbXG4gICAgICAgICAgICAgICAgYCR7YXJnc1dpdGhDU1NTdHlsZXNbMF19ICVvYCxcbiAgICAgICAgICAgICAgICAuLi5hcmdzV2l0aENTU1N0eWxlcy5zbGljZSgxKSxcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3JpZ2luYWxNZXRob2QoLi4uYXJnc1dpdGhDU1NTdHlsZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmlnaW5hbE1ldGhvZChcbiAgICAgICAgICAgICAgaW5qZWN0ZWRDb21wb25lbnRTdGFja0FzRmFrZUVycm9yXG4gICAgICAgICAgICAgICAgPyBBTlNJX1NUWUxFX0RJTU1JTkdfVEVNUExBVEVfV0lUSF9DT01QT05FTlRfU1RBQ0tcbiAgICAgICAgICAgICAgICA6IEFOU0lfU1RZTEVfRElNTUlOR19URU1QTEFURSxcbiAgICAgICAgICAgICAgLi4uZm9ybWF0Q29uc29sZUFyZ3VtZW50cyguLi5hcmdzKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9yaWdpbmFsTWV0aG9kKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0YXJnZXRDb25zb2xlW21ldGhvZF0gPSBvdmVycmlkZU1ldGhvZDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNb3JlIG1lYW5pbmdmdWwgbmFtZXMgZm9yIFwicmVuZGVyZXJJbnRlcmZhY2VzXCIgYW5kIFwicmVuZGVyZXJzXCIuXG4gIGNvbnN0IGZpYmVyUm9vdHM6IHtbUmVuZGVyZXJJRF06IFNldDxtaXhlZD59ID0ge307XG4gIGNvbnN0IHJlbmRlcmVySW50ZXJmYWNlcyA9IG5ldyBNYXA8UmVuZGVyZXJJRCwgUmVuZGVyZXJJbnRlcmZhY2U+KCk7XG4gIGNvbnN0IGxpc3RlbmVyczoge1tzdHJpbmddOiBBcnJheTxIYW5kbGVyPn0gPSB7fTtcbiAgY29uc3QgcmVuZGVyZXJzID0gbmV3IE1hcDxSZW5kZXJlcklELCBSZWFjdFJlbmRlcmVyPigpO1xuICBjb25zdCBiYWNrZW5kcyA9IG5ldyBNYXA8c3RyaW5nLCBEZXZUb29sc0JhY2tlbmQ+KCk7XG5cbiAgY29uc3QgaG9vazogRGV2VG9vbHNIb29rID0ge1xuICAgIHJlbmRlcmVySW50ZXJmYWNlcyxcbiAgICBsaXN0ZW5lcnMsXG5cbiAgICBiYWNrZW5kcyxcblxuICAgIC8vIEZhc3QgUmVmcmVzaCBmb3Igd2ViIHJlbGllcyBvbiB0aGlzLlxuICAgIHJlbmRlcmVycyxcbiAgICBoYXNVbnN1cHBvcnRlZFJlbmRlcmVyQXR0YWNoZWQ6IGZhbHNlLFxuXG4gICAgZW1pdCxcbiAgICBnZXRGaWJlclJvb3RzLFxuICAgIGluamVjdCxcbiAgICBvbixcbiAgICBvZmYsXG4gICAgc3ViLFxuXG4gICAgLy8gVGhpcyBpcyBhIGxlZ2FjeSBmbGFnLlxuICAgIC8vIFJlYWN0IHYxNiBjaGVja3MgdGhlIGhvb2sgZm9yIHRoaXMgdG8gZW5zdXJlIERldlRvb2xzIGlzIG5ldyBlbm91Z2guXG4gICAgc3VwcG9ydHNGaWJlcjogdHJ1ZSxcblxuICAgIC8vIFJlYWN0IEZsaWdodCBDbGllbnQgY2hlY2tzIHRoZSBob29rIGZvciB0aGlzIHRvIGVuc3VyZSBEZXZUb29scyBpcyBuZXcgZW5vdWdoLlxuICAgIHN1cHBvcnRzRmxpZ2h0OiB0cnVlLFxuXG4gICAgLy8gUmVhY3QgY2FsbHMgdGhlc2UgbWV0aG9kcy5cbiAgICBjaGVja0RDRSxcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCxcbiAgICBvbkNvbW1pdEZpYmVyUm9vdCxcbiAgICAvLyBSZWFjdCB2MTguMCtcbiAgICBvblBvc3RDb21taXRGaWJlclJvb3QsXG4gICAgc2V0U3RyaWN0TW9kZSxcblxuICAgIC8vIFNjaGVkdWxlIFByb2ZpbGVyIHJ1bnRpbWUgaGVscGVycy5cbiAgICAvLyBUaGVzZSBpbnRlcm5hbCBSZWFjdCBtb2R1bGVzIHRvIHJlcG9ydCB0aGVpciBvd24gYm91bmRhcmllc1xuICAgIC8vIHdoaWNoIGluIHR1cm4gZW5hYmxlcyB0aGUgcHJvZmlsZXIgdG8gZGltIG9yIGZpbHRlciBpbnRlcm5hbCBmcmFtZXMuXG4gICAgZ2V0SW50ZXJuYWxNb2R1bGVSYW5nZXMsXG4gICAgcmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0LFxuICAgIHJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wLFxuICB9O1xuXG4gIGlmIChtYXliZVNldHRpbmdzT3JTZXR0aW5nc1Byb21pc2UgPT0gbnVsbCkge1xuICAgIC8vIFNldCBkZWZhdWx0IHNldHRpbmdzXG4gICAgaG9vay5zZXR0aW5ncyA9IHtcbiAgICAgIGFwcGVuZENvbXBvbmVudFN0YWNrOiB0cnVlLFxuICAgICAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IGZhbHNlLFxuICAgICAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzOiB0cnVlLFxuICAgICAgaGlkZUNvbnNvbGVMb2dzSW5TdHJpY3RNb2RlOiBmYWxzZSxcbiAgICB9O1xuICAgIHBhdGNoQ29uc29sZUZvckVycm9yc0FuZFdhcm5pbmdzKCk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKG1heWJlU2V0dGluZ3NPclNldHRpbmdzUHJvbWlzZSlcbiAgICAgIC50aGVuKHNldHRpbmdzID0+IHtcbiAgICAgICAgaG9vay5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICBob29rLmVtaXQoJ3NldHRpbmdzSW5pdGlhbGl6ZWQnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgcGF0Y2hDb25zb2xlRm9yRXJyb3JzQW5kV2FybmluZ3MoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICB0YXJnZXRDb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3QgRGV2VG9vbHMgZmFpbGVkIHRvIGdldCBDb25zb2xlIFBhdGNoaW5nIHNldHRpbmdzLiBDb25zb2xlIHdvbid0IGJlIHBhdGNoZWQgYW5kIHNvbWUgY29uc29sZSBmZWF0dXJlcyB3aWxsIG5vdCB3b3JrLlwiLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgdGFyZ2V0LFxuICAgICdfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18nLFxuICAgICh7XG4gICAgICAvLyBUaGlzIHByb3BlcnR5IG5lZWRzIHRvIGJlIGNvbmZpZ3VyYWJsZSBmb3IgdGhlIHRlc3QgZW52aXJvbm1lbnQsXG4gICAgICAvLyBlbHNlIHdlIHdvbid0IGJlIGFibGUgdG8gZGVsZXRlIGFuZCByZWNyZWF0ZSBpdCBiZXR3ZWVuIHRlc3RzLlxuICAgICAgY29uZmlndXJhYmxlOiBfX0RFVl9fLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBob29rO1xuICAgICAgfSxcbiAgICB9OiBPYmplY3QpLFxuICApO1xuXG4gIHJldHVybiBob29rO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/hook.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/hydration.js":
/*!*************************************************!*\
  !*** ../react-devtools-shared/src/hydration.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dehydrate\": () => (/* binding */ dehydrate),\n/* harmony export */   \"fillInPath\": () => (/* binding */ fillInPath),\n/* harmony export */   \"hydrate\": () => (/* binding */ hydrate),\n/* harmony export */   \"meta\": () => (/* binding */ meta)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar meta = {\n  inspectable: Symbol('inspectable'),\n  inspected: Symbol('inspected'),\n  name: Symbol('name'),\n  preview_long: Symbol('preview_long'),\n  preview_short: Symbol('preview_short'),\n  readonly: Symbol('readonly'),\n  size: Symbol('size'),\n  type: Symbol('type'),\n  unserializable: Symbol('unserializable')\n};\n// This threshold determines the depth at which the bridge \"dehydrates\" nested data.\n// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,\n// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).\n//\n// Reducing this threshold will improve the speed of initial component inspection,\n// but may decrease the responsiveness of expanding objects/arrays to inspect further.\nvar LEVEL_THRESHOLD = 2;\n/**\n * Generate the dehydrated metadata for complex object instances\n */\n\nfunction createDehydrated(type, inspectable, data, cleaned, path) {\n  cleaned.push(path);\n  var dehydrated = {\n    inspectable: inspectable,\n    type: type,\n    preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n    preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n    name: typeof data.constructor !== 'function' || typeof data.constructor.name !== 'string' || data.constructor.name === 'Object' ? '' : data.constructor.name\n  };\n\n  if (type === 'array' || type === 'typed_array') {\n    dehydrated.size = data.length;\n  } else if (type === 'object') {\n    dehydrated.size = Object.keys(data).length;\n  }\n\n  if (type === 'iterator' || type === 'typed_array') {\n    dehydrated.readonly = true;\n  }\n\n  return dehydrated;\n}\n/**\n * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).\n * The paths of the stripped out objects are appended to the `cleaned` list.\n * On the other side of the barrier, the cleaned list is used to \"re-hydrate\" the cleaned representation into\n * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.\n *\n * Input: {\"some\": {\"attr\": fn()}, \"other\": AnInstance}\n * Output: {\n *   \"some\": {\n *     \"attr\": {\"name\": the fn.name, type: \"function\"}\n *   },\n *   \"other\": {\n *     \"name\": \"AnInstance\",\n *     \"type\": \"object\",\n *   },\n * }\n * and cleaned = [[\"some\", \"attr\"], [\"other\"]]\n */\n\n\nfunction dehydrate(data, cleaned, unserializable, path, isPathAllowed) {\n  var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var type = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getDataType)(data);\n  var isPathAllowedCheck;\n\n  switch (type) {\n    case 'html_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.tagName,\n        type: type\n      };\n\n    case 'function':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,\n        type: type\n      };\n\n    case 'string':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (isPathAllowedCheck) {\n        return data;\n      } else {\n        return data.length <= 500 ? data : data.slice(0, 500) + '...';\n      }\n\n    case 'bigint':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type: type\n      };\n\n    case 'symbol':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type: type\n      };\n    // React Elements aren't very inspector-friendly,\n    // and often contain private fields or circular references.\n\n    case 'react_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getDisplayNameForReactElement)(data) || 'Unknown',\n        type: type\n      };\n    // ArrayBuffers error if you try to inspect them.\n\n    case 'array_buffer':\n    case 'data_view':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',\n        size: data.byteLength,\n        type: type\n      };\n\n    case 'array':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      var arr = [];\n\n      for (var i = 0; i < data.length; i++) {\n        arr[i] = dehydrateKey(data, i, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n      }\n\n      return arr;\n\n    case 'html_all_collection':\n    case 'typed_array':\n    case 'iterator':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        var unserializableValue = {\n          unserializable: true,\n          type: type,\n          readonly: true,\n          size: type === 'typed_array' ? data.length : undefined,\n          preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n          preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n          name: typeof data.constructor !== 'function' || typeof data.constructor.name !== 'string' || data.constructor.name === 'Object' ? '' : data.constructor.name\n        }; // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n\n        Array.from(data).forEach(function (item, i) {\n          return unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n        });\n        unserializable.push(path);\n        return unserializableValue;\n      }\n\n    case 'opaque_iterator':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data[Symbol.toStringTag],\n        type: type\n      };\n\n    case 'date':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type: type\n      };\n\n    case 'regexp':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type: type\n      };\n\n    case 'object':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        var object = {};\n        (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getAllEnumerableKeys)(data).forEach(function (key) {\n          var name = key.toString();\n          object[name] = dehydrateKey(data, key, cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n        });\n        return object;\n      }\n\n    case 'class_instance':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      var value = {\n        unserializable: true,\n        type: type,\n        readonly: true,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: typeof data.constructor !== 'function' || typeof data.constructor.name !== 'string' ? '' : data.constructor.name\n      };\n      (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getAllEnumerableKeys)(data).forEach(function (key) {\n        var keyAsString = key.toString();\n        value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n      });\n      unserializable.push(path);\n      return value;\n\n    case 'infinity':\n    case 'nan':\n    case 'undefined':\n      // Some values are lossy when sent through a WebSocket.\n      // We dehydrate+rehydrate them to preserve their type.\n      cleaned.push(path);\n      return {\n        type: type\n      };\n\n    default:\n      return data;\n  }\n}\n\nfunction dehydrateKey(parent, key, cleaned, unserializable, path, isPathAllowed) {\n  var level = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n  try {\n    return dehydrate(parent[key], cleaned, unserializable, path, isPathAllowed, level);\n  } catch (error) {\n    var preview = '';\n\n    if (_typeof(error) === 'object' && error !== null && typeof error.stack === 'string') {\n      preview = error.stack;\n    } else if (typeof error === 'string') {\n      preview = error;\n    }\n\n    cleaned.push(path);\n    return {\n      inspectable: false,\n      preview_short: '[Exception]',\n      preview_long: preview ? '[Exception: ' + preview + ']' : '[Exception]',\n      name: preview,\n      type: 'unknown'\n    };\n  }\n}\n\nfunction fillInPath(object, data, path, value) {\n  var target = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getInObject)(object, path);\n\n  if (target != null) {\n    if (!target[meta.unserializable]) {\n      delete target[meta.inspectable];\n      delete target[meta.inspected];\n      delete target[meta.name];\n      delete target[meta.preview_long];\n      delete target[meta.preview_short];\n      delete target[meta.readonly];\n      delete target[meta.size];\n      delete target[meta.type];\n    }\n  }\n\n  if (value !== null && data.unserializable.length > 0) {\n    var unserializablePath = data.unserializable[0];\n    var isMatch = unserializablePath.length === path.length;\n\n    for (var i = 0; i < path.length; i++) {\n      if (path[i] !== unserializablePath[i]) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    if (isMatch) {\n      upgradeUnserializable(value, value);\n    }\n  }\n\n  (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.setInObject)(object, path, value);\n}\nfunction hydrate(object, cleaned, unserializable) {\n  cleaned.forEach(function (path) {\n    var length = path.length;\n    var last = path[length - 1];\n    var parent = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getInObject)(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    var value = parent[last];\n\n    if (!value) {\n      return;\n    } else if (value.type === 'infinity') {\n      parent[last] = Infinity;\n    } else if (value.type === 'nan') {\n      parent[last] = NaN;\n    } else if (value.type === 'undefined') {\n      parent[last] = undefined;\n    } else {\n      // Replace the string keys with Symbols so they're non-enumerable.\n      var replaced = {};\n      replaced[meta.inspectable] = !!value.inspectable;\n      replaced[meta.inspected] = false;\n      replaced[meta.name] = value.name;\n      replaced[meta.preview_long] = value.preview_long;\n      replaced[meta.preview_short] = value.preview_short;\n      replaced[meta.size] = value.size;\n      replaced[meta.readonly] = !!value.readonly;\n      replaced[meta.type] = value.type;\n      parent[last] = replaced;\n    }\n  });\n  unserializable.forEach(function (path) {\n    var length = path.length;\n    var last = path[length - 1];\n    var parent = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getInObject)(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    var node = parent[last];\n\n    var replacement = _objectSpread({}, node);\n\n    upgradeUnserializable(replacement, node);\n    parent[last] = replacement;\n  });\n  return object;\n}\n\nfunction upgradeUnserializable(destination, source) {\n  var _Object$definePropert;\n\n  Object.defineProperties(destination, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, meta.inspected, {\n    configurable: true,\n    enumerable: false,\n    value: !!source.inspected\n  }), _defineProperty(_Object$definePropert, meta.name, {\n    configurable: true,\n    enumerable: false,\n    value: source.name\n  }), _defineProperty(_Object$definePropert, meta.preview_long, {\n    configurable: true,\n    enumerable: false,\n    value: source.preview_long\n  }), _defineProperty(_Object$definePropert, meta.preview_short, {\n    configurable: true,\n    enumerable: false,\n    value: source.preview_short\n  }), _defineProperty(_Object$definePropert, meta.size, {\n    configurable: true,\n    enumerable: false,\n    value: source.size\n  }), _defineProperty(_Object$definePropert, meta.readonly, {\n    configurable: true,\n    enumerable: false,\n    value: !!source.readonly\n  }), _defineProperty(_Object$definePropert, meta.type, {\n    configurable: true,\n    enumerable: false,\n    value: source.type\n  }), _defineProperty(_Object$definePropert, meta.unserializable, {\n    configurable: true,\n    enumerable: false,\n    value: !!source.unserializable\n  }), _Object$definePropert));\n  delete destination.inspected;\n  delete destination.name;\n  delete destination.preview_long;\n  delete destination.preview_short;\n  delete destination.size;\n  delete destination.readonly;\n  delete destination.type;\n  delete destination.unserializable;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9oeWRyYXRpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFPQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVJBOztBQVdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BOztBQVNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFTQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFnQkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQVdBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFhQTtBQUNBO0FBRUE7QUFRQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUEvT0E7QUFpUEE7O0FBRUE7QUFRQTs7QUFDQTtBQUNBO0FBUUE7QUFDQTs7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQUVBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2h5ZHJhdGlvbi5qcz8wYjdhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7XG4gIGdldERhdGFUeXBlLFxuICBnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudCxcbiAgZ2V0QWxsRW51bWVyYWJsZUtleXMsXG4gIGdldEluT2JqZWN0LFxuICBmb3JtYXREYXRhRm9yUHJldmlldyxcbiAgc2V0SW5PYmplY3QsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSB7XG4gIERlaHlkcmF0ZWREYXRhLFxuICBJbnNwZWN0ZWRFbGVtZW50UGF0aCxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBtZXRhID0ge1xuICBpbnNwZWN0YWJsZTogKFN5bWJvbCgnaW5zcGVjdGFibGUnKTogc3ltYm9sKSxcbiAgaW5zcGVjdGVkOiAoU3ltYm9sKCdpbnNwZWN0ZWQnKTogc3ltYm9sKSxcbiAgbmFtZTogKFN5bWJvbCgnbmFtZScpOiBzeW1ib2wpLFxuICBwcmV2aWV3X2xvbmc6IChTeW1ib2woJ3ByZXZpZXdfbG9uZycpOiBzeW1ib2wpLFxuICBwcmV2aWV3X3Nob3J0OiAoU3ltYm9sKCdwcmV2aWV3X3Nob3J0Jyk6IHN5bWJvbCksXG4gIHJlYWRvbmx5OiAoU3ltYm9sKCdyZWFkb25seScpOiBzeW1ib2wpLFxuICBzaXplOiAoU3ltYm9sKCdzaXplJyk6IHN5bWJvbCksXG4gIHR5cGU6IChTeW1ib2woJ3R5cGUnKTogc3ltYm9sKSxcbiAgdW5zZXJpYWxpemFibGU6IChTeW1ib2woJ3Vuc2VyaWFsaXphYmxlJyk6IHN5bWJvbCksXG59O1xuXG5leHBvcnQgdHlwZSBEZWh5ZHJhdGVkID0ge1xuICBpbnNwZWN0YWJsZTogYm9vbGVhbixcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgcHJldmlld19sb25nOiBzdHJpbmcgfCBudWxsLFxuICBwcmV2aWV3X3Nob3J0OiBzdHJpbmcgfCBudWxsLFxuICByZWFkb25seT86IGJvb2xlYW4sXG4gIHNpemU/OiBudW1iZXIsXG4gIHR5cGU6IHN0cmluZyxcbn07XG5cbi8vIFR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29tcGxleCBpdGVyYXRhYmxlIG9iamVjdHMgKGUuZy4gTWFwLCBTZXQsIEltbXV0YWJsZUpTKSBuZWVkIHNwZWNpYWwgaGFuZGxpbmcuXG4vLyBUaGVzZSBvYmplY3RzIGNhbid0IGJlIHNlcmlhbGl6ZWQgd2l0aG91dCBsb3NpbmcgdHlwZSBpbmZvcm1hdGlvbixcbi8vIHNvIGEgXCJVbnNlcmlhbGl6YWJsZVwiIHR5cGUgd3JhcHBlciBpcyB1c2VkICh3aXRoIG1ldGEtZGF0YSBrZXlzKSB0byBzZW5kIG5lc3RlZCB2YWx1ZXMtXG4vLyB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCB0eXBlIGFuZCBuYW1lLlxuZXhwb3J0IHR5cGUgVW5zZXJpYWxpemFibGUgPSB7XG4gIG5hbWU6IHN0cmluZyB8IG51bGwsXG4gIHByZXZpZXdfbG9uZzogc3RyaW5nIHwgbnVsbCxcbiAgcHJldmlld19zaG9ydDogc3RyaW5nIHwgbnVsbCxcbiAgcmVhZG9ubHk/OiBib29sZWFuLFxuICBzaXplPzogbnVtYmVyLFxuICB0eXBlOiBzdHJpbmcsXG4gIHVuc2VyaWFsaXphYmxlOiBib29sZWFuLFxuICBbc3RyaW5nIHwgbnVtYmVyXTogYW55LFxufTtcblxuLy8gVGhpcyB0aHJlc2hvbGQgZGV0ZXJtaW5lcyB0aGUgZGVwdGggYXQgd2hpY2ggdGhlIGJyaWRnZSBcImRlaHlkcmF0ZXNcIiBuZXN0ZWQgZGF0YS5cbi8vIERlaHlkcmF0aW9uIG1lYW5zIHRoYXQgd2UgZG9uJ3Qgc2VyaWFsaXplIHRoZSBkYXRhIGZvciBlLmcuIHBvc3RNZXNzYWdlIG9yIHN0cmluZ2lmeSxcbi8vIHVubGVzcyB0aGUgZnJvbnRlbmQgZXhwbGljaXRseSByZXF1ZXN0cyBpdCAoZS5nLiBhIHVzZXIgY2xpY2tzIHRvIGV4cGFuZCBhIHByb3BzIG9iamVjdCkuXG4vL1xuLy8gUmVkdWNpbmcgdGhpcyB0aHJlc2hvbGQgd2lsbCBpbXByb3ZlIHRoZSBzcGVlZCBvZiBpbml0aWFsIGNvbXBvbmVudCBpbnNwZWN0aW9uLFxuLy8gYnV0IG1heSBkZWNyZWFzZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgZXhwYW5kaW5nIG9iamVjdHMvYXJyYXlzIHRvIGluc3BlY3QgZnVydGhlci5cbmNvbnN0IExFVkVMX1RIUkVTSE9MRCA9IDI7XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIGRlaHlkcmF0ZWQgbWV0YWRhdGEgZm9yIGNvbXBsZXggb2JqZWN0IGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVEZWh5ZHJhdGVkKFxuICB0eXBlOiBzdHJpbmcsXG4gIGluc3BlY3RhYmxlOiBib29sZWFuLFxuICBkYXRhOiBPYmplY3QsXG4gIGNsZWFuZWQ6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuKTogRGVoeWRyYXRlZCB7XG4gIGNsZWFuZWQucHVzaChwYXRoKTtcblxuICBjb25zdCBkZWh5ZHJhdGVkOiBEZWh5ZHJhdGVkID0ge1xuICAgIGluc3BlY3RhYmxlLFxuICAgIHR5cGUsXG4gICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgbmFtZTpcbiAgICAgIHR5cGVvZiBkYXRhLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0J1xuICAgICAgICA/ICcnXG4gICAgICAgIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lLFxuICB9O1xuXG4gIGlmICh0eXBlID09PSAnYXJyYXknIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnNpemUgPSBkYXRhLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGRlaHlkcmF0ZWQuc2l6ZSA9IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnaXRlcmF0b3InIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWh5ZHJhdGVkO1xufVxuXG4vKipcbiAqIFN0cmlwIG91dCBjb21wbGV4IGRhdGEgKGluc3RhbmNlcywgZnVuY3Rpb25zLCBhbmQgZGF0YSBuZXN0ZWQgPiBMRVZFTF9USFJFU0hPTEQgbGV2ZWxzIGRlZXApLlxuICogVGhlIHBhdGhzIG9mIHRoZSBzdHJpcHBlZCBvdXQgb2JqZWN0cyBhcmUgYXBwZW5kZWQgdG8gdGhlIGBjbGVhbmVkYCBsaXN0LlxuICogT24gdGhlIG90aGVyIHNpZGUgb2YgdGhlIGJhcnJpZXIsIHRoZSBjbGVhbmVkIGxpc3QgaXMgdXNlZCB0byBcInJlLWh5ZHJhdGVcIiB0aGUgY2xlYW5lZCByZXByZXNlbnRhdGlvbiBpbnRvXG4gKiBhbiBvYmplY3Qgd2l0aCBzeW1ib2xzIGFzIGF0dHJpYnV0ZXMsIHNvIHRoYXQgYSBzYW5pdGl6ZWQgb2JqZWN0IGNhbiBiZSBkaXN0aW5ndWlzaGVkIGZyb20gYSBub3JtYWwgb2JqZWN0LlxuICpcbiAqIElucHV0OiB7XCJzb21lXCI6IHtcImF0dHJcIjogZm4oKX0sIFwib3RoZXJcIjogQW5JbnN0YW5jZX1cbiAqIE91dHB1dDoge1xuICogICBcInNvbWVcIjoge1xuICogICAgIFwiYXR0clwiOiB7XCJuYW1lXCI6IHRoZSBmbi5uYW1lLCB0eXBlOiBcImZ1bmN0aW9uXCJ9XG4gKiAgIH0sXG4gKiAgIFwib3RoZXJcIjoge1xuICogICAgIFwibmFtZVwiOiBcIkFuSW5zdGFuY2VcIixcbiAqICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAqICAgfSxcbiAqIH1cbiAqIGFuZCBjbGVhbmVkID0gW1tcInNvbWVcIiwgXCJhdHRyXCJdLCBbXCJvdGhlclwiXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlaHlkcmF0ZShcbiAgZGF0YTogT2JqZWN0LFxuICBjbGVhbmVkOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PixcbiAgdW5zZXJpYWxpemFibGU6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBpc1BhdGhBbGxvd2VkOiAocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4gYm9vbGVhbixcbiAgbGV2ZWw6IG51bWJlciA9IDAsXG4pOiAkUHJvcGVydHlUeXBlPERlaHlkcmF0ZWREYXRhLCAnZGF0YSc+IHtcbiAgY29uc3QgdHlwZSA9IGdldERhdGFUeXBlKGRhdGEpO1xuXG4gIGxldCBpc1BhdGhBbGxvd2VkQ2hlY2s7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaHRtbF9lbGVtZW50JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhLnRhZ05hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6XG4gICAgICAgICAgdHlwZW9mIGRhdGEubmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhZGF0YS5uYW1lXG4gICAgICAgICAgICA/ICdmdW5jdGlvbidcbiAgICAgICAgICAgIDogZGF0YS5uYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuICAgICAgaWYgKGlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA8PSA1MDAgPyBkYXRhIDogZGF0YS5zbGljZSgwLCA1MDApICsgJy4uLic7XG4gICAgICB9XG5cbiAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICAvLyBSZWFjdCBFbGVtZW50cyBhcmVuJ3QgdmVyeSBpbnNwZWN0b3ItZnJpZW5kbHksXG4gICAgLy8gYW5kIG9mdGVuIGNvbnRhaW4gcHJpdmF0ZSBmaWVsZHMgb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgICBjYXNlICdyZWFjdF9lbGVtZW50JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudChkYXRhKSB8fCAnVW5rbm93bicsXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgLy8gQXJyYXlCdWZmZXJzIGVycm9yIGlmIHlvdSB0cnkgdG8gaW5zcGVjdCB0aGVtLlxuICAgIGNhc2UgJ2FycmF5X2J1ZmZlcic6XG4gICAgY2FzZSAnZGF0YV92aWV3JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiB0eXBlID09PSAnZGF0YV92aWV3JyA/ICdEYXRhVmlldycgOiAnQXJyYXlCdWZmZXInLFxuICAgICAgICBzaXplOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcbiAgICAgIGlmIChsZXZlbCA+PSBMRVZFTF9USFJFU0hPTEQgJiYgIWlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVoeWRyYXRlZCh0eXBlLCB0cnVlLCBkYXRhLCBjbGVhbmVkLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFycjogQXJyYXk8T2JqZWN0PiA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGRlaHlkcmF0ZUtleShcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGksXG4gICAgICAgICAgY2xlYW5lZCxcbiAgICAgICAgICB1bnNlcmlhbGl6YWJsZSxcbiAgICAgICAgICBwYXRoLmNvbmNhdChbaV0pLFxuICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG5cbiAgICBjYXNlICdodG1sX2FsbF9jb2xsZWN0aW9uJzpcbiAgICBjYXNlICd0eXBlZF9hcnJheSc6XG4gICAgY2FzZSAnaXRlcmF0b3InOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcbiAgICAgIGlmIChsZXZlbCA+PSBMRVZFTF9USFJFU0hPTEQgJiYgIWlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVoeWRyYXRlZCh0eXBlLCB0cnVlLCBkYXRhLCBjbGVhbmVkLCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHVuc2VyaWFsaXphYmxlVmFsdWU6IFVuc2VyaWFsaXphYmxlID0ge1xuICAgICAgICAgIHVuc2VyaWFsaXphYmxlOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgc2l6ZTogdHlwZSA9PT0gJ3R5cGVkX2FycmF5JyA/IGRhdGEubGVuZ3RoIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICAgIG5hbWU6XG4gICAgICAgICAgICB0eXBlb2YgZGF0YS5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGRhdGEuY29uc3RydWN0b3IubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCdcbiAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICA6IGRhdGEuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUUklDS1lcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFsuLi5zcHJlYWRdIHN5bnRheCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAvLyBUaGlzIHByb2plY3QgdXNlcyBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1zcHJlYWQgaW4gXCJsb29zZVwiIG1vZGUgd2hpY2ggb25seSB3b3JrcyB3aXRoIEFycmF5IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgKGUuZy4gdHlwZWQgYXJyYXlzLCBTZXRzKSB3aWxsIG5vdCBzcHJlYWQgY29ycmVjdGx5LlxuICAgICAgICBBcnJheS5mcm9tKGRhdGEpLmZvckVhY2goXG4gICAgICAgICAgKGl0ZW0sIGkpID0+XG4gICAgICAgICAgICAodW5zZXJpYWxpemFibGVWYWx1ZVtpXSA9IGRlaHlkcmF0ZShcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgY2xlYW5lZCxcbiAgICAgICAgICAgICAgdW5zZXJpYWxpemFibGUsXG4gICAgICAgICAgICAgIHBhdGguY29uY2F0KFtpXSksXG4gICAgICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA/IDEgOiBsZXZlbCArIDEsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgKTtcblxuICAgICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuXG4gICAgICAgIHJldHVybiB1bnNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb3BhcXVlX2l0ZXJhdG9yJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhW1N5bWJvbC50b1N0cmluZ1RhZ10sXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvYmplY3Q6IHtcbiAgICAgICAgICBbc3RyaW5nXTogJFByb3BlcnR5VHlwZTxEZWh5ZHJhdGVkRGF0YSwgJ2RhdGEnPixcbiAgICAgICAgfSA9IHt9O1xuICAgICAgICBnZXRBbGxFbnVtZXJhYmxlS2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgIG9iamVjdFtuYW1lXSA9IGRlaHlkcmF0ZUtleShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjbGVhbmVkLFxuICAgICAgICAgICAgdW5zZXJpYWxpemFibGUsXG4gICAgICAgICAgICBwYXRoLmNvbmNhdChbbmFtZV0pLFxuICAgICAgICAgICAgaXNQYXRoQWxsb3dlZCxcbiAgICAgICAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA/IDEgOiBsZXZlbCArIDEsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICBjYXNlICdjbGFzc19pbnN0YW5jZSc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlOiBVbnNlcmlhbGl6YWJsZSA9IHtcbiAgICAgICAgdW5zZXJpYWxpemFibGU6IHRydWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6XG4gICAgICAgICAgdHlwZW9mIGRhdGEuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICB0eXBlb2YgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICB9O1xuXG4gICAgICBnZXRBbGxFbnVtZXJhYmxlS2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFsdWVba2V5QXNTdHJpbmddID0gZGVoeWRyYXRlKFxuICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICBjbGVhbmVkLFxuICAgICAgICAgIHVuc2VyaWFsaXphYmxlLFxuICAgICAgICAgIHBhdGguY29uY2F0KFtrZXlBc1N0cmluZ10pLFxuICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBjYXNlICdpbmZpbml0eSc6XG4gICAgY2FzZSAnbmFuJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgLy8gU29tZSB2YWx1ZXMgYXJlIGxvc3N5IHdoZW4gc2VudCB0aHJvdWdoIGEgV2ViU29ja2V0LlxuICAgICAgLy8gV2UgZGVoeWRyYXRlK3JlaHlkcmF0ZSB0aGVtIHRvIHByZXNlcnZlIHRoZWlyIHR5cGUuXG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge3R5cGV9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlaHlkcmF0ZUtleShcbiAgcGFyZW50OiBPYmplY3QsXG4gIGtleTogbnVtYmVyIHwgc3RyaW5nIHwgc3ltYm9sLFxuICBjbGVhbmVkOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PixcbiAgdW5zZXJpYWxpemFibGU6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBpc1BhdGhBbGxvd2VkOiAocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4gYm9vbGVhbixcbiAgbGV2ZWw6IG51bWJlciA9IDAsXG4pOiAkUHJvcGVydHlUeXBlPERlaHlkcmF0ZWREYXRhLCAnZGF0YSc+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVoeWRyYXRlKFxuICAgICAgcGFyZW50W2tleV0sXG4gICAgICBjbGVhbmVkLFxuICAgICAgdW5zZXJpYWxpemFibGUsXG4gICAgICBwYXRoLFxuICAgICAgaXNQYXRoQWxsb3dlZCxcbiAgICAgIGxldmVsLFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbGV0IHByZXZpZXcgPSAnJztcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIGVycm9yLnN0YWNrID09PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgcHJldmlldyA9IGVycm9yLnN0YWNrO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgcHJldmlldyA9IGVycm9yO1xuICAgIH1cbiAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgIHByZXZpZXdfc2hvcnQ6ICdbRXhjZXB0aW9uXScsXG4gICAgICBwcmV2aWV3X2xvbmc6IHByZXZpZXcgPyAnW0V4Y2VwdGlvbjogJyArIHByZXZpZXcgKyAnXScgOiAnW0V4Y2VwdGlvbl0nLFxuICAgICAgbmFtZTogcHJldmlldyxcbiAgICAgIHR5cGU6ICd1bmtub3duJyxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsSW5QYXRoKFxuICBvYmplY3Q6IE9iamVjdCxcbiAgZGF0YTogRGVoeWRyYXRlZERhdGEsXG4gIHBhdGg6IEluc3BlY3RlZEVsZW1lbnRQYXRoLFxuICB2YWx1ZTogYW55LFxuKSB7XG4gIGNvbnN0IHRhcmdldCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aCk7XG4gIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgIGlmICghdGFyZ2V0W21ldGEudW5zZXJpYWxpemFibGVdKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEuaW5zcGVjdGFibGVdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLmluc3BlY3RlZF07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEubmFtZV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEucHJldmlld19sb25nXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5wcmV2aWV3X3Nob3J0XTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5yZWFkb25seV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEuc2l6ZV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEudHlwZV07XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIGRhdGEudW5zZXJpYWxpemFibGUubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHVuc2VyaWFsaXphYmxlUGF0aCA9IGRhdGEudW5zZXJpYWxpemFibGVbMF07XG4gICAgbGV0IGlzTWF0Y2ggPSB1bnNlcmlhbGl6YWJsZVBhdGgubGVuZ3RoID09PSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldICE9PSB1bnNlcmlhbGl6YWJsZVBhdGhbaV0pIHtcbiAgICAgICAgaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZSh2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldEluT2JqZWN0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZShcbiAgb2JqZWN0OiBhbnksXG4gIGNsZWFuZWQ6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICB1bnNlcmlhbGl6YWJsZTogQXJyYXk8QXJyYXk8c3RyaW5nIHwgbnVtYmVyPj4sXG4pOiBPYmplY3Qge1xuICBjbGVhbmVkLmZvckVhY2goKHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4pID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQuaGFzT3duUHJvcGVydHkobGFzdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHBhcmVudFtsYXN0XTtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICdpbmZpbml0eScpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gJ25hbicpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IE5hTjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxhY2UgdGhlIHN0cmluZyBrZXlzIHdpdGggU3ltYm9scyBzbyB0aGV5J3JlIG5vbi1lbnVtZXJhYmxlLlxuICAgICAgY29uc3QgcmVwbGFjZWQ6IHtba2V5OiBzeW1ib2xdOiBib29sZWFuIHwgc3RyaW5nfSA9IHt9O1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0YWJsZV0gPSAhIXZhbHVlLmluc3BlY3RhYmxlO1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0ZWRdID0gZmFsc2U7XG4gICAgICByZXBsYWNlZFttZXRhLm5hbWVdID0gdmFsdWUubmFtZTtcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19sb25nXSA9IHZhbHVlLnByZXZpZXdfbG9uZztcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19zaG9ydF0gPSB2YWx1ZS5wcmV2aWV3X3Nob3J0O1xuICAgICAgcmVwbGFjZWRbbWV0YS5zaXplXSA9IHZhbHVlLnNpemU7XG4gICAgICByZXBsYWNlZFttZXRhLnJlYWRvbmx5XSA9ICEhdmFsdWUucmVhZG9ubHk7XG4gICAgICByZXBsYWNlZFttZXRhLnR5cGVdID0gdmFsdWUudHlwZTtcblxuICAgICAgcGFyZW50W2xhc3RdID0gcmVwbGFjZWQ7XG4gICAgfVxuICB9KTtcbiAgdW5zZXJpYWxpemFibGUuZm9yRWFjaCgocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5oYXNPd25Qcm9wZXJ0eShsYXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBwYXJlbnRbbGFzdF07XG5cbiAgICBjb25zdCByZXBsYWNlbWVudCA9IHtcbiAgICAgIC4uLm5vZGUsXG4gICAgfTtcblxuICAgIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShyZXBsYWNlbWVudCwgbm9kZSk7XG5cbiAgICBwYXJlbnRbbGFzdF0gPSByZXBsYWNlbWVudDtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShkZXN0aW5hdGlvbjogT2JqZWN0LCBzb3VyY2U6IE9iamVjdCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZXN0aW5hdGlvbiwge1xuICAgIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb21wdXRlZC1wcm9wXVxuICAgIFttZXRhLmluc3BlY3RlZF06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICEhc291cmNlLmluc3BlY3RlZCxcbiAgICB9LFxuICAgIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb21wdXRlZC1wcm9wXVxuICAgIFttZXRhLm5hbWVdOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2UubmFtZSxcbiAgICB9LFxuICAgIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb21wdXRlZC1wcm9wXVxuICAgIFttZXRhLnByZXZpZXdfbG9uZ106IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZS5wcmV2aWV3X2xvbmcsXG4gICAgfSxcbiAgICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29tcHV0ZWQtcHJvcF1cbiAgICBbbWV0YS5wcmV2aWV3X3Nob3J0XToge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlLnByZXZpZXdfc2hvcnQsXG4gICAgfSxcbiAgICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29tcHV0ZWQtcHJvcF1cbiAgICBbbWV0YS5zaXplXToge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlLnNpemUsXG4gICAgfSxcbiAgICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29tcHV0ZWQtcHJvcF1cbiAgICBbbWV0YS5yZWFkb25seV06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICEhc291cmNlLnJlYWRvbmx5LFxuICAgIH0sXG4gICAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbXB1dGVkLXByb3BdXG4gICAgW21ldGEudHlwZV06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZS50eXBlLFxuICAgIH0sXG4gICAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbXB1dGVkLXByb3BdXG4gICAgW21ldGEudW5zZXJpYWxpemFibGVdOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiAhIXNvdXJjZS51bnNlcmlhbGl6YWJsZSxcbiAgICB9LFxuICB9KTtcblxuICBkZWxldGUgZGVzdGluYXRpb24uaW5zcGVjdGVkO1xuICBkZWxldGUgZGVzdGluYXRpb24ubmFtZTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfbG9uZztcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfc2hvcnQ7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5zaXplO1xuICBkZWxldGUgZGVzdGluYXRpb24ucmVhZG9ubHk7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi50eXBlO1xuICBkZWxldGUgZGVzdGluYXRpb24udW5zZXJpYWxpemFibGU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/hydration.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/isArray.js":
/*!***********************************************!*\
  !*** ../react-devtools-shared/src/isArray.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar isArray = Array.isArray;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9pc0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9pc0FycmF5LmpzP2E0OTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/isArray.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/storage.js":
/*!***********************************************!*\
  !*** ../react-devtools-shared/src/storage.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"localStorageGetItem\": () => (/* binding */ localStorageGetItem),\n/* harmony export */   \"localStorageRemoveItem\": () => (/* binding */ localStorageRemoveItem),\n/* harmony export */   \"localStorageSetItem\": () => (/* binding */ localStorageSetItem),\n/* harmony export */   \"sessionStorageGetItem\": () => (/* binding */ sessionStorageGetItem),\n/* harmony export */   \"sessionStorageRemoveItem\": () => (/* binding */ sessionStorageRemoveItem),\n/* harmony export */   \"sessionStorageSetItem\": () => (/* binding */ sessionStorageSetItem)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction localStorageGetItem(key) {\n  try {\n    return localStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction localStorageRemoveItem(key) {\n  try {\n    localStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction localStorageSetItem(key, value) {\n  try {\n    return localStorage.setItem(key, value);\n  } catch (error) {}\n}\nfunction sessionStorageGetItem(key) {\n  try {\n    return sessionStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction sessionStorageRemoveItem(key) {\n  try {\n    sessionStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction sessionStorageSetItem(key, value) {\n  try {\n    return sessionStorage.setItem(key, value);\n  } catch (error) {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zdG9yYWdlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUmVhY3REZXZUb29sc0JhY2tlbmQvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zdG9yYWdlLmpzPzk0ZTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsU3RvcmFnZUdldEl0ZW0oa2V5OiBzdHJpbmcpOiBhbnkge1xuICB0cnkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFN0b3JhZ2VSZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFN0b3JhZ2VTZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlR2V0SXRlbShrZXk6IHN0cmluZyk6IGFueSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlU2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IHZvaWQge1xuICB0cnkge1xuICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/storage.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/utils.js":
/*!*********************************************!*\
  !*** ../react-devtools-shared/src/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"alphaSortKeys\": () => (/* binding */ alphaSortKeys),\n/* harmony export */   \"backendToFrontendSerializedElementMapper\": () => (/* binding */ backendToFrontendSerializedElementMapper),\n/* harmony export */   \"deletePathInObject\": () => (/* binding */ deletePathInObject),\n/* harmony export */   \"filterOutLocationComponentFilters\": () => (/* binding */ filterOutLocationComponentFilters),\n/* harmony export */   \"formatDataForPreview\": () => (/* binding */ formatDataForPreview),\n/* harmony export */   \"getAllEnumerableKeys\": () => (/* binding */ getAllEnumerableKeys),\n/* harmony export */   \"getDataType\": () => (/* binding */ getDataType),\n/* harmony export */   \"getDefaultComponentFilters\": () => (/* binding */ getDefaultComponentFilters),\n/* harmony export */   \"getDefaultOpenInEditorURL\": () => (/* binding */ getDefaultOpenInEditorURL),\n/* harmony export */   \"getDisplayName\": () => (/* binding */ getDisplayName),\n/* harmony export */   \"getDisplayNameForReactElement\": () => (/* binding */ getDisplayNameForReactElement),\n/* harmony export */   \"getIfReloadedAndProfiling\": () => (/* binding */ getIfReloadedAndProfiling),\n/* harmony export */   \"getInObject\": () => (/* binding */ getInObject),\n/* harmony export */   \"getIsReloadAndProfileSupported\": () => (/* binding */ getIsReloadAndProfileSupported),\n/* harmony export */   \"getOpenInEditorURL\": () => (/* binding */ getOpenInEditorURL),\n/* harmony export */   \"getProfilingSettings\": () => (/* binding */ getProfilingSettings),\n/* harmony export */   \"getSavedComponentFilters\": () => (/* binding */ getSavedComponentFilters),\n/* harmony export */   \"getUID\": () => (/* binding */ getUID),\n/* harmony export */   \"getWrappedDisplayName\": () => (/* binding */ getWrappedDisplayName),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"normalizeUrl\": () => (/* binding */ normalizeUrl),\n/* harmony export */   \"onReloadAndProfile\": () => (/* binding */ onReloadAndProfile),\n/* harmony export */   \"onReloadAndProfileFlagsReset\": () => (/* binding */ onReloadAndProfileFlagsReset),\n/* harmony export */   \"parseElementDisplayNameFromBackend\": () => (/* binding */ parseElementDisplayNameFromBackend),\n/* harmony export */   \"printOperationsArray\": () => (/* binding */ printOperationsArray),\n/* harmony export */   \"renamePathInObject\": () => (/* binding */ renamePathInObject),\n/* harmony export */   \"setInObject\": () => (/* binding */ setInObject),\n/* harmony export */   \"setSavedComponentFilters\": () => (/* binding */ setSavedComponentFilters),\n/* harmony export */   \"shallowDiffers\": () => (/* binding */ shallowDiffers),\n/* harmony export */   \"utfDecodeStringWithRanges\": () => (/* binding */ utfDecodeStringWithRanges),\n/* harmony export */   \"utfEncodeString\": () => (/* binding */ utfEncodeString)\n/* harmony export */ });\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ \"../../node_modules/lru-cache/index.js\");\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/ReactSymbols */ \"../shared/ReactSymbols.js\");\n/* harmony import */ var shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shared/ReactFeatureFlags */ \"../shared/ReactFeatureFlags.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var _frontend_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-devtools-shared/src/frontend/types */ \"../react-devtools-shared/src/frontend/types.js\");\n/* harmony import */ var react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-devtools-shared/src/storage */ \"../react-devtools-shared/src/storage.js\");\n/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hydration */ \"../react-devtools-shared/src/hydration.js\");\n/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isArray */ \"../react-devtools-shared/src/isArray.js\");\n/* harmony import */ var _backend_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./backend/utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n // $FlowFixMe[method-unbinding]\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.\n// Try to reuse the already encoded strings.\n\nvar encodedStringCache = new (lru_cache__WEBPACK_IMPORTED_MODULE_0___default())({\n  max: 1000\n});\nfunction alphaSortKeys(a, b) {\n  if (a.toString() > b.toString()) {\n    return 1;\n  } else if (b.toString() > a.toString()) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nfunction getAllEnumerableKeys(obj) {\n  var keys = new Set();\n  var current = obj;\n\n  var _loop = function _loop() {\n    var currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));\n    var descriptors = Object.getOwnPropertyDescriptors(current);\n    currentKeys.forEach(function (key) {\n      // $FlowFixMe[incompatible-type]: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n      if (descriptors[key].enumerable) {\n        keys.add(key);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  };\n\n  while (current != null) {\n    _loop();\n  }\n\n  return keys;\n} // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37\n\nfunction getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {\n  var displayName = outerType === null || outerType === void 0 ? void 0 : outerType.displayName;\n  return displayName || \"\".concat(wrapperName, \"(\").concat(getDisplayName(innerType, fallbackName), \")\");\n}\nfunction getDisplayName(type) {\n  var fallbackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Anonymous';\n  var nameFromCache = cachedDisplayNames.get(type);\n\n  if (nameFromCache != null) {\n    return nameFromCache;\n  }\n\n  var displayName = fallbackName; // The displayName property is not guaranteed to be a string.\n  // It's only safe to use for our purposes if it's a string.\n  // github.com/facebook/react-devtools/issues/803\n\n  if (typeof type.displayName === 'string') {\n    displayName = type.displayName;\n  } else if (typeof type.name === 'string' && type.name !== '') {\n    displayName = type.name;\n  }\n\n  cachedDisplayNames.set(type, displayName);\n  return displayName;\n}\nvar uidCounter = 0;\nfunction getUID() {\n  return ++uidCounter;\n}\nfunction utfDecodeStringWithRanges(array, left, right) {\n  var string = '';\n\n  for (var i = left; i <= right; i++) {\n    string += String.fromCodePoint(array[i]);\n  }\n\n  return string;\n}\n\nfunction surrogatePairToCodePoint(charCode1, charCode2) {\n  return ((charCode1 & 0x3ff) << 10) + (charCode2 & 0x3ff) + 0x10000;\n} // Credit for this encoding approach goes to Tim Down:\n// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript\n\n\nfunction utfEncodeString(string) {\n  var cached = encodedStringCache.get(string);\n\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  var encoded = [];\n  var i = 0;\n  var charCode;\n\n  while (i < string.length) {\n    charCode = string.charCodeAt(i); // Handle multibyte unicode characters (like emoji).\n\n    if ((charCode & 0xf800) === 0xd800) {\n      encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));\n    } else {\n      encoded.push(charCode);\n    }\n\n    ++i;\n  }\n\n  encodedStringCache.set(string, encoded);\n  return encoded;\n}\nfunction printOperationsArray(operations) {\n  // The first two values are always rendererID and rootID\n  var rendererID = operations[0];\n  var rootID = operations[1];\n  var logs = [\"operations for renderer:\".concat(rendererID, \" and root:\").concat(rootID)];\n  var i = 2; // Reassemble the string table.\n\n  var stringTable = [null // ID = 0 corresponds to the null string.\n  ];\n  var stringTableSize = operations[i++];\n  var stringTableEnd = i + stringTableSize;\n\n  while (i < stringTableEnd) {\n    var nextLength = operations[i++];\n    var nextString = utfDecodeStringWithRanges(operations, i, i + nextLength - 1);\n    stringTable.push(nextString);\n    i += nextLength;\n  }\n\n  while (i < operations.length) {\n    var operation = operations[i];\n\n    switch (operation) {\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD:\n        {\n          var _id = operations[i + 1];\n          var type = operations[i + 2];\n          i += 3;\n\n          if (type === _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeRoot) {\n            logs.push(\"Add new root node \".concat(_id));\n            i++; // isStrictModeCompliant\n\n            i++; // supportsProfiling\n\n            i++; // supportsStrictMode\n\n            i++; // hasOwnerMetadata\n          } else {\n            var parentID = operations[i];\n            i++;\n            i++; // ownerID\n\n            var displayNameStringID = operations[i];\n            var displayName = stringTable[displayNameStringID];\n            i++;\n            i++; // key\n\n            logs.push(\"Add node \".concat(_id, \" (\").concat(displayName || 'null', \") as child of \").concat(parentID));\n          }\n\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE:\n        {\n          var removeLength = operations[i + 1];\n          i += 2;\n\n          for (var removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n            var _id2 = operations[i];\n            i += 1;\n            logs.push(\"Remove node \".concat(_id2));\n          }\n\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE_ROOT:\n        {\n          i += 1;\n          logs.push(\"Remove root \".concat(rootID));\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_SET_SUBTREE_MODE:\n        {\n          var _id3 = operations[i + 1];\n          var mode = operations[i + 1];\n          i += 3;\n          logs.push(\"Mode \".concat(mode, \" set for subtree with root \").concat(_id3));\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REORDER_CHILDREN:\n        {\n          var _id4 = operations[i + 1];\n          var numChildren = operations[i + 2];\n          i += 3;\n          var children = operations.slice(i, i + numChildren);\n          i += numChildren;\n          logs.push(\"Re-order node \".concat(_id4, \" children \").concat(children.join(',')));\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_TREE_BASE_DURATION:\n        // Base duration updates are only sent while profiling is in progress.\n        // We can ignore them at this point.\n        // The profiler UI uses them lazily in order to generate the tree.\n        i += 3;\n        break;\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:\n        var id = operations[i + 1];\n        var numErrors = operations[i + 2];\n        var numWarnings = operations[i + 3];\n        i += 4;\n        logs.push(\"Node \".concat(id, \" has \").concat(numErrors, \" errors and \").concat(numWarnings, \" warnings\"));\n        break;\n\n      default:\n        throw Error(\"Unsupported Bridge operation \\\"\".concat(operation, \"\\\"\"));\n    }\n  }\n\n  console.log(logs.join('\\n  '));\n}\nfunction getDefaultComponentFilters() {\n  return [{\n    type: _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ComponentFilterElementType,\n    value: _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeHostComponent,\n    isEnabled: true\n  }];\n}\nfunction getSavedComponentFilters() {\n  try {\n    var raw = (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY);\n\n    if (raw != null) {\n      var parsedFilters = JSON.parse(raw);\n      return filterOutLocationComponentFilters(parsedFilters);\n    }\n  } catch (error) {}\n\n  return getDefaultComponentFilters();\n}\nfunction setSavedComponentFilters(componentFilters) {\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY, JSON.stringify(filterOutLocationComponentFilters(componentFilters)));\n} // Following __debugSource removal from Fiber, the new approach for finding the source location\n// of a component, represented by the Fiber, is based on lazily generating and parsing component stack frames\n// To find the original location, React DevTools will perform symbolication, source maps are required for that.\n// In order to start filtering Fibers, we need to find location for all of them, which can't be done lazily.\n// Eager symbolication can become quite expensive for large applications.\n\nfunction filterOutLocationComponentFilters(componentFilters) {\n  // This is just an additional check to preserve the previous state\n  // Filters can be stored on the backend side or in user land (in a window object)\n  if (!Array.isArray(componentFilters)) {\n    return componentFilters;\n  }\n\n  return componentFilters.filter(function (f) {\n    return f.type !== _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ComponentFilterLocation;\n  });\n}\nfunction getDefaultOpenInEditorURL() {\n  return typeof process.env.EDITOR_URL === 'string' ? process.env.EDITOR_URL : '';\n}\nfunction getOpenInEditorURL() {\n  try {\n    var raw = (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_OPEN_IN_EDITOR_URL);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultOpenInEditorURL();\n}\nfunction parseElementDisplayNameFromBackend(displayName, type) {\n  if (displayName === null) {\n    return {\n      formattedDisplayName: null,\n      hocDisplayNames: null,\n      compiledWithForget: false\n    };\n  }\n\n  if (displayName.startsWith('Forget(')) {\n    var displayNameWithoutForgetWrapper = displayName.slice(7, displayName.length - 1);\n\n    var _parseElementDisplayN = parseElementDisplayNameFromBackend(displayNameWithoutForgetWrapper, type),\n        formattedDisplayName = _parseElementDisplayN.formattedDisplayName,\n        _hocDisplayNames = _parseElementDisplayN.hocDisplayNames;\n\n    return {\n      formattedDisplayName: formattedDisplayName,\n      hocDisplayNames: _hocDisplayNames,\n      compiledWithForget: true\n    };\n  }\n\n  var hocDisplayNames = null;\n\n  switch (type) {\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeClass:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeForwardRef:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeFunction:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeMemo:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeVirtual:\n      if (displayName.indexOf('(') >= 0) {\n        var matches = displayName.match(/[^()]+/g);\n\n        if (matches != null) {\n          // $FlowFixMe[incompatible-type]\n          displayName = matches.pop();\n          hocDisplayNames = matches;\n        }\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  return {\n    // $FlowFixMe[incompatible-return]\n    formattedDisplayName: displayName,\n    hocDisplayNames: hocDisplayNames,\n    compiledWithForget: false\n  };\n} // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction getInObject(object, path) {\n  return path.reduce(function (reduced, attr) {\n    if (reduced) {\n      if (hasOwnProperty.call(reduced, attr)) {\n        return reduced[attr];\n      }\n\n      if (typeof reduced[Symbol.iterator] === 'function') {\n        // Convert iterable to array and return array[index]\n        //\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        return Array.from(reduced)[attr];\n      }\n    }\n\n    return null;\n  }, object);\n}\nfunction deletePathInObject(object, path) {\n  var length = path.length;\n  var last = path[length - 1];\n\n  if (object != null) {\n    var parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(parent)) {\n        parent.splice(last, 1);\n      } else {\n        delete parent[last];\n      }\n    }\n  }\n}\nfunction renamePathInObject(object, oldPath, newPath) {\n  var length = oldPath.length;\n\n  if (object != null) {\n    var parent = getInObject(object, oldPath.slice(0, length - 1));\n\n    if (parent) {\n      var lastOld = oldPath[length - 1];\n      var lastNew = newPath[length - 1];\n      parent[lastNew] = parent[lastOld];\n\n      if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(parent)) {\n        parent.splice(lastOld, 1);\n      } else {\n        delete parent[lastOld];\n      }\n    }\n  }\n}\nfunction setInObject(object, path, value) {\n  var length = path.length;\n  var last = path[length - 1];\n\n  if (object != null) {\n    var parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      parent[last] = value;\n    }\n  }\n}\n\n/**\n * Get a enhanced/artificial type string based on the object instance\n */\nfunction getDataType(data) {\n  if (data === null) {\n    return 'null';\n  } else if (data === undefined) {\n    return 'undefined';\n  }\n\n  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {\n    return 'html_element';\n  }\n\n  var type = _typeof(data);\n\n  switch (type) {\n    case 'bigint':\n      return 'bigint';\n\n    case 'boolean':\n      return 'boolean';\n\n    case 'function':\n      return 'function';\n\n    case 'number':\n      if (Number.isNaN(data)) {\n        return 'nan';\n      } else if (!Number.isFinite(data)) {\n        return 'infinity';\n      } else {\n        return 'number';\n      }\n\n    case 'object':\n      if (data.$$typeof === shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_ELEMENT_TYPE || data.$$typeof === shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LEGACY_ELEMENT_TYPE) {\n        return 'react_element';\n      }\n\n      if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(data)) {\n        return 'array';\n      } else if (ArrayBuffer.isView(data)) {\n        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';\n      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {\n        // HACK This ArrayBuffer check is gross; is there a better way?\n        // We could try to create a new DataView with the value.\n        // If it doesn't error, we know it's an ArrayBuffer,\n        // but this seems kind of awkward and expensive.\n        return 'array_buffer';\n      } else if (typeof data[Symbol.iterator] === 'function') {\n        var iterator = data[Symbol.iterator]();\n\n        if (!iterator) {// Proxies might break assumptoins about iterators.\n          // See github.com/facebook/react/issues/21654\n        } else {\n          return iterator === data ? 'opaque_iterator' : 'iterator';\n        }\n      } else if (data.constructor && data.constructor.name === 'RegExp') {\n        return 'regexp';\n      } else {\n        // $FlowFixMe[method-unbinding]\n        var toStringValue = Object.prototype.toString.call(data);\n\n        if (toStringValue === '[object Date]') {\n          return 'date';\n        } else if (toStringValue === '[object HTMLAllCollection]') {\n          return 'html_all_collection';\n        }\n      }\n\n      if (!isPlainObject(data)) {\n        return 'class_instance';\n      }\n\n      return 'object';\n\n    case 'string':\n      return 'string';\n\n    case 'symbol':\n      return 'symbol';\n\n    case 'undefined':\n      if ( // $FlowFixMe[method-unbinding]\n      Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {\n        return 'html_all_collection';\n      }\n\n      return 'undefined';\n\n    default:\n      return 'unknown';\n  }\n} // Fork of packages/react-is/src/ReactIs.js:30, but with legacy element type\n// Which has been changed in https://github.com/facebook/react/pull/28813\n\nfunction typeOfWithLegacyElementSymbol(object) {\n  if (_typeof(object) === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_ELEMENT_TYPE:\n      case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LEGACY_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FRAGMENT_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROFILER_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_STRICT_MODE_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_LIST_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_VIEW_TRANSITION_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONTEXT_TYPE:\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FORWARD_REF_TYPE:\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LAZY_TYPE:\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_MEMO_TYPE:\n                return $$typeofType;\n\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONSUMER_TYPE:\n                if (shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_2__.enableRenderableContext) {\n                  return $$typeofType;\n                }\n\n              // Fall through\n\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROVIDER_TYPE:\n                if (!shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_2__.enableRenderableContext) {\n                  return $$typeofType;\n                }\n\n              // Fall through\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\n\nfunction getDisplayNameForReactElement(element) {\n  var elementType = typeOfWithLegacyElementSymbol(element);\n\n  switch (elementType) {\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONSUMER_TYPE:\n      return 'ContextConsumer';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROVIDER_TYPE:\n      return 'ContextProvider';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONTEXT_TYPE:\n      return 'Context';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FORWARD_REF_TYPE:\n      return 'ForwardRef';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LAZY_TYPE:\n      return 'Lazy';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_MEMO_TYPE:\n      return 'Memo';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_VIEW_TRANSITION_TYPE:\n      return 'ViewTransition';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_TRACING_MARKER_TYPE:\n      return 'TracingMarker';\n\n    default:\n      var type = element.type;\n\n      if (typeof type === 'string') {\n        return type;\n      } else if (typeof type === 'function') {\n        return getDisplayName(type, 'Anonymous');\n      } else if (type != null) {\n        return 'NotImplementedInDevtools';\n      } else {\n        return 'Element';\n      }\n\n  }\n}\nvar MAX_PREVIEW_STRING_LENGTH = 50;\n\nfunction truncateForDisplay(string) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;\n\n  if (string.length > length) {\n    return string.slice(0, length) + '…';\n  } else {\n    return string;\n  }\n} // Attempts to mimic Chrome's inline preview for values.\n// For example, the following value...\n//   {\n//      foo: 123,\n//      bar: \"abc\",\n//      baz: [true, false],\n//      qux: { ab: 1, cd: 2 }\n//   };\n//\n// Would show a preview of...\n//   {foo: 123, bar: \"abc\", baz: Array(2), qux: {…}}\n//\n// And the following value...\n//   [\n//     123,\n//     \"abc\",\n//     [true, false],\n//     { foo: 123, bar: \"abc\" }\n//   ];\n//\n// Would show a preview of...\n//   [123, \"abc\", Array(2), {…}]\n\n\nfunction formatDataForPreview(data, showFormattedValue) {\n  if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__.meta.type)) {\n    return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__.meta.preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_6__.meta.preview_short];\n  }\n\n  var type = getDataType(data);\n\n  switch (type) {\n    case 'html_element':\n      return \"<\".concat(truncateForDisplay(data.tagName.toLowerCase()), \" />\");\n\n    case 'function':\n      if (typeof data.name === 'function' || data.name === '') {\n        return '() => {}';\n      }\n\n      return \"\".concat(truncateForDisplay(data.name), \"() {}\");\n\n    case 'string':\n      return \"\\\"\".concat(data, \"\\\"\");\n\n    case 'bigint':\n      return truncateForDisplay(data.toString() + 'n');\n\n    case 'regexp':\n      return truncateForDisplay(data.toString());\n\n    case 'symbol':\n      return truncateForDisplay(data.toString());\n\n    case 'react_element':\n      return \"<\".concat(truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown'), \" />\");\n\n    case 'array_buffer':\n      return \"ArrayBuffer(\".concat(data.byteLength, \")\");\n\n    case 'data_view':\n      return \"DataView(\".concat(data.buffer.byteLength, \")\");\n\n    case 'array':\n      if (showFormattedValue) {\n        var formatted = '';\n\n        for (var i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += formatDataForPreview(data[i], false);\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"[\".concat(truncateForDisplay(formatted), \"]\");\n      } else {\n        var length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__.meta.size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__.meta.size] : data.length;\n        return \"Array(\".concat(length, \")\");\n      }\n\n    case 'typed_array':\n      var shortName = \"\".concat(data.constructor.name, \"(\").concat(data.length, \")\");\n\n      if (showFormattedValue) {\n        var _formatted = '';\n\n        for (var _i = 0; _i < data.length; _i++) {\n          if (_i > 0) {\n            _formatted += ', ';\n          }\n\n          _formatted += data[_i];\n\n          if (_formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"\".concat(shortName, \" [\").concat(truncateForDisplay(_formatted), \"]\");\n      } else {\n        return shortName;\n      }\n\n    case 'iterator':\n      var name = data.constructor.name;\n\n      if (showFormattedValue) {\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        var array = Array.from(data);\n        var _formatted2 = '';\n\n        for (var _i2 = 0; _i2 < array.length; _i2++) {\n          var entryOrEntries = array[_i2];\n\n          if (_i2 > 0) {\n            _formatted2 += ', ';\n          } // TRICKY\n          // Browsers display Maps and Sets differently.\n          // To mimic their behavior, detect if we've been given an entries tuple.\n          //   Map(2) {\"abc\" => 123, \"def\" => 123}\n          //   Set(2) {\"abc\", 123}\n\n\n          if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(entryOrEntries)) {\n            var key = formatDataForPreview(entryOrEntries[0], true);\n            var value = formatDataForPreview(entryOrEntries[1], false);\n            _formatted2 += \"\".concat(key, \" => \").concat(value);\n          } else {\n            _formatted2 += formatDataForPreview(entryOrEntries, false);\n          }\n\n          if (_formatted2.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"\".concat(name, \"(\").concat(data.size, \") {\").concat(truncateForDisplay(_formatted2), \"}\");\n      } else {\n        return \"\".concat(name, \"(\").concat(data.size, \")\");\n      }\n\n    case 'opaque_iterator':\n      {\n        return data[Symbol.toStringTag];\n      }\n\n    case 'date':\n      return data.toString();\n\n    case 'class_instance':\n      return data.constructor.name;\n\n    case 'object':\n      if (showFormattedValue) {\n        var keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);\n        var _formatted3 = '';\n\n        for (var _i3 = 0; _i3 < keys.length; _i3++) {\n          var _key = keys[_i3];\n\n          if (_i3 > 0) {\n            _formatted3 += ', ';\n          }\n\n          _formatted3 += \"\".concat(_key.toString(), \": \").concat(formatDataForPreview(data[_key], false));\n\n          if (_formatted3.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return \"{\".concat(truncateForDisplay(_formatted3), \"}\");\n      } else {\n        return '{…}';\n      }\n\n    case 'boolean':\n    case 'number':\n    case 'infinity':\n    case 'nan':\n    case 'null':\n    case 'undefined':\n      return data;\n\n    default:\n      try {\n        return truncateForDisplay(String(data));\n      } catch (error) {\n        return 'unserializable';\n      }\n\n  }\n} // Basically checking that the object only has Object in its prototype chain\n\nvar isPlainObject = function isPlainObject(object) {\n  var objectPrototype = Object.getPrototypeOf(object);\n  if (!objectPrototype) return true;\n  var objectParentPrototype = Object.getPrototypeOf(objectPrototype);\n  return !objectParentPrototype;\n};\nfunction backendToFrontendSerializedElementMapper(element) {\n  var _parseElementDisplayN2 = parseElementDisplayNameFromBackend(element.displayName, element.type),\n      formattedDisplayName = _parseElementDisplayN2.formattedDisplayName,\n      hocDisplayNames = _parseElementDisplayN2.hocDisplayNames,\n      compiledWithForget = _parseElementDisplayN2.compiledWithForget;\n\n  return _objectSpread(_objectSpread({}, element), {}, {\n    displayName: formattedDisplayName,\n    hocDisplayNames: hocDisplayNames,\n    compiledWithForget: compiledWithForget\n  });\n} // Chrome normalizes urls like webpack-internals:// but new URL don't, so cannot use new URL here.\n\nfunction normalizeUrl(url) {\n  return url.replace('/./', '/');\n}\nfunction getIsReloadAndProfileSupported() {\n  // Notify the frontend if the backend supports the Storage API (e.g. localStorage).\n  // If not, features like reload-and-profile will not work correctly and must be disabled.\n  var isBackendStorageAPISupported = false;\n\n  try {\n    localStorage.getItem('test');\n    isBackendStorageAPISupported = true;\n  } catch (error) {}\n\n  return isBackendStorageAPISupported && (0,_backend_utils__WEBPACK_IMPORTED_MODULE_8__.isSynchronousXHRSupported)();\n} // Expected to be used only by browser extension and react-devtools-inline\n\nfunction getIfReloadedAndProfiling() {\n  return (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === 'true';\n}\nfunction getProfilingSettings() {\n  return {\n    recordChangeDescriptions: (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true',\n    recordTimeline: (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_TIMELINE_KEY) === 'true'\n  };\n}\nfunction onReloadAndProfile(recordChangeDescriptions, recordTimeline) {\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, 'true');\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, recordChangeDescriptions ? 'true' : 'false');\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_TIMELINE_KEY, recordTimeline ? 'true' : 'false');\n}\nfunction onReloadAndProfileFlagsReset() {\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageRemoveItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY);\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageRemoveItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY);\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageRemoveItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_TIMELINE_KEY);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFrQkE7QUFDQTtBQWNBO0FBS0E7QUFRQTtBQU9BO0FBQ0E7QUFZQTs7QUFHQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBOztBQUZBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7O0FBR0E7QUFBQTtBQWFBOztBQUNBO0FBQ0E7O0FBR0E7QUFNQTtBQUNBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFHQTtBQUFBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQXZGQTtBQXlGQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFPQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBO0FBQ0E7O0FBREE7QUFBQTtBQUFBOztBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBaEJBOztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTRCQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQXhFQTtBQTBFQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFqQkE7O0FBWEE7O0FBK0JBO0FBQ0E7QUFyQ0E7QUF1Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZDQTtBQXlDQTtBQUVBOztBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUlBO0FBQ0E7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakpBO0FBbUpBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFKQTtBQU9BO0FBRUE7QUFJQTtBQUNBO0FBSUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzLmpzPzY2YTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IHtcbiAgUkVBQ1RfQ09OU1VNRVJfVFlQRSxcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBSRUFDVF9MQVpZX1RZUEUsXG4gIFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSxcbiAgUkVBQ1RfTUVNT19UWVBFLFxuICBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSxcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSxcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFLFxuICBSRUFDVF9TVVNQRU5TRV9UWVBFLFxuICBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFLFxuICBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRSxcbn0gZnJvbSAnc2hhcmVkL1JlYWN0U3ltYm9scyc7XG5pbXBvcnQge2VuYWJsZVJlbmRlcmFibGVDb250ZXh0fSBmcm9tICdzaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MnO1xuaW1wb3J0IHtcbiAgVFJFRV9PUEVSQVRJT05fQURELFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkUsXG4gIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09ULFxuICBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOLFxuICBUUkVFX09QRVJBVElPTl9TRVRfU1VCVFJFRV9NT0RFLFxuICBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTLFxuICBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OLFxuICBMT0NBTF9TVE9SQUdFX0NPTVBPTkVOVF9GSUxURVJfUFJFRkVSRU5DRVNfS0VZLFxuICBMT0NBTF9TVE9SQUdFX09QRU5fSU5fRURJVE9SX1VSTCxcbiAgU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVksXG4gIFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVksXG4gIFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfVElNRUxJTkVfS0VZLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZSxcbiAgQ29tcG9uZW50RmlsdGVyTG9jYXRpb24sXG4gIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCxcbn0gZnJvbSAnLi9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQge1xuICBFbGVtZW50VHlwZVJvb3QsXG4gIEVsZW1lbnRUeXBlQ2xhc3MsXG4gIEVsZW1lbnRUeXBlRm9yd2FyZFJlZixcbiAgRWxlbWVudFR5cGVGdW5jdGlvbixcbiAgRWxlbWVudFR5cGVNZW1vLFxuICBFbGVtZW50VHlwZVZpcnR1YWwsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHtcbiAgbG9jYWxTdG9yYWdlR2V0SXRlbSxcbiAgbG9jYWxTdG9yYWdlU2V0SXRlbSxcbiAgc2Vzc2lvblN0b3JhZ2VHZXRJdGVtLFxuICBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0sXG4gIHNlc3Npb25TdG9yYWdlU2V0SXRlbSxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zdG9yYWdlJztcbmltcG9ydCB7bWV0YX0gZnJvbSAnLi9oeWRyYXRpb24nO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5JztcblxuaW1wb3J0IHR5cGUge1xuICBDb21wb25lbnRGaWx0ZXIsXG4gIEVsZW1lbnRUeXBlLFxuICBTZXJpYWxpemVkRWxlbWVudCBhcyBTZXJpYWxpemVkRWxlbWVudEZyb250ZW5kLFxuICBMUlVDYWNoZSxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFByb2ZpbGluZ1NldHRpbmdzLFxuICBTZXJpYWxpemVkRWxlbWVudCBhcyBTZXJpYWxpemVkRWxlbWVudEJhY2tlbmQsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC90eXBlcyc7XG5pbXBvcnQge2lzU3luY2hyb25vdXNYSFJTdXBwb3J0ZWR9IGZyb20gJy4vYmFja2VuZC91dGlscyc7XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY29uc3QgY2FjaGVkRGlzcGxheU5hbWVzOiBXZWFrTWFwPEZ1bmN0aW9uLCBzdHJpbmc+ID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gT24gbGFyZ2UgdHJlZXMsIGVuY29kaW5nIHRha2VzIHNpZ25pZmljYW50IHRpbWUuXG4vLyBUcnkgdG8gcmV1c2UgdGhlIGFscmVhZHkgZW5jb2RlZCBzdHJpbmdzLlxuY29uc3QgZW5jb2RlZFN0cmluZ0NhY2hlOiBMUlVDYWNoZTxzdHJpbmcsIEFycmF5PG51bWJlcj4+ID0gbmV3IExSVSh7XG4gIG1heDogMTAwMCxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gYWxwaGFTb3J0S2V5cyhcbiAgYTogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLFxuICBiOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsXG4pOiBudW1iZXIge1xuICBpZiAoYS50b1N0cmluZygpID4gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYi50b1N0cmluZygpID4gYS50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxFbnVtZXJhYmxlS2V5cyhcbiAgb2JqOiBPYmplY3QsXG4pOiBTZXQ8c3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sPiB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0PHN0cmluZyB8IG51bWJlciB8IHN5bWJvbD4oKTtcbiAgbGV0IGN1cnJlbnQgPSBvYmo7XG4gIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICBjb25zdCBjdXJyZW50S2V5cyA9IFtcbiAgICAgIC4uLk9iamVjdC5rZXlzKGN1cnJlbnQpLFxuICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhjdXJyZW50KSxcbiAgICBdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoY3VycmVudCk7XG4gICAgY3VycmVudEtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IGtleSBjYW4gYmUgYSBTeW1ib2wgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgaWYgKGRlc2NyaXB0b3JzW2tleV0uZW51bWVyYWJsZSkge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8vIE1pcnJvciBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi83YzIxYmY3MmFjZTc3MDk0ZmQxOTEwY2MzNTBhNTQ4Mjg3ZWY4MzUwL3BhY2thZ2VzL3NoYXJlZC9nZXRDb21wb25lbnROYW1lLmpzI0wyNy1MMzdcbmV4cG9ydCBmdW5jdGlvbiBnZXRXcmFwcGVkRGlzcGxheU5hbWUoXG4gIG91dGVyVHlwZTogbWl4ZWQsXG4gIGlubmVyVHlwZTogYW55LFxuICB3cmFwcGVyTmFtZTogc3RyaW5nLFxuICBmYWxsYmFja05hbWU/OiBzdHJpbmcsXG4pOiBzdHJpbmcge1xuICBjb25zdCBkaXNwbGF5TmFtZSA9IChvdXRlclR5cGU6IGFueSk/LmRpc3BsYXlOYW1lO1xuICByZXR1cm4gKFxuICAgIGRpc3BsYXlOYW1lIHx8IGAke3dyYXBwZXJOYW1lfSgke2dldERpc3BsYXlOYW1lKGlubmVyVHlwZSwgZmFsbGJhY2tOYW1lKX0pYFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoXG4gIHR5cGU6IEZ1bmN0aW9uLFxuICBmYWxsYmFja05hbWU6IHN0cmluZyA9ICdBbm9ueW1vdXMnLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbmFtZUZyb21DYWNoZSA9IGNhY2hlZERpc3BsYXlOYW1lcy5nZXQodHlwZSk7XG4gIGlmIChuYW1lRnJvbUNhY2hlICE9IG51bGwpIHtcbiAgICByZXR1cm4gbmFtZUZyb21DYWNoZTtcbiAgfVxuXG4gIGxldCBkaXNwbGF5TmFtZSA9IGZhbGxiYWNrTmFtZTtcblxuICAvLyBUaGUgZGlzcGxheU5hbWUgcHJvcGVydHkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYSBzdHJpbmcuXG4gIC8vIEl0J3Mgb25seSBzYWZlIHRvIHVzZSBmb3Igb3VyIHB1cnBvc2VzIGlmIGl0J3MgYSBzdHJpbmcuXG4gIC8vIGdpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtZGV2dG9vbHMvaXNzdWVzLzgwM1xuICBpZiAodHlwZW9mIHR5cGUuZGlzcGxheU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlLm5hbWUgPT09ICdzdHJpbmcnICYmIHR5cGUubmFtZSAhPT0gJycpIHtcbiAgICBkaXNwbGF5TmFtZSA9IHR5cGUubmFtZTtcbiAgfVxuXG4gIGNhY2hlZERpc3BsYXlOYW1lcy5zZXQodHlwZSwgZGlzcGxheU5hbWUpO1xuICByZXR1cm4gZGlzcGxheU5hbWU7XG59XG5cbmxldCB1aWRDb3VudGVyOiBudW1iZXIgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VUlEKCk6IG51bWJlciB7XG4gIHJldHVybiArK3VpZENvdW50ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1dGZEZWNvZGVTdHJpbmdXaXRoUmFuZ2VzKFxuICBhcnJheTogQXJyYXk8bnVtYmVyPixcbiAgbGVmdDogbnVtYmVyLFxuICByaWdodDogbnVtYmVyLFxuKTogc3RyaW5nIHtcbiAgbGV0IHN0cmluZyA9ICcnO1xuICBmb3IgKGxldCBpID0gbGVmdDsgaSA8PSByaWdodDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBzdXJyb2dhdGVQYWlyVG9Db2RlUG9pbnQoXG4gIGNoYXJDb2RlMTogbnVtYmVyLFxuICBjaGFyQ29kZTI6IG51bWJlcixcbik6IG51bWJlciB7XG4gIHJldHVybiAoKGNoYXJDb2RlMSAmIDB4M2ZmKSA8PCAxMCkgKyAoY2hhckNvZGUyICYgMHgzZmYpICsgMHgxMDAwMDtcbn1cblxuLy8gQ3JlZGl0IGZvciB0aGlzIGVuY29kaW5nIGFwcHJvYWNoIGdvZXMgdG8gVGltIERvd246XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODc3MzI2L2hvdy1jYW4taS10ZWxsLWlmLWEtc3RyaW5nLWNvbnRhaW5zLW11bHRpYnl0ZS1jaGFyYWN0ZXJzLWluLWphdmFzY3JpcHRcbmV4cG9ydCBmdW5jdGlvbiB1dGZFbmNvZGVTdHJpbmcoc3RyaW5nOiBzdHJpbmcpOiBBcnJheTxudW1iZXI+IHtcbiAgY29uc3QgY2FjaGVkID0gZW5jb2RlZFN0cmluZ0NhY2hlLmdldChzdHJpbmcpO1xuICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG5cbiAgY29uc3QgZW5jb2RlZCA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCBjaGFyQ29kZTtcbiAgd2hpbGUgKGkgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgY2hhckNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAvLyBIYW5kbGUgbXVsdGlieXRlIHVuaWNvZGUgY2hhcmFjdGVycyAobGlrZSBlbW9qaSkuXG4gICAgaWYgKChjaGFyQ29kZSAmIDB4ZjgwMCkgPT09IDB4ZDgwMCkge1xuICAgICAgZW5jb2RlZC5wdXNoKHN1cnJvZ2F0ZVBhaXJUb0NvZGVQb2ludChjaGFyQ29kZSwgc3RyaW5nLmNoYXJDb2RlQXQoKytpKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGVkLnB1c2goY2hhckNvZGUpO1xuICAgIH1cbiAgICArK2k7XG4gIH1cblxuICBlbmNvZGVkU3RyaW5nQ2FjaGUuc2V0KHN0cmluZywgZW5jb2RlZCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludE9wZXJhdGlvbnNBcnJheShvcGVyYXRpb25zOiBBcnJheTxudW1iZXI+KSB7XG4gIC8vIFRoZSBmaXJzdCB0d28gdmFsdWVzIGFyZSBhbHdheXMgcmVuZGVyZXJJRCBhbmQgcm9vdElEXG4gIGNvbnN0IHJlbmRlcmVySUQgPSBvcGVyYXRpb25zWzBdO1xuICBjb25zdCByb290SUQgPSBvcGVyYXRpb25zWzFdO1xuXG4gIGNvbnN0IGxvZ3MgPSBbYG9wZXJhdGlvbnMgZm9yIHJlbmRlcmVyOiR7cmVuZGVyZXJJRH0gYW5kIHJvb3Q6JHtyb290SUR9YF07XG5cbiAgbGV0IGkgPSAyO1xuXG4gIC8vIFJlYXNzZW1ibGUgdGhlIHN0cmluZyB0YWJsZS5cbiAgY29uc3Qgc3RyaW5nVGFibGU6IEFycmF5PG51bGwgfCBzdHJpbmc+ID0gW1xuICAgIG51bGwsIC8vIElEID0gMCBjb3JyZXNwb25kcyB0byB0aGUgbnVsbCBzdHJpbmcuXG4gIF07XG4gIGNvbnN0IHN0cmluZ1RhYmxlU2l6ZSA9IG9wZXJhdGlvbnNbaSsrXTtcbiAgY29uc3Qgc3RyaW5nVGFibGVFbmQgPSBpICsgc3RyaW5nVGFibGVTaXplO1xuICB3aGlsZSAoaSA8IHN0cmluZ1RhYmxlRW5kKSB7XG4gICAgY29uc3QgbmV4dExlbmd0aCA9IG9wZXJhdGlvbnNbaSsrXTtcbiAgICBjb25zdCBuZXh0U3RyaW5nID0gdXRmRGVjb2RlU3RyaW5nV2l0aFJhbmdlcyhcbiAgICAgIG9wZXJhdGlvbnMsXG4gICAgICBpLFxuICAgICAgaSArIG5leHRMZW5ndGggLSAxLFxuICAgICk7XG4gICAgc3RyaW5nVGFibGUucHVzaChuZXh0U3RyaW5nKTtcbiAgICBpICs9IG5leHRMZW5ndGg7XG4gIH1cblxuICB3aGlsZSAoaSA8IG9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tpXTtcblxuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX0FERDoge1xuICAgICAgICBjb25zdCBpZCA9ICgob3BlcmF0aW9uc1tpICsgMV06IGFueSk6IG51bWJlcik7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKG9wZXJhdGlvbnNbaSArIDJdOiBhbnkpOiBFbGVtZW50VHlwZSk7XG5cbiAgICAgICAgaSArPSAzO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBFbGVtZW50VHlwZVJvb3QpIHtcbiAgICAgICAgICBsb2dzLnB1c2goYEFkZCBuZXcgcm9vdCBub2RlICR7aWR9YCk7XG5cbiAgICAgICAgICBpKys7IC8vIGlzU3RyaWN0TW9kZUNvbXBsaWFudFxuICAgICAgICAgIGkrKzsgLy8gc3VwcG9ydHNQcm9maWxpbmdcbiAgICAgICAgICBpKys7IC8vIHN1cHBvcnRzU3RyaWN0TW9kZVxuICAgICAgICAgIGkrKzsgLy8gaGFzT3duZXJNZXRhZGF0YVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcmVudElEID0gKChvcGVyYXRpb25zW2ldOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICAgIGkrKztcblxuICAgICAgICAgIGkrKzsgLy8gb3duZXJJRFxuXG4gICAgICAgICAgY29uc3QgZGlzcGxheU5hbWVTdHJpbmdJRCA9IG9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSBzdHJpbmdUYWJsZVtkaXNwbGF5TmFtZVN0cmluZ0lEXTtcbiAgICAgICAgICBpKys7XG5cbiAgICAgICAgICBpKys7IC8vIGtleVxuXG4gICAgICAgICAgbG9ncy5wdXNoKFxuICAgICAgICAgICAgYEFkZCBub2RlICR7aWR9ICgke2Rpc3BsYXlOYW1lIHx8ICdudWxsJ30pIGFzIGNoaWxkIG9mICR7cGFyZW50SUR9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9SRU1PVkU6IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlTGVuZ3RoID0gKChvcGVyYXRpb25zW2kgKyAxXTogYW55KTogbnVtYmVyKTtcbiAgICAgICAgaSArPSAyO1xuXG4gICAgICAgIGZvciAobGV0IHJlbW92ZUluZGV4ID0gMDsgcmVtb3ZlSW5kZXggPCByZW1vdmVMZW5ndGg7IHJlbW92ZUluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBpZCA9ICgob3BlcmF0aW9uc1tpXTogYW55KTogbnVtYmVyKTtcbiAgICAgICAgICBpICs9IDE7XG5cbiAgICAgICAgICBsb2dzLnB1c2goYFJlbW92ZSBub2RlICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UOiB7XG4gICAgICAgIGkgKz0gMTtcblxuICAgICAgICBsb2dzLnB1c2goYFJlbW92ZSByb290ICR7cm9vdElEfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERToge1xuICAgICAgICBjb25zdCBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICBjb25zdCBtb2RlID0gb3BlcmF0aW9uc1tpICsgMV07XG5cbiAgICAgICAgaSArPSAzO1xuXG4gICAgICAgIGxvZ3MucHVzaChgTW9kZSAke21vZGV9IHNldCBmb3Igc3VidHJlZSB3aXRoIHJvb3QgJHtpZH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU46IHtcbiAgICAgICAgY29uc3QgaWQgPSAoKG9wZXJhdGlvbnNbaSArIDFdOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICBjb25zdCBudW1DaGlsZHJlbiA9ICgob3BlcmF0aW9uc1tpICsgMl06IGFueSk6IG51bWJlcik7XG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBvcGVyYXRpb25zLnNsaWNlKGksIGkgKyBudW1DaGlsZHJlbik7XG4gICAgICAgIGkgKz0gbnVtQ2hpbGRyZW47XG5cbiAgICAgICAgbG9ncy5wdXNoKGBSZS1vcmRlciBub2RlICR7aWR9IGNoaWxkcmVuICR7Y2hpbGRyZW4uam9pbignLCcpfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTjpcbiAgICAgICAgLy8gQmFzZSBkdXJhdGlvbiB1cGRhdGVzIGFyZSBvbmx5IHNlbnQgd2hpbGUgcHJvZmlsaW5nIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAvLyBXZSBjYW4gaWdub3JlIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgICAgICAgLy8gVGhlIHByb2ZpbGVyIFVJIHVzZXMgdGhlbSBsYXppbHkgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIHRyZWUuXG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1M6XG4gICAgICAgIGNvbnN0IGlkID0gb3BlcmF0aW9uc1tpICsgMV07XG4gICAgICAgIGNvbnN0IG51bUVycm9ycyA9IG9wZXJhdGlvbnNbaSArIDJdO1xuICAgICAgICBjb25zdCBudW1XYXJuaW5ncyA9IG9wZXJhdGlvbnNbaSArIDNdO1xuXG4gICAgICAgIGkgKz0gNDtcblxuICAgICAgICBsb2dzLnB1c2goXG4gICAgICAgICAgYE5vZGUgJHtpZH0gaGFzICR7bnVtRXJyb3JzfSBlcnJvcnMgYW5kICR7bnVtV2FybmluZ3N9IHdhcm5pbmdzYCxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgQnJpZGdlIG9wZXJhdGlvbiBcIiR7b3BlcmF0aW9ufVwiYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc29sZS5sb2cobG9ncy5qb2luKCdcXG4gICcpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRDb21wb25lbnRGaWx0ZXJzKCk6IEFycmF5PENvbXBvbmVudEZpbHRlcj4ge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IENvbXBvbmVudEZpbHRlckVsZW1lbnRUeXBlLFxuICAgICAgdmFsdWU6IEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCxcbiAgICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICB9LFxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2F2ZWRDb21wb25lbnRGaWx0ZXJzKCk6IEFycmF5PENvbXBvbmVudEZpbHRlcj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZUdldEl0ZW0oXG4gICAgICBMT0NBTF9TVE9SQUdFX0NPTVBPTkVOVF9GSUxURVJfUFJFRkVSRU5DRVNfS0VZLFxuICAgICk7XG4gICAgaWYgKHJhdyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJzZWRGaWx0ZXJzOiBBcnJheTxDb21wb25lbnRGaWx0ZXI+ID0gSlNPTi5wYXJzZShyYXcpO1xuICAgICAgcmV0dXJuIGZpbHRlck91dExvY2F0aW9uQ29tcG9uZW50RmlsdGVycyhwYXJzZWRGaWx0ZXJzKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICByZXR1cm4gZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNhdmVkQ29tcG9uZW50RmlsdGVycyhcbiAgY29tcG9uZW50RmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPixcbik6IHZvaWQge1xuICBsb2NhbFN0b3JhZ2VTZXRJdGVtKFxuICAgIExPQ0FMX1NUT1JBR0VfQ09NUE9ORU5UX0ZJTFRFUl9QUkVGRVJFTkNFU19LRVksXG4gICAgSlNPTi5zdHJpbmdpZnkoZmlsdGVyT3V0TG9jYXRpb25Db21wb25lbnRGaWx0ZXJzKGNvbXBvbmVudEZpbHRlcnMpKSxcbiAgKTtcbn1cblxuLy8gRm9sbG93aW5nIF9fZGVidWdTb3VyY2UgcmVtb3ZhbCBmcm9tIEZpYmVyLCB0aGUgbmV3IGFwcHJvYWNoIGZvciBmaW5kaW5nIHRoZSBzb3VyY2UgbG9jYXRpb25cbi8vIG9mIGEgY29tcG9uZW50LCByZXByZXNlbnRlZCBieSB0aGUgRmliZXIsIGlzIGJhc2VkIG9uIGxhemlseSBnZW5lcmF0aW5nIGFuZCBwYXJzaW5nIGNvbXBvbmVudCBzdGFjayBmcmFtZXNcbi8vIFRvIGZpbmQgdGhlIG9yaWdpbmFsIGxvY2F0aW9uLCBSZWFjdCBEZXZUb29scyB3aWxsIHBlcmZvcm0gc3ltYm9saWNhdGlvbiwgc291cmNlIG1hcHMgYXJlIHJlcXVpcmVkIGZvciB0aGF0LlxuLy8gSW4gb3JkZXIgdG8gc3RhcnQgZmlsdGVyaW5nIEZpYmVycywgd2UgbmVlZCB0byBmaW5kIGxvY2F0aW9uIGZvciBhbGwgb2YgdGhlbSwgd2hpY2ggY2FuJ3QgYmUgZG9uZSBsYXppbHkuXG4vLyBFYWdlciBzeW1ib2xpY2F0aW9uIGNhbiBiZWNvbWUgcXVpdGUgZXhwZW5zaXZlIGZvciBsYXJnZSBhcHBsaWNhdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyT3V0TG9jYXRpb25Db21wb25lbnRGaWx0ZXJzKFxuICBjb21wb25lbnRGaWx0ZXJzOiBBcnJheTxDb21wb25lbnRGaWx0ZXI+LFxuKTogQXJyYXk8Q29tcG9uZW50RmlsdGVyPiB7XG4gIC8vIFRoaXMgaXMganVzdCBhbiBhZGRpdGlvbmFsIGNoZWNrIHRvIHByZXNlcnZlIHRoZSBwcmV2aW91cyBzdGF0ZVxuICAvLyBGaWx0ZXJzIGNhbiBiZSBzdG9yZWQgb24gdGhlIGJhY2tlbmQgc2lkZSBvciBpbiB1c2VyIGxhbmQgKGluIGEgd2luZG93IG9iamVjdClcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbXBvbmVudEZpbHRlcnMpKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudEZpbHRlcnM7XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50RmlsdGVycy5maWx0ZXIoZiA9PiBmLnR5cGUgIT09IENvbXBvbmVudEZpbHRlckxvY2F0aW9uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRPcGVuSW5FZGl0b3JVUkwoKTogc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzLmVudi5FRElUT1JfVVJMID09PSAnc3RyaW5nJ1xuICAgID8gcHJvY2Vzcy5lbnYuRURJVE9SX1VSTFxuICAgIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVuSW5FZGl0b3JVUkwoKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2VHZXRJdGVtKExPQ0FMX1NUT1JBR0VfT1BFTl9JTl9FRElUT1JfVVJMKTtcbiAgICBpZiAocmF3ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cbiAgcmV0dXJuIGdldERlZmF1bHRPcGVuSW5FZGl0b3JVUkwoKTtcbn1cblxudHlwZSBQYXJzZUVsZW1lbnREaXNwbGF5TmFtZUZyb21CYWNrZW5kUmV0dXJuID0ge1xuICBmb3JtYXR0ZWREaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgaG9jRGlzcGxheU5hbWVzOiBBcnJheTxzdHJpbmc+IHwgbnVsbCxcbiAgY29tcGlsZWRXaXRoRm9yZ2V0OiBib29sZWFuLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVsZW1lbnREaXNwbGF5TmFtZUZyb21CYWNrZW5kKFxuICBkaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgdHlwZTogRWxlbWVudFR5cGUsXG4pOiBQYXJzZUVsZW1lbnREaXNwbGF5TmFtZUZyb21CYWNrZW5kUmV0dXJuIHtcbiAgaWYgKGRpc3BsYXlOYW1lID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdHRlZERpc3BsYXlOYW1lOiBudWxsLFxuICAgICAgaG9jRGlzcGxheU5hbWVzOiBudWxsLFxuICAgICAgY29tcGlsZWRXaXRoRm9yZ2V0OiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgaWYgKGRpc3BsYXlOYW1lLnN0YXJ0c1dpdGgoJ0ZvcmdldCgnKSkge1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lV2l0aG91dEZvcmdldFdyYXBwZXIgPSBkaXNwbGF5TmFtZS5zbGljZShcbiAgICAgIDcsXG4gICAgICBkaXNwbGF5TmFtZS5sZW5ndGggLSAxLFxuICAgICk7XG5cbiAgICBjb25zdCB7Zm9ybWF0dGVkRGlzcGxheU5hbWUsIGhvY0Rpc3BsYXlOYW1lc30gPVxuICAgICAgcGFyc2VFbGVtZW50RGlzcGxheU5hbWVGcm9tQmFja2VuZChkaXNwbGF5TmFtZVdpdGhvdXRGb3JnZXRXcmFwcGVyLCB0eXBlKTtcbiAgICByZXR1cm4ge2Zvcm1hdHRlZERpc3BsYXlOYW1lLCBob2NEaXNwbGF5TmFtZXMsIGNvbXBpbGVkV2l0aEZvcmdldDogdHJ1ZX07XG4gIH1cblxuICBsZXQgaG9jRGlzcGxheU5hbWVzID0gbnVsbDtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBFbGVtZW50VHlwZUNsYXNzOlxuICAgIGNhc2UgRWxlbWVudFR5cGVGb3J3YXJkUmVmOlxuICAgIGNhc2UgRWxlbWVudFR5cGVGdW5jdGlvbjpcbiAgICBjYXNlIEVsZW1lbnRUeXBlTWVtbzpcbiAgICBjYXNlIEVsZW1lbnRUeXBlVmlydHVhbDpcbiAgICAgIGlmIChkaXNwbGF5TmFtZS5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gZGlzcGxheU5hbWUubWF0Y2goL1teKCldKy9nKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXG4gICAgICAgICAgZGlzcGxheU5hbWUgPSBtYXRjaGVzLnBvcCgpO1xuICAgICAgICAgIGhvY0Rpc3BsYXlOYW1lcyA9IG1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIGZvcm1hdHRlZERpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICBob2NEaXNwbGF5TmFtZXMsXG4gICAgY29tcGlsZWRXaXRoRm9yZ2V0OiBmYWxzZSxcbiAgfTtcbn1cblxuLy8gUHVsbGVkIGZyb20gcmVhY3QtY29tcGF0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC1jb21wYXQvYmxvYi83YzVkZTAwZTdjODVlMmZmZDAxMWJmM2FmMDI4OTliNjNmNjk5ZDNhL3NyYy9pbmRleC5qcyNMMzQ5XG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMocHJldjogT2JqZWN0LCBuZXh0OiBPYmplY3QpOiBib29sZWFuIHtcbiAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gcHJldikge1xuICAgIGlmICghKGF0dHJpYnV0ZSBpbiBuZXh0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXR0cmlidXRlIGluIG5leHQpIHtcbiAgICBpZiAocHJldlthdHRyaWJ1dGVdICE9PSBuZXh0W2F0dHJpYnV0ZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbk9iamVjdChvYmplY3Q6IE9iamVjdCwgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPik6IGFueSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgocmVkdWNlZDogT2JqZWN0LCBhdHRyOiBhbnkpOiBhbnkgPT4ge1xuICAgIGlmIChyZWR1Y2VkKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZWR1Y2VkLCBhdHRyKSkge1xuICAgICAgICByZXR1cm4gcmVkdWNlZFthdHRyXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlZFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIENvbnZlcnQgaXRlcmFibGUgdG8gYXJyYXkgYW5kIHJldHVybiBhcnJheVtpbmRleF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVFJJQ0tZXG4gICAgICAgIC8vIERvbid0IHVzZSBbLi4uc3ByZWFkXSBzeW50YXggZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHVzZXMgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tc3ByZWFkIGluIFwibG9vc2VcIiBtb2RlIHdoaWNoIG9ubHkgd29ya3Mgd2l0aCBBcnJheSB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyIHR5cGVzIChlLmcuIHR5cGVkIGFycmF5cywgU2V0cykgd2lsbCBub3Qgc3ByZWFkIGNvcnJlY3RseS5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocmVkdWNlZClbYXR0cl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQYXRoSW5PYmplY3QoXG4gIG9iamVjdDogT2JqZWN0LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICBjb25zdCBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0SW5PYmplY3Qob2JqZWN0LCBwYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAoaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5zcGxpY2UoKChsYXN0OiBhbnkpOiBudW1iZXIpLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBwYXJlbnRbbGFzdF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5hbWVQYXRoSW5PYmplY3QoXG4gIG9iamVjdDogT2JqZWN0LFxuICBvbGRQYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBuZXdQYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuKSB7XG4gIGNvbnN0IGxlbmd0aCA9IG9sZFBhdGgubGVuZ3RoO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIG9sZFBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGNvbnN0IGxhc3RPbGQgPSBvbGRQYXRoW2xlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbGFzdE5ldyA9IG5ld1BhdGhbbGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRbbGFzdE5ld10gPSBwYXJlbnRbbGFzdE9sZF07XG4gICAgICBpZiAoaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5zcGxpY2UoKChsYXN0T2xkOiBhbnkpOiBudW1iZXIpLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBwYXJlbnRbbGFzdE9sZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbk9iamVjdChcbiAgb2JqZWN0OiBPYmplY3QsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIHZhbHVlOiBhbnksXG4pIHtcbiAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gIGNvbnN0IGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBEYXRhVHlwZSA9XG4gIHwgJ2FycmF5J1xuICB8ICdhcnJheV9idWZmZXInXG4gIHwgJ2JpZ2ludCdcbiAgfCAnYm9vbGVhbidcbiAgfCAnY2xhc3NfaW5zdGFuY2UnXG4gIHwgJ2RhdGFfdmlldydcbiAgfCAnZGF0ZSdcbiAgfCAnZnVuY3Rpb24nXG4gIHwgJ2h0bWxfYWxsX2NvbGxlY3Rpb24nXG4gIHwgJ2h0bWxfZWxlbWVudCdcbiAgfCAnaW5maW5pdHknXG4gIHwgJ2l0ZXJhdG9yJ1xuICB8ICdvcGFxdWVfaXRlcmF0b3InXG4gIHwgJ25hbidcbiAgfCAnbnVsbCdcbiAgfCAnbnVtYmVyJ1xuICB8ICdvYmplY3QnXG4gIHwgJ3JlYWN0X2VsZW1lbnQnXG4gIHwgJ3JlZ2V4cCdcbiAgfCAnc3RyaW5nJ1xuICB8ICdzeW1ib2wnXG4gIHwgJ3R5cGVkX2FycmF5J1xuICB8ICd1bmRlZmluZWQnXG4gIHwgJ3Vua25vd24nO1xuXG4vKipcbiAqIEdldCBhIGVuaGFuY2VkL2FydGlmaWNpYWwgdHlwZSBzdHJpbmcgYmFzZWQgb24gdGhlIG9iamVjdCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YVR5cGUoZGF0YTogT2JqZWN0KTogRGF0YVR5cGUge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuICdodG1sX2VsZW1lbnQnO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBkYXRhO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgcmV0dXJuICdiaWdpbnQnO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKE51bWJlci5pc05hTihkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ25hbic7XG4gICAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdpbmZpbml0eSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICB9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChcbiAgICAgICAgZGF0YS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFIHx8XG4gICAgICAgIGRhdGEuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEVcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gJ3JlYWN0X2VsZW1lbnQnO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmNvbnN0cnVjdG9yLCAnQllURVNfUEVSX0VMRU1FTlQnKVxuICAgICAgICAgID8gJ3R5cGVkX2FycmF5J1xuICAgICAgICAgIDogJ2RhdGFfdmlldyc7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY29uc3RydWN0b3IgJiYgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInKSB7XG4gICAgICAgIC8vIEhBQ0sgVGhpcyBBcnJheUJ1ZmZlciBjaGVjayBpcyBncm9zczsgaXMgdGhlcmUgYSBiZXR0ZXIgd2F5P1xuICAgICAgICAvLyBXZSBjb3VsZCB0cnkgdG8gY3JlYXRlIGEgbmV3IERhdGFWaWV3IHdpdGggdGhlIHZhbHVlLlxuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IGVycm9yLCB3ZSBrbm93IGl0J3MgYW4gQXJyYXlCdWZmZXIsXG4gICAgICAgIC8vIGJ1dCB0aGlzIHNlZW1zIGtpbmQgb2YgYXdrd2FyZCBhbmQgZXhwZW5zaXZlLlxuICAgICAgICByZXR1cm4gJ2FycmF5X2J1ZmZlcic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgaWYgKCFpdGVyYXRvcikge1xuICAgICAgICAgIC8vIFByb3hpZXMgbWlnaHQgYnJlYWsgYXNzdW1wdG9pbnMgYWJvdXQgaXRlcmF0b3JzLlxuICAgICAgICAgIC8vIFNlZSBnaXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMTY1NFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvciA9PT0gZGF0YSA/ICdvcGFxdWVfaXRlcmF0b3InIDogJ2l0ZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLmNvbnN0cnVjdG9yICYmIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBjb25zdCB0b1N0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpO1xuICAgICAgICBpZiAodG9TdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZ1ZhbHVlID09PSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nKSB7XG4gICAgICAgICAgcmV0dXJuICdodG1sX2FsbF9jb2xsZWN0aW9uJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdjbGFzc19pbnN0YW5jZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGlmIChcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXSdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gJ2h0bWxfYWxsX2NvbGxlY3Rpb24nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xuICB9XG59XG5cbi8vIEZvcmsgb2YgcGFja2FnZXMvcmVhY3QtaXMvc3JjL1JlYWN0SXMuanM6MzAsIGJ1dCB3aXRoIGxlZ2FjeSBlbGVtZW50IHR5cGVcbi8vIFdoaWNoIGhhcyBiZWVuIGNoYW5nZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjg4MTNcbmZ1bmN0aW9uIHR5cGVPZldpdGhMZWdhY3lFbGVtZW50U3ltYm9sKG9iamVjdDogYW55KTogbWl4ZWQge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICBjYXNlIFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zdCAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZVJlbmRlcmFibGVDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZVJlbmRlcmFibGVDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KFxuICBlbGVtZW50OiBSZWFjdCRFbGVtZW50PGFueT4sXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZWxlbWVudFR5cGUgPSB0eXBlT2ZXaXRoTGVnYWN5RWxlbWVudFN5bWJvbChlbGVtZW50KTtcbiAgc3dpdGNoIChlbGVtZW50VHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dENvbnN1bWVyJztcbiAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XG4gICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICByZXR1cm4gJ0NvbnRleHQnO1xuICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgIHJldHVybiAnRm9yd2FyZFJlZic7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICByZXR1cm4gJ0xhenknO1xuICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgcmV0dXJuICdNZW1vJztcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gICAgY2FzZSBSRUFDVF9WSUVXX1RSQU5TSVRJT05fVFlQRTpcbiAgICAgIHJldHVybiAnVmlld1RyYW5zaXRpb24nO1xuICAgIGNhc2UgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTpcbiAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnN0IHt0eXBlfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUodHlwZSwgJ0Fub255bW91cycpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdOb3RJbXBsZW1lbnRlZEluRGV2dG9vbHMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdFbGVtZW50JztcbiAgICAgIH1cbiAgfVxufVxuXG5jb25zdCBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIID0gNTA7XG5cbmZ1bmN0aW9uIHRydW5jYXRlRm9yRGlzcGxheShcbiAgc3RyaW5nOiBzdHJpbmcsXG4gIGxlbmd0aDogbnVtYmVyID0gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCxcbikge1xuICBpZiAoc3RyaW5nLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgbGVuZ3RoKSArICfigKYnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gbWltaWMgQ2hyb21lJ3MgaW5saW5lIHByZXZpZXcgZm9yIHZhbHVlcy5cbi8vIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIHZhbHVlLi4uXG4vLyAgIHtcbi8vICAgICAgZm9vOiAxMjMsXG4vLyAgICAgIGJhcjogXCJhYmNcIixcbi8vICAgICAgYmF6OiBbdHJ1ZSwgZmFsc2VdLFxuLy8gICAgICBxdXg6IHsgYWI6IDEsIGNkOiAyIH1cbi8vICAgfTtcbi8vXG4vLyBXb3VsZCBzaG93IGEgcHJldmlldyBvZi4uLlxuLy8gICB7Zm9vOiAxMjMsIGJhcjogXCJhYmNcIiwgYmF6OiBBcnJheSgyKSwgcXV4OiB74oCmfX1cbi8vXG4vLyBBbmQgdGhlIGZvbGxvd2luZyB2YWx1ZS4uLlxuLy8gICBbXG4vLyAgICAgMTIzLFxuLy8gICAgIFwiYWJjXCIsXG4vLyAgICAgW3RydWUsIGZhbHNlXSxcbi8vICAgICB7IGZvbzogMTIzLCBiYXI6IFwiYWJjXCIgfVxuLy8gICBdO1xuLy9cbi8vIFdvdWxkIHNob3cgYSBwcmV2aWV3IG9mLi4uXG4vLyAgIFsxMjMsIFwiYWJjXCIsIEFycmF5KDIpLCB74oCmfV1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRhRm9yUHJldmlldyhcbiAgZGF0YTogYW55LFxuICBzaG93Rm9ybWF0dGVkVmFsdWU6IGJvb2xlYW4sXG4pOiBzdHJpbmcge1xuICBpZiAoZGF0YSAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgbWV0YS50eXBlKSkge1xuICAgIHJldHVybiBzaG93Rm9ybWF0dGVkVmFsdWVcbiAgICAgID8gZGF0YVttZXRhLnByZXZpZXdfbG9uZ11cbiAgICAgIDogZGF0YVttZXRhLnByZXZpZXdfc2hvcnRdO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IGdldERhdGFUeXBlKGRhdGEpO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2h0bWxfZWxlbWVudCc6XG4gICAgICByZXR1cm4gYDwke3RydW5jYXRlRm9yRGlzcGxheShkYXRhLnRhZ05hbWUudG9Mb3dlckNhc2UoKSl9IC8+YDtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBpZiAodHlwZW9mIGRhdGEubmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCBkYXRhLm5hbWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnKCkgPT4ge30nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAke3RydW5jYXRlRm9yRGlzcGxheShkYXRhLm5hbWUpfSgpIHt9YDtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIGBcIiR7ZGF0YX1cImA7XG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50b1N0cmluZygpICsgJ24nKTtcbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShkYXRhLnRvU3RyaW5nKCkpO1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KGRhdGEudG9TdHJpbmcoKSk7XG4gICAgY2FzZSAncmVhY3RfZWxlbWVudCc6XG4gICAgICByZXR1cm4gYDwke3RydW5jYXRlRm9yRGlzcGxheShcbiAgICAgICAgZ2V0RGlzcGxheU5hbWVGb3JSZWFjdEVsZW1lbnQoZGF0YSkgfHwgJ1Vua25vd24nLFxuICAgICAgKX0gLz5gO1xuICAgIGNhc2UgJ2FycmF5X2J1ZmZlcic6XG4gICAgICByZXR1cm4gYEFycmF5QnVmZmVyKCR7ZGF0YS5ieXRlTGVuZ3RofSlgO1xuICAgIGNhc2UgJ2RhdGFfdmlldyc6XG4gICAgICByZXR1cm4gYERhdGFWaWV3KCR7ZGF0YS5idWZmZXIuYnl0ZUxlbmd0aH0pYDtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgKz0gJywgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0dGVkICs9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGFbaV0sIGZhbHNlKTtcbiAgICAgICAgICBpZiAoZm9ybWF0dGVkLmxlbmd0aCA+IE1BWF9QUkVWSUVXX1NUUklOR19MRU5HVEgpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZG9pbmcgYSBsb3Qgb2YgdW5uZWNlc3NhcnkgaXRlcmF0aW9uLi4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBbJHt0cnVuY2F0ZUZvckRpc3BsYXkoZm9ybWF0dGVkKX1dYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgbWV0YS5zaXplKVxuICAgICAgICAgID8gZGF0YVttZXRhLnNpemVdXG4gICAgICAgICAgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGBBcnJheSgke2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICBjYXNlICd0eXBlZF9hcnJheSc6XG4gICAgICBjb25zdCBzaG9ydE5hbWUgPSBgJHtkYXRhLmNvbnN0cnVjdG9yLm5hbWV9KCR7ZGF0YS5sZW5ndGh9KWA7XG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgKz0gJywgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0dGVkICs9IGRhdGFbaV07XG4gICAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtzaG9ydE5hbWV9IFske3RydW5jYXRlRm9yRGlzcGxheShmb3JtYXR0ZWQpfV1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNob3J0TmFtZTtcbiAgICAgIH1cbiAgICBjYXNlICdpdGVyYXRvcic6XG4gICAgICBjb25zdCBuYW1lID0gZGF0YS5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIC8vIFRSSUNLWVxuICAgICAgICAvLyBEb24ndCB1c2UgWy4uLnNwcmVhZF0gc3ludGF4IGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIC8vIFRoaXMgcHJvamVjdCB1c2VzIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXNwcmVhZCBpbiBcImxvb3NlXCIgbW9kZSB3aGljaCBvbmx5IHdvcmtzIHdpdGggQXJyYXkgdmFsdWVzLlxuICAgICAgICAvLyBPdGhlciB0eXBlcyAoZS5nLiB0eXBlZCBhcnJheXMsIFNldHMpIHdpbGwgbm90IHNwcmVhZCBjb3JyZWN0bHkuXG4gICAgICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShkYXRhKTtcblxuICAgICAgICBsZXQgZm9ybWF0dGVkID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBlbnRyeU9yRW50cmllcyA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgKz0gJywgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUUklDS1lcbiAgICAgICAgICAvLyBCcm93c2VycyBkaXNwbGF5IE1hcHMgYW5kIFNldHMgZGlmZmVyZW50bHkuXG4gICAgICAgICAgLy8gVG8gbWltaWMgdGhlaXIgYmVoYXZpb3IsIGRldGVjdCBpZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIGVudHJpZXMgdHVwbGUuXG4gICAgICAgICAgLy8gICBNYXAoMikge1wiYWJjXCIgPT4gMTIzLCBcImRlZlwiID0+IDEyM31cbiAgICAgICAgICAvLyAgIFNldCgyKSB7XCJhYmNcIiwgMTIzfVxuICAgICAgICAgIGlmIChpc0FycmF5KGVudHJ5T3JFbnRyaWVzKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZm9ybWF0RGF0YUZvclByZXZpZXcoZW50cnlPckVudHJpZXNbMF0sIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmb3JtYXREYXRhRm9yUHJldmlldyhlbnRyeU9yRW50cmllc1sxXSwgZmFsc2UpO1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9IGAke2tleX0gPT4gJHt2YWx1ZX1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgKz0gZm9ybWF0RGF0YUZvclByZXZpZXcoZW50cnlPckVudHJpZXMsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm9ybWF0dGVkLmxlbmd0aCA+IE1BWF9QUkVWSUVXX1NUUklOR19MRU5HVEgpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZG9pbmcgYSBsb3Qgb2YgdW5uZWNlc3NhcnkgaXRlcmF0aW9uLi4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7bmFtZX0oJHtkYXRhLnNpemV9KSB7JHt0cnVuY2F0ZUZvckRpc3BsYXkoZm9ybWF0dGVkKX19YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfSgke2RhdGEuc2l6ZX0pYDtcbiAgICAgIH1cbiAgICBjYXNlICdvcGFxdWVfaXRlcmF0b3InOiB7XG4gICAgICByZXR1cm4gZGF0YVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAgIH1cbiAgICBjYXNlICdkYXRlJzpcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgY2FzZSAnY2xhc3NfaW5zdGFuY2UnOlxuICAgICAgcmV0dXJuIGRhdGEuY29uc3RydWN0b3IubmFtZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShnZXRBbGxFbnVtZXJhYmxlS2V5cyhkYXRhKSkuc29ydChhbHBoYVNvcnRLZXlzKTtcblxuICAgICAgICBsZXQgZm9ybWF0dGVkID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgKz0gJywgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0dGVkICs9IGAke2tleS50b1N0cmluZygpfTogJHtmb3JtYXREYXRhRm9yUHJldmlldyhcbiAgICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICl9YDtcbiAgICAgICAgICBpZiAoZm9ybWF0dGVkLmxlbmd0aCA+IE1BWF9QUkVWSUVXX1NUUklOR19MRU5HVEgpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZG9pbmcgYSBsb3Qgb2YgdW5uZWNlc3NhcnkgaXRlcmF0aW9uLi4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGB7JHt0cnVuY2F0ZUZvckRpc3BsYXkoZm9ybWF0dGVkKX19YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAne+KApn0nO1xuICAgICAgfVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnaW5maW5pdHknOlxuICAgIGNhc2UgJ25hbic6XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KFN0cmluZyhkYXRhKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gJ3Vuc2VyaWFsaXphYmxlJztcbiAgICAgIH1cbiAgfVxufVxuXG4vLyBCYXNpY2FsbHkgY2hlY2tpbmcgdGhhdCB0aGUgb2JqZWN0IG9ubHkgaGFzIE9iamVjdCBpbiBpdHMgcHJvdG90eXBlIGNoYWluXG5leHBvcnQgY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmplY3Q6IE9iamVjdCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgaWYgKCFvYmplY3RQcm90b3R5cGUpIHJldHVybiB0cnVlO1xuXG4gIGNvbnN0IG9iamVjdFBhcmVudFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3RQcm90b3R5cGUpO1xuICByZXR1cm4gIW9iamVjdFBhcmVudFByb3RvdHlwZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrZW5kVG9Gcm9udGVuZFNlcmlhbGl6ZWRFbGVtZW50TWFwcGVyKFxuICBlbGVtZW50OiBTZXJpYWxpemVkRWxlbWVudEJhY2tlbmQsXG4pOiBTZXJpYWxpemVkRWxlbWVudEZyb250ZW5kIHtcbiAgY29uc3Qge2Zvcm1hdHRlZERpc3BsYXlOYW1lLCBob2NEaXNwbGF5TmFtZXMsIGNvbXBpbGVkV2l0aEZvcmdldH0gPVxuICAgIHBhcnNlRWxlbWVudERpc3BsYXlOYW1lRnJvbUJhY2tlbmQoZWxlbWVudC5kaXNwbGF5TmFtZSwgZWxlbWVudC50eXBlKTtcblxuICByZXR1cm4ge1xuICAgIC4uLmVsZW1lbnQsXG4gICAgZGlzcGxheU5hbWU6IGZvcm1hdHRlZERpc3BsYXlOYW1lLFxuICAgIGhvY0Rpc3BsYXlOYW1lcyxcbiAgICBjb21waWxlZFdpdGhGb3JnZXQsXG4gIH07XG59XG5cbi8vIENocm9tZSBub3JtYWxpemVzIHVybHMgbGlrZSB3ZWJwYWNrLWludGVybmFsczovLyBidXQgbmV3IFVSTCBkb24ndCwgc28gY2Fubm90IHVzZSBuZXcgVVJMIGhlcmUuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVXJsKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHVybC5yZXBsYWNlKCcvLi8nLCAnLycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNSZWxvYWRBbmRQcm9maWxlU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICAvLyBOb3RpZnkgdGhlIGZyb250ZW5kIGlmIHRoZSBiYWNrZW5kIHN1cHBvcnRzIHRoZSBTdG9yYWdlIEFQSSAoZS5nLiBsb2NhbFN0b3JhZ2UpLlxuICAvLyBJZiBub3QsIGZlYXR1cmVzIGxpa2UgcmVsb2FkLWFuZC1wcm9maWxlIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGFuZCBtdXN0IGJlIGRpc2FibGVkLlxuICBsZXQgaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0ZXN0Jyk7XG4gICAgaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gIHJldHVybiBpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkICYmIGlzU3luY2hyb25vdXNYSFJTdXBwb3J0ZWQoKTtcbn1cblxuLy8gRXhwZWN0ZWQgdG8gYmUgdXNlZCBvbmx5IGJ5IGJyb3dzZXIgZXh0ZW5zaW9uIGFuZCByZWFjdC1kZXZ0b29scy1pbmxpbmVcbmV4cG9ydCBmdW5jdGlvbiBnZXRJZlJlbG9hZGVkQW5kUHJvZmlsaW5nKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHNlc3Npb25TdG9yYWdlR2V0SXRlbShTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSkgPT09ICd0cnVlJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvZmlsaW5nU2V0dGluZ3MoKTogUHJvZmlsaW5nU2V0dGluZ3Mge1xuICByZXR1cm4ge1xuICAgIHJlY29yZENoYW5nZURlc2NyaXB0aW9uczpcbiAgICAgIHNlc3Npb25TdG9yYWdlR2V0SXRlbShTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZKSA9PT1cbiAgICAgICd0cnVlJyxcbiAgICByZWNvcmRUaW1lbGluZTpcbiAgICAgIHNlc3Npb25TdG9yYWdlR2V0SXRlbShTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX1RJTUVMSU5FX0tFWSkgPT09ICd0cnVlJyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uUmVsb2FkQW5kUHJvZmlsZShcbiAgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOiBib29sZWFuLFxuICByZWNvcmRUaW1lbGluZTogYm9vbGVhbixcbik6IHZvaWQge1xuICBzZXNzaW9uU3RvcmFnZVNldEl0ZW0oU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVksICd0cnVlJyk7XG4gIHNlc3Npb25TdG9yYWdlU2V0SXRlbShcbiAgICBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZLFxuICAgIHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICk7XG4gIHNlc3Npb25TdG9yYWdlU2V0SXRlbShcbiAgICBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX1RJTUVMSU5FX0tFWSxcbiAgICByZWNvcmRUaW1lbGluZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblJlbG9hZEFuZFByb2ZpbGVGbGFnc1Jlc2V0KCk6IHZvaWQge1xuICBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0oU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVkpO1xuICBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0oU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSk7XG4gIHNlc3Npb25TdG9yYWdlUmVtb3ZlSXRlbShTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX1RJTUVMSU5FX0tFWSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/utils.js\n");

/***/ }),

/***/ "../react-devtools-timeline/src/constants.js":
/*!***************************************************!*\
  !*** ../react-devtools-timeline/src/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COMFORTABLE_LINE_HEIGHT\": () => (/* reexport safe */ react_devtools_shared_src_devtools_constants_js__WEBPACK_IMPORTED_MODULE_0__.COMFORTABLE_LINE_HEIGHT),\n/* harmony export */   \"COMPACT_LINE_HEIGHT\": () => (/* reexport safe */ react_devtools_shared_src_devtools_constants_js__WEBPACK_IMPORTED_MODULE_0__.COMPACT_LINE_HEIGHT),\n/* harmony export */   \"REACT_TOTAL_NUM_LANES\": () => (/* binding */ REACT_TOTAL_NUM_LANES),\n/* harmony export */   \"SCHEDULING_PROFILER_VERSION\": () => (/* binding */ SCHEDULING_PROFILER_VERSION),\n/* harmony export */   \"SNAPSHOT_MAX_HEIGHT\": () => (/* binding */ SNAPSHOT_MAX_HEIGHT)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_devtools_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/devtools/constants.js */ \"../react-devtools-shared/src/devtools/constants.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar REACT_TOTAL_NUM_LANES = 31; // Increment this number any time a backwards breaking change is made to the profiler metadata.\n\nvar SCHEDULING_PROFILER_VERSION = 1;\nvar SNAPSHOT_MAX_HEIGHT = 60;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtdGltZWxpbmUvc3JjL2NvbnN0YW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUtBOztBQUdBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9yZWFjdC1kZXZ0b29scy10aW1lbGluZS9zcmMvY29uc3RhbnRzLmpzPzU5MDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZXhwb3J0IHtcbiAgQ09NRk9SVEFCTEVfTElORV9IRUlHSFQsXG4gIENPTVBBQ1RfTElORV9IRUlHSFQsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvY29uc3RhbnRzLmpzJztcblxuZXhwb3J0IGNvbnN0IFJFQUNUX1RPVEFMX05VTV9MQU5FUyA9IDMxO1xuXG4vLyBJbmNyZW1lbnQgdGhpcyBudW1iZXIgYW55IHRpbWUgYSBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIHByb2ZpbGVyIG1ldGFkYXRhLlxuZXhwb3J0IGNvbnN0IFNDSEVEVUxJTkdfUFJPRklMRVJfVkVSU0lPTiA9IDE7XG5cbmV4cG9ydCBjb25zdCBTTkFQU0hPVF9NQVhfSEVJR0hUID0gNjA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-timeline/src/constants.js\n");

/***/ }),

/***/ "../shared/ReactFeatureFlags.js":
/*!**************************************!*\
  !*** ../shared/ReactFeatureFlags.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"alwaysThrottleRetries\": () => (/* binding */ alwaysThrottleRetries),\n/* harmony export */   \"disableClientCache\": () => (/* binding */ disableClientCache),\n/* harmony export */   \"disableCommentsAsDOMContainers\": () => (/* binding */ disableCommentsAsDOMContainers),\n/* harmony export */   \"disableDefaultPropsExceptForClasses\": () => (/* binding */ disableDefaultPropsExceptForClasses),\n/* harmony export */   \"disableInputAttributeSyncing\": () => (/* binding */ disableInputAttributeSyncing),\n/* harmony export */   \"disableLegacyContext\": () => (/* binding */ disableLegacyContext),\n/* harmony export */   \"disableLegacyContextForFunctionComponents\": () => (/* binding */ disableLegacyContextForFunctionComponents),\n/* harmony export */   \"disableLegacyMode\": () => (/* binding */ disableLegacyMode),\n/* harmony export */   \"disableSchedulerTimeoutInWorkLoop\": () => (/* binding */ disableSchedulerTimeoutInWorkLoop),\n/* harmony export */   \"disableTextareaChildren\": () => (/* binding */ disableTextareaChildren),\n/* harmony export */   \"enableAsyncDebugInfo\": () => (/* binding */ enableAsyncDebugInfo),\n/* harmony export */   \"enableAsyncIterableChildren\": () => (/* binding */ enableAsyncIterableChildren),\n/* harmony export */   \"enableCPUSuspense\": () => (/* binding */ enableCPUSuspense),\n/* harmony export */   \"enableComponentPerformanceTrack\": () => (/* binding */ enableComponentPerformanceTrack),\n/* harmony export */   \"enableCreateEventHandleAPI\": () => (/* binding */ enableCreateEventHandleAPI),\n/* harmony export */   \"enableDO_NOT_USE_disableStrictPassiveEffect\": () => (/* binding */ enableDO_NOT_USE_disableStrictPassiveEffect),\n/* harmony export */   \"enableFabricCompleteRootInCommitPhase\": () => (/* binding */ enableFabricCompleteRootInCommitPhase),\n/* harmony export */   \"enableFizzExternalRuntime\": () => (/* binding */ enableFizzExternalRuntime),\n/* harmony export */   \"enableHalt\": () => (/* binding */ enableHalt),\n/* harmony export */   \"enableHiddenSubtreeInsertionEffectCleanup\": () => (/* binding */ enableHiddenSubtreeInsertionEffectCleanup),\n/* harmony export */   \"enableHydrationLaneScheduling\": () => (/* binding */ enableHydrationLaneScheduling),\n/* harmony export */   \"enableInfiniteRenderLoopDetection\": () => (/* binding */ enableInfiniteRenderLoopDetection),\n/* harmony export */   \"enableLegacyCache\": () => (/* binding */ enableLegacyCache),\n/* harmony export */   \"enableLegacyFBSupport\": () => (/* binding */ enableLegacyFBSupport),\n/* harmony export */   \"enableLegacyHidden\": () => (/* binding */ enableLegacyHidden),\n/* harmony export */   \"enableMoveBefore\": () => (/* binding */ enableMoveBefore),\n/* harmony export */   \"enableNoCloningMemoCache\": () => (/* binding */ enableNoCloningMemoCache),\n/* harmony export */   \"enableObjectFiber\": () => (/* binding */ enableObjectFiber),\n/* harmony export */   \"enableOwnerStacks\": () => (/* binding */ enableOwnerStacks),\n/* harmony export */   \"enablePersistedModeClonedFlag\": () => (/* binding */ enablePersistedModeClonedFlag),\n/* harmony export */   \"enablePostpone\": () => (/* binding */ enablePostpone),\n/* harmony export */   \"enableProfilerCommitHooks\": () => (/* binding */ enableProfilerCommitHooks),\n/* harmony export */   \"enableProfilerNestedUpdatePhase\": () => (/* binding */ enableProfilerNestedUpdatePhase),\n/* harmony export */   \"enableProfilerTimer\": () => (/* binding */ enableProfilerTimer),\n/* harmony export */   \"enableReactTestRendererWarning\": () => (/* binding */ enableReactTestRendererWarning),\n/* harmony export */   \"enableRenderableContext\": () => (/* binding */ enableRenderableContext),\n/* harmony export */   \"enableRetryLaneExpiration\": () => (/* binding */ enableRetryLaneExpiration),\n/* harmony export */   \"enableSchedulingProfiler\": () => (/* binding */ enableSchedulingProfiler),\n/* harmony export */   \"enableScopeAPI\": () => (/* binding */ enableScopeAPI),\n/* harmony export */   \"enableShallowPropDiffing\": () => (/* binding */ enableShallowPropDiffing),\n/* harmony export */   \"enableSiblingPrerendering\": () => (/* binding */ enableSiblingPrerendering),\n/* harmony export */   \"enableSuspenseAvoidThisFallback\": () => (/* binding */ enableSuspenseAvoidThisFallback),\n/* harmony export */   \"enableSuspenseCallback\": () => (/* binding */ enableSuspenseCallback),\n/* harmony export */   \"enableTaint\": () => (/* binding */ enableTaint),\n/* harmony export */   \"enableThrottledScheduling\": () => (/* binding */ enableThrottledScheduling),\n/* harmony export */   \"enableTransitionTracing\": () => (/* binding */ enableTransitionTracing),\n/* harmony export */   \"enableTrustedTypesIntegration\": () => (/* binding */ enableTrustedTypesIntegration),\n/* harmony export */   \"enableUpdaterTracking\": () => (/* binding */ enableUpdaterTracking),\n/* harmony export */   \"enableUseEffectEventHook\": () => (/* binding */ enableUseEffectEventHook),\n/* harmony export */   \"enableUseResourceEffectHook\": () => (/* binding */ enableUseResourceEffectHook),\n/* harmony export */   \"enableViewTransition\": () => (/* binding */ enableViewTransition),\n/* harmony export */   \"enableYieldingBeforePassive\": () => (/* binding */ enableYieldingBeforePassive),\n/* harmony export */   \"favorSafetyOverHydrationPerf\": () => (/* binding */ favorSafetyOverHydrationPerf),\n/* harmony export */   \"passChildrenWhenCloningPersistedNodes\": () => (/* binding */ passChildrenWhenCloningPersistedNodes),\n/* harmony export */   \"renameElementSymbol\": () => (/* binding */ renameElementSymbol),\n/* harmony export */   \"retryLaneExpirationMs\": () => (/* binding */ retryLaneExpirationMs),\n/* harmony export */   \"syncLaneExpirationMs\": () => (/* binding */ syncLaneExpirationMs),\n/* harmony export */   \"transitionLaneExpirationMs\": () => (/* binding */ transitionLaneExpirationMs)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n// None\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\nvar enableHydrationLaneScheduling = true; // -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n// TODO: Finish rolling out in www\n\nvar favorSafetyOverHydrationPerf = true; // Need to remove didTimeout argument from Scheduler before landing\n\nvar disableSchedulerTimeoutInWorkLoop = false; // TODO: Land at Meta before removing.\n\nvar disableDefaultPropsExceptForClasses = true; // -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\n\nvar enableSuspenseCallback = false; // Experimental Scope support.\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\n\nvar enableCreateEventHandleAPI = false; // Support legacy Primer support on internal FB www\n\nvar enableLegacyFBSupport = false; // -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\n\nvar enableYieldingBeforePassive = false; // Experiment to intentionally yield less to block high framerate animations.\n\nvar enableThrottledScheduling = false;\nvar enableLegacyCache = true;\nvar enableAsyncIterableChildren = true;\nvar enableTaint = true;\nvar enablePostpone = true;\nvar enableHalt = true;\nvar enableViewTransition = true;\n/**\n * Switches the Fabric API from doing layout in commit work instead of complete work.\n */\n\nvar enableFabricCompleteRootInCommitPhase = false;\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\n\nvar enableObjectFiber = false;\nvar enableTransitionTracing = false; // FB-only usage. The new API has different semantics.\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\nvar enableSuspenseAvoidThisFallback = false;\nvar enableCPUSuspense = true; // Test this at Meta before enabling.\n\nvar enableNoCloningMemoCache = false;\nvar enableUseEffectEventHook = true; // Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\n\nvar enableFizzExternalRuntime = true;\nvar alwaysThrottleRetries = true;\nvar passChildrenWhenCloningPersistedNodes = false;\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\n\nvar enablePersistedModeClonedFlag = false;\nvar enableOwnerStacks = true;\nvar enableShallowPropDiffing = false;\nvar enableSiblingPrerendering = true;\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\n\nvar enableRetryLaneExpiration = false;\nvar retryLaneExpirationMs = 5000;\nvar syncLaneExpirationMs = 250;\nvar transitionLaneExpirationMs = 5000;\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\n\nvar enableInfiniteRenderLoopDetection = false;\n/**\n * Experimental new hook for better managing resources in effects.\n */\n\nvar enableUseResourceEffectHook = false; // -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n// Renames the internal symbol for elements since they have changed signature/constructor\n\nvar renameElementSymbol = true;\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\n\nvar enableHiddenSubtreeInsertionEffectCleanup = false;\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\n\nvar disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\n\nvar disableLegacyContextForFunctionComponents = true; // Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\n\nvar enableMoveBefore = false; // Disabled caching behavior of `react/cache` in client runtimes.\n\nvar disableClientCache = true; // Warn on any usage of ReactTestRenderer\n\nvar enableReactTestRendererWarning = true; // Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\n\nvar disableLegacyMode = true; // Make <Context> equivalent to <Context.Provider> instead of <Context.Consumer>\n\nvar enableRenderableContext = true; // -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\n\nvar disableCommentsAsDOMContainers = true;\nvar enableTrustedTypesIntegration = false; // Prevent the value and checked attributes from syncing with their related\n// DOM properties\n\nvar disableInputAttributeSyncing = false; // Disables children for <textarea> elements\n\nvar disableTextareaChildren = false; // -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Gather advanced timing metrics for Profiler subtrees.\n\nvar enableProfilerTimer = false; // Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\n\nvar enableComponentPerformanceTrack = true; // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\n\nvar enableSchedulingProfiler = !enableComponentPerformanceTrack && false; // Record durations for commit and passive effects phases.\n\nvar enableProfilerCommitHooks = false; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n\nvar enableProfilerNestedUpdatePhase = false;\nvar enableAsyncDebugInfo = true; // Track which Fiber(s) schedule render work.\n\nvar enableUpdaterTracking = false; // Internal only.\n\nvar enableDO_NOT_USE_disableStrictPassiveEffect = false;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTs7QUFHQTs7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUdBOztBQUdBOztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBR0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBOztBQUdBOztBQUdBO0FBRUE7O0FBR0E7QUFFQTtBQUdBO0FBQ0E7O0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7O0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFFQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7OztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBRUE7Ozs7QUFHQTtBQUVBOzs7O0FBR0E7QUFDQTs7OztBQUdBOztBQUdBOztBQUdBOztBQUdBO0FBR0E7QUFDQTs7QUFDQTs7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBRUE7QUFHQTs7QUFDQTs7QUFHQTtBQUdBO0FBQ0E7QUFFQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBOztBQUNBOztBQUlBOztBQUdBO0FBRUE7O0FBR0E7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9zaGFyZWQvUmVhY3RGZWF0dXJlRmxhZ3MuanM/NzdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3cgc3RyaWN0XG4gKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExhbmQgb3IgcmVtb3ZlICh6ZXJvIGVmZm9ydClcbi8vXG4vLyBGbGFncyB0aGF0IGNhbiBsaWtlbHkgYmUgZGVsZXRlZCBvciBsYW5kZWQgd2l0aG91dCBjb25zZXF1ZW5jZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIE5vbmVcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtpbGxzd2l0Y2hcbi8vXG4vLyBGbGFncyB0aGF0IGV4aXN0IHNvbGVseSB0byB0dXJuIG9mZiBhIGNoYW5nZSBpbiBjYXNlIGl0IGNhdXNlcyBhIHJlZ3Jlc3Npb25cbi8vIHdoZW4gaXQgcm9sbHMgb3V0IHRvIHByb2QuIFdlIHNob3VsZCByZW1vdmUgdGhlc2UgYXMgc29vbiBhcyBwb3NzaWJsZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBlbmFibGVIeWRyYXRpb25MYW5lU2NoZWR1bGluZyA9IHRydWU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMYW5kIG9yIHJlbW92ZSAobW9kZXJhdGUgZWZmb3J0KVxuLy9cbi8vIEZsYWdzIHRoYXQgY2FuIGJlIHByb2JhYmx5IGRlbGV0ZWQgb3IgbGFuZGVkLCBidXQgbWlnaHQgcmVxdWlyZSBleHRyYSBlZmZvcnRcbi8vIGxpa2UgbWlncmF0aW5nIGludGVybmFsIGNhbGxlcnMgb3IgcGVyZm9ybWFuY2UgdGVzdGluZy5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFRPRE86IEZpbmlzaCByb2xsaW5nIG91dCBpbiB3d3dcbmV4cG9ydCBjb25zdCBmYXZvclNhZmV0eU92ZXJIeWRyYXRpb25QZXJmID0gdHJ1ZTtcblxuLy8gTmVlZCB0byByZW1vdmUgZGlkVGltZW91dCBhcmd1bWVudCBmcm9tIFNjaGVkdWxlciBiZWZvcmUgbGFuZGluZ1xuZXhwb3J0IGNvbnN0IGRpc2FibGVTY2hlZHVsZXJUaW1lb3V0SW5Xb3JrTG9vcCA9IGZhbHNlO1xuXG4vLyBUT0RPOiBMYW5kIGF0IE1ldGEgYmVmb3JlIHJlbW92aW5nLlxuZXhwb3J0IGNvbnN0IGRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzID0gdHJ1ZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNsYXRlZCBmb3IgcmVtb3ZhbCBpbiB0aGUgZnV0dXJlIChzaWduaWZpY2FudCBlZmZvcnQpXG4vL1xuLy8gVGhlc2UgYXJlIGV4cGVyaW1lbnRzIHRoYXQgZGlkbid0IHdvcmsgb3V0LCBhbmQgbmV2ZXIgc2hpcHBlZCwgYnV0IHdlIGNhbid0XG4vLyBkZWxldGUgZnJvbSB0aGUgY29kZWJhc2UgdW50aWwgd2UgbWlncmF0ZSBpbnRlcm5hbCBjYWxsZXJzLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQWRkIGEgY2FsbGJhY2sgcHJvcGVydHkgdG8gc3VzcGVuc2UgdG8gbm90aWZ5IHdoaWNoIHByb21pc2VzIGFyZSBjdXJyZW50bHlcbi8vIGluIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgYWxsb3dzIHJlcG9ydGluZyBhbmQgdHJhY2luZyBvZiB3aGF0IGlzIGNhdXNpbmdcbi8vIHRoZSB1c2VyIHRvIHNlZSBhIGxvYWRpbmcgc3RhdGUuXG4vL1xuLy8gQWxzbyBhbGxvd3MgaHlkcmF0aW9uIGNhbGxiYWNrcyB0byBmaXJlIHdoZW4gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGdldHNcbi8vIGh5ZHJhdGVkIG9yIGRlbGV0ZWQuXG4vL1xuLy8gVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgYnkgdGhlIFRyYW5zaXRpb24gVHJhY2luZyBwcm9wb3NhbC5cbmV4cG9ydCBjb25zdCBlbmFibGVTdXNwZW5zZUNhbGxiYWNrID0gZmFsc2U7XG5cbi8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxuZXhwb3J0IGNvbnN0IGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7XG5cbi8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbmV4cG9ydCBjb25zdCBlbmFibGVDcmVhdGVFdmVudEhhbmRsZUFQSSA9IGZhbHNlO1xuXG4vLyBTdXBwb3J0IGxlZ2FjeSBQcmltZXIgc3VwcG9ydCBvbiBpbnRlcm5hbCBGQiB3d3dcbmV4cG9ydCBjb25zdCBlbmFibGVMZWdhY3lGQlN1cHBvcnQgPSBmYWxzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9uZ29pbmcgZXhwZXJpbWVudHNcbi8vXG4vLyBUaGVzZSBhcmUgZmVhdHVyZXMgdGhhdCB3ZSdyZSBlaXRoZXIgYWN0aXZlbHkgZXhwbG9yaW5nIG9yIGFyZSByZWFzb25hYmx5XG4vLyBsaWtlbHkgdG8gaW5jbHVkZSBpbiBhbiB1cGNvbWluZyByZWxlYXNlLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gWWllbGQgdG8gdGhlIGJyb3dzZXIgZXZlbnQgbG9vcCBhbmQgbm90IGp1c3QgdGhlIHNjaGVkdWxlciBldmVudCBsb29wIGJlZm9yZSBwYXNzaXZlIGVmZmVjdHMuXG4vLyBGaXggZ2F0ZWQgdGVzdHMgdGhhdCBmYWlsIHdpdGggdGhpcyBmbGFnIGVuYWJsZWQgYmVmb3JlIHR1cm5pbmcgaXQgYmFjayBvbi5cbmV4cG9ydCBjb25zdCBlbmFibGVZaWVsZGluZ0JlZm9yZVBhc3NpdmUgPSBmYWxzZTtcblxuLy8gRXhwZXJpbWVudCB0byBpbnRlbnRpb25hbGx5IHlpZWxkIGxlc3MgdG8gYmxvY2sgaGlnaCBmcmFtZXJhdGUgYW5pbWF0aW9ucy5cbmV4cG9ydCBjb25zdCBlbmFibGVUaHJvdHRsZWRTY2hlZHVsaW5nID0gZmFsc2U7XG5cbmV4cG9ydCBjb25zdCBlbmFibGVMZWdhY3lDYWNoZSA9IF9fRVhQRVJJTUVOVEFMX187XG5cbmV4cG9ydCBjb25zdCBlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4gPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlVGFpbnQgPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlUG9zdHBvbmUgPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlSGFsdCA9IF9fRVhQRVJJTUVOVEFMX187XG5cbmV4cG9ydCBjb25zdCBlbmFibGVWaWV3VHJhbnNpdGlvbiA9IF9fRVhQRVJJTUVOVEFMX187XG5cbi8qKlxuICogU3dpdGNoZXMgdGhlIEZhYnJpYyBBUEkgZnJvbSBkb2luZyBsYXlvdXQgaW4gY29tbWl0IHdvcmsgaW5zdGVhZCBvZiBjb21wbGV0ZSB3b3JrLlxuICovXG5leHBvcnQgY29uc3QgZW5hYmxlRmFicmljQ29tcGxldGVSb290SW5Db21taXRQaGFzZSA9IGZhbHNlO1xuXG4vKipcbiAqIFN3aXRjaGVzIEZpYmVyIGNyZWF0aW9uIHRvIGEgc2ltcGxlIG9iamVjdCBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVPYmplY3RGaWJlciA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTtcblxuLy8gRkItb25seSB1c2FnZS4gVGhlIG5ldyBBUEkgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MuXG5leHBvcnQgY29uc3QgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7XG5cbi8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuZXhwb3J0IGNvbnN0IGVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2sgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IGVuYWJsZUNQVVN1c3BlbnNlID0gX19FWFBFUklNRU5UQUxfXztcblxuLy8gVGVzdCB0aGlzIGF0IE1ldGEgYmVmb3JlIGVuYWJsaW5nLlxuZXhwb3J0IGNvbnN0IGVuYWJsZU5vQ2xvbmluZ01lbW9DYWNoZSA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlVXNlRWZmZWN0RXZlbnRIb29rID0gX19FWFBFUklNRU5UQUxfXztcblxuLy8gVGVzdCBpbiB3d3cgYmVmb3JlIGVuYWJsaW5nIGluIG9wZW4gc291cmNlLlxuLy8gRW5hYmxlcyBET00tc2VydmVyIHRvIHN0cmVhbSBpdHMgaW5zdHJ1Y3Rpb24gc2V0IGFzIGRhdGEtYXR0cmlidXRlc1xuLy8gKGhhbmRsZWQgd2l0aCBhbiBNdXRhdGlvbk9ic2VydmVyKSBpbnN0ZWFkIG9mIGlubGluZS1zY3JpcHRzXG5leHBvcnQgY29uc3QgZW5hYmxlRml6ekV4dGVybmFsUnVudGltZSA9IF9fRVhQRVJJTUVOVEFMX187XG5cbmV4cG9ydCBjb25zdCBhbHdheXNUaHJvdHRsZVJldHJpZXMgPSB0cnVlO1xuXG5leHBvcnQgY29uc3QgcGFzc0NoaWxkcmVuV2hlbkNsb25pbmdQZXJzaXN0ZWROb2RlcyA9IGZhbHNlO1xuXG4vKipcbiAqIEVuYWJsZXMgYSBuZXcgRmliZXIgZmxhZyB1c2VkIGluIHBlcnNpc3RlZCBtb2RlIHRvIHJlZHVjZSB0aGUgbnVtYmVyXG4gKiBvZiBjbG9uZWQgaG9zdCBjb21wb25lbnRzLlxuICovXG5leHBvcnQgY29uc3QgZW5hYmxlUGVyc2lzdGVkTW9kZUNsb25lZEZsYWcgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IGVuYWJsZU93bmVyU3RhY2tzID0gX19FWFBFUklNRU5UQUxfXztcblxuZXhwb3J0IGNvbnN0IGVuYWJsZVNoYWxsb3dQcm9wRGlmZmluZyA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlU2libGluZ1ByZXJlbmRlcmluZyA9IHRydWU7XG5cbi8qKlxuICogRW5hYmxlcyBhbiBleHBpcmF0aW9uIHRpbWUgZm9yIHJldHJ5IGxhbmVzIHRvIGF2b2lkIHN0YXJ2YXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVSZXRyeUxhbmVFeHBpcmF0aW9uID0gZmFsc2U7XG5leHBvcnQgY29uc3QgcmV0cnlMYW5lRXhwaXJhdGlvbk1zID0gNTAwMDtcbmV4cG9ydCBjb25zdCBzeW5jTGFuZUV4cGlyYXRpb25NcyA9IDI1MDtcbmV4cG9ydCBjb25zdCB0cmFuc2l0aW9uTGFuZUV4cGlyYXRpb25NcyA9IDUwMDA7XG5cbi8qKlxuICogRW5hYmxlcyBhIG5ldyBlcnJvciBkZXRlY3Rpb24gZm9yIGluZmluaXRlIHJlbmRlciBsb29wcyBmcm9tIHVwZGF0ZXMgY2F1c2VkXG4gKiBieSBzZXRTdGF0ZSBvciBzaW1pbGFyIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudCBvd25pbmcgdGhlIHN0YXRlLlxuICovXG5leHBvcnQgY29uc3QgZW5hYmxlSW5maW5pdGVSZW5kZXJMb29wRGV0ZWN0aW9uID0gZmFsc2U7XG5cbi8qKlxuICogRXhwZXJpbWVudGFsIG5ldyBob29rIGZvciBiZXR0ZXIgbWFuYWdpbmcgcmVzb3VyY2VzIGluIGVmZmVjdHMuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVVc2VSZXNvdXJjZUVmZmVjdEhvb2sgPSBmYWxzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlYWR5IGZvciBuZXh0IG1ham9yLlxuLy9cbi8vIEFsaWFzIF9fTkVYVF9NQUpPUl9fIHRvIF9fRVhQRVJJTUVOVEFMX18gZm9yIGVhc2llciBza2ltbWluZy5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFRPRE86IEFueXRoaW5nIHRoYXQncyBzZXQgdG8gYHRydWVgIGluIHRoaXMgc2VjdGlvbiBzaG91bGQgZWl0aGVyIGJlIGNsZWFuZWRcbi8vIHVwIChpZiBpdCdzIG9uIGV2ZXJ5d2hlcmUsIGluY2x1ZGluZyBNZXRhIGFuZCBSTiBidWlsZHMpIG9yIG1vdmVkIHRvIGFcbi8vIGRpZmZlcmVudCBzZWN0aW9uIG9mIHRoaXMgZmlsZS5cblxuLy8gY29uc3QgX19ORVhUX01BSk9SX18gPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG4vLyBSZW5hbWVzIHRoZSBpbnRlcm5hbCBzeW1ib2wgZm9yIGVsZW1lbnRzIHNpbmNlIHRoZXkgaGF2ZSBjaGFuZ2VkIHNpZ25hdHVyZS9jb25zdHJ1Y3RvclxuZXhwb3J0IGNvbnN0IHJlbmFtZUVsZW1lbnRTeW1ib2wgPSB0cnVlO1xuXG4vKipcbiAqIEVuYWJsZXMgYSBmaXggdG8gcnVuIGluc2VydGlvbiBlZmZlY3QgY2xlYW51cCBvbiBoaWRkZW4gc3VidHJlZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVIaWRkZW5TdWJ0cmVlSW5zZXJ0aW9uRWZmZWN0Q2xlYW51cCA9IGZhbHNlO1xuXG4vKipcbiAqIFJlbW92ZXMgbGVnYWN5IHN0eWxlIGNvbnRleHQgZGVmaW5lZCB1c2luZyBzdGF0aWMgYGNvbnRleHRUeXBlc2AgYW5kIGNvbnN1bWVkIHdpdGggc3RhdGljIGBjaGlsZENvbnRleHRUeXBlc2AuXG4gKi9cbmV4cG9ydCBjb25zdCBkaXNhYmxlTGVnYWN5Q29udGV4dCA9IHRydWU7XG4vKipcbiAqIFJlbW92ZXMgbGVnYWN5IHN0eWxlIGNvbnRleHQganVzdCBmcm9tIGZ1bmN0aW9uIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBkaXNhYmxlTGVnYWN5Q29udGV4dEZvckZ1bmN0aW9uQ29tcG9uZW50cyA9IHRydWU7XG5cbi8vIEVuYWJsZSB0aGUgbW92ZUJlZm9yZSgpIGFsdGVybmF0aXZlIHRvIGluc2VydEJlZm9yZSgpLiBUaGlzIHByZXNlcnZlcyBzdGF0ZXMgb2YgbW92ZXMuXG5leHBvcnQgY29uc3QgZW5hYmxlTW92ZUJlZm9yZSA9IGZhbHNlO1xuXG4vLyBEaXNhYmxlZCBjYWNoaW5nIGJlaGF2aW9yIG9mIGByZWFjdC9jYWNoZWAgaW4gY2xpZW50IHJ1bnRpbWVzLlxuZXhwb3J0IGNvbnN0IGRpc2FibGVDbGllbnRDYWNoZSA9IHRydWU7XG5cbi8vIFdhcm4gb24gYW55IHVzYWdlIG9mIFJlYWN0VGVzdFJlbmRlcmVyXG5leHBvcnQgY29uc3QgZW5hYmxlUmVhY3RUZXN0UmVuZGVyZXJXYXJuaW5nID0gdHJ1ZTtcblxuLy8gRGlzYWJsZXMgbGVnYWN5IG1vZGVcbi8vIFRoaXMgYWxsb3dzIHVzIHRvIGxhbmQgYnJlYWtpbmcgY2hhbmdlcyB0byByZW1vdmUgbGVnYWN5IG1vZGUgQVBJcyBpbiBleHBlcmltZW50YWwgYnVpbGRzXG4vLyBiZWZvcmUgcmVtb3ZpbmcgdGhlbSBpbiBzdGFibGUgaW4gdGhlIG5leHQgTWFqb3JcbmV4cG9ydCBjb25zdCBkaXNhYmxlTGVnYWN5TW9kZSA9IHRydWU7XG5cbi8vIE1ha2UgPENvbnRleHQ+IGVxdWl2YWxlbnQgdG8gPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQgb2YgPENvbnRleHQuQ29uc3VtZXI+XG5leHBvcnQgY29uc3QgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSB0cnVlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ2hvcHBpbmcgQmxvY2tcbi8vXG4vLyBQbGFubmVkIGZlYXR1cmUgZGVwcmVjYXRpb25zIGFuZCBicmVha2luZyBjaGFuZ2VzLiBTb3J0ZWQgcm91Z2hseSBpbiBvcmRlciBvZlxuLy8gd2hlbiB3ZSBwbGFuIHRvIGVuYWJsZSB0aGVtLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlYWN0IERPTSBDaG9wcGluZyBCbG9ja1xuLy9cbi8vIFNpbWlsYXIgdG8gbWFpbiBDaG9wcGluZyBCbG9jayBidXQgb25seSBmbGFncyByZWxhdGVkIHRvIFJlYWN0IERPTS4gVGhlc2UgYXJlXG4vLyBncm91cGVkIGJlY2F1c2Ugd2Ugd2lsbCBsaWtlbHkgYmF0Y2ggYWxsIG9mIHRoZW0gaW50byBhIHNpbmdsZSBtYWpvciByZWxlYXNlLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gRGlzYWJsZSBzdXBwb3J0IGZvciBjb21tZW50IG5vZGVzIGFzIFJlYWN0IERPTSBjb250YWluZXJzLiBBbHJlYWR5IGRpc2FibGVkXG4vLyBpbiBvcGVuIHNvdXJjZSwgYnV0IHd3dyBjb2RlYmFzZSBzdGlsbCByZWxpZXMgb24gaXQuIE5lZWQgdG8gcmVtb3ZlLlxuZXhwb3J0IGNvbnN0IGRpc2FibGVDb21tZW50c0FzRE9NQ29udGFpbmVycyA9IHRydWU7XG5cbmV4cG9ydCBjb25zdCBlbmFibGVUcnVzdGVkVHlwZXNJbnRlZ3JhdGlvbiA9IGZhbHNlO1xuXG4vLyBQcmV2ZW50IHRoZSB2YWx1ZSBhbmQgY2hlY2tlZCBhdHRyaWJ1dGVzIGZyb20gc3luY2luZyB3aXRoIHRoZWlyIHJlbGF0ZWRcbi8vIERPTSBwcm9wZXJ0aWVzXG5leHBvcnQgY29uc3QgZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZyA9IGZhbHNlO1xuXG4vLyBEaXNhYmxlcyBjaGlsZHJlbiBmb3IgPHRleHRhcmVhPiBlbGVtZW50c1xuZXhwb3J0IGNvbnN0IGRpc2FibGVUZXh0YXJlYUNoaWxkcmVuID0gZmFsc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZWJ1Z2dpbmcgYW5kIERldlRvb2xzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuZXhwb3J0IGNvbnN0IGVuYWJsZVByb2ZpbGVyVGltZXIgPSBfX1BST0ZJTEVfXztcblxuLy8gQWRkcyBwZXJmb3JtYW5jZS5tZWFzdXJlKCkgbWFya3MgdXNpbmcgQ2hyb21lIGV4dGVuc2lvbnMgdG8gYWxsb3cgZm9ybWF0dGVkXG4vLyBDb21wb25lbnQgcmVuZGVyaW5nIHRyYWNrcyB0byBzaG93IHVwIGluIHRoZSBQZXJmb3JtYW5jZSB0YWIuXG4vLyBUaGlzIGZsYWcgd2lsbCBiZSB1c2VkIGZvciBib3RoIFNlcnZlciBDb21wb25lbnQgYW5kIENsaWVudCBDb21wb25lbnQgdHJhY2tzLlxuLy8gQWxsIGNhbGxzIHNob3VsZCBhbHNvIGJlIGdhdGVkIG9uIGVuYWJsZVByb2ZpbGVyVGltZXIuXG5leHBvcnQgY29uc3QgZW5hYmxlQ29tcG9uZW50UGVyZm9ybWFuY2VUcmFjayA9IF9fRVhQRVJJTUVOVEFMX187XG5cbi8vIEFkZHMgdXNlciB0aW1pbmcgbWFya3MgZm9yIGUuZy4gc3RhdGUgdXBkYXRlcywgc3VzcGVuc2UsIGFuZCB3b3JrIGxvb3Agc3R1ZmYsXG4vLyBmb3IgYW4gZXhwZXJpbWVudGFsIHRpbWVsaW5lIHRvb2wuXG5leHBvcnQgY29uc3QgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyOiBib29sZWFuID1cbiAgIWVuYWJsZUNvbXBvbmVudFBlcmZvcm1hbmNlVHJhY2sgJiYgX19QUk9GSUxFX187XG5cbi8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cbmV4cG9ydCBjb25zdCBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzID0gX19QUk9GSUxFX187XG5cbi8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5leHBvcnQgY29uc3QgZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVQaGFzZSA9IF9fUFJPRklMRV9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlQXN5bmNEZWJ1Z0luZm8gPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG4vLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cbmV4cG9ydCBjb25zdCBlbmFibGVVcGRhdGVyVHJhY2tpbmcgPSBfX1BST0ZJTEVfXztcblxuLy8gSW50ZXJuYWwgb25seS5cbmV4cG9ydCBjb25zdCBlbmFibGVET19OT1RfVVNFX2Rpc2FibGVTdHJpY3RQYXNzaXZlRWZmZWN0ID0gZmFsc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../shared/ReactFeatureFlags.js\n");

/***/ }),

/***/ "../shared/ReactSymbols.js":
/*!*********************************!*\
  !*** ../shared/ReactSymbols.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASYNC_ITERATOR\": () => (/* binding */ ASYNC_ITERATOR),\n/* harmony export */   \"REACT_CONSUMER_TYPE\": () => (/* binding */ REACT_CONSUMER_TYPE),\n/* harmony export */   \"REACT_CONTEXT_TYPE\": () => (/* binding */ REACT_CONTEXT_TYPE),\n/* harmony export */   \"REACT_ELEMENT_TYPE\": () => (/* binding */ REACT_ELEMENT_TYPE),\n/* harmony export */   \"REACT_FORWARD_REF_TYPE\": () => (/* binding */ REACT_FORWARD_REF_TYPE),\n/* harmony export */   \"REACT_FRAGMENT_TYPE\": () => (/* binding */ REACT_FRAGMENT_TYPE),\n/* harmony export */   \"REACT_LAZY_TYPE\": () => (/* binding */ REACT_LAZY_TYPE),\n/* harmony export */   \"REACT_LEGACY_ELEMENT_TYPE\": () => (/* binding */ REACT_LEGACY_ELEMENT_TYPE),\n/* harmony export */   \"REACT_LEGACY_HIDDEN_TYPE\": () => (/* binding */ REACT_LEGACY_HIDDEN_TYPE),\n/* harmony export */   \"REACT_MEMO_CACHE_SENTINEL\": () => (/* binding */ REACT_MEMO_CACHE_SENTINEL),\n/* harmony export */   \"REACT_MEMO_TYPE\": () => (/* binding */ REACT_MEMO_TYPE),\n/* harmony export */   \"REACT_OFFSCREEN_TYPE\": () => (/* binding */ REACT_OFFSCREEN_TYPE),\n/* harmony export */   \"REACT_PORTAL_TYPE\": () => (/* binding */ REACT_PORTAL_TYPE),\n/* harmony export */   \"REACT_POSTPONE_TYPE\": () => (/* binding */ REACT_POSTPONE_TYPE),\n/* harmony export */   \"REACT_PROFILER_TYPE\": () => (/* binding */ REACT_PROFILER_TYPE),\n/* harmony export */   \"REACT_PROVIDER_TYPE\": () => (/* binding */ REACT_PROVIDER_TYPE),\n/* harmony export */   \"REACT_SCOPE_TYPE\": () => (/* binding */ REACT_SCOPE_TYPE),\n/* harmony export */   \"REACT_STRICT_MODE_TYPE\": () => (/* binding */ REACT_STRICT_MODE_TYPE),\n/* harmony export */   \"REACT_SUSPENSE_LIST_TYPE\": () => (/* binding */ REACT_SUSPENSE_LIST_TYPE),\n/* harmony export */   \"REACT_SUSPENSE_TYPE\": () => (/* binding */ REACT_SUSPENSE_TYPE),\n/* harmony export */   \"REACT_TRACING_MARKER_TYPE\": () => (/* binding */ REACT_TRACING_MARKER_TYPE),\n/* harmony export */   \"REACT_VIEW_TRANSITION_TYPE\": () => (/* binding */ REACT_VIEW_TRANSITION_TYPE),\n/* harmony export */   \"getIteratorFn\": () => (/* binding */ getIteratorFn)\n/* harmony export */ });\n/* harmony import */ var shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shared/ReactFeatureFlags */ \"../shared/ReactFeatureFlags.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n // ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\n\nvar REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_ELEMENT_TYPE = shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_0__.renameElementSymbol ? Symbol.for('react.transitional.element') : REACT_LEGACY_ELEMENT_TYPE;\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_SCOPE_TYPE = Symbol.for('react.scope');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nvar REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\nvar REACT_POSTPONE_TYPE = Symbol.for('react.postpone');\nvar REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\nvar ASYNC_ITERATOR = Symbol.asyncIterator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL1JlYWN0U3ltYm9scy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBR0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUlBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3NoYXJlZC9SZWFjdFN5bWJvbHMuanM/YzAyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge3JlbmFtZUVsZW1lbnRTeW1ib2x9IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbmV4cG9ydCBjb25zdCBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFOiBzeW1ib2wgPSByZW5hbWVFbGVtZW50U3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnQnKVxuICA6IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEU7XG5leHBvcnQgY29uc3QgUkVBQ1RfUE9SVEFMX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0ZSQUdNRU5UX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9QUk9GSUxFUl9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX1BST1ZJREVSX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7IC8vIFRPRE86IERlbGV0ZSB3aXRoIGVuYWJsZVJlbmRlcmFibGVDb250ZXh0XG5leHBvcnQgY29uc3QgUkVBQ1RfQ09OU1VNRVJfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QuY29uc3VtZXInKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9DT05URVhUX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX1NVU1BFTlNFX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKFxuICAncmVhY3Quc3VzcGVuc2VfbGlzdCcsXG4pO1xuZXhwb3J0IGNvbnN0IFJFQUNUX01FTU9fVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0xBWllfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX1NDT1BFX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcihcbiAgJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nLFxuKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKFxuICAncmVhY3QudHJhY2luZ19tYXJrZXInLFxuKTtcblxuZXhwb3J0IGNvbnN0IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw6IHN5bWJvbCA9IFN5bWJvbC5mb3IoXG4gICdyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsJyxcbik7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9QT1NUUE9ORV9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3N0cG9uZScpO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoXG4gICdyZWFjdC52aWV3X3RyYW5zaXRpb24nLFxuKTtcblxuY29uc3QgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xuY29uc3QgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGU6ID9hbnkpOiA/KCkgPT4gP0l0ZXJhdG9yPGFueT4ge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXliZUl0ZXJhdG9yID1cbiAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBBU1lOQ19JVEVSQVRPUiA9IFN5bWJvbC5hc3luY0l0ZXJhdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../shared/ReactSymbols.js\n");

/***/ }),

/***/ "../shared/hasOwnProperty.js":
/*!***********************************!*\
  !*** ../shared/hasOwnProperty.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasOwnProperty);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2hhc093blByb3BlcnR5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9zaGFyZWQvaGFzT3duUHJvcGVydHkuanM/YmJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmV4cG9ydCBkZWZhdWx0IGhhc093blByb3BlcnR5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../shared/hasOwnProperty.js\n");

/***/ }),

/***/ "../shared/isArray.js":
/*!****************************!*\
  !*** ../shared/isArray.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar isArrayImpl = Array.isArray;\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2lzQXJyYXkuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7OztBQVdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL1JlYWN0RGV2VG9vbHNCYWNrZW5kLy4uL3NoYXJlZC9pc0FycmF5LmpzP2Q5M2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZGVjbGFyZSBmdW5jdGlvbiBpc0FycmF5KGE6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKEFycmF5LmlzQXJyYXkoYSkpO1xuXG5jb25zdCBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYTogbWl4ZWQpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../shared/isArray.js\n");

/***/ }),

/***/ "../shared/objectIs.js":
/*!*****************************!*\
  !*** ../shared/objectIs.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = // $FlowFixMe[method-unbinding]\ntypeof Object.is === 'function' ? Object.is : is;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (objectIs);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL29iamVjdElzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7O0FBU0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFHQTs7QUFFQTtBQUVBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9SZWFjdERldlRvb2xzQmFja2VuZC8uLi9zaGFyZWQvb2JqZWN0SXMuanM/ZDFjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4OiBhbnksIHk6IGFueSkge1xuICByZXR1cm4gKFxuICAgICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICk7XG59XG5cbmNvbnN0IG9iamVjdElzOiAoeDogYW55LCB5OiBhbnkpID0+IGJvb2xlYW4gPVxuICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0SXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../shared/objectIs.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/backend.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});